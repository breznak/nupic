# 1 "/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 164 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp" 2
# 28 "/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/sstream" 1 3
# 37 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/sstream" 3

# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 1 3
# 37 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3

# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ios" 1 3
# 37 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ios" 3

# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/iosfwd" 1 3
# 37 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/iosfwd" 3

# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/c++config.h" 1 3
# 184 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;




}
# 426 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/c++config.h" 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/os_defines.h" 1 3
# 39 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/os_defines.h" 3
# 1 "/usr/include/features.h" 1 3 4
# 342 "/usr/include/features.h" 3 4
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 343 "/usr/include/features.h" 2 3 4
# 364 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 385 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 386 "/usr/include/sys/cdefs.h" 2 3 4
# 365 "/usr/include/features.h" 2 3 4
# 388 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4
# 10 "/usr/include/gnu/stubs.h" 3 4
# 1 "/usr/include/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/gnu/stubs.h" 2 3 4
# 389 "/usr/include/features.h" 2 3 4
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/os_defines.h" 2 3
# 427 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/c++config.h" 2 3


# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/cpu_defines.h" 1 3
# 430 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/c++config.h" 2 3
# 39 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/iosfwd" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stringfwd.h" 1 3
# 38 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stringfwd.h" 3


# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/memoryfwd.h" 1 3
# 47 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/memoryfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{
# 63 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/memoryfwd.h" 3
  template<typename>
    class allocator;

  template<>
    class allocator<void>;


  template<typename, typename>
    struct uses_allocator;




}
# 41 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stringfwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 52 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stringfwd.h" 3
  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;


  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;


  typedef basic_string<wchar_t> wstring;
# 87 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stringfwd.h" 3
}
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/iosfwd" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/postypes.h" 1 3
# 39 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/postypes.h" 3

# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cwchar" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 36 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/stdio.h" 1 3 4
# 44 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;
# 64 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 37 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/bin/../lib/clang/3.3/include/stdarg.h" 1 3 4
# 30 "/usr/bin/../lib/clang/3.3/include/stdarg.h" 3 4
typedef __builtin_va_list va_list;
# 48 "/usr/bin/../lib/clang/3.3/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 40 "/usr/include/wchar.h" 2 3 4

# 1 "/usr/include/bits/wchar.h" 1 3 4
# 42 "/usr/include/wchar.h" 2 3 4
# 51 "/usr/include/wchar.h" 3 4
# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3 4
# 34 "/usr/bin/../lib/clang/3.3/include/stddef.h" 3 4
typedef long int ptrdiff_t;







typedef long unsigned int size_t;
# 99 "/usr/bin/../lib/clang/3.3/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 52 "/usr/include/wchar.h" 2 3 4
# 82 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 106 "/usr/include/wchar.h" 3 4
typedef __mbstate_t mbstate_t;
# 132 "/usr/include/wchar.h" 3 4
extern "C" {




struct tm;
# 147 "/usr/include/wchar.h" 3 4
extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     throw () __attribute__ ((__pure__));

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));




extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) throw ();


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) throw ();




# 1 "/usr/include/xlocale.h" 1 3 4
# 27 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 181 "/usr/include/wchar.h" 2 3 4

extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    __locale_t __loc) throw ();

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, __locale_t __loc) throw ();





extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) throw ();
# 206 "/usr/include/wchar.h" 3 4
extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        __locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, __locale_t __loc) throw ();


extern wchar_t *wcsdup (const wchar_t *__s) throw () __attribute__ ((__malloc__));
# 227 "/usr/include/wchar.h" 3 4
extern wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     throw () __attribute__ ((__pure__));
# 237 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     throw () __attribute__ ((__pure__));






extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));





extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     throw () __attribute__ ((__pure__));
# 266 "/usr/include/wchar.h" 3 4
extern wchar_t *wcspbrk (const wchar_t *__wcs, const wchar_t *__accept)
     throw () __attribute__ ((__pure__));
# 277 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsstr (const wchar_t *__haystack, const wchar_t *__needle)
     throw () __attribute__ ((__pure__));



extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (const wchar_t *__s) throw () __attribute__ ((__pure__));
# 299 "/usr/include/wchar.h" 3 4
extern wchar_t *wcswcs (const wchar_t *__haystack, const wchar_t *__needle)
     throw () __attribute__ ((__pure__));





extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));
# 320 "/usr/include/wchar.h" 3 4
extern wchar_t *wmemchr (const wchar_t *__s, wchar_t __c, size_t __n)
     throw () __attribute__ ((__pure__));



extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();





extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     const wchar_t *__restrict __s2, size_t __n)
     throw ();






extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();
# 408 "/usr/include/wchar.h" 3 4
extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();






extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (const wchar_t *__s, size_t __n) throw ();






extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();





extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();







extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();






__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();






__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();
# 530 "/usr/include/wchar.h" 3 4
extern long int wcstol_l (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     __locale_t __loc) throw ();

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, __locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, __locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, __locale_t __loc)
     throw ();

extern double wcstod_l (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern float wcstof_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern long double wcstold_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         __locale_t __loc) throw ();






extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();






extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();






extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     throw () ;
# 689 "/usr/include/wchar.h" 3 4
extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;
# 745 "/usr/include/wchar.h" 3 4
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
# 801 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 827 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 837 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);







extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) throw ();







extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     const wchar_t *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) throw ();
# 891 "/usr/include/wchar.h" 3 4
}
# 45 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cwchar" 2 3
# 62 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 135 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;


  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }



}







namespace __gnu_cxx
{





  using ::wcstold;
# 257 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
# 41 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/postypes.h" 2 3
# 68 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 88 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/postypes.h" 3
  typedef long streamoff;
# 98 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/postypes.h" 3
  typedef ptrdiff_t streamsize;
# 111 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 133 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;
# 240 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/postypes.h" 3
}
# 41 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/iosfwd" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 74 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
# 39 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ios" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/exception" 1 3
# 34 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/exception" 3

#pragma GCC visibility push(default)



# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/atomic_lockfree_defines.h" 1 3
# 34 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/atomic_lockfree_defines.h" 3
# 39 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/exception" 2 3

extern "C++" {

namespace std
{
# 60 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/exception" 3
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();



    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }



    virtual ~bad_exception() throw();


    virtual const char* what() const throw();
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();



  void terminate() throw() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();



  void unexpected() __attribute__ ((__noreturn__));
# 117 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/exception" 3
  bool uncaught_exception() throw() __attribute__ ((__pure__));


}

namespace __gnu_cxx
{
# 142 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ios" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/char_traits.h" 1 3
# 38 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/char_traits.h" 3

# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 1 3
# 60 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/functexcept.h" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/functexcept.h" 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/exception_defines.h" 1 3
# 41 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/functexcept.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
# 61 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/cpp_type_traits.h" 1 3
# 36 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/cpp_type_traits.h" 3
# 68 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/cpp_type_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
    class __normal_iterator;


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };




  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 198 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/cpp_type_traits.h" 3
  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
# 422 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/cpp_type_traits.h" 3
}
# 62 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ext/type_traits.h" 1 3
# 33 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ext/type_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
# 63 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ext/numeric_traits.h" 1 3
# 33 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
# 54 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 99 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
# 64 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_pair.h" 1 3
# 59 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_pair.h" 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/move.h" 1 3
# 34 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/move.h" 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/concept_check.h" 1 3
# 34 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/concept_check.h" 3
# 35 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline _Tp*
    __addressof(_Tp& __r)
    {
      return reinterpret_cast<_Tp*>
 (&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
    }


}
# 149 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 164 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/move.h" 3
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)




    {



      _Tp __tmp = (__a);
      __a = (__b);
      __b = (__tmp);
    }




  template<typename _Tp, size_t _Nm>
    inline void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])



    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 60 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_pair.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{
# 95 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





                         pair()
      : first(), second() { }


                         pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }



      template<class _U1, class _U2>
 pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }
# 209 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_pair.h" 3
    };


  template<class _T1, class _T2>
    inline bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
# 284 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
    { return pair<_T1, _T2>(__x, __y); }





}
# 65 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator_base_types.h" 1 3
# 63 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator_base_types.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{
# 89 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 116 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 162 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };



  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }





  template<typename _Iterator, bool _HasBase>
    struct _Iter_base
    {
      typedef _Iterator iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct _Iter_base<_Iterator, true>
    {
      typedef typename _Iterator::iterator_type iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it.base(); }
    };
# 233 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator_base_types.h" 3
}
# 66 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator_base_funcs.h" 1 3
# 63 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator_base_funcs.h" 3


# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/debug/debug.h" 1 3
# 46 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 66 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator_base_funcs.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {



      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {



      return __last - __first;
    }
# 112 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {


                                     ;
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {



      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {



      __i += __n;
    }
# 171 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }
# 203 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator_base_funcs.h" 3
}
# 67 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator.h" 1 3
# 67 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 95 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;







      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }
# 159 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator.h" 3
      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 289 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>







    inline typename reverse_iterator<_IteratorL>::difference_type
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)

    { return __y.base() - __x.base(); }
# 401 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
# 428 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_back(__value);
 return *this;
      }
# 451 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 477 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 492 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
# 518 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_front(__value);
 return *this;
      }
# 541 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 567 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 586 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
# 629 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }
# 655 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator.h" 3
      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 681 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
# 705 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

                         __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }


      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };
# 803 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>







    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)

    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}
# 68 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{






  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          _ValueType1 __tmp = (*__a);
          *__a = (*__b);
          *__b = (__tmp);
 }
    };

  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };
# 117 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {







      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;






      typedef typename iterator_traits<_ForwardIterator1>::reference
 _ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
 _ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
 && __are_same<_ValueType1&, _ReferenceType1>::__value
 && __are_same<_ValueType2&, _ReferenceType2>::__value>::
 iter_swap(__a, __b);



    }
# 163 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {





                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 191 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {



      if (__b < __a)
 return __b;
      return __a;
    }
# 214 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {



      if (__a < __b)
 return __b;
      return __a;
    }
# 237 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 258 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    struct _Niter_base
    : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Niter_base<_Iterator>::iterator_type
    __niter_base(_Iterator __it)
    { return std::_Niter_base<_Iterator>::_S_base(__it); }


  template<typename _Iterator>
    struct _Miter_base
    : _Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Miter_base<_Iterator>::iterator_type
    __miter_base(_Iterator __it)
    { return std::_Miter_base<_Iterator>::_S_base(__it); }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };
# 325 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 3
  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };
# 363 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
# 448 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {




                                                     ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 500 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 3
  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };
# 528 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 3
  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };
# 558 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
# 617 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {






                                                     ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 675 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
         __last - __first);
    }
# 719 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {



                                                     ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 779 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {



      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)
       * (__last1 - __first1));
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }


  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 typedef typename iterator_traits<_II1>::iterator_category _Category1;
 typedef typename iterator_traits<_II2>::iterator_category _Category2;
 typedef std::__lc_rai<_Category1, _Category2> __rai_type;

 __last1 = __rai_type::__newlast1(__first1, __last1,
      __first2, __last2);
 for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
      ++__first1, ++__first2)
   {
     if (*__first1 < *__first2)
       return true;
     if (*__first2 < *__first1)
       return false;
   }
 return __first1 == __last1 && __first2 != __last2;
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   const int __result = __builtin_memcmp(__first1, __first2,
      std::min(__len1, __len2));
   return __result != 0 ? __result < 0 : __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }
# 941 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {




      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;




                                                                  ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }



  inline int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline unsigned
  __lg(unsigned __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline unsigned long
  __lg(unsigned long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

  inline unsigned long long
  __lg(unsigned long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }
# 1019 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {






                                                       ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
# 1051 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {



                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
# 1082 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {
# 1096 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 3
                                                       ;
                                                       ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
# 1118 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;




                                                       ;
                                                       ;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
# 1158 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {






                                                       ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1195 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {



                                                       ;

      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }


}
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/char_traits.h" 2 3

# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cwchar" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 45 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cwchar" 2 3
# 42 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/char_traits.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
# 57 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 82 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>(-1); }

      static int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{
# 226 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return __builtin_memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }



      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>(-1); }

      static int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static char_type
      to_char_type(const int_type& __c)
      { return char_type(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return int_type(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((0xffffffffu)); }

      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };



}
# 41 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ios" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/localefwd.h" 1 3
# 38 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/localefwd.h" 3


# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/c++locale.h" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/c++locale.h" 3

# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/clocale" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/clocale" 3


# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3 4
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4

extern "C" {
# 53 "/usr/include/locale.h" 3 4
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 120 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) throw ();


extern struct lconv *localeconv (void) throw ();
# 151 "/usr/include/locale.h" 3 4
extern __locale_t newlocale (int __category_mask, const char *__locale,
        __locale_t __base) throw ();
# 186 "/usr/include/locale.h" 3 4
extern __locale_t duplocale (__locale_t __dataset) throw ();



extern void freelocale (__locale_t __dataset) throw ();






extern __locale_t uselocale (__locale_t __dataset) throw ();







}
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/clocale" 2 3








namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  extern "C" __typeof(uselocale) __uselocale;


}


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 88 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }


}
# 41 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/localefwd.h" 2 3

# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cctype" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cctype" 3


# 1 "/usr/include/ctype.h" 1 3 4
# 26 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/bits/types.h" 1 3 4
# 27 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 121 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 122 "/usr/include/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
# 27 "/usr/include/ctype.h" 2 3 4

extern "C" {
# 39 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 28 "/usr/include/bits/byteswap.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/byteswap.h" 2 3 4






# 1 "/usr/include/bits/byteswap-16.h" 1 3 4
# 36 "/usr/include/bits/byteswap.h" 2 3 4
# 61 "/usr/include/endian.h" 2 3 4
# 40 "/usr/include/ctype.h" 2 3 4






enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const__));
# 110 "/usr/include/ctype.h" 3 4
extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();
# 136 "/usr/include/ctype.h" 3 4
extern int isblank (int) throw ();






extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
# 271 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) throw ();
extern int isalpha_l (int, __locale_t) throw ();
extern int iscntrl_l (int, __locale_t) throw ();
extern int isdigit_l (int, __locale_t) throw ();
extern int islower_l (int, __locale_t) throw ();
extern int isgraph_l (int, __locale_t) throw ();
extern int isprint_l (int, __locale_t) throw ();
extern int ispunct_l (int, __locale_t) throw ();
extern int isspace_l (int, __locale_t) throw ();
extern int isupper_l (int, __locale_t) throw ();
extern int isxdigit_l (int, __locale_t) throw ();

extern int isblank_l (int, __locale_t) throw ();



extern int __tolower_l (int __c, __locale_t __l) throw ();
extern int tolower_l (int __c, __locale_t __l) throw ();


extern int __toupper_l (int __c, __locale_t __l) throw ();
extern int toupper_l (int __c, __locale_t __l) throw ();
# 347 "/usr/include/ctype.h" 3 4
}
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cctype" 2 3
# 62 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 55 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;

  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;

  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;


}
# 42 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ios" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ios_base.h" 1 3
# 38 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ios_base.h" 3

# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ext/atomicity.h" 1 3
# 33 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ext/atomicity.h" 3


# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/gthr.h" 1 3
# 30 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 148 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/gthr.h" 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/gthr-default.h" 1 3
# 35 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
# 23 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 28 "/usr/include/sched.h" 3 4
# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3 4
# 29 "/usr/include/sched.h" 2 3 4



# 1 "/usr/include/time.h" 1 3 4
# 75 "/usr/include/time.h" 3 4
typedef __time_t time_t;
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };
# 33 "/usr/include/sched.h" 2 3 4


typedef __pid_t pid_t;






# 1 "/usr/include/bits/sched.h" 1 3 4
# 72 "/usr/include/bits/sched.h" 3 4
struct sched_param
  {
    int __sched_priority;
  };

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


extern int setns (int __fd, int __nstype) throw ();



}







struct __sched_param
  {
    int __sched_priority;
  };
# 118 "/usr/include/bits/sched.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 201 "/usr/include/bits/sched.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}
# 42 "/usr/include/sched.h" 2 3 4




extern "C" {


extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
# 116 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
# 24 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
extern "C" {








# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3 4
# 38 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/time.h" 1 3 4
# 30 "/usr/include/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 86 "/usr/include/bits/time.h" 3 4
# 1 "/usr/include/bits/timex.h" 1 3 4
# 25 "/usr/include/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 87 "/usr/include/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();

}
# 42 "/usr/include/time.h" 2 3 4
# 59 "/usr/include/time.h" 3 4
typedef __clock_t clock_t;
# 91 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 103 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 133 "/usr/include/time.h" 3 4
struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 161 "/usr/include/time.h" 3 4
struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;
# 189 "/usr/include/time.h" 3 4
extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) throw ();





extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     throw ();







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) throw ();



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) throw ();






extern struct tm *gmtime (const time_t *__timer) throw ();



extern struct tm *localtime (const time_t *__timer) throw ();





extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();





extern char *asctime (const struct tm *__tp) throw ();


extern char *ctime (const time_t *__timer) throw ();







extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) throw ();
# 319 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 334 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();





extern int timespec_get (struct timespec *__ts, int __base)
     throw () __attribute__ ((__nonnull__ (1)));
# 403 "/usr/include/time.h" 3 4
extern int getdate_err;
# 412 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 426 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 25 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 21 "/usr/include/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 22 "/usr/include/bits/pthreadtypes.h" 2 3 4
# 60 "/usr/include/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;





typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 90 "/usr/include/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    short __spins;
    short __elision;
    __pthread_list_t __list;
# 124 "/usr/include/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    unsigned long int __pad1;
    unsigned long int __pad2;


    unsigned int __flags;

  } __data;
# 211 "/usr/include/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 27 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/setjmp.h" 1 3 4
# 26 "/usr/include/bits/setjmp.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 27 "/usr/include/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 125 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 166 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 201 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 239 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  throw () __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     throw () __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
# 505 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 517 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 551 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
# 753 "/usr/include/pthread.h" 3 4
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
# 817 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
# 899 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 1011 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
# 1055 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
# 1122 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
# 1156 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();
# 1170 "/usr/include/pthread.h" 3 4
}
# 36 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/gthr-default.h" 2 3
# 47 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 101 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once")));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific")));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific")));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create")));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join")));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal")));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self")));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach")));

static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel")));

static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield")));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock")));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock")));

static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock")));

static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock")));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init")));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy")));

static __typeof(pthread_cond_init) __gthrw_pthread_cond_init __attribute__ ((__weakref__("pthread_cond_init")));
static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast")));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal")));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait")));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait")));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy")));

static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create")));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete")));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init")));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype")));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy")));
# 236 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static __typeof(pthread_key_create) __gthrw___pthread_key_create __attribute__ ((__weakref__("__pthread_key_create")));
# 246 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw___pthread_key_create;
  return __gthread_active_ptr != 0;
}
# 658 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    __gthrw_pthread_mutex_init (__mutex, __null);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}


static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}


static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
# 807 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}


static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}


static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_destroy (__mutex);
}
# 849 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}
# 149 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/gthr.h" 2 3


#pragma GCC visibility pop
# 36 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ext/atomicity.h" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/atomic_word.h" 1 3
# 32 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 37 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, 4); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __atomic_fetch_add(__mem, __val, 4); }
# 64 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }


}
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ios_base.h" 2 3

# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 1 3
# 38 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 3


# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/string" 1 3
# 37 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/string" 3




# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/allocator.h" 1 3
# 46 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/allocator.h" 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/c++allocator.h" 1 3
# 33 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/c++allocator.h" 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ext/new_allocator.h" 1 3
# 33 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ext/new_allocator.h" 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/new" 1 3
# 38 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/new" 3




#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };

  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();
}
# 91 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/new" 3
void* operator new(std::size_t) throw(std::bad_alloc)
  __attribute__((__externally_visible__));
void* operator new[](std::size_t) throw(std::bad_alloc)
  __attribute__((__externally_visible__));
void operator delete(void*) throw()
  __attribute__((__externally_visible__));
void operator delete[](void*) throw()
  __attribute__((__externally_visible__));
void* operator new(std::size_t, const std::nothrow_t&) throw()
  __attribute__((__externally_visible__));
void* operator new[](std::size_t, const std::nothrow_t&) throw()
  __attribute__((__externally_visible__));
void operator delete(void*, const std::nothrow_t&) throw()
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) throw()
  __attribute__((__externally_visible__));


inline void* operator new(std::size_t, void* __p) throw()
{ return __p; }
inline void* operator new[](std::size_t, void* __p) throw()
{ return __p; }


inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }

}

#pragma GCC visibility pop
# 34 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ext/new_allocator.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  using std::size_t;
  using std::ptrdiff_t;
# 57 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };







      new_allocator() throw() { }

      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }

      pointer
      address(reference __x) const
      { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const
      { return std::__addressof(__x); }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const throw()
      { return size_t(-1) / sizeof(_Tp); }
# 128 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ext/new_allocator.h" 3
      void
      construct(pointer __p, const _Tp& __val)
      { ::new((void *)__p) _Tp(__val); }

      void
      destroy(pointer __p) { __p->~_Tp(); }

    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }


}
# 34 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/c++allocator.h" 2 3
# 47 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/allocator.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{
# 62 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/allocator.h" 3
  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };






    };
# 91 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/allocator.h" 3
  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };







      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __gnu_cxx::new_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    { return false; }






  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };
# 219 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/allocator.h" 3
}
# 42 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/string" 2 3


# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ostream_insert.h" 1 3
# 34 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ostream_insert.h" 3


# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/cxxabi_forced.h" 1 3
# 35 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 37 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
# 45 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/string" 2 3



# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_function.h" 1 3
# 59 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 100 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
# 139 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_function.h" 3
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
# 203 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_function.h" 3
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
# 267 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_function.h" 3
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };
# 350 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 421 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }
# 508 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_function.h" 3
    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 541 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}



# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/backward/binders.h" 1 3
# 59 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/backward/binders.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 103 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}
# 732 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_function.h" 2 3
# 49 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/string" 2 3


# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/range_access.h" 1 3
# 34 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/range_access.h" 3
# 52 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/string" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 1 3
# 38 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{
# 111 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _CharT_alloc_type::size_type size_type;
      typedef typename _CharT_alloc_type::difference_type difference_type;
      typedef typename _CharT_alloc_type::reference reference;
      typedef typename _CharT_alloc_type::const_reference const_reference;
      typedef typename _CharT_alloc_type::pointer pointer;
      typedef typename _CharT_alloc_type::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
# 148 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };

      struct _Rep : _Rep_base
      {

 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
# 173 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
 static const size_type _S_max_size;
 static const _CharT _S_terminal;



        static size_type _S_empty_rep_storage[];

        static _Rep&
        _S_empty_rep()
        {



   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
   return *reinterpret_cast<_Rep*>(__p);
 }

        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }

        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }

        void
 _M_set_leaked()
        { this->_M_refcount = -1; }

        void
 _M_set_sharable()
        { this->_M_refcount = 0; }

 void
 _M_set_length_and_sharable(size_type __n)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {
       this->_M_set_sharable();
       this->_M_length = __n;
       traits_type::assign(this->_M_refdata()[__n], _S_terminal);


     }
 }

 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }

 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }


 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);

 void
 _M_dispose(const _Alloc& __a)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {

                                                                  ;
       if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
        -1) <= 0)
  {
                                                              ;
    _M_destroy(__a);
  }
     }
 }

 void
 _M_destroy(const _Alloc&) throw();

 _CharT*
 _M_refcopy() throw()
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
   return _M_refdata();
 }

 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }

 _CharT* _M_p;
      };

    public:




      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const
      { return iterator(_M_data()); }

      iterator
      _M_iend() const
      { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }


      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2)
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }

    public:







      basic_string()

      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }







      explicit
      basic_string(const _Alloc& __a);






      basic_string(const basic_string& __str);






      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
# 483 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());





      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());






      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());
# 531 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());




      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }





      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 564 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 604 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      iterator
      begin()
      {
 _M_leak();
 return iterator(_M_data());
      }





      const_iterator
      begin() const
      { return const_iterator(_M_data()); }





      iterator
      end()
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }





      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }
# 710 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
    public:



      size_type
      size() const
      { return _M_rep()->_M_length; }



      size_type
      length() const
      { return _M_rep()->_M_length; }


      size_type
      max_size() const
      { return _Rep::_S_max_size; }
# 739 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 752 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }
# 775 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      capacity() const
      { return _M_rep()->_M_capacity; }
# 796 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear()
      { _M_mutate(0, this->size(), 0); }





      bool
      empty() const
      { return this->size() == 0; }
# 825 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const
      {
                                       ;
 return _M_data()[__pos];
      }
# 842 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {

                                       ;

                                         ;
 _M_leak();
 return _M_data()[__pos];
      }
# 863 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
# 882 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }
# 931 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }
# 972 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str);
# 988 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);







      basic_string&
      append(const _CharT* __s, size_type __n);






      basic_string&
      append(const _CharT* __s)
      {
                               ;
 return this->append(__s, traits_type::length(__s));
      }
# 1020 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c);
# 1042 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }






      basic_string&
      assign(const basic_string& __str);
# 1099 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
# 1115 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n);
# 1127 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
                               ;
 return this->assign(__s, traits_type::length(__s));
      }
# 1143 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 1155 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
# 1184 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
# 1200 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
# 1232 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
# 1254 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
# 1277 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
# 1295 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
                               ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
# 1318 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1336 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      iterator
      insert(iterator __p, _CharT __c)
      {
                                                                 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1361 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }
# 1377 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      iterator
      erase(iterator __position)
      {

                               ;
 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1397 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 1428 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1450 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1475 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
# 1495 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
                               ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1519 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1537 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 1556 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {

                          ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
# 1577 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
                               ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 1598 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {

                          ;
 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
# 1621 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {

                            ;
                                             ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }



      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 1697 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);



      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }



      template<class _Integer>
        static _CharT*
        _S_construct_aux(_Integer __beg, _Integer __end,
    const _Alloc& __a, __true_type)
        { return _S_construct_aux_2(static_cast<size_type>(__beg),
        __end, __a); }

      static _CharT*
      _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc& __a)
      { return _S_construct(__req, __c, __a); }

      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);



      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:
# 1779 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 1789 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      void
      swap(basic_string& __s);
# 1799 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      const _CharT*
      c_str() const
      { return _M_data(); }







      const _CharT*
      data() const
      { return _M_data(); }




      allocator_type
      get_allocator() const
      { return _M_dataplus; }
# 1832 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
# 1845 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const

      { return this->find(__str.data(), __pos, __str.size()); }
# 1860 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
                               ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 1877 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const ;
# 1890 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const

      { return this->rfind(__str.data(), __pos, __str.size()); }
# 1907 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
# 1920 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 1937 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const ;
# 1951 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const

      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 1968 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1981 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
                               ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 2000 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }
# 2015 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const

      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 2032 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 2045 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 2064 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }
# 2078 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const

      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 2095 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
# 2109 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
                               ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 2126 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
                  ;
# 2141 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const

      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 2158 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
# 2172 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 2189 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
                  ;
# 2205 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2224 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 2256 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2282 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
# 2300 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
# 2324 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 2351 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };
# 2363 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }
# 2484 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 2530 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 2567 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 2604 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 2641 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 2678 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 2715 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
# 2733 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 2751 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 2774 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 2791 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return getline(__is, __str, __is.widen('\n')); }

  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}
# 53 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/string" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.tcc" 1 3
# 41 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 try
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {

      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   __throw_logic_error(("basic_string::_S_construct null not valid"));

 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));

 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 try
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {

      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();


      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);

      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }
# 240 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {

   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
                                             ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {

   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
                                             ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
                                              ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {

           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     typename basic_string<_CharT, _Traits, _Alloc>::iterator
     basic_string<_CharT, _Traits, _Alloc>::
     erase(iterator __first, iterator __last)
     {

                           ;




       const size_type __size = __last - __first;
       if (__size)
  {
    const size_type __pos = __first - _M_ibegin();
    _M_mutate(__pos, __size, size_type(0));
    _M_rep()->_M_set_leaked();
    return iterator(_M_data() + __pos);
  }
       else
  return __first;
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
                                               ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {

    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {

    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {

      if (_M_rep() == &_S_empty_rep())
 return;

      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {

   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);

   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);

   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {

   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {

   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }

      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {


      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
# 577 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_string.tcc" 3
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);







      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;




      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);

      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);

   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;







      __p->_M_set_sharable();
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);

      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
                                      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
                                             ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
                                    ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
                                    ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
                                              ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }




  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
# 54 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/string" 2 3
# 41 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{
# 62 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 98 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 117 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 3
    locale() throw();
# 126 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 136 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 151 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 164 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 177 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 191 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 206 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    string
    name() const;
# 225 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw();







    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }
# 253 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 269 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 3
    static locale
    global(const locale& __loc);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 304 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 6 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };
# 338 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 369 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);



    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();

  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {

                                                           ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
                                                              ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    facet(const facet&);

    facet&
    operator=(const facet&);
  };
# 436 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const throw();
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {

                                                           ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
                                                              ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    void
    _M_install_cache(const facet*, size_t);
  };
# 583 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 3
  template<typename _CharT>
    class collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 610 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 624 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 641 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 660 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 674 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 703 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 717 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 730 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();



  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }

    protected:
      virtual
      ~collate_byname() { }
    };


}


# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.tcc" 1 3
# 38 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
# 102 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.tcc" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }
# 130 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.tcc" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }




  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);




}
# 788 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_classes.h" 2 3
# 42 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ios_base.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{






  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16
    };

  inline _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }

  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16
    };

  inline _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }

  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16
    };

  inline _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline const _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }


  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };
# 199 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ios_base.h" 3
  class ios_base
  {
  public:







    class failure : public exception
    {
    public:


      explicit
      failure(const string& __str) throw();



      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();

    private:
      string _M_msg;
    };
# 255 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 330 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 361 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 393 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;


    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 419 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 436 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ios_base.h" 3
    typedef void (*event_callback) (event __e, ios_base& __b, int __i);
# 448 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      {

                                                             ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
                                                                ;
          }
        return __res;
      }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init() throw();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 561 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 577 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 594 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 620 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 671 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 683 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc) throw();
# 694 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 705 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 724 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 740 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 761 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 778 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base() throw ();



  private:
    ios_base(const ios_base&);

    ios_base&
    operator=(const ios_base&);
  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }


}
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ios" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 1 3
# 37 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3








namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 119 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(basic_streambuf*, basic_streambuf*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:







      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 208 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      locale
      pubimbue(const locale& __loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 225 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 238 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      basic_streambuf*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }
# 250 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }
# 262 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }




      int
      pubsync() { return this->sync(); }
# 283 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 297 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 315 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 337 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 356 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 371 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 396 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 423 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 449 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 463 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 481 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 497 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 508 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 528 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 544 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 554 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 575 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      virtual void
      imbue(const locale& __loc)
      { }
# 590 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 601 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 613 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 626 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      virtual int
      sync() { return 0; }
# 648 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 664 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 686 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 699 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 723 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      virtual int_type
      pbackfail(int_type __c = traits_type::eof())
      { return traits_type::eof(); }
# 741 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 767 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      virtual int_type
      overflow(int_type __c = traits_type::eof())
      { return traits_type::eof(); }



    public:
# 782 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 3
      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }



      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }

      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }

    private:


      basic_streambuf(const basic_streambuf& __sb)
      : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur),
      _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg),
      _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur),
      _M_buf_locale(__sb._M_buf_locale)
      { }

      basic_streambuf&
      operator=(const basic_streambuf&) { return *this; };
    };


  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);



}


# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/streambuf.tcc" 1 3
# 38 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/streambuf.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->__safe_gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->__safe_pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }




  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);




}
# 829 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/streambuf" 2 3
# 44 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ios" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_ios.h" 1 3
# 34 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_ios.h" 3



# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 1 3
# 38 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3

# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cwctype" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cwctype" 3
# 50 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cwctype" 3
# 1 "/usr/include/wctype.h" 1 3 4
# 33 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/wchar.h" 1 3 4
# 34 "/usr/include/wctype.h" 2 3 4
# 52 "/usr/include/wctype.h" 3 4
typedef unsigned long int wctype_t;
# 71 "/usr/include/wctype.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {
# 111 "/usr/include/wctype.h" 3 4
extern int iswalnum (wint_t __wc) throw ();





extern int iswalpha (wint_t __wc) throw ();


extern int iswcntrl (wint_t __wc) throw ();



extern int iswdigit (wint_t __wc) throw ();



extern int iswgraph (wint_t __wc) throw ();




extern int iswlower (wint_t __wc) throw ();


extern int iswprint (wint_t __wc) throw ();




extern int iswpunct (wint_t __wc) throw ();




extern int iswspace (wint_t __wc) throw ();




extern int iswupper (wint_t __wc) throw ();




extern int iswxdigit (wint_t __wc) throw ();





extern int iswblank (wint_t __wc) throw ();
# 171 "/usr/include/wctype.h" 3 4
extern wctype_t wctype (const char *__property) throw ();



extern int iswctype (wint_t __wc, wctype_t __desc) throw ();
# 186 "/usr/include/wctype.h" 3 4
typedef const __int32_t *wctrans_t;







extern wint_t towlower (wint_t __wc) throw ();


extern wint_t towupper (wint_t __wc) throw ();


}
# 213 "/usr/include/wctype.h" 3 4
extern "C" {




extern wctrans_t wctrans (const char *__property) throw ();


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) throw ();
# 230 "/usr/include/wctype.h" 3 4
extern int iswalnum_l (wint_t __wc, __locale_t __locale) throw ();





extern int iswalpha_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswcntrl_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswdigit_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswgraph_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswlower_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswprint_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswpunct_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswspace_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswupper_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswxdigit_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswblank_l (wint_t __wc, __locale_t __locale) throw ();



extern wctype_t wctype_l (const char *__property, __locale_t __locale)
     throw ();



extern int iswctype_l (wint_t __wc, wctype_t __desc, __locale_t __locale)
     throw ();







extern wint_t towlower_l (wint_t __wc, __locale_t __locale) throw ();


extern wint_t towupper_l (wint_t __wc, __locale_t __locale) throw ();



extern wctrans_t wctrans_l (const char *__property, __locale_t __locale)
     throw ();


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      __locale_t __locale) throw ();



}
# 51 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cwctype" 2 3
# 80 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cwctype" 3
namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cctype" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cctype" 3
# 41 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/ctype_base.h" 1 3
# 36 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/ctype_base.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;
  };


}
# 42 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 2 3






# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/streambuf_iterator.h" 1 3
# 34 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/streambuf_iterator.h" 3




namespace std __attribute__ ((__visibility__ ("default")))
{
# 49 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/streambuf_iterator.h" 3
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
                      _CharT*,




        _CharT&>

    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

    private:







      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;

    public:

                         istreambuf_iterator() throw()
      : _M_sbuf(0), _M_c(traits_type::eof()) { }
# 112 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/streambuf_iterator.h" 3
      istreambuf_iterator(istream_type& __s) throw()
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) throw()
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {


                        ;
 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {


                        ;

 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) throw()
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) throw()
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const throw()
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->__safe_gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->__safe_gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }




}
# 49 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 64 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 142 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 161 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 178 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 194 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 210 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 224 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 239 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 253 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 268 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 285 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 304 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 323 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 345 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char* __to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 370 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 389 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 408 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 427 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 445 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const = 0;
# 462 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 478 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const = 0;
# 495 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 514 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const = 0;
# 535 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const = 0;
# 556 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const = 0;
# 581 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const = 0;
    };
# 604 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 673 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 710 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 723 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 736 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 751 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 765 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 779 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 794 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 811 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 827 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 844 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 864 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 891 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 922 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 955 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char* __to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
# 1004 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1021 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1037 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1054 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1074 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1097 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }
# 1123 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const
      { return __c; }
# 1149 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const
      {
 __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
# 1174 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1207 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1218 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();


      virtual
      ~ctype();
# 1242 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1261 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1279 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1297 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1314 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1331 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1347 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1364 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1384 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const;
# 1406 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const;
# 1429 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const;
# 1455 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;


      void
      _M_initialize_ctype() throw();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };



}



# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/ctype_inline.h" 1 3
# 37 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/ctype_inline.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }


}
# 1512 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class __num_base
  {
  public:


    enum
      {
 _S_ominus,
 _S_oplus,
 _S_ox,
 _S_oX,
 _S_odigits,
 _S_odigits_end = _S_odigits + 16,
 _S_oudigits = _S_odigits_end,
 _S_oudigits_end = _S_oudigits + 16,
 _S_oe = _S_odigits + 14,
 _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
 _M_use_grouping(false),
 _M_truename(0), _M_truename_size(0), _M_falsename(0),
 _M_falsename_size(0), _M_decimal_point(_CharT()),
 _M_thousands_sep(_CharT()), _M_allocated(false)
 { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }
# 1640 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }
# 1678 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1692 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }
# 1706 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1719 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1750 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1763 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1776 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1793 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1805 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1818 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1831 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1844 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~numpunct_byname() { }
    };
# 1914 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1935 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1961 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 1998 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2058 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2101 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
 iter_type
 _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
 _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
 _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2172 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, void*&) const;
# 2235 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2253 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2274 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2292 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2334 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __io, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2397 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2422 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __io, __fill, __v); }

    protected:
      template<typename _ValueT>
 iter_type
 _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
 iter_type
 _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
# 2470 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, double) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type, long double) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, const void*) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;
# 2528 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 3
  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }


  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }


}


# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.tcc" 1 3
# 34 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = 0;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      try
 {
   _M_grouping_size = __np.grouping().size();
   __grouping = new char[_M_grouping_size];
   __np.grouping().copy(__grouping, _M_grouping_size);
   _M_grouping = __grouping;
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(_M_grouping[0]) > 0
        && (_M_grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   _M_truename_size = __np.truename().size();
   __truename = new _CharT[_M_truename_size];
   __np.truename().copy(__truename, _M_truename_size);
   _M_truename = __truename;

   _M_falsename_size = __np.falsename().size();
   __falsename = new _CharT[_M_falsename_size];
   __np.falsename().copy(__falsename, _M_falsename_size);
   _M_falsename = __falsename;

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
   throw;
 }
    }
# 136 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.tcc" 3
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
   ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
   : __gnu_cxx::__numeric_traits<_ValueT>::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative
  && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
     else
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
# 730 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 966 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);




 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
          __fbuf, __prec, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
       __fbuf, __prec, __v);
   }
# 1027 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1152 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }
# 1189 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }




  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class numpunct<wchar_t>;
  extern template class numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);




}
# 2609 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/locale_facets.h" 2 3
# 38 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_ios.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 65 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:







      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }

      bool
      operator!() const
      { return this->fail(); }
# 130 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 141 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 194 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 215 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 250 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 288 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 300 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 340 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 354 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 383 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 403 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 423 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 442 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);

      void
      _M_cache_locale(const locale& __loc);
    };


}


# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_ios.tcc" 1 3
# 34 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_ios.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 146 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }




  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;




}
# 476 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/basic_ios.h" 2 3
# 45 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ios" 2 3
# 39 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ostream" 1 3
# 37 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ostream" 3




namespace std __attribute__ ((__visibility__ ("default")))
{
# 57 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 83 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 107 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 165 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
# 219 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ostream" 3
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }
# 244 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ostream" 3
      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
# 269 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 302 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ostream" 3
      __ostream_type&
      put(char_type __c);






      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 334 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 347 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ostream" 3
      __ostream_type&
      flush();
# 357 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ostream" 3
      pos_type
      tellp();
# 368 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 380 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }

      template<typename _ValueT>
 __ostream_type&
 _M_insert(_ValueT __v);
    };
# 399 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 418 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
# 428 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ostream" 3
      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
# 449 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ostream" 3
      operator bool() const
      { return _M_ok; }
    };
# 469 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 511 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 562 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
# 574 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
# 607 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ostream" 3
}


# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ostream.tcc" 1 3
# 38 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/ostream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }




  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);




}
# 610 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ostream" 2 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 57 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:







      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 119 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 167 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }
# 213 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }
# 234 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 258 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 268 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 301 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
      int_type
      get();
# 315 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
      __istream_type&
      get(char_type& __c);
# 342 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 353 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 376 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 386 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 415 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 426 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 450 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
      __istream_type&
      ignore(streamsize __n, int_type __delim);

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore();
# 467 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
      int_type
      peek();
# 485 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 504 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 521 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
      __istream_type&
      putback(char_type __c);
# 537 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
      __istream_type&
      unget();
# 555 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
      int
      sync();
# 570 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
      pos_type
      tellg();
# 585 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
      __istream_type&
      seekg(pos_type);
# 601 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }

      template<typename _ValueT>
 __istream_type&
 _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 656 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {

      bool _M_ok;

    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 692 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 705 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
      operator bool() const
      { return _M_ok; }
    };
# 721 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 763 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 794 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }
    };
# 854 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);
# 877 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 3
}


# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/istream.tcc" 1 3
# 38 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/istream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && bool(__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();




       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 513 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       if (!this->fail())
  __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
        ios_base::in);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekpos(__pos,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }




  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;




}
# 880 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/istream" 2 3
# 39 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/sstream" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{
# 63 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

    protected:

      ios_base::openmode _M_mode;


      __string_type _M_string;

    public:
# 97 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
# 110 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
      { _M_stringbuf_init(__mode); }
# 125 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/sstream" 3
      __string_type
      str() const
      {
 __string_type __ret;
 if (this->pptr())
   {

     if (this->pptr() > this->egptr())
       __ret = __string_type(this->pbase(), this->pptr());
     else
        __ret = __string_type(this->pbase(), this->egptr());
   }
 else
   __ret = _M_string;
 return __ret;
      }
# 149 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/sstream" 3
      void
      str(const __string_type& __s)
      {

 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }

    protected:

      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }

      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }

      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = traits_type::eof());

      virtual int_type
      overflow(int_type __c = traits_type::eof());
# 201 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string.clear();


     _M_sync(__s, __n, 0);
   }
 return this;
      }

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);




      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);



      void
      _M_update_egptr()
      {
 const bool __testin = _M_mode & ios_base::in;
 if (this->pptr() && this->pptr() > this->egptr())
   {
     if (__testin)
       this->setg(this->eback(), this->gptr(), this->pptr());
     else
       this->setg(this->pptr(), this->pptr(), this->pptr());
   }
      }



      void
      _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off);
    };
# 271 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 307 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
# 325 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }
# 347 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 386 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 422 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
# 440 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }
# 462 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 501 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 536 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
# 552 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }
# 574 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };


}


# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/sstream.tcc" 1 3
# 38 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/sstream.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {


   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();
      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
# 110 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/sstream.tcc" 3
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp;
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();

   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);



      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();

   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->setg(this->eback(), this->eback() + __newoffi,
    this->egptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       _M_pbump(this->pbase(), this->epptr(), __newoffo);
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;

      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();

   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->setg(this->eback(), this->eback() + __pos,
      this->egptr());
       if (__testout)
  _M_pbump(this->pbase(), this->epptr(), __pos);
       __ret = __sp;
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();

      if (__base != _M_string.data())
 {

   __endg += __i;
   __i = 0;
   __endp = __endg;
 }

      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   _M_pbump(__base, __endp, __o);



   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off)
    {
      this->setp(__pbeg, __pend);
      while (__off > __gnu_cxx::__numeric_traits<int>::__max)
 {
   this->pbump(__gnu_cxx::__numeric_traits<int>::__max);
   __off -= __gnu_cxx::__numeric_traits<int>::__max;
 }
      this->pbump(__off);
    }




  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;


  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;




}
# 601 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/sstream" 2 3
# 29 "/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp" 2


# 1 "/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.hpp" 1
# 31 "/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.hpp"
# 1 "/home/marek/devel/nupic/nta/engine/Input.hpp" 1
# 38 "/home/marek/devel/nupic/nta/engine/Input.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/vector" 1 3
# 59 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/vector" 3



# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_construct.h" 1 3
# 61 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_construct.h" 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ext/alloc_traits.h" 1 3
# 33 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ext/alloc_traits.h" 3








namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
# 120 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ext/alloc_traits.h" 3
template<typename _Alloc>
  struct __alloc_traits



  {
    typedef _Alloc allocator_type;
# 199 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/ext/alloc_traits.h" 3
    typedef typename _Alloc::pointer pointer;
    typedef typename _Alloc::const_pointer const_pointer;
    typedef typename _Alloc::value_type value_type;
    typedef typename _Alloc::reference reference;
    typedef typename _Alloc::const_reference const_reference;
    typedef typename _Alloc::size_type size_type;
    typedef typename _Alloc::difference_type difference_type;

    static pointer
    allocate(_Alloc& __a, size_type __n)
    { return __a.allocate(__n); }

    static void deallocate(_Alloc& __a, pointer __p, size_type __n)
    { __a.deallocate(__p, __n); }

    template<typename _Tp>
      static void construct(_Alloc& __a, pointer __p, const _Tp& __arg)
      { __a.construct(__p, __arg); }

    static void destroy(_Alloc& __a, pointer __p)
    { __a.destroy(__p); }

    static size_type max_size(const _Alloc& __a)
    { return __a.max_size(); }

    static const _Alloc& _S_select_on_copy(const _Alloc& __a) { return __a; }

    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
    {


      std::__alloc_swap<_Alloc>::_S_do_it(__a, __b);
    }

    template<typename _Tp>
      struct rebind
      { typedef typename _Alloc::template rebind<_Tp>::other other; };

  };


}
# 62 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_construct.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{
# 77 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_construct.h" 3
  template<typename _T1, typename _T2>
    inline void
    _Construct(_T1* __p, const _T2& __value)
    {


      ::new(static_cast<void*>(__p)) _T1(__value);
    }





  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }







  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __first != __last; ++__first)
 __traits::destroy(__alloc, std::__addressof(*__first));
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }


}
# 63 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/vector" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_uninitialized.h" 1 3
# 59 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_uninitialized.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, ++__cur)
  std::_Construct(std::__addressof(*__cur), *__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 105 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;

      return std::__uninitialized_copy<(__is_trivial(_ValueType1)
     && __is_trivial(_ValueType2))>::
 __uninit_copy(__first, __last, __result);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 162 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill<__is_trivial(_ValueType)>::
 __uninit_fill(__first, __last, __x);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        { std::fill_n(__first, __n, __x); }
    };
# 216 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill_n<__is_trivial(_ValueType)>::
 __uninit_fill_n(__first, __n, __x);
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __first != __last; ++__first, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a((__first),
      (__last),
      __result, __alloc);
    }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_if_noexcept_a(_InputIterator __first,
           _InputIterator __last,
           _ForwardIterator __result,
           _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a
 ((__first),
  (__last), __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill_n(__first, __n, __x); }
# 346 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }
# 654 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_uninitialized.h" 3
}
# 64 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/vector" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 1 3
# 66 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Tp>::other _Tp_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
        pointer;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 pointer _M_start;
 pointer _M_finish;
 pointer _M_end_of_storage;

 _Vector_impl()
 : _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }

 _Vector_impl(_Tp_alloc_type const& __a)
 : _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }
# 101 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
 void _M_swap_data(_Vector_impl& __x)
 {
   std::swap(_M_start, __x._M_start);
   std::swap(_M_finish, __x._M_finish);
   std::swap(_M_end_of_storage, __x._M_end_of_storage);
 }
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base()
      : _M_impl() { }

      _Vector_base(const allocator_type& __a)
      : _M_impl(__a) { }

      _Vector_base(size_t __n)
      : _M_impl()
      { _M_create_storage(__n); }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      { _M_create_storage(__n); }
# 159 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      pointer
      _M_allocate(size_t __n)
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
 if (__p)
   _M_impl.deallocate(__p, __n);
      }

    private:
      void
      _M_create_storage(size_t __n)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
    };
# 209 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;



      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;

    public:
      typedef _Tp value_type;
      typedef typename _Base::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:





      vector()
      : _Base() { }





      explicit
      vector(const allocator_type& __a)
      : _Base(__a) { }
# 294 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const value_type& __value = value_type(),
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
# 310 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(),
        _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 397 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      template<typename _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }
# 414 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      ~vector()
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator()); }
# 426 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 478 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 501 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
# 529 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      using _Base::get_allocator;







      iterator
      begin()
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end()
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }
# 644 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      size_type
      size() const
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const
      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
# 703 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 if (__new_size > size())
   insert(end(), __new_size - size(), __x);
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 724 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      size_type
      capacity() const
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const
      { return begin() == end(); }
# 754 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 769 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      reference
      operator[](size_type __n)
      { return *(this->_M_impl._M_start + __n); }
# 784 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const
      { return *(this->_M_impl._M_start + __n); }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("vector::_M_range_check"));
      }

    public:
# 809 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 827 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      { return *(end() - 1); }





      const_reference
      back() const
      { return *(end() - 1); }
# 876 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      pointer

      data()
      { return std::__addressof(front()); }




      const_pointer

      data() const
      { return std::__addressof(front()); }
# 900 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                              __x);
     ++this->_M_impl._M_finish;
   }
 else



   _M_insert_aux(end(), __x);

      }
# 936 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      void
      pop_back()
      {
 --this->_M_impl._M_finish;
 _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      }
# 972 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 1022 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 1048 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 1074 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      iterator
      erase(iterator __position);
# 1095 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 1107 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      void
      swap(vector& __x)



      {
 this->_M_impl._M_swap_data(__x._M_impl);
 _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
                           __x._M_get_Tp_allocator());
      }







      void
      clear()
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
        {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
# 1159 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
   this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
   this->_M_impl._M_end_of_storage =
     this->_M_impl._M_start + static_cast<size_type>(__n);
   _M_fill_initialize(static_cast<size_type>(__n), __value);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
       _InputIterator __last, std::input_iterator_tag)
        {
   for (; __first != __last; ++__first)



     push_back(*__first);

 }


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag)
        {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
          _M_get_Tp_allocator());
 this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
      }
# 1237 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);
# 1277 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
        { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_insert(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);
# 1322 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      void
      _M_insert_aux(iterator __position, const value_type& __x);
# 1335 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }





      void
      _M_erase_at_end(pointer __pos)
      {
 std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
 this->_M_impl._M_finish = __pos;
      }
# 1388 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
    };
# 1401 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 1418 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    { __x.swap(__y); }


}
# 65 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/vector" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_bvector.h" 1 3
# 63 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_bvector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() : _M_p(0), _M_mask(0) { }

    operator bool() const
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x)
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x)
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip()
    { *_M_p ^= _M_mask; }
  };
# 136 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_bvector.h" 3
  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
  {
    for (; __first != __last; ++__first)
      *__first = __x;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
 __fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
 __fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      __fill_bvector(__first, __last, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename _Alloc::template rebind<_Bit_type>::other
        _Bit_alloc_type;

      struct _Bvector_impl
      : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_type* _M_end_of_storage;

 _Bvector_impl()
 : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }

 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }







      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator()
      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Bit_allocator()); }

      _Bvector_base()
      : _M_impl() { }

      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }
# 465 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_bvector.h" 3
      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_type*
      _M_allocate(size_t __n)
      { return _M_impl.allocate(_S_nword(__n)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   _M_impl.deallocate(_M_impl._M_start._M_p,
        _M_impl._M_end_of_storage - _M_impl._M_start._M_p);
      }

      static size_t
      _S_nword(size_t __n)
      { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }
    };


}




namespace std __attribute__ ((__visibility__ ("default")))
{
# 517 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_bvector.h" 3
template<typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
  {
    typedef _Bvector_base<_Alloc> _Base;





  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef _Alloc allocator_type;

    allocator_type get_allocator() const
    { return _Base::get_allocator(); }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_S_nword;
    using _Base::_M_get_Bit_allocator;

  public:
    vector()
    : _Base() { }

    explicit
    vector(const allocator_type& __a)
    : _Base(__a) { }
# 572 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_bvector.h" 3
    explicit
    vector(size_type __n, const bool& __value = bool(),
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage,
  __value ? ~0 : 0);
    }


    vector(const vector& __x)
    : _Base(__x._M_get_Bit_allocator())
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }
# 611 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_bvector.h" 3
    template<typename _InputIterator>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_initialize_dispatch(__first, __last, _Integral());
      }


    ~vector() { }

    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;
      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
      begin());
      return *this;
    }
# 661 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_bvector.h" 3
    void
    assign(size_type __n, const bool& __x)
    { _M_fill_assign(__n, __x); }
# 672 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_bvector.h" 3
    template<typename _InputIterator>
      void
      assign(_InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_assign_dispatch(__first, __last, _Integral());
      }
# 687 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_bvector.h" 3
    iterator
    begin()
    { return this->_M_impl._M_start; }

    const_iterator
    begin() const
    { return this->_M_impl._M_start; }

    iterator
    end()
    { return this->_M_impl._M_finish; }

    const_iterator
    end() const
    { return this->_M_impl._M_finish; }

    reverse_iterator
    rbegin()
    { return reverse_iterator(end()); }

    const_reverse_iterator
    rbegin() const
    { return const_reverse_iterator(end()); }

    reverse_iterator
    rend()
    { return reverse_iterator(begin()); }

    const_reverse_iterator
    rend() const
    { return const_reverse_iterator(begin()); }
# 737 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_bvector.h" 3
    size_type
    size() const
    { return size_type(end() - begin()); }

    size_type
    max_size() const
    {
      const size_type __isize =
 __gnu_cxx::__numeric_traits<difference_type>::__max
 - int(_S_word_bit) + 1;
      const size_type __asize = _M_get_Bit_allocator().max_size();
      return (__asize <= __isize / int(_S_word_bit)
       ? __asize * int(_S_word_bit) : __isize);
    }

    size_type
    capacity() const
    { return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0)
         - begin()); }

    bool
    empty() const
    { return begin() == end(); }

    reference
    operator[](size_type __n)
    {
      return *iterator(this->_M_impl._M_start._M_p
         + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

    const_reference
    operator[](size_type __n) const
    {
      return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

  protected:
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
        __throw_out_of_range(("vector<bool>::_M_range_check"));
    }

  public:
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    void
    reserve(size_type __n)
    {
      if (__n > max_size())
 __throw_length_error(("vector::reserve"));
      if (capacity() < __n)
 _M_reallocate(__n);
    }

    reference
    front()
    { return *begin(); }

    const_reference
    front() const
    { return *begin(); }

    reference
    back()
    { return *(end() - 1); }

    const_reference
    back() const
    { return *(end() - 1); }






    void
    data() { }

    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void
    swap(vector& __x)
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);



      std::__alloc_swap<typename _Base::_Bit_alloc_type>::
 _S_do_it(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());
    }


    static void
    swap(reference __x, reference __y)
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator
    insert(iterator __position, const bool& __x = bool())
    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }
# 877 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_bvector.h" 3
    template<typename _InputIterator>
      void
      insert(iterator __position,
      _InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_insert_dispatch(__position, __first, __last, _Integral());
      }


    void
    insert(iterator __position, size_type __n, const bool& __x)
    { _M_fill_insert(__position, __n, __x); }






    void
    pop_back()
    { --this->_M_impl._M_finish; }

    iterator
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

    iterator
    erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }

    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }







    void
    flip()
    {
      for (_Bit_type * __p = this->_M_impl._M_start._M_p;
    __p != this->_M_impl._M_end_of_storage; ++__p)
        *__p = ~*__p;
    }

    void
    clear()
    { _M_erase_at_end(begin()); }


  protected:

    iterator
    _M_copy_aligned(const_iterator __first, const_iterator __last,
      iterator __result)
    {
      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
         iterator(__q, 0));
    }

    void
    _M_initialize(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }

    void
    _M_reallocate(size_type __n);
# 977 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_bvector.h" 3
    template<typename _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(static_cast<size_type>(__n));
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
      }

    template<typename _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<typename _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   push_back(*__first);
      }

    template<typename _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }



    template<typename _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign(__n, __val); }

    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   _M_erase_at_end(begin() + __n);
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
 }
    }

    template<typename _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

    template<typename _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   _M_erase_at_end(std::copy(__first, __last, begin()));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }





    template<typename _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }

    template<typename _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }

    void
    _M_fill_insert(iterator __position, size_type __n, bool __x);

    template<typename _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

    template<typename _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag);

    void
    _M_insert_aux(iterator __position, bool __x);

    size_type
    _M_check_len(size_type __n, const char* __s) const
    {
      if (max_size() - size() < __n)
 __throw_length_error((__s));

      const size_type __len = size() + std::max(size(), __n);
      return (__len < size() || __len > max_size()) ? max_size() : __len;
    }

    void
    _M_erase_at_end(iterator __pos)
    { this->_M_impl._M_finish = __pos; }
  };


}
# 66 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/vector" 2 3



# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/vector.tcc" 1 3
# 59 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/vector.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
     (this->_M_impl._M_start),
     (this->_M_impl._M_finish));
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }
# 105 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
   && __position == end())
 {
   _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);
   ++this->_M_impl._M_finish;
 }
      else
 {
# 127 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/vector.tcc" 3
     _M_insert_aux(__position, __x);
 }
      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __position)
    {
      if (__position + 1 != end())
 std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 {
   if (__last != end())
     std::copy(__last, end(), __first);
   _M_erase_at_end(__first.base() + (end() - __last));
 }
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {
# 184 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/vector.tcc" 3
   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp.swap(*this);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
     __n - size(), __val,
     _M_get_Tp_allocator());
   this->_M_impl._M_finish += __n - size();
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
   }
      }
# 316 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_insert_aux(iterator __position, const _Tp& __x)

    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 {
   _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
              (*(this->_M_impl._M_finish - 1)));

   ++this->_M_impl._M_finish;

   _Tp __x_copy = __x;

   std::copy_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1);



   *__position = __x_copy;



 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector::_M_insert_aux");
   const size_type __elems_before = __position - begin();
   pointer __new_start(this->_M_allocate(__len));
   pointer __new_finish(__new_start);
   try
     {




       _Alloc_traits::construct(this->_M_impl,
                         __new_start + __elems_before,



                                __x);

       __new_finish = 0;

       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (this->_M_impl._M_start, __position.base(),
   __new_start, _M_get_Tp_allocator());

       ++__new_finish;

       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (__position.base(), this->_M_impl._M_finish,
   __new_finish, _M_get_Tp_allocator());
     }
          catch(...)
     {
       if (!__new_finish)
  _Alloc_traits::destroy(this->_M_impl,
                         __new_start + __elems_before);
       else
  std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
       _M_deallocate(__new_start, __len);
       throw;
     }
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __new_start;
   this->_M_impl._M_finish = __new_finish;
   this->_M_impl._M_end_of_storage = __new_start + __len;
 }
    }
# 439 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       value_type __x_copy = __x;
       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    std::copy_backward(__position.base(), __old_finish - __n, __old_finish);

    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
      __n - __elems_after,
      __x_copy,
      _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n - __elems_after;
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = 0;

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, __position.base(),
       __new_start, _M_get_Tp_allocator());

    __new_finish += __n;

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (__position.base(), this->_M_impl._M_finish,
       __new_finish, _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }
# 591 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      std::copy_backward(__position.base(), __old_finish - __n, __old_finish);

      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (this->_M_impl._M_start, __position.base(),
         __new_start, _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_copy_a(__first, __last,
          __new_finish,
          _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (__position.base(), this->_M_impl._M_finish,
         __new_finish, _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }



  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_reallocate(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_finish = _M_copy_aligned(begin(), end(),
      iterator(__q, 0));
      this->_M_deallocate();
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   std::fill(__i, __i + difference_type(__n), __x);
   this->_M_impl._M_finish = std::copy(__position, end(),
           __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_type * __q = this->_M_allocate(__len);
  iterator __i = _M_copy_aligned(begin(), __position,
            iterator(__q, 0));
  __i = std::copy(__first, __last, __i);
  this->_M_impl._M_finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
  this->_M_impl._M_start = iterator(__q, 0);
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   *__i++ = __x;
   this->_M_impl._M_finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }
# 812 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/vector.tcc" 3
}
# 70 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/vector" 2 3
# 39 "/home/marek/devel/nupic/nta/engine/Input.hpp" 2
# 1 "/home/marek/devel/nupic/nta/types/types.hpp" 1
# 31 "/home/marek/devel/nupic/nta/types/types.hpp"
# 1 "/home/marek/devel/nupic/nta/types/types.h" 1
# 32 "/home/marek/devel/nupic/nta/types/types.h"
# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 33 "/home/marek/devel/nupic/nta/types/types.h" 2




typedef enum NTA_BasicType
  {
    NTA_BasicType_Byte,
    NTA_BasicType_Int16,
    NTA_BasicType_UInt16,
    NTA_BasicType_Int32,
    NTA_BasicType_UInt32,
    NTA_BasicType_Int64,
    NTA_BasicType_UInt64,
    NTA_BasicType_Real32,
    NTA_BasicType_Real64,
    NTA_BasicType_Handle,


    NTA_BasicType_Last,




    NTA_BasicType_Real = NTA_BasicType_Real32,


  } NTA_BasicType;



typedef char NTA_Byte;

typedef size_t NTA_Size;

typedef short NTA_Int16;
typedef unsigned short NTA_UInt16;

typedef float NTA_Real32;
typedef double NTA_Real64;
typedef void * NTA_Handle;
# 105 "/home/marek/devel/nupic/nta/types/types.h"
typedef int NTA_Int32;
typedef unsigned int NTA_UInt32;
typedef long NTA_Int64;
typedef unsigned long NTA_UInt64;
# 117 "/home/marek/devel/nupic/nta/types/types.h"
  typedef NTA_Real32 NTA_Real;







  typedef NTA_Int32 NTA_Int;
  typedef NTA_UInt32 NTA_UInt;
# 147 "/home/marek/devel/nupic/nta/types/types.h"
typedef enum NTA_LogLevel
  {
    NTA_LogLevel_None,
    NTA_LogLevel_Minimal,
    NTA_LogLevel_Normal,
    NTA_LogLevel_Verbose,
  } NTA_LogLevel;
# 32 "/home/marek/devel/nupic/nta/types/types.hpp" 2



namespace nta
{

  typedef NTA_Byte Byte;
  typedef NTA_Int16 Int16;
  typedef NTA_UInt16 UInt16;
  typedef NTA_Int32 Int32;
  typedef NTA_UInt32 UInt32;
  typedef NTA_Int64 Int64;
  typedef NTA_UInt64 UInt64;
  typedef NTA_Real32 Real32;
  typedef NTA_Real64 Real64;
  typedef NTA_Handle Handle;

  typedef NTA_Real Real;
  typedef NTA_Int Int;
  typedef NTA_UInt UInt;

  typedef NTA_Size Size;


  enum LogLevel
  {
    LogLevel_None = NTA_LogLevel_None,
    LogLevel_Minimal,
    LogLevel_Normal,
    LogLevel_Verbose,
  };

}
# 40 "/home/marek/devel/nupic/nta/engine/Input.hpp" 2
# 1 "/home/marek/devel/nupic/nta/ntypes/Array.hpp" 1
# 35 "/home/marek/devel/nupic/nta/ntypes/Array.hpp"
# 1 "/home/marek/devel/nupic/nta/ntypes/ArrayBase.hpp" 1
# 42 "/home/marek/devel/nupic/nta/ntypes/ArrayBase.hpp"
namespace nta
{





  class ArrayBase
  {
  public:





    ArrayBase(NTA_BasicType type, void* buffer, size_t count);






    explicit ArrayBase(NTA_BasicType type);





    virtual ~ArrayBase();





    void
    allocateBuffer(size_t count);

    void
    setBuffer(void *buffer, size_t count);

    void
    releaseBuffer();

    void*
    getBuffer() const;


    size_t
    getCount() const;

    NTA_BasicType
    getType() const;

  protected:


    char* buffer_;
    size_t count_;
    NTA_BasicType type_;
    bool own_;
  };
}
# 36 "/home/marek/devel/nupic/nta/ntypes/Array.hpp" 2
# 1 "/home/marek/devel/nupic/nta/utils/Log.hpp" 1
# 32 "/home/marek/devel/nupic/nta/utils/Log.hpp"
# 1 "/home/marek/devel/nupic/nta/utils/LoggingException.hpp" 1
# 31 "/home/marek/devel/nupic/nta/utils/LoggingException.hpp"
# 1 "/home/marek/devel/nupic/nta/types/Exception.hpp" 1
# 32 "/home/marek/devel/nupic/nta/types/Exception.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/stdexcept" 1 3
# 37 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/stdexcept" 3




namespace std __attribute__ ((__visibility__ ("default")))
{
# 55 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/stdexcept" 3
  class logic_error : public exception
  {
    string _M_msg;

  public:

    explicit
    logic_error(const string& __arg);

    virtual ~logic_error() throw();



    virtual const char*
    what() const throw();
  };



  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg);
    virtual ~domain_error() throw();
  };


  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg);
    virtual ~invalid_argument() throw();
  };



  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg);
    virtual ~length_error() throw();
  };



  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg);
    virtual ~out_of_range() throw();
  };






  class runtime_error : public exception
  {
    string _M_msg;

  public:

    explicit
    runtime_error(const string& __arg);

    virtual ~runtime_error() throw();



    virtual const char*
    what() const throw();
  };


  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg);
    virtual ~range_error() throw();
  };


  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg);
    virtual ~overflow_error() throw();
  };


  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg);
    virtual ~underflow_error() throw();
  };




}
# 33 "/home/marek/devel/nupic/nta/types/Exception.hpp" 2



namespace nta
{
# 70 "/home/marek/devel/nupic/nta/types/Exception.hpp"
  class Exception : public std::runtime_error
  {
  public:
# 86 "/home/marek/devel/nupic/nta/types/Exception.hpp"
    Exception(const std::string & filename,
              UInt32 lineno,
              const std::string & message,
              const std::string & stacktrace = "") :
      std::runtime_error(""),
      filename_(filename),
      lineno_(lineno),
      message_(message),
      stackTrace_(stacktrace)
    {
    }
# 108 "/home/marek/devel/nupic/nta/types/Exception.hpp"
    virtual ~Exception() throw()
    {
    }
# 122 "/home/marek/devel/nupic/nta/types/Exception.hpp"
    virtual const char * what() const throw()
    {
      try
      {
        return getMessage();
      }
      catch (...)
      {
        return "Exception caught in non-throwing Exception::what()";
      }
    }
# 142 "/home/marek/devel/nupic/nta/types/Exception.hpp"
    const char * getFilename() const
    {
      return filename_.c_str();
    }
# 155 "/home/marek/devel/nupic/nta/types/Exception.hpp"
    UInt32 getLineNumber() const
    {
      return lineno_;
    }






    virtual const char * getMessage() const
    {
      return message_.c_str();
    }
# 178 "/home/marek/devel/nupic/nta/types/Exception.hpp"
    virtual const char * getStackTrace() const
    {
      return stackTrace_.c_str();
    }

  protected:
    std::string filename_;
    UInt32 lineno_;
    std::string message_;
    std::string stackTrace_;


  };
}
# 32 "/home/marek/devel/nupic/nta/utils/LoggingException.hpp" 2


namespace nta
{
  class LoggingException : public Exception
  {
  public:
    LoggingException(const std::string& filename, UInt32 lineno) :
      Exception(filename, lineno, std::string()), ss_(std::string()),
      lmessageValid_(false), alreadyLogged_(false)
    {
    }

    virtual ~LoggingException() throw();

    virtual const char * getMessage() const
    {





      if (! lmessageValid_) {
        lmessage_ = ss_.str();
        lmessageValid_ = true;
      }
      return lmessage_.c_str();
    }

    template <typename T> LoggingException& operator<<(const T& obj)
    {


      lmessageValid_ = false;
      ss_ << obj;
      return *this;
    }

    LoggingException(const LoggingException& l) : Exception(l),
                                                  ss_(l.ss_.str()),
                                                  lmessage_(""),
                                                  lmessageValid_(false),
                                                  alreadyLogged_(true)

    {

      getMessage();
    }

  private:
    std::stringstream ss_;
    mutable std::string lmessage_;
    mutable bool lmessageValid_;
    bool alreadyLogged_;
  };

}
# 33 "/home/marek/devel/nupic/nta/utils/Log.hpp" 2
# 1 "/home/marek/devel/nupic/nta/utils/LogItem.hpp" 1
# 32 "/home/marek/devel/nupic/nta/utils/LogItem.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/iostream" 1 3
# 37 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/iostream" 3





namespace std __attribute__ ((__visibility__ ("default")))
{
# 60 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;


}
# 33 "/home/marek/devel/nupic/nta/utils/LogItem.hpp" 2

namespace nta {
# 48 "/home/marek/devel/nupic/nta/utils/LogItem.hpp"
  class LogItem {
  public:

    typedef enum {debug, info, warn, error} LogLevel;



    LogItem(const char *filename, int line, LogLevel level);




    virtual ~LogItem();




    std::ostringstream& stream();

    static void setOutputFile(std::ostream& ostream);


  protected:
    const char *filename_;
    int lineno_;
    LogLevel level_;
    std::ostringstream msg_;

  private:
    static std::ostream* ostream_;

  };


}
# 34 "/home/marek/devel/nupic/nta/utils/Log.hpp" 2
# 37 "/home/marek/devel/nupic/nta/ntypes/Array.hpp" 2

namespace nta
{
  class Array : public ArrayBase
  {
  public:
    Array(NTA_BasicType type, void * buffer, size_t count) :
      ArrayBase(type, buffer, count)
    {
    }

    explicit Array(NTA_BasicType type) : ArrayBase(type)
    {
    }





    void invariant()
    {
      if (!own_)
        throw nta::LoggingException("/home/marek/devel/nupic/nta/ntypes/Array.hpp", 59) << "Array must own its buffer";
    }
  private:

    void setBuffer(void * buffer, size_t count);
  };
}
# 41 "/home/marek/devel/nupic/nta/engine/Input.hpp" 2

namespace nta
{
  class Link;
  class Region;
  class Output;
# 58 "/home/marek/devel/nupic/nta/engine/Input.hpp"
  class Input
  {
  public:
    Input(Region& region, NTA_BasicType type, bool isRegionLevel);
    ~Input();




    void setName(const std::string& name);

    const std::string& getName() const;





    void
    addLink(const std::string& linkType, const std::string& linkParams,
            Output* srcOutput);





    Link*
    findLink(const std::string& srcRegionName,
             const std::string& srcOutputName);
# 100 "/home/marek/devel/nupic/nta/engine/Input.hpp"
    void
    removeLink(Link*& link);


    void
    prepare();

    const Array &
    getData() const;

    Region&
    getRegion();

    const std::vector<Link*>&
    getLinks();

    bool
    isRegionLevel();
# 132 "/home/marek/devel/nupic/nta/engine/Input.hpp"
    size_t
    evaluateLinks();





    void
    initialize();

    bool
    isInitialized();






    typedef std::vector< std::vector<size_t> > SplitterMap;

    const SplitterMap& getSplitterMap() const;


    template <typename T> void getInputForNode(size_t nodeIndex, std::vector<T>& input) const;

  private:
    Region& region_;


    bool isRegionLevel_;




    std::vector<Link*> links_;

    bool zeroCopyEnabled_;


    bool initialized_;
    Array data_;






    mutable SplitterMap splitterMap_;
# 188 "/home/marek/devel/nupic/nta/engine/Input.hpp"
    std::vector<size_t> linkOffsets_;

    size_t size_;


    std::string name_;
# 204 "/home/marek/devel/nupic/nta/engine/Input.hpp"
    void
    uninitialize();



  };

}
# 32 "/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.hpp" 2
# 1 "/home/marek/devel/nupic/nta/engine/RegionImpl.hpp" 1
# 40 "/home/marek/devel/nupic/nta/engine/RegionImpl.hpp"
# 1 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp" 1
# 38 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
# 1 "/home/marek/devel/nupic/nta/ntypes/object_model.h" 1
# 40 "/home/marek/devel/nupic/nta/ntypes/object_model.h"
extern "C" {
# 98 "/home/marek/devel/nupic/nta/ntypes/object_model.h"
typedef struct _NTA_ReadBufferHandle { char c; } * NTA_ReadBufferHandle;
typedef struct NTA_ReadBuffer
{

  void (*reset)(NTA_ReadBufferHandle handle);
  NTA_Size (*getSize)(NTA_ReadBufferHandle handle);
  const NTA_Byte * (*getData)(NTA_ReadBufferHandle handle);
  NTA_Int32 (*readByte)(NTA_ReadBufferHandle handle, NTA_Byte * value);
  NTA_Int32 (*readByteArray)(NTA_ReadBufferHandle handle, NTA_Byte * value, NTA_Size * size);
  NTA_Int32 (*readAsString)(NTA_ReadBufferHandle handle,
      NTA_Byte ** value,
      NTA_UInt32 * size,
      NTA_Byte *(*fAlloc)(NTA_UInt32),
      void (*fDealloc)(NTA_Byte *)
    );

  NTA_Int32 (*readInt32)(NTA_ReadBufferHandle handle, NTA_Int32 * value);
  NTA_Int32 (*readInt32Array)(NTA_ReadBufferHandle handle, NTA_Int32 * value, NTA_Size size);
  NTA_Int32 (*readUInt32)(NTA_ReadBufferHandle handle, NTA_UInt32 * value);
  NTA_Int32 (*readUInt32Array)(NTA_ReadBufferHandle handle, NTA_UInt32 * value, NTA_Size size);
  NTA_Int32 (*readInt64)(NTA_ReadBufferHandle handle, NTA_Int64 * value);
  NTA_Int32 (*readInt64Array)(NTA_ReadBufferHandle handle, NTA_Int64 * value, NTA_Size size);
  NTA_Int32 (*readUInt64)(NTA_ReadBufferHandle handle, NTA_UInt64 * value);
  NTA_Int32 (*readUInt64Array)(NTA_ReadBufferHandle handle, NTA_UInt64 * value, NTA_Size size);
  NTA_Int32 (*readReal32)(NTA_ReadBufferHandle handle, NTA_Real32 * value);
  NTA_Int32 (*readReal32Array)(NTA_ReadBufferHandle handle, NTA_Real32 * value, NTA_Size size);
  NTA_Int32 (*readReal64)(NTA_ReadBufferHandle handle, NTA_Real64 * value);
  NTA_Int32 (*readReal64Array)(NTA_ReadBufferHandle handle, NTA_Real64 * value, NTA_Size size);


  NTA_ReadBufferHandle handle;

} NTA_ReadBuffer;
# 143 "/home/marek/devel/nupic/nta/ntypes/object_model.h"
typedef struct _NTA_ReadBufferIteratorHandle { char c; } * NTA_ReadBufferIteratorHandle;
typedef struct NTA_ReadBufferIterator
{

   void (*reset)(NTA_ReadBufferIteratorHandle handle);
   const NTA_ReadBuffer * (*next)(NTA_ReadBufferIteratorHandle handle);


   NTA_ReadBufferIteratorHandle handle;
} NTA_ReadBufferIterator;
# 166 "/home/marek/devel/nupic/nta/ntypes/object_model.h"
typedef struct _NTA_WriteBufferHandle { char c; } * NTA_WriteBufferHandle;
typedef struct NTA_WriteBuffer
{

  NTA_Size (*getSize)(NTA_WriteBufferHandle handle);
  const NTA_Byte * (*getData)(NTA_WriteBufferHandle handle);
  NTA_Int32 (*writeByte)(NTA_WriteBufferHandle handle, NTA_Byte value);
  NTA_Int32 (*writeByteArray)(NTA_WriteBufferHandle handle, const NTA_Byte * value, NTA_Size size);
  NTA_Int32 (*writeAsString)(NTA_WriteBufferHandle handle, const NTA_Byte * value, NTA_Size size);
  NTA_Int32 (*writeInt32)(NTA_WriteBufferHandle handle, NTA_Int32 value);
  NTA_Int32 (*writeInt32Array)(NTA_WriteBufferHandle handle, const NTA_Int32 * value, NTA_Size size);
  NTA_Int32 (*writeUInt32)(NTA_WriteBufferHandle handle, NTA_UInt32 value);
  NTA_Int32 (*writeUInt32Array)(NTA_WriteBufferHandle handle, const NTA_UInt32 * value, NTA_Size size);
  NTA_Int32 (*writeInt64)(NTA_WriteBufferHandle handle, NTA_Int64 value);
  NTA_Int32 (*writeInt64Array)(NTA_WriteBufferHandle handle, const NTA_Int64 * value, NTA_Size size);
  NTA_Int32 (*writeUInt64)(NTA_WriteBufferHandle handle, NTA_UInt64 value);
  NTA_Int32 (*writeUInt64Array)(NTA_WriteBufferHandle handle, const NTA_UInt64 * value, NTA_Size size);
  NTA_Int32 (*writeReal32)(NTA_WriteBufferHandle handle, NTA_Real32 value);
  NTA_Int32 (*writeReal32Array)(NTA_WriteBufferHandle handle, const NTA_Real32 * value, NTA_Size size);
  NTA_Int32 (*writeReal64)(NTA_WriteBufferHandle handle, NTA_Real64 value);
  NTA_Int32 (*writeReal64Array)(NTA_WriteBufferHandle handle, const NTA_Real64 * value, NTA_Size size);


  NTA_WriteBufferHandle handle;

} NTA_WriteBuffer;
# 205 "/home/marek/devel/nupic/nta/ntypes/object_model.h"
typedef struct _NTA_InputRangeHandle { char c; } * NTA_InputRangeHandle;
typedef struct NTA_InputRange
{

  const NTA_Byte * (*begin)(NTA_InputRangeHandle handle);
  const NTA_Byte * (*end)(NTA_InputRangeHandle handle);
  NTA_Size (*getElementCount)(NTA_InputRangeHandle handle);
  NTA_Size (*getElementSize)(NTA_InputRangeHandle handle);


  NTA_InputRangeHandle handle;

} NTA_InputRange;
# 230 "/home/marek/devel/nupic/nta/ntypes/object_model.h"
typedef struct _NTA_InputRangeMapEntryHandle { char c; } * NTA_InputRangeMapEntryHandle;
typedef struct NTA_InputRangeMapEntry
{

  void (*reset)(NTA_InputRangeMapEntryHandle handle);
  const NTA_InputRange * (*next)(NTA_InputRangeMapEntryHandle handle);


  const NTA_Byte * name;
  NTA_InputRangeMapEntryHandle handle;

} NTA_InputRangeMapEntry;
# 254 "/home/marek/devel/nupic/nta/ntypes/object_model.h"
typedef struct _NTA_InputRangeMapHandle { char c; } * NTA_InputRangeMapHandle;
typedef struct NTA_InputRangeMap
{

  void (*reset)(NTA_InputRangeMapHandle handle);
  const NTA_InputRangeMapEntry * (*next)(NTA_InputRangeMapHandle handle);
  const NTA_InputRangeMapEntry * (*lookup)(NTA_InputRangeMapHandle handle, const NTA_Byte * name);


  NTA_InputRangeMapHandle handle;

} NTA_InputRangeMap;
# 276 "/home/marek/devel/nupic/nta/ntypes/object_model.h"
typedef struct NTA_IndexRange
{

  NTA_UInt32 begin;
  NTA_UInt32 size;

} NTA_IndexRange;
# 294 "/home/marek/devel/nupic/nta/ntypes/object_model.h"
typedef struct NTA_IndexRangeList
{

  NTA_Size rangeCount;
  NTA_IndexRange * ranges;

} NTA_IndexRangeList;
# 314 "/home/marek/devel/nupic/nta/ntypes/object_model.h"
typedef struct _NTA_OutputRangeHandle { char c; } * NTA_OutputRangeHandle;
typedef struct NTA_OutputRange
{

  NTA_Byte * (*begin)(NTA_OutputRangeHandle handle);
  NTA_Byte * (*end)(NTA_OutputRangeHandle handle);
  NTA_Size (*getElementCount)(NTA_OutputRangeHandle handle);
  NTA_Size (*getElementSize)(NTA_OutputRangeHandle handle);


  NTA_OutputRangeHandle handle;

} NTA_OutputRange;
# 337 "/home/marek/devel/nupic/nta/ntypes/object_model.h"
typedef struct NTA_OutputRangeMapEntry
{
  const NTA_Byte * name;
  NTA_OutputRange * range;

} NTA_OutputRangeMapEntry;
# 355 "/home/marek/devel/nupic/nta/ntypes/object_model.h"
typedef struct _NTA_OutputRangeMapHandle { char c; } * NTA_OutputRangeMapHandle;
typedef struct NTA_OutputRangeMap
{

  void (*reset)(NTA_OutputRangeMapHandle handle);
  NTA_OutputRangeMapEntry * (*next)(NTA_OutputRangeMapHandle handle);
  NTA_OutputRange * (*lookup)(NTA_OutputRangeMapHandle handle, const NTA_Byte * name);


  NTA_OutputRangeMapHandle handle;

} NTA_OutputRangeMap;
# 378 "/home/marek/devel/nupic/nta/ntypes/object_model.h"
typedef struct NTA_ParameterMapEntry
{
  const NTA_Byte * name;
  const NTA_ReadBuffer * value;

} NTA_ParameterMapEntry;
# 396 "/home/marek/devel/nupic/nta/ntypes/object_model.h"
typedef struct _NTA_ParameterMapHandle { char c; } * NTA_ParameterMapHandle;
typedef struct NTA_ParameterMap
{

  void (*reset)(NTA_ParameterMapHandle handle);
  const NTA_ParameterMapEntry * (*next)(NTA_ParameterMapHandle handle);
  const NTA_ReadBuffer * (*lookup)(NTA_ParameterMapHandle handle, const NTA_Byte * name);


  NTA_ParameterMapHandle handle;

} NTA_ParameterMap;
# 418 "/home/marek/devel/nupic/nta/ntypes/object_model.h"
typedef struct _NTA_InputHandle { char c; } * NTA_InputHandle;
typedef struct NTA_Input
{

  const NTA_Byte * (*begin)(NTA_InputHandle handle, NTA_Int32 nodeIdx,
                            const NTA_Byte* sentinelP);
  const NTA_Byte * (*end)(NTA_InputHandle handle, NTA_Int32 nodeIdx);
  NTA_Size (*getElementCount)(NTA_InputHandle handle, NTA_Int32 nodeIdx);
  NTA_Size (*getElementSize)(NTA_InputHandle handle);

  NTA_Size * (*getLinkBoundaries)(NTA_InputHandle handle, NTA_Int32 nodeIdx);
  NTA_Size (*getLinkCount)(NTA_InputHandle handle, NTA_Int32 nodeIdx);


  NTA_InputHandle handle;

} NTA_Input;
# 445 "/home/marek/devel/nupic/nta/ntypes/object_model.h"
typedef struct _NTA_OutputHandle { char c; } * NTA_OutputHandle;
typedef struct NTA_Output
{

  NTA_Byte * (*begin)(NTA_OutputHandle handle, NTA_Int32 nodeIdx);
  NTA_Byte * (*end)(NTA_OutputHandle handle, NTA_Int32 nodeIdx);
  NTA_Size (*getElementCount)(NTA_OutputHandle handle, NTA_Int32 nodeIdx);
  NTA_Size (*getElementSize)(NTA_OutputHandle handle);


  NTA_OutputHandle handle;

} NTA_Output;
# 470 "/home/marek/devel/nupic/nta/ntypes/object_model.h"
typedef struct _NTA_NodeInfoHandle { char c; } * NTA_NodeInfoHandle;
typedef struct _NTA_NodeInfo
{

  NTA_UInt64 (*getID)(NTA_NodeInfoHandle handle);
  const NTA_Byte * (*getType)(NTA_NodeInfoHandle handle);
  NTA_LogLevel (*getLogLevel)(NTA_NodeInfoHandle handle);
  NTA_Input * (*getInput)(NTA_NodeInfoHandle handle, const NTA_Byte* varName);
  NTA_Output * (*getOutput)(NTA_NodeInfoHandle handle, const NTA_Byte* varName);
  NTA_InputRangeMap * (*getInputs)(NTA_NodeInfoHandle handle);
  NTA_OutputRangeMap * (*getOutputs)(NTA_NodeInfoHandle handle);
  NTA_ParameterMap * (*getParameters)(NTA_NodeInfoHandle handle);
  NTA_ReadBuffer * (*getState)(NTA_NodeInfoHandle handle);
  NTA_Size (*getMNNodeCount)(NTA_NodeInfoHandle handle);
  const NTA_IndexRangeList * (*getMNInputLists)(NTA_NodeInfoHandle handle, const NTA_Byte* varName);
  const NTA_Size * (*getMNOutputSizes)(NTA_NodeInfoHandle handle, const NTA_Byte* varName);


  NTA_NodeInfoHandle handle;

} NTA_NodeInfo;
# 503 "/home/marek/devel/nupic/nta/ntypes/object_model.h"
typedef struct _NTA_MultiNodeInfoHandle { char c; } * NTA_MultiNodeInfoHandle;
typedef struct _NTA_MultiNodeInfo
{


  NTA_Size (*getNodeCount)(NTA_MultiNodeInfoHandle handle);
  const NTA_IndexRangeList * (*getInputList)(NTA_MultiNodeInfoHandle handle, const NTA_Byte* varName);
  const NTA_Size * (*getOutputSizes)(NTA_NodeInfoHandle handle, const NTA_Byte* varName);


  NTA_MultiNodeInfoHandle handle;

} NTA_MultiNodeInfo;
# 528 "/home/marek/devel/nupic/nta/ntypes/object_model.h"
typedef struct _NTA_InputSizeMapEntryHandle { char c; } * NTA_InputSizeMapEntryHandle;
typedef struct NTA_InputSizeMapEntry
{

  const NTA_Byte * name;
  NTA_UInt32 count;
  NTA_UInt32 * sizes;

} NTA_InputSizeMapEntry;
# 549 "/home/marek/devel/nupic/nta/ntypes/object_model.h"
typedef struct _NTA_InputSizeMapHandle { char c; } * NTA_InputSizeMapHandle;
typedef struct NTA_InputSizeMap
{

  void (*reset)(NTA_InputSizeMapHandle handle);
  const NTA_InputSizeMapEntry * (*next)(NTA_InputSizeMapHandle handle);
  const NTA_InputSizeMapEntry * (*lookup)(NTA_InputSizeMapHandle handle, const NTA_Byte * name);


  NTA_InputSizeMapHandle handle;

} NTA_InputSizeMap;
# 571 "/home/marek/devel/nupic/nta/ntypes/object_model.h"
typedef struct NTA_OutputSizeMapEntry
{
  const NTA_Byte * name;
  NTA_UInt32 size;

} NTA_OutputSizeMapEntry;
# 589 "/home/marek/devel/nupic/nta/ntypes/object_model.h"
typedef struct _NTA_OutputSizeMapHandle { char c; } * NTA_OutputSizeMapHandle;
typedef struct NTA_OutputSizeMap
{

  void (*reset)(NTA_OutputSizeMapHandle handle);
  NTA_OutputSizeMapEntry * (*next)(NTA_OutputSizeMapHandle handle);
  NTA_UInt32 (*lookup)(NTA_OutputSizeMapHandle handle, const NTA_Byte * name);


  NTA_OutputSizeMapHandle handle;

} NTA_OutputSizeMap;
# 612 "/home/marek/devel/nupic/nta/ntypes/object_model.h"
typedef struct _NTA_InitialStateInfoHandle { char c; } * NTA_InitialStateInfoHandle;
typedef struct _NTA_InitialStateInfo
{

  const NTA_Byte * (*getNodeType)(NTA_InitialStateInfoHandle handle);
  const NTA_InputSizeMap * (*getInputSizes)(NTA_InitialStateInfoHandle handle);
  const NTA_OutputSizeMap * (*getOutputSizes)(NTA_InitialStateInfoHandle handle);
  const NTA_ParameterMap * (*getParameters)(NTA_InitialStateInfoHandle handle);
  const NTA_MultiNodeInfo * (*getMultiNodeInfo)(NTA_InitialStateInfoHandle handle);


  NTA_InitialStateInfoHandle handle;

} NTA_InitialStateInfo;



}
# 39 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp" 2



namespace nta
{
# 54 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
  struct IReadBuffer
  {



    virtual ~IReadBuffer() {}







    virtual void reset() const = 0;
# 77 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Size getSize() const = 0;
# 88 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual const Byte * getData() const = 0;







    virtual Int32 read(Byte & value) const = 0;
# 110 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 read(Byte * value, Size & size) const = 0;
# 138 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual NTA_Int32 readString(
        NTA_Byte * &value,
        NTA_UInt32 &size,
        NTA_Byte *(fAlloc)(NTA_UInt32 size),
        void (fDealloc)(NTA_Byte *)
      ) const = 0;
# 152 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 read(Int32 & value) const = 0;
# 165 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 read(Int32 * value, Size size) const = 0;
# 174 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 read(UInt32 & value) const = 0;
# 188 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 read(UInt32 * value, Size size) const = 0;
# 197 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 read(Int64 & value) const = 0;
# 211 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 read(Int64 * value, Size size) const = 0;
# 220 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 read(UInt64 & value) const = 0;
# 234 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 read(UInt64 * value, Size size) const = 0;
# 244 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 read(Real32 & value) const = 0;
# 258 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 read(Real32 * value, Size size) const = 0;
# 267 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 read(Real64 & value) const = 0;
# 281 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 read(Real64 * value, Size size) const = 0;

  };
# 295 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
  struct IReadBufferIterator
  {



    virtual ~IReadBufferIterator() {}
# 309 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual void reset() = 0;
# 321 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual const IReadBuffer * next() = 0;
  };
# 335 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
  struct IWriteBuffer
  {



    virtual ~IWriteBuffer() {}
# 349 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 write(Byte value) = 0;
# 359 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 write(const Byte * value, Size size) = 0;
# 373 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 writeString(const Byte * value, Size size) = 0;
# 382 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 write(Int32 value) = 0;
# 392 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 write(const Int32 * value, Size size) = 0;
# 401 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 write(UInt32 value) = 0;
# 411 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 write(const UInt32 * value, Size size) = 0;
# 420 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 write(Int64 value) = 0;
# 430 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 write(const Int64 * value, Size size) = 0;
# 439 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 write(UInt64 value) = 0;
# 449 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 write(const UInt64 * value, Size size) = 0;
# 458 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 write(Real32 value) = 0;
# 468 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 write(const Real32 * value, Size size) = 0;
# 477 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 write(Real64 value) = 0;
# 487 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Int32 write(const Real64 * value, Size size) = 0;







    virtual Size getSize() = 0;
# 504 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual const Byte * getData() = 0;
  };
# 526 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
  struct IRange
  {



    virtual ~IRange() {}






    virtual Size getElementCount() const = 0;
# 547 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Size getElementSize() const = 0;
  };
# 567 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
  struct IInputRange : public IRange
  {





    virtual const Byte * begin() const = 0;
# 584 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual const Byte * end() const = 0;
  };
# 602 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
  struct IOutputRange : public IRange
  {





    virtual Byte * begin() = 0;
# 619 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Byte * end() = 0;
  };
# 635 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
  struct IInputRangeMapEntry
  {



    virtual ~IInputRangeMapEntry() {}
# 649 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual void reset() const = 0;
# 661 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual const IInputRange * next() const = 0;




    const Byte * name;
  };
# 682 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
  struct IInputRangeMap
  {



    virtual ~IInputRangeMap() {}
# 696 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual void reset() const = 0;
# 708 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual const IInputRangeMapEntry * next() const = 0;
# 720 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual const IInputRangeMapEntry * lookup(const Byte * name) const = 0;
  };
# 733 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
  struct IOutputRangeMapEntry
  {



    const Byte * name;




    IOutputRange * range;
  };
# 759 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
  struct IOutputRangeMap
  {



    virtual ~IOutputRangeMap() {}
# 773 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual void reset() = 0;
# 785 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual IOutputRangeMapEntry * next() = 0;
# 797 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual IOutputRange * lookup(const Byte * name) = 0;
  };
# 811 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
  struct IInput
  {
    enum {allNodes = -1};




    virtual ~IInput() {}
# 828 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual const Byte * begin(Int32 nodeIdx=allNodes, const Byte* sentinelP=0) = 0;
# 839 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual const Byte * end(Int32 nodeIdx=allNodes) = 0;







    virtual Size getElementCount(Int32 nodeIdx=allNodes) = 0;
# 856 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Size getElementSize() = 0;







    virtual Size getLinkCount(Int32 nodeIdx=allNodes) = 0;







    virtual Size * getLinkBoundaries(Int32 nodeIdx=allNodes) = 0;

  };
# 888 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
  struct IOutput
  {
    enum {allNodes = -1};




    virtual ~IOutput() {}







    virtual Byte * begin(Int32 nodeIdx=allNodes) = 0;
# 914 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Byte * end(Int32 nodeIdx=allNodes) = 0;







    virtual Size getElementCount(Int32 nodeIdx=allNodes) = 0;
# 931 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual Size getElementSize() = 0;

  };
# 945 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
  struct INodeInfo
  {



    virtual ~INodeInfo() {}
# 964 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual const Byte * getType() = 0;
# 977 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual LogLevel getLogLevel() = 0;
# 991 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual IInput * getInput(const NTA_Byte* varName) = 0;
# 1003 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual IOutput * getOutput(const NTA_Byte* varName) = 0;
# 1019 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual IInputRangeMap & getInputs() = 0;
# 1034 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual IOutputRangeMap & getOutputs() = 0;
# 1045 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual IReadBuffer & getState() = 0;
# 1055 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual NTA_Size getMNNodeCount() = 0;
# 1068 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual const NTA_IndexRangeList * getMNInputLists(const NTA_Byte* varName) = 0;
# 1078 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual const NTA_Size * getMNOutputSizes(const NTA_Byte* varName) = 0;
  };
# 1093 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
  struct IInputSizeMap
  {
    virtual ~IInputSizeMap() {}
    virtual void reset()= 0;
    virtual const NTA_InputSizeMapEntry * next() = 0;
    virtual const NTA_InputSizeMapEntry * lookup(const Byte * name) = 0;
  };
# 1113 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
  struct IOutputSizeMap
  {
    virtual ~IOutputSizeMap() {}
    virtual void reset()= 0;
    virtual const NTA_OutputSizeMapEntry * next() = 0;
    virtual const NTA_OutputSizeMapEntry * lookup(const Byte * name) = 0;
  };
# 1133 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    struct IParameterMapEntry
    {



      const Byte * name;




      const IReadBuffer * value;
    };
# 1158 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
  struct IParameterMap
  {



    virtual ~IParameterMap() {}
# 1172 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual void reset() const = 0;
# 1184 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual const IParameterMapEntry * next() const = 0;
# 1196 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
    virtual const IReadBuffer * lookup(const Byte * name) const = 0;
  };
# 1210 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
  struct IInitialStateInfo
  {
    virtual ~IInitialStateInfo() {}
    virtual const Byte * getNodeType() = 0;
    virtual const IInputSizeMap & getInputSizes() = 0;
    virtual const IOutputSizeMap & getOutputSizes() = 0;
    virtual const IParameterMap & getParameters() = 0;
  };
# 1269 "/home/marek/devel/nupic/nta/ntypes/object_model.hpp"
inline NTA_Byte *_ReadString_alloc(NTA_UInt32 size)
  { return new NTA_Byte[size]; }
inline void _ReadString_dealloc(NTA_Byte *p)
  { delete[] p; }

inline std::string ReadStringFromBuffer(const IReadBuffer &buf)
{
  NTA_Byte *value = 0;
  NTA_UInt32 size = 0;
  NTA_Int32 result = buf.readString(value, size,
      _ReadString_alloc, _ReadString_dealloc);
  if(result != 0)
    throw std::runtime_error("Failed to read string from stream.");
  std::string toReturn(value, size);

  delete[] value;
  return toReturn;
}



}
# 41 "/home/marek/devel/nupic/nta/engine/RegionImpl.hpp" 2

namespace nta
{

  struct Spec;
  class Region;
  class Dimensions;
  class Input;
  class Output;
  class Array;
  class ArrayRef;
  class NodeSet;
  class BundleIO;

  class RegionImpl
  {
  public:



    RegionImpl(Region* region);

    virtual ~RegionImpl();





    const std::string& getType() const;

    const std::string& getName() const;

    const NodeSet& getEnabledNodes() const;






    virtual Int32 getParameterInt32(const std::string& name, Int64 index);
    virtual UInt32 getParameterUInt32(const std::string& name, Int64 index);
    virtual Int64 getParameterInt64(const std::string& name, Int64 index);
    virtual UInt64 getParameterUInt64(const std::string& name, Int64 index);
    virtual Real32 getParameterReal32(const std::string& name, Int64 index);
    virtual Real64 getParameterReal64(const std::string& name, Int64 index);
    virtual Handle getParameterHandle(const std::string& name, Int64 index);

    virtual void setParameterInt32(const std::string& name, Int64 index, Int32 value);
    virtual void setParameterUInt32(const std::string& name, Int64 index, UInt32 value);
    virtual void setParameterInt64(const std::string& name, Int64 index, Int64 value);
    virtual void setParameterUInt64(const std::string& name, Int64 index, UInt64 value);
    virtual void setParameterReal32(const std::string& name, Int64 index, Real32 value);
    virtual void setParameterReal64(const std::string& name, Int64 index, Real64 value);
    virtual void setParameterHandle(const std::string& name, Int64 index, Handle value);

    virtual void getParameterArray(const std::string& name, Int64 index, Array & array);
    virtual void setParameterArray(const std::string& name, Int64 index, const Array & array);

    virtual void setParameterString(const std::string& name, Int64 index, const std::string& s);
    virtual std::string getParameterString(const std::string& name, Int64 index);
# 113 "/home/marek/devel/nupic/nta/engine/RegionImpl.hpp"
    virtual void serialize(BundleIO& bundle) = 0;


    virtual void deserialize(BundleIO& bundle) = 0;






    virtual void initialize() = 0;


    virtual void compute() = 0;




    virtual std::string executeCommand(const std::vector<std::string>& args, Int64 index) = 0;






    virtual size_t getNodeOutputElementCount(const std::string& outputName) = 0;
# 150 "/home/marek/devel/nupic/nta/engine/RegionImpl.hpp"
    virtual void getParameterFromBuffer(const std::string& name,
                                        Int64 index,
                                        IWriteBuffer& value) = 0;
# 162 "/home/marek/devel/nupic/nta/engine/RegionImpl.hpp"
    virtual void setParameterFromBuffer(const std::string& name,
                              Int64 index,
                              IReadBuffer& value) = 0;
# 179 "/home/marek/devel/nupic/nta/engine/RegionImpl.hpp"
    virtual size_t getParameterArrayCount(const std::string& name, Int64 index);







    virtual bool isParameterShared(const std::string& name);



  protected:
    Region* region_;
# 205 "/home/marek/devel/nupic/nta/engine/RegionImpl.hpp"
    std::ostream& getSerializationOutputStream(const std::string& name);
    std::istream& getSerializationInputStream(const std::string& name);
    std::string getSerializationPath(const std::string& name);




    const Input* getInput(const std::string& name);
    const Output* getOutput(const std::string& name);

    const Dimensions& getDimensions();

  };

}
# 33 "/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.hpp" 2
# 1 "/home/marek/devel/nupic/nta/ntypes/Value.hpp" 1
# 38 "/home/marek/devel/nupic/nta/ntypes/Value.hpp"
# 1 "/home/marek/devel/nupic/nta/types/BasicType.hpp" 1
# 30 "/home/marek/devel/nupic/nta/types/BasicType.hpp"
namespace nta
{







  class BasicType
  {
  public:
# 52 "/home/marek/devel/nupic/nta/types/BasicType.hpp"
    static bool isValid(NTA_BasicType t);



    static const char * getName(NTA_BasicType t);


    template <typename T> static const char* getName();


    template <typename T> static NTA_BasicType getType();


    static size_t getSize(NTA_BasicType t);






    static NTA_BasicType parse(const std::string & s);

  private:
    BasicType();
    BasicType(const BasicType &);
  };
}
# 39 "/home/marek/devel/nupic/nta/ntypes/Value.hpp" 2
# 1 "/home/marek/devel/nupic/nta/ntypes/Scalar.hpp" 1
# 38 "/home/marek/devel/nupic/nta/ntypes/Scalar.hpp"
namespace nta
{
  class Scalar
  {
  public:
    Scalar(NTA_BasicType theTypeParam);

    NTA_BasicType getType();

    template <typename T> T getValue() const;


    union {
      NTA_Handle handle;
      NTA_Byte byte;
      NTA_Int16 int16;
      NTA_UInt16 uint16;
      NTA_Int32 int32;
      NTA_UInt32 uint32;
      NTA_Int64 int64;
      NTA_UInt64 uint64;
      NTA_Real32 real32;
      NTA_Real64 real64;
    } value;


  private:
    NTA_BasicType theType_;

  };

}
# 40 "/home/marek/devel/nupic/nta/ntypes/Value.hpp" 2


# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/map" 1 3
# 59 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/map" 3

# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_tree.h" 1 3
# 69 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_tree.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 89 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_tree.h" 3
  enum _Rb_tree_color { _S_red = false, _S_black = true };

  struct _Rb_tree_node_base
  {
    typedef _Rb_tree_node_base* _Base_ptr;
    typedef const _Rb_tree_node_base* _Const_Base_ptr;

    _Rb_tree_color _M_color;
    _Base_ptr _M_parent;
    _Base_ptr _M_left;
    _Base_ptr _M_right;

    static _Base_ptr
    _S_minimum(_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Const_Base_ptr
    _S_minimum(_Const_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Base_ptr
    _S_maximum(_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }

    static _Const_Base_ptr
    _S_maximum(_Const_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }
  };

  template<typename _Val>
    struct _Rb_tree_node : public _Rb_tree_node_base
    {
      typedef _Rb_tree_node<_Val>* _Link_type;
      _Val _M_value_field;







    };

  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_increment(const _Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_decrement(_Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_decrement(const _Rb_tree_node_base* __x) throw ();

  template<typename _Tp>
    struct _Rb_tree_iterator
    {
      typedef _Tp value_type;
      typedef _Tp& reference;
      typedef _Tp* pointer;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
      typedef _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_iterator()
      : _M_node() { }

      explicit
      _Rb_tree_iterator(_Link_type __x)
      : _M_node(__x) { }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return std::__addressof(static_cast<_Link_type>
    (_M_node)->_M_value_field); }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
  };

  template<typename _Tp>
    struct _Rb_tree_const_iterator
    {
      typedef _Tp value_type;
      typedef const _Tp& reference;
      typedef const _Tp* pointer;

      typedef _Rb_tree_iterator<_Tp> iterator;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_const_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
      typedef const _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_const_iterator()
      : _M_node() { }

      explicit
      _Rb_tree_const_iterator(_Link_type __x)
      : _M_node(__x) { }

      _Rb_tree_const_iterator(const iterator& __it)
      : _M_node(__it._M_node) { }

      iterator
      _M_const_cast() const
      { return iterator(static_cast<typename iterator::_Link_type>
   (const_cast<typename iterator::_Base_ptr>(_M_node))); }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return std::__addressof(static_cast<_Link_type>
    (_M_node)->_M_value_field); }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }

  void
  _Rb_tree_insert_and_rebalance(const bool __insert_left,
                                _Rb_tree_node_base* __x,
                                _Rb_tree_node_base* __p,
                                _Rb_tree_node_base& __header) throw ();

  _Rb_tree_node_base*
  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
          _Rb_tree_node_base& __header) throw ();


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc = allocator<_Val> >
    class _Rb_tree
    {
      typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other
              _Node_allocator;

    protected:
      typedef _Rb_tree_node_base* _Base_ptr;
      typedef const _Rb_tree_node_base* _Const_Base_ptr;

    public:
      typedef _Key key_type;
      typedef _Val value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef _Rb_tree_node<_Val>* _Link_type;
      typedef const _Rb_tree_node<_Val>* _Const_Link_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

      _Node_allocator&
      _M_get_Node_allocator()
      { return *static_cast<_Node_allocator*>(&this->_M_impl); }

      const _Node_allocator&
      _M_get_Node_allocator() const
      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Node_allocator()); }

    protected:
      _Link_type
      _M_get_node()
      { return _M_impl._Node_allocator::allocate(1); }

      void
      _M_put_node(_Link_type __p)
      { _M_impl._Node_allocator::deallocate(__p, 1); }


      _Link_type
      _M_create_node(const value_type& __x)
      {
 _Link_type __tmp = _M_get_node();
 try
   { get_allocator().construct
       (std::__addressof(__tmp->_M_value_field), __x); }
 catch(...)
   {
     _M_put_node(__tmp);
     throw;
   }
 return __tmp;
      }

      void
      _M_destroy_node(_Link_type __p)
      {
 get_allocator().destroy(std::__addressof(__p->_M_value_field));
 _M_put_node(__p);
      }
# 426 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_tree.h" 3
      _Link_type
      _M_clone_node(_Const_Link_type __x)
      {
 _Link_type __tmp = _M_create_node(__x->_M_value_field);
 __tmp->_M_color = __x->_M_color;
 __tmp->_M_left = 0;
 __tmp->_M_right = 0;
 return __tmp;
      }

    protected:
      template<typename _Key_compare,
        bool _Is_pod_comparator = __is_pod(_Key_compare)>
        struct _Rb_tree_impl : public _Node_allocator
        {
   _Key_compare _M_key_compare;
   _Rb_tree_node_base _M_header;
   size_type _M_node_count;

   _Rb_tree_impl()
   : _Node_allocator(), _M_key_compare(), _M_header(),
     _M_node_count(0)
   { _M_initialize(); }

   _Rb_tree_impl(const _Key_compare& __comp, const _Node_allocator& __a)
   : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),
     _M_node_count(0)
   { _M_initialize(); }
# 462 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_tree.h" 3
 private:
   void
   _M_initialize()
   {
     this->_M_header._M_color = _S_red;
     this->_M_header._M_parent = 0;
     this->_M_header._M_left = &this->_M_header;
     this->_M_header._M_right = &this->_M_header;
   }
 };

      _Rb_tree_impl<_Compare> _M_impl;

    protected:
      _Base_ptr&
      _M_root()
      { return this->_M_impl._M_header._M_parent; }

      _Const_Base_ptr
      _M_root() const
      { return this->_M_impl._M_header._M_parent; }

      _Base_ptr&
      _M_leftmost()
      { return this->_M_impl._M_header._M_left; }

      _Const_Base_ptr
      _M_leftmost() const
      { return this->_M_impl._M_header._M_left; }

      _Base_ptr&
      _M_rightmost()
      { return this->_M_impl._M_header._M_right; }

      _Const_Base_ptr
      _M_rightmost() const
      { return this->_M_impl._M_header._M_right; }

      _Link_type
      _M_begin()
      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }

      _Const_Link_type
      _M_begin() const
      {
 return static_cast<_Const_Link_type>
   (this->_M_impl._M_header._M_parent);
      }

      _Link_type
      _M_end()
      { return static_cast<_Link_type>(&this->_M_impl._M_header); }

      _Const_Link_type
      _M_end() const
      { return static_cast<_Const_Link_type>(&this->_M_impl._M_header); }

      static const_reference
      _S_value(_Const_Link_type __x)
      { return __x->_M_value_field; }

      static const _Key&
      _S_key(_Const_Link_type __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Link_type
      _S_left(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_left); }

      static _Const_Link_type
      _S_left(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_left); }

      static _Link_type
      _S_right(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_right); }

      static _Const_Link_type
      _S_right(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_right); }

      static const_reference
      _S_value(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x)->_M_value_field; }

      static const _Key&
      _S_key(_Const_Base_ptr __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Base_ptr
      _S_minimum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Const_Base_ptr
      _S_minimum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Base_ptr
      _S_maximum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

      static _Const_Base_ptr
      _S_maximum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

    public:
      typedef _Rb_tree_iterator<value_type> iterator;
      typedef _Rb_tree_const_iterator<value_type> const_iterator;

      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    private:
      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_unique_pos(const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_equal_pos(const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_hint_unique_pos(const_iterator __pos,
        const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_hint_equal_pos(const_iterator __pos,
       const key_type& __k);
# 611 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_tree.h" 3
      iterator
      _M_insert_(_Base_ptr __x, _Base_ptr __y,
   const value_type& __v);



      iterator
      _M_insert_lower(_Base_ptr __y, const value_type& __v);

      iterator
      _M_insert_equal_lower(const value_type& __x);


      _Link_type
      _M_copy(_Const_Link_type __x, _Link_type __p);

      void
      _M_erase(_Link_type __x);

      iterator
      _M_lower_bound(_Link_type __x, _Link_type __y,
       const _Key& __k);

      const_iterator
      _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
       const _Key& __k) const;

      iterator
      _M_upper_bound(_Link_type __x, _Link_type __y,
       const _Key& __k);

      const_iterator
      _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
       const _Key& __k) const;

    public:

      _Rb_tree() { }

      _Rb_tree(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_impl(__comp, _Node_allocator(__a)) { }

      _Rb_tree(const _Rb_tree& __x)
      : _M_impl(__x._M_impl._M_key_compare, __x._M_get_Node_allocator())
      {
 if (__x._M_root() != 0)
   {
     _M_root() = _M_copy(__x._M_begin(), _M_end());
     _M_leftmost() = _S_minimum(_M_root());
     _M_rightmost() = _S_maximum(_M_root());
     _M_impl._M_node_count = __x._M_impl._M_node_count;
   }
      }





      ~_Rb_tree()
      { _M_erase(_M_begin()); }

      _Rb_tree&
      operator=(const _Rb_tree& __x);


      _Compare
      key_comp() const
      { return _M_impl._M_key_compare; }

      iterator
      begin()
      {
 return iterator(static_cast<_Link_type>
   (this->_M_impl._M_header._M_left));
      }

      const_iterator
      begin() const
      {
 return const_iterator(static_cast<_Const_Link_type>
         (this->_M_impl._M_header._M_left));
      }

      iterator
      end()
      { return iterator(static_cast<_Link_type>(&this->_M_impl._M_header)); }

      const_iterator
      end() const
      {
 return const_iterator(static_cast<_Const_Link_type>
         (&this->_M_impl._M_header));
      }

      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }

      bool
      empty() const
      { return _M_impl._M_node_count == 0; }

      size_type
      size() const
      { return _M_impl._M_node_count; }

      size_type
      max_size() const
      { return _M_get_Node_allocator().max_size(); }

      void
      swap(_Rb_tree& __t);
# 771 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_tree.h" 3
      pair<iterator, bool>
      _M_insert_unique(const value_type& __x);

      iterator
      _M_insert_equal(const value_type& __x);

      iterator
      _M_insert_unique_(const_iterator __position, const value_type& __x);

      iterator
      _M_insert_equal_(const_iterator __position, const value_type& __x);


      template<typename _InputIterator>
        void
        _M_insert_unique(_InputIterator __first, _InputIterator __last);

      template<typename _InputIterator>
        void
        _M_insert_equal(_InputIterator __first, _InputIterator __last);

    private:
      void
      _M_erase_aux(const_iterator __position);

      void
      _M_erase_aux(const_iterator __first, const_iterator __last);

    public:
# 824 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_tree.h" 3
      void
      erase(iterator __position)
      { _M_erase_aux(__position); }

      void
      erase(const_iterator __position)
      { _M_erase_aux(__position); }

      size_type
      erase(const key_type& __x);
# 846 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_tree.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_erase_aux(__first, __last); }

      void
      erase(const_iterator __first, const_iterator __last)
      { _M_erase_aux(__first, __last); }

      void
      erase(const key_type* __first, const key_type* __last);

      void
      clear()
      {
        _M_erase(_M_begin());
        _M_leftmost() = _M_end();
        _M_root() = 0;
        _M_rightmost() = _M_end();
        _M_impl._M_node_count = 0;
      }


      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      iterator
      lower_bound(const key_type& __k)
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      lower_bound(const key_type& __k) const
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      iterator
      upper_bound(const key_type& __k)
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      upper_bound(const key_type& __k) const
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      pair<iterator, iterator>
      equal_range(const key_type& __k);

      pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;


      bool
      __rb_verify() const;
    };

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return __x.size() == __y.size()
      && std::equal(__x.begin(), __x.end(), __y.begin());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x == __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return __y < __x; }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__y < __x); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x < __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { __x.swap(__y); }
# 984 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_tree.h" 3
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)
    {
      if (this != &__x)
 {

   clear();
   _M_impl._M_key_compare = __x._M_impl._M_key_compare;
   if (__x._M_root() != 0)
     {
       _M_root() = _M_copy(__x._M_begin(), _M_end());
       _M_leftmost() = _S_minimum(_M_root());
       _M_rightmost() = _S_maximum(_M_root());
       _M_impl._M_node_count = __x._M_impl._M_node_count;
     }
 }
      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_(_Base_ptr __x, _Base_ptr __p, const _Val& __v)

    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || _M_impl._M_key_compare(_KeyOfValue()(__v),
            _S_key(__p)));

      _Link_type __z = _M_create_node((__v));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_lower(_Base_ptr __p, const _Val& __v)

    {
      bool __insert_left = (__p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _KeyOfValue()(__v)));

      _Link_type __z = _M_create_node((__v));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_equal_lower(const _Val& __v)

    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower(__y, (__v));
    }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
    _M_copy(_Const_Link_type __x, _Link_type __p)
    {

      _Link_type __top = _M_clone_node(__x);
      __top->_M_parent = __p;

      try
 {
   if (__x->_M_right)
     __top->_M_right = _M_copy(_S_right(__x), __top);
   __p = __top;
   __x = _S_left(__x);

   while (__x != 0)
     {
       _Link_type __y = _M_clone_node(__x);
       __p->_M_left = __y;
       __y->_M_parent = __p;
       if (__x->_M_right)
  __y->_M_right = _M_copy(_S_right(__x), __y);
       __p = __y;
       __x = _S_left(__x);
     }
 }
      catch(...)
 {
   _M_erase(__top);
   throw;
 }
      return __top;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase(_Link_type __x)
    {

      while (__x != 0)
 {
   _M_erase(_S_right(__x));
   _Link_type __y = _S_left(__x);
   _M_destroy_node(__x);
   __x = __y;
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Link_type __x, _Link_type __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Link_type __xu(__x), __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<iterator,
            iterator>(_M_lower_bound(__x, __y, __k),
        _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<iterator, iterator>(iterator(__y),
          iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Const_Link_type __xu(__x), __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<const_iterator,
            const_iterator>(_M_lower_bound(__x, __y, __k),
       _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<const_iterator, const_iterator>(const_iterator(__y),
        const_iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t)
    {
      if (_M_root() == 0)
 {
   if (__t._M_root() != 0)
     {
       _M_root() = __t._M_root();
       _M_leftmost() = __t._M_leftmost();
       _M_rightmost() = __t._M_rightmost();
       _M_root()->_M_parent = _M_end();

       __t._M_root() = 0;
       __t._M_leftmost() = __t._M_end();
       __t._M_rightmost() = __t._M_end();
     }
 }
      else if (__t._M_root() == 0)
 {
   __t._M_root() = _M_root();
   __t._M_leftmost() = _M_leftmost();
   __t._M_rightmost() = _M_rightmost();
   __t._M_root()->_M_parent = __t._M_end();

   _M_root() = 0;
   _M_leftmost() = _M_end();
   _M_rightmost() = _M_end();
 }
      else
 {
   std::swap(_M_root(),__t._M_root());
   std::swap(_M_leftmost(),__t._M_leftmost());
   std::swap(_M_rightmost(),__t._M_rightmost());

   _M_root()->_M_parent = _M_end();
   __t._M_root()->_M_parent = __t._M_end();
 }

      std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);



      std::__alloc_swap<_Node_allocator>::
 _S_do_it(_M_get_Node_allocator(), __t._M_get_Node_allocator());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_unique_pos(const key_type& __k)
    {
      typedef pair<_Base_ptr, _Base_ptr> _Res;
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      bool __comp = true;
      while (__x != 0)
 {
   __y = __x;
   __comp = _M_impl._M_key_compare(__k, _S_key(__x));
   __x = __comp ? _S_left(__x) : _S_right(__x);
 }
      iterator __j = iterator(__y);
      if (__comp)
 {
   if (__j == begin())
     return _Res(__x, __y);
   else
     --__j;
 }
      if (_M_impl._M_key_compare(_S_key(__j._M_node), __k))
 return _Res(__x, __y);
      return _Res(__j._M_node, 0);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_equal_pos(const key_type& __k)
    {
      typedef pair<_Base_ptr, _Base_ptr> _Res;
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = _M_impl._M_key_compare(__k, _S_key(__x)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _Res(__x, __y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator, bool>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_unique(const _Val& __v)

    {
      typedef pair<iterator, bool> _Res;
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_unique_pos(_KeyOfValue()(__v));

      if (__res.second)
 return _Res(_M_insert_(__res.first, __res.second,
          (__v)),
      true);

      return _Res(iterator(static_cast<_Link_type>(__res.first)), false);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_equal(const _Val& __v)

    {
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_equal_pos(_KeyOfValue()(__v));
      return _M_insert_(__res.first, __res.second, (__v));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
         typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_hint_unique_pos(const_iterator __position,
      const key_type& __k)
    {
      iterator __pos = __position._M_const_cast();
      typedef pair<_Base_ptr, _Base_ptr> _Res;


      if (__pos._M_node == _M_end())
 {
   if (size() > 0
       && _M_impl._M_key_compare(_S_key(_M_rightmost()), __k))
     return _Res(0, _M_rightmost());
   else
     return _M_get_insert_unique_pos(__k);
 }
      else if (_M_impl._M_key_compare(__k, _S_key(__pos._M_node)))
 {

   iterator __before = __pos;
   if (__pos._M_node == _M_leftmost())
     return _Res(_M_leftmost(), _M_leftmost());
   else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), __k))
     {
       if (_S_right(__before._M_node) == 0)
  return _Res(0, __before._M_node);
       else
  return _Res(__pos._M_node, __pos._M_node);
     }
   else
     return _M_get_insert_unique_pos(__k);
 }
      else if (_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
 {

   iterator __after = __pos;
   if (__pos._M_node == _M_rightmost())
     return _Res(0, _M_rightmost());
   else if (_M_impl._M_key_compare(__k, _S_key((++__after)._M_node)))
     {
       if (_S_right(__pos._M_node) == 0)
  return _Res(0, __pos._M_node);
       else
  return _Res(__after._M_node, __after._M_node);
     }
   else
     return _M_get_insert_unique_pos(__k);
 }
      else

 return _Res(__pos._M_node, 0);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_unique_(const_iterator __position, const _Val& __v)

    {
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_hint_unique_pos(__position, _KeyOfValue()(__v));

      if (__res.second)
 return _M_insert_(__res.first, __res.second,
     (__v));
      return iterator(static_cast<_Link_type>(__res.first));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
         typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_hint_equal_pos(const_iterator __position, const key_type& __k)
    {
      iterator __pos = __position._M_const_cast();
      typedef pair<_Base_ptr, _Base_ptr> _Res;


      if (__pos._M_node == _M_end())
 {
   if (size() > 0
       && !_M_impl._M_key_compare(__k, _S_key(_M_rightmost())))
     return _Res(0, _M_rightmost());
   else
     return _M_get_insert_equal_pos(__k);
 }
      else if (!_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
 {

   iterator __before = __pos;
   if (__pos._M_node == _M_leftmost())
     return _Res(_M_leftmost(), _M_leftmost());
   else if (!_M_impl._M_key_compare(__k, _S_key((--__before)._M_node)))
     {
       if (_S_right(__before._M_node) == 0)
  return _Res(0, __before._M_node);
       else
  return _Res(__pos._M_node, __pos._M_node);
     }
   else
     return _M_get_insert_equal_pos(__k);
 }
      else
 {

   iterator __after = __pos;
   if (__pos._M_node == _M_rightmost())
     return _Res(0, _M_rightmost());
   else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node), __k))
     {
       if (_S_right(__pos._M_node) == 0)
  return _Res(0, __pos._M_node);
       else
  return _Res(__after._M_node, __after._M_node);
     }
   else
     return _Res(0, 0);
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>



    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    _M_insert_equal_(const_iterator __position, const _Val& __v)

    {
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_hint_equal_pos(__position, _KeyOfValue()(__v));

      if (__res.second)
 return _M_insert_(__res.first, __res.second,
     (__v));

      return _M_insert_equal_lower((__v));
    }
# 1714 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_tree.h" 3
  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_unique(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   _M_insert_unique_(end(), *__first);
      }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_equal(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   _M_insert_equal_(end(), *__first);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase_aux(const_iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (const_cast<_Base_ptr>(__position._M_node),
     this->_M_impl._M_header));
      _M_destroy_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase_aux(const_iterator __first, const_iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   erase(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key& __x)
    {
      pair<iterator, iterator> __p = equal_range(__x);
      const size_type __old_size = size();
      erase(__p.first, __p.second);
      return __old_size - size();
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key* __first, const _Key* __last)
    {
      while (__first != __last)
 erase(*__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k)
    {
      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k) const
    {
      const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    count(const _Key& __k) const
    {
      pair<const_iterator, const_iterator> __p = equal_range(__k);
      const size_type __n = std::distance(__p.first, __p.second);
      return __n;
    }

  __attribute__ ((__pure__)) unsigned int
  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
                       const _Rb_tree_node_base* __root) throw ();

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    bool
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
    {
      if (_M_impl._M_node_count == 0 || begin() == end())
 return _M_impl._M_node_count == 0 && begin() == end()
        && this->_M_impl._M_header._M_left == _M_end()
        && this->_M_impl._M_header._M_right == _M_end();

      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
      for (const_iterator __it = begin(); __it != end(); ++__it)
 {
   _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
   _Const_Link_type __L = _S_left(__x);
   _Const_Link_type __R = _S_right(__x);

   if (__x->_M_color == _S_red)
     if ((__L && __L->_M_color == _S_red)
  || (__R && __R->_M_color == _S_red))
       return false;

   if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
     return false;
   if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
     return false;

   if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
     return false;
 }

      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
 return false;
      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
 return false;
      return true;
    }


}
# 61 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/map" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_map.h" 1 3
# 66 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_map.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 94 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_map.h" 3
  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,
            typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class map
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;





    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class map<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;


      _Rep_type _M_t;

    public:


      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;







      map()
      : _M_t() { }






      explicit
      map(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a)) { }
# 180 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_map.h" 3
      map(const map& __x)
      : _M_t(__x._M_t) { }
# 223 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_map.h" 3
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_unique(__first, __last); }
# 240 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_map.h" 3
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Pair_alloc_type(__a))
        { _M_t._M_insert_unique(__first, __last); }
# 263 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_map.h" 3
      map&
      operator=(const map& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 309 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_map.h" 3
      allocator_type
      get_allocator() const
      { return allocator_type(_M_t.get_allocator()); }







      iterator
      begin()
      { return _M_t.begin(); }






      const_iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end()
      { return _M_t.end(); }






      const_iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend()
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }
# 428 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_map.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 455 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_map.h" 3
      mapped_type&
      operator[](const key_type& __k)
      {



 iterator __i = lower_bound(__k);

 if (__i == end() || key_comp()(__k, (*__i).first))





          __i = insert(__i, value_type(__k, mapped_type()));

 return (*__i).second;
      }
# 500 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_map.h" 3
      mapped_type&
      at(const key_type& __k)
      {
 iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }

      const mapped_type&
      at(const key_type& __k) const
      {
 const_iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }
# 593 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_map.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_t._M_insert_unique(__x); }
# 642 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_map.h" 3
      iterator



      insert(iterator __position, const value_type& __x)

      { return _M_t._M_insert_unique_(__position, __x); }
# 668 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_map.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_unique(__first, __last); }
# 709 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_map.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 725 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 761 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_map.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 777 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_map.h" 3
      void
      swap(map& __x)
      { _M_t.swap(__x._M_t); }







      void
      clear()
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 820 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 835 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_map.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 847 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_map.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
# 862 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_map.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 877 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_map.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }







      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }







      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 916 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 935 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_map.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator==(const map<_K1, _T1, _C1, _A1>&,
     const map<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator<(const map<_K1, _T1, _C1, _A1>&,
    const map<_K1, _T1, _C1, _A1>&);
    };
# 960 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 977 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,
  map<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


}
# 62 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/map" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multimap.h" 1 3
# 64 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multimap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 92 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multimap.h" 3
  template <typename _Key, typename _Tp,
     typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class multimap
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;





    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class multimap<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;

      _Rep_type _M_t;

    public:


      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;






      multimap()
      : _M_t() { }






      explicit
      multimap(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a)) { }
# 177 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multimap.h" 3
      multimap(const multimap& __x)
      : _M_t(__x._M_t) { }
# 218 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_equal(__first, __last); }
# 234 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Pair_alloc_type(__a))
        { _M_t._M_insert_equal(__first, __last); }
# 257 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multimap.h" 3
      multimap&
      operator=(const multimap& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 303 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multimap.h" 3
      allocator_type
      get_allocator() const
      { return allocator_type(_M_t.get_allocator()); }







      iterator
      begin()
      { return _M_t.begin(); }






      const_iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end()
      { return _M_t.end(); }






      const_iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend()
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }
# 420 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multimap.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 500 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multimap.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }
# 533 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multimap.h" 3
      iterator



      insert(iterator __position, const value_type& __x)

      { return _M_t._M_insert_equal_(__position, __x); }
# 560 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
# 614 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multimap.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 630 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multimap.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 670 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multimap.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 686 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multimap.h" 3
      void
      swap(multimap& __x)
      { _M_t.swap(__x._M_t); }







      void
      clear()
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 729 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multimap.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 744 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multimap.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }






      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
# 768 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multimap.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 783 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multimap.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }







      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }







      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 820 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multimap.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 837 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multimap.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator==(const multimap<_K1, _T1, _C1, _A1>&,
     const multimap<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator<(const multimap<_K1, _T1, _C1, _A1>&,
    const multimap<_K1, _T1, _C1, _A1>&);
  };
# 862 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 879 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,
         multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


}
# 63 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/map" 2 3
# 43 "/home/marek/devel/nupic/nta/ntypes/Value.hpp" 2
# 1 "/home/marek/devel/nupic/external/common/include/boost/shared_ptr.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/shared_ptr.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/config.hpp" 1
# 26 "/home/marek/devel/nupic/external/common/include/boost/config.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/config/user.hpp" 1
# 26 "/home/marek/devel/nupic/external/common/include/boost/config.hpp" 2





# 1 "/home/marek/devel/nupic/external/common/include/boost/config/select_compiler_config.hpp" 1
# 31 "/home/marek/devel/nupic/external/common/include/boost/config.hpp" 2




# 1 "/home/marek/devel/nupic/external/common/include/boost/config/compiler/clang.hpp" 1
# 35 "/home/marek/devel/nupic/external/common/include/boost/config.hpp" 2





# 1 "/home/marek/devel/nupic/external/common/include/boost/config/select_stdlib_config.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/config/select_stdlib_config.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 2 3
# 18 "/home/marek/devel/nupic/external/common/include/boost/config/select_stdlib_config.hpp" 2
# 37 "/home/marek/devel/nupic/external/common/include/boost/config/select_stdlib_config.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/config/no_tr1/utility.hpp" 1
# 21 "/home/marek/devel/nupic/external/common/include/boost/config/no_tr1/utility.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/utility" 1 3
# 59 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/utility" 3
# 69 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/utility" 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_relops.h" 1 3
# 67 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_relops.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
  namespace rel_ops
  {
# 85 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 98 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 111 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 124 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }


  }

}
# 70 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/utility" 2 3
# 21 "/home/marek/devel/nupic/external/common/include/boost/config/no_tr1/utility.hpp" 2
# 37 "/home/marek/devel/nupic/external/common/include/boost/config/select_stdlib_config.hpp" 2
# 40 "/home/marek/devel/nupic/external/common/include/boost/config.hpp" 2




# 1 "/home/marek/devel/nupic/external/common/include/boost/config/stdlib/libstdcpp3.hpp" 1
# 76 "/home/marek/devel/nupic/external/common/include/boost/config/stdlib/libstdcpp3.hpp"
# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4
extern "C" {
# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/bits/environments.h" 1 3 4
# 22 "/usr/include/bits/environments.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 23 "/usr/include/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 220 "/usr/include/unistd.h" 3 4
typedef __ssize_t ssize_t;






# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3 4
# 227 "/usr/include/unistd.h" 2 3 4





typedef __gid_t gid_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __useconds_t useconds_t;
# 267 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) throw () __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;
# 334 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) throw ();
# 345 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     throw ();






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 376 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) ;
# 404 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) throw () ;




extern int pipe2 (int __pipedes[2], int __flags) throw () ;
# 432 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) throw ();
# 444 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     throw ();






extern int usleep (__useconds_t __useconds);
# 469 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw () ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) throw () ;
# 511 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) throw () ;





extern char *get_current_dir_name (void) throw ();







extern char *getwd (char *__buf)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) throw () ;


extern int dup2 (int __fd, int __fd2) throw ();




extern int dup3 (int __fd, int __fd2, int __flags) throw ();



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) throw () __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     throw () __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) throw () ;




extern void _exit (int __status) __attribute__ ((__noreturn__));






# 1 "/usr/include/bits/confname.h" 1 3 4
# 24 "/usr/include/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 610 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     throw () __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) throw ();


extern long int sysconf (int __name) throw ();



extern size_t confstr (int __name, char *__buf, size_t __len) throw ();




extern __pid_t getpid (void) throw ();


extern __pid_t getppid (void) throw ();




extern __pid_t getpgrp (void) throw ();
# 646 "/usr/include/unistd.h" 3 4
extern __pid_t __getpgid (__pid_t __pid) throw ();

extern __pid_t getpgid (__pid_t __pid) throw ();






extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();
# 672 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) throw ();
# 689 "/usr/include/unistd.h" 3 4
extern __pid_t setsid (void) throw ();



extern __pid_t getsid (__pid_t __pid) throw ();



extern __uid_t getuid (void) throw ();


extern __uid_t geteuid (void) throw ();


extern __gid_t getgid (void) throw ();


extern __gid_t getegid (void) throw ();




extern int getgroups (int __size, __gid_t __list[]) throw () ;



extern int group_member (__gid_t __gid) throw ();






extern int setuid (__uid_t __uid) throw () ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) throw () ;




extern int seteuid (__uid_t __uid) throw () ;






extern int setgid (__gid_t __gid) throw () ;




extern int setregid (__gid_t __rgid, __gid_t __egid) throw () ;




extern int setegid (__gid_t __gid) throw () ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     throw ();



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     throw ();



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     throw () ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     throw () ;






extern __pid_t fork (void) throw ();







extern __pid_t vfork (void) throw ();





extern char *ttyname (int __fd) throw ();



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) throw ();





extern int ttyslot (void) throw ();




extern int link (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     throw () __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) throw () __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) throw () __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     throw () __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) throw () __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) throw ();


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) throw () __attribute__ ((__nonnull__ (1)));
# 893 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/getopt.h" 1 3 4
# 48 "/usr/include/getopt.h" 3 4
extern "C" {
# 57 "/usr/include/getopt.h" 3 4
extern char *optarg;
# 71 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 150 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       throw ();
# 185 "/usr/include/getopt.h" 3 4
}
# 894 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) throw () __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) throw () ;





extern int getdomainname (char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) throw ();


extern int revoke (const char *__file) throw () __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     throw () __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) throw ();



extern char *getusershell (void) throw ();
extern void endusershell (void) throw ();
extern void setusershell (void) throw ();





extern int daemon (int __nochdir, int __noclose) throw () ;






extern int chroot (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) throw ();






extern long int gethostid (void);


extern void sync (void) throw ();





extern int getpagesize (void) throw () __attribute__ ((__const__));




extern int getdtablesize (void) throw ();
# 1015 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 1027 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 1038 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) throw () ;
# 1048 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) throw () ;
# 1059 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) throw () ;





extern void *sbrk (intptr_t __delta) throw ();
# 1080 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) throw ();
# 1103 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1113 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1134 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);







extern char *crypt (const char *__key, const char *__salt)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__block, int __edflag) throw () __attribute__ ((__nonnull__ (1)));






extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));
# 1172 "/usr/include/unistd.h" 3 4
}
# 76 "/home/marek/devel/nupic/external/common/include/boost/config/stdlib/libstdcpp3.hpp" 2
# 44 "/home/marek/devel/nupic/external/common/include/boost/config.hpp" 2





# 1 "/home/marek/devel/nupic/external/common/include/boost/config/select_platform_config.hpp" 1
# 49 "/home/marek/devel/nupic/external/common/include/boost/config.hpp" 2




# 1 "/home/marek/devel/nupic/external/common/include/boost/config/platform/linux.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/config/platform/linux.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdlib" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdlib" 3
# 72 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 32 "/usr/include/stdlib.h" 3 4
# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3 4
# 33 "/usr/include/stdlib.h" 2 3 4

extern "C" {







# 1 "/usr/include/bits/waitflags.h" 1 3 4
# 42 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
# 66 "/usr/include/bits/waitstatus.h" 3 4
union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 43 "/usr/include/stdlib.h" 2 3 4
# 97 "/usr/include/stdlib.h" 3 4
typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 139 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;




extern double atof (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));
# 239 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 305 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





# 1 "/usr/include/sys/types.h" 1 3 4
# 27 "/usr/include/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;
# 70 "/usr/include/sys/types.h" 3 4
typedef __mode_t mode_t;




typedef __nlink_t nlink_t;
# 104 "/usr/include/sys/types.h" 3 4
typedef __id_t id_t;
# 115 "/usr/include/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 140 "/usr/include/sys/types.h" 3 4
typedef __suseconds_t suseconds_t;






# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3 4
# 147 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 194 "/usr/include/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 219 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/select.h" 1 3 4
# 30 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 22 "/usr/include/bits/select.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 23 "/usr/include/bits/select.h" 2 3 4
# 31 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 22 "/usr/include/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 34 "/usr/include/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;








# 1 "/usr/include/bits/time.h" 1 3 4
# 46 "/usr/include/sys/select.h" 2 3 4








typedef long int __fd_mask;
# 64 "/usr/include/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 96 "/usr/include/sys/select.h" 3 4
extern "C" {
# 106 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 118 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 131 "/usr/include/sys/select.h" 3 4
}
# 220 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/sysmacros.h" 1 3 4
# 24 "/usr/include/sys/sysmacros.h" 3 4
extern "C" {

__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     throw () __attribute__ ((__const__));
# 58 "/usr/include/sys/sysmacros.h" 3 4
}
# 223 "/usr/include/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 262 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;
# 273 "/usr/include/sys/types.h" 3 4
}
# 315 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();




extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));
# 466 "/usr/include/stdlib.h" 3 4
extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;
# 480 "/usr/include/stdlib.h" 3 4
extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) throw ();




extern void cfree (void *__ptr) throw ();




# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 493 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     throw () __attribute__ ((__malloc__)) ;




extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
# 535 "/usr/include/stdlib.h" 3 4
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) throw () __attribute__ ((__noreturn__));





extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));







extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;





extern char *secure_getenv (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
# 606 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));
# 620 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 630 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 642 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 652 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 663 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 674 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 684 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 694 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 706 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 717 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;






extern char *canonicalize_file_name (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 734 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);





extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;
# 812 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));






extern int mblen (const char *__s, size_t __n) throw ();


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) throw ();


extern int wctomb (char *__s, wchar_t __wchar) throw ();



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     throw ();
# 888 "/usr/include/stdlib.h" 3 4
extern int rpmatch (const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 899 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));



# 1 "/usr/include/bits/stdlib-float.h" 1 3 4
# 956 "/usr/include/stdlib.h" 2 3 4
# 968 "/usr/include/stdlib.h" 3 4
}
# 73 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdlib" 2 3
# 114 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdlib" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;





  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;





  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline long
  abs(long __i) { return __builtin_labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }



  inline __int128
  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }



}
# 196 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 228 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}
# 15 "/home/marek/devel/nupic/external/common/include/boost/config/platform/linux.hpp" 2
# 74 "/home/marek/devel/nupic/external/common/include/boost/config/platform/linux.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/config/posix_features.hpp" 1
# 74 "/home/marek/devel/nupic/external/common/include/boost/config/platform/linux.hpp" 2
# 53 "/home/marek/devel/nupic/external/common/include/boost/config.hpp" 2




# 1 "/home/marek/devel/nupic/external/common/include/boost/config/suffix.hpp" 1
# 34 "/home/marek/devel/nupic/external/common/include/boost/config/suffix.hpp" 3
# 481 "/home/marek/devel/nupic/external/common/include/boost/config/suffix.hpp" 3
namespace boost{

   __extension__ typedef long long long_long_type;
   __extension__ typedef unsigned long long ulong_long_type;




}
# 57 "/home/marek/devel/nupic/external/common/include/boost/config.hpp" 2
# 17 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp" 2
# 27 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/config/no_tr1/memory.hpp" 1
# 21 "/home/marek/devel/nupic/external/common/include/boost/config/no_tr1/memory.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/memory" 1 3
# 47 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/memory" 3
# 66 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/memory" 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_tempbuf.h" 1 3
# 62 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_tempbuf.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 83 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len)
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 110 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, std::nothrow); }







  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {



    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<bool>
    struct __uninitialized_construct_buf_dispatch
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer __first, _Pointer __last,
       _ForwardIterator __seed)
        {
   if(__first == __last)
     return;

   _Pointer __cur = __first;
   try
     {
       std::_Construct(std::__addressof(*__first),
         (*__seed));
       _Pointer __prev = __cur;
       ++__cur;
       for(; __cur != __last; ++__cur, ++__prev)
  std::_Construct(std::__addressof(*__cur),
    (*__prev));
       *__seed = (*__prev);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_construct_buf_dispatch<true>
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer, _Pointer, _ForwardIterator) { }
    };
# 229 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_tempbuf.h" 3
  template<typename _Pointer, typename _ForwardIterator>
    inline void
    __uninitialized_construct_buf(_Pointer __first, _Pointer __last,
      _ForwardIterator __seed)
    {
      typedef typename std::iterator_traits<_Pointer>::value_type
 _ValueType;

      std::__uninitialized_construct_buf_dispatch<
        __has_trivial_constructor(_ValueType)>::
   __ucr(__first, __last, __seed);
    }

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {
      try
 {
   std::pair<pointer, size_type> __p(std::get_temporary_buffer<
         value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (_M_buffer)
     std::__uninitialized_construct_buf(_M_buffer, _M_buffer + _M_len,
            __first);
 }
      catch(...)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }


}
# 67 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/memory" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_raw_storage_iter.h" 1 3
# 59 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_raw_storage_iter.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{






  template <class _OutputIterator, class _Tp>
    class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _OutputIterator _M_iter;

    public:
      explicit
      raw_storage_iterator(_OutputIterator __x)
      : _M_iter(__x) {}

      raw_storage_iterator&
      operator*() { return *this; }

      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
 std::_Construct(std::__addressof(*_M_iter), __element);
 return *this;
      }

      raw_storage_iterator<_OutputIterator, _Tp>&
      operator++()
      {
 ++_M_iter;
 return *this;
      }

      raw_storage_iterator<_OutputIterator, _Tp>
      operator++(int)
      {
 raw_storage_iterator<_OutputIterator, _Tp> __tmp = *this;
 ++_M_iter;
 return __tmp;
      }
    };


}
# 68 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/memory" 2 3
# 87 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/memory" 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/backward/auto_ptr.h" 1 3
# 36 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/backward/auto_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 47 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/backward/auto_ptr.h" 3
  template<typename _Tp1>
    struct auto_ptr_ref
    {
      _Tp1* _M_ptr;

      explicit
      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }
    } ;
# 86 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/backward/auto_ptr.h" 3
  template<typename _Tp>
    class auto_ptr
    {
    private:
      _Tp* _M_ptr;

    public:

      typedef _Tp element_type;







      explicit
      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
# 112 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }
# 124 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }
# 135 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/backward/auto_ptr.h" 3
      auto_ptr&
      operator=(auto_ptr& __a) throw()
      {
 reset(__a.release());
 return *this;
      }
# 152 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr&
        operator=(auto_ptr<_Tp1>& __a) throw()
        {
   reset(__a.release());
   return *this;
 }
# 170 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/backward/auto_ptr.h" 3
      ~auto_ptr() { delete _M_ptr; }
# 180 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/backward/auto_ptr.h" 3
      element_type&
      operator*() const throw()
      {
                                   ;
 return *_M_ptr;
      }







      element_type*
      operator->() const throw()
      {
                                   ;
 return _M_ptr;
      }
# 210 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/backward/auto_ptr.h" 3
      element_type*
      get() const throw() { return _M_ptr; }
# 224 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/backward/auto_ptr.h" 3
      element_type*
      release() throw()
      {
 element_type* __tmp = _M_ptr;
 _M_ptr = 0;
 return __tmp;
      }
# 239 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/backward/auto_ptr.h" 3
      void
      reset(element_type* __p = 0) throw()
      {
 if (__p != _M_ptr)
   {
     delete _M_ptr;
     _M_ptr = __p;
   }
      }
# 260 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr_ref<element_type> __ref) throw()
      : _M_ptr(__ref._M_ptr) { }

      auto_ptr&
      operator=(auto_ptr_ref<element_type> __ref) throw()
      {
 if (__ref._M_ptr != this->get())
   {
     delete _M_ptr;
     _M_ptr = __ref._M_ptr;
   }
 return *this;
      }

      template<typename _Tp1>
        operator auto_ptr_ref<_Tp1>() throw()
        { return auto_ptr_ref<_Tp1>(this->release()); }

      template<typename _Tp1>
        operator auto_ptr<_Tp1>() throw()
        { return auto_ptr<_Tp1>(this->release()); }
    } ;



  template<>
    class auto_ptr<void>
    {
    public:
      typedef void element_type;
    } ;
# 327 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/backward/auto_ptr.h" 3
}
# 88 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/memory" 2 3
# 21 "/home/marek/devel/nupic/external/common/include/boost/config/no_tr1/memory.hpp" 2
# 27 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/assert.hpp" 1
# 50 "/home/marek/devel/nupic/external/common/include/boost/assert.hpp"
# 1 "/usr/include/assert.h" 1 3 4
# 64 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 50 "/home/marek/devel/nupic/external/common/include/boost/assert.hpp" 2
# 81 "/home/marek/devel/nupic/external/common/include/boost/assert.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdlib" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdlib" 3
# 81 "/home/marek/devel/nupic/external/common/include/boost/assert.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/current_function.hpp" 1
# 22 "/home/marek/devel/nupic/external/common/include/boost/current_function.hpp"
namespace boost
{

namespace detail
{

inline void current_function_helper()
{
# 61 "/home/marek/devel/nupic/external/common/include/boost/current_function.hpp"
}

}

}
# 83 "/home/marek/devel/nupic/external/common/include/boost/assert.hpp" 2








    namespace boost
    {
      namespace assertion
      {
        namespace detail
        {
          inline void assertion_failed_msg(char const * expr, char const * msg, char const * function,
            char const * file, long line)
          {
            std::cerr
              << "***** Internal Program Error - assertion (" << expr << ") failed in "
              << function << ":\n"
              << file << '(' << line << "): " << msg << std::endl;
            std::abort();
          }
        }
      }
    }
# 29 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/checked_delete.hpp" 1
# 24 "/home/marek/devel/nupic/external/common/include/boost/checked_delete.hpp"
namespace boost
{



template<class T> inline void checked_delete(T * x)
{

    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];
    (void) sizeof(type_must_be_complete);
    delete x;
}

template<class T> inline void checked_array_delete(T * x)
{
    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];
    (void) sizeof(type_must_be_complete);
    delete [] x;
}

template<class T> struct checked_deleter
{
    typedef void result_type;
    typedef T * argument_type;

    void operator()(T * x) const
    {

        boost::checked_delete(x);
    }
};

template<class T> struct checked_array_deleter
{
    typedef void result_type;
    typedef T * argument_type;

    void operator()(T * x) const
    {
        boost::checked_array_delete(x);
    }
};

}
# 30 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/throw_exception.hpp" 1
# 5 "/home/marek/devel/nupic/external/common/include/boost/throw_exception.hpp" 3
# 29 "/home/marek/devel/nupic/external/common/include/boost/throw_exception.hpp" 3
# 1 "/home/marek/devel/nupic/external/common/include/boost/exception/detail/attribute_noreturn.hpp" 1 3
# 29 "/home/marek/devel/nupic/external/common/include/boost/throw_exception.hpp" 2 3

# 1 "/home/marek/devel/nupic/external/common/include/boost/detail/workaround.hpp" 1 3
# 30 "/home/marek/devel/nupic/external/common/include/boost/throw_exception.hpp" 2 3
# 43 "/home/marek/devel/nupic/external/common/include/boost/throw_exception.hpp" 3
# 1 "/home/marek/devel/nupic/external/common/include/boost/exception/exception.hpp" 1 3
# 10 "/home/marek/devel/nupic/external/common/include/boost/exception/exception.hpp" 3





namespace
boost
    {
    namespace
    exception_detail
        {
        template <class T>
        class
        refcount_ptr
            {
            public:

            refcount_ptr():
                px_(0)
                {
                }

            ~refcount_ptr()
                {
                release();
                }

            refcount_ptr( refcount_ptr const & x ):
                px_(x.px_)
                {
                add_ref();
                }

            refcount_ptr &
            operator=( refcount_ptr const & x )
                {
                adopt(x.px_);
                return *this;
                }

            void
            adopt( T * px )
                {
                release();
                px_=px;
                add_ref();
                }

            T *
            get() const
                {
                return px_;
                }

            private:

            T * px_;

            void
            add_ref()
                {
                if( px_ )
                    px_->add_ref();
                }

            void
            release()
                {
                if( px_ && px_->release() )
                    px_=0;
                }
            };
        }



    template <class Tag,class T>
    class error_info;

    typedef error_info<struct throw_function_,char const *> throw_function;
    typedef error_info<struct throw_file_,char const *> throw_file;
    typedef error_info<struct throw_line_,int> throw_line;

    template <>
    class
    error_info<throw_function_,char const *>
        {
        public:
        typedef char const * value_type;
        value_type v_;
        explicit
        error_info( value_type v ):
            v_(v)
            {
            }
        };

    template <>
    class
    error_info<throw_file_,char const *>
        {
        public:
        typedef char const * value_type;
        value_type v_;
        explicit
        error_info( value_type v ):
            v_(v)
            {
            }
        };

    template <>
    class
    error_info<throw_line_,int>
        {
        public:
        typedef int value_type;
        value_type v_;
        explicit
        error_info( value_type v ):
            v_(v)
            {
            }
        };



#pragma GCC visibility push (default)


 class exception;


#pragma GCC visibility pop



 template <class T>
    class shared_ptr;

    namespace
    exception_detail
        {
        class error_info_base;
        struct type_info_;

        struct
        error_info_container
            {
            virtual char const * diagnostic_information( char const * ) const = 0;
            virtual shared_ptr<error_info_base> get( type_info_ const & ) const = 0;
            virtual void set( shared_ptr<error_info_base> const &, type_info_ const & ) = 0;
            virtual void add_ref() const = 0;
            virtual bool release() const = 0;
            virtual refcount_ptr<exception_detail::error_info_container> clone() const = 0;

            protected:

            ~error_info_container() throw()
                {
                }
            };

        template <class>
        struct get_info;

        template <>
        struct get_info<throw_function>;

        template <>
        struct get_info<throw_file>;

        template <>
        struct get_info<throw_line>;

        char const * get_diagnostic_information( exception const &, char const * );

        void copy_boost_exception( exception *, exception const * );

        template <class E,class Tag,class T>
        E const & set_info( E const &, error_info<Tag,T> const & );

        template <class E>
        E const & set_info( E const &, throw_function const & );

        template <class E>
        E const & set_info( E const &, throw_file const & );

        template <class E>
        E const & set_info( E const &, throw_line const & );
        }



#pragma GCC visibility push (default)


 class
    exception
        {
        protected:

        exception():
            throw_function_(0),
            throw_file_(0),
            throw_line_(-1)
            {
            }
# 231 "/home/marek/devel/nupic/external/common/include/boost/exception/exception.hpp" 3
        virtual ~exception() throw()

            = 0

            ;




        private:

        template <class E>
        friend E const & exception_detail::set_info( E const &, throw_function const & );

        template <class E>
        friend E const & exception_detail::set_info( E const &, throw_file const & );

        template <class E>
        friend E const & exception_detail::set_info( E const &, throw_line const & );

        template <class E,class Tag,class T>
        friend E const & exception_detail::set_info( E const &, error_info<Tag,T> const & );

        friend char const * exception_detail::get_diagnostic_information( exception const &, char const * );

        template <class>
        friend struct exception_detail::get_info;
        friend struct exception_detail::get_info<throw_function>;
        friend struct exception_detail::get_info<throw_file>;
        friend struct exception_detail::get_info<throw_line>;
        friend void exception_detail::copy_boost_exception( exception *, exception const * );

        mutable exception_detail::refcount_ptr<exception_detail::error_info_container> data_;
        mutable char const * throw_function_;
        mutable char const * throw_file_;
        mutable int throw_line_;
        };


#pragma GCC visibility pop



 inline
    exception::
    ~exception() throw()
        {
        }

    namespace
    exception_detail
        {
        template <class E>
        E const &
        set_info( E const & x, throw_function const & y )
            {
            x.throw_function_=y.v_;
            return x;
            }

        template <class E>
        E const &
        set_info( E const & x, throw_file const & y )
            {
            x.throw_file_=y.v_;
            return x;
            }

        template <class E>
        E const &
        set_info( E const & x, throw_line const & y )
            {
            x.throw_line_=y.v_;
            return x;
            }
        }



    namespace
    exception_detail
        {


#pragma GCC visibility push (default)


 template <class T>
        struct
        error_info_injector:
            public T,
            public exception
            {
            explicit
            error_info_injector( T const & x ):
                T(x)
                {
                }

            ~error_info_injector() throw()
                {
                }
            };


#pragma GCC visibility pop



 struct large_size { char c[256]; };
        large_size dispatch_boost_exception( exception const * );

        struct small_size { };
        small_size dispatch_boost_exception( void const * );

        template <class,int>
        struct enable_error_info_helper;

        template <class T>
        struct
        enable_error_info_helper<T,sizeof(large_size)>
            {
            typedef T type;
            };

        template <class T>
        struct
        enable_error_info_helper<T,sizeof(small_size)>
            {
            typedef error_info_injector<T> type;
            };

        template <class T>
        struct
        enable_error_info_return_type
            {
            typedef typename enable_error_info_helper<T,sizeof(exception_detail::dispatch_boost_exception(static_cast<T *>(0)))>::type type;
            };
        }

    template <class T>
    inline
    typename
    exception_detail::enable_error_info_return_type<T>::type
    enable_error_info( T const & x )
        {
        typedef typename exception_detail::enable_error_info_return_type<T>::type rt;
        return rt(x);
        }



    namespace
    exception_detail
        {


#pragma GCC visibility push (default)


 class
        clone_base
            {
            public:

            virtual clone_base const * clone() const = 0;
            virtual void rethrow() const = 0;

            virtual
            ~clone_base() throw()
                {
                }
            };


#pragma GCC visibility pop



 inline
        void
        copy_boost_exception( exception * a, exception const * b )
            {
            refcount_ptr<error_info_container> data;
            if( error_info_container * d=b->data_.get() )
                data = d->clone();
            a->throw_file_ = b->throw_file_;
            a->throw_line_ = b->throw_line_;
            a->throw_function_ = b->throw_function_;
            a->data_ = data;
            }

        inline
        void
        copy_boost_exception( void *, void const * )
            {
            }

        template <class T>
        class
        clone_impl:
            public T,
            public virtual clone_base
            {
            struct clone_tag { };
            clone_impl( clone_impl const & x, clone_tag ):
                T(x)
                {
                copy_boost_exception(this,&x);
                }

            public:

            explicit
            clone_impl( T const & x ):
                T(x)
                {
                copy_boost_exception(this,&x);
                }

            ~clone_impl() throw()
                {
                }

            private:

            clone_base const *
            clone() const
                {
                return new clone_impl(*this,clone_tag());
                }

            void
            rethrow() const
                {
                throw*this;
                }
            };
        }

    template <class T>
    inline
    exception_detail::clone_impl<T>
    enable_current_exception( T const & x )
        {
        return exception_detail::clone_impl<T>(x);
        }
    }
# 43 "/home/marek/devel/nupic/external/common/include/boost/throw_exception.hpp" 2 3







namespace boost
{






inline void throw_exception_assert_compatibility( std::exception const & ) { }

template<class E> __attribute__((__noreturn__)) inline void throw_exception( E const & e )
{


    throw_exception_assert_compatibility(e);


    throw enable_current_exception(enable_error_info(e));



}




    namespace
    exception_detail
    {
        template <class E>
        __attribute__((__noreturn__))
        void
        throw_exception_( E const & x, char const * current_function, char const * file, int line )
        {
            boost::throw_exception(
                set_info(
                    set_info(
                        set_info(
                            enable_error_info(x),
                            throw_function(current_function)),
                        throw_file(file)),
                    throw_line(line)));
        }
    }

}
# 31 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/shared_count.hpp" 1
# 28 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/shared_count.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/bad_weak_ptr.hpp" 1
# 26 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/bad_weak_ptr.hpp"
namespace boost
{
# 39 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/bad_weak_ptr.hpp"
class bad_weak_ptr: public std::exception
{
public:

    virtual char const * what() const throw()
    {
        return "tr1::bad_weak_ptr";
    }
};





}
# 28 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/shared_count.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/sp_counted_base.hpp" 1
# 21 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/sp_counted_base.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/sp_has_sync.hpp" 1
# 21 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/sp_counted_base.hpp" 2
# 36 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/sp_counted_base.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/sp_counted_base_gcc_x86.hpp" 1
# 27 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/sp_counted_base_gcc_x86.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/detail/sp_typeinfo.hpp" 1
# 109 "/home/marek/devel/nupic/external/common/include/boost/detail/sp_typeinfo.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/typeinfo" 1 3
# 33 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/typeinfo" 3






#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 80 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const
    { return __name[0] == '*' ? __name + 1 : __name; }
# 115 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/typeinfo" 3
    bool before(const type_info& __arg) const
    { return (__name[0] == '*' && __arg.__name[0] == '*')
 ? __name < __arg.__name
 : __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const
    {
      return ((__name == __arg.__name)
       || (__name[0] != '*' &&
    __builtin_strcmp (__name, __arg.__name) == 0));
    }
# 136 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/typeinfo" 3
    bool operator!=(const type_info& __arg) const
    { return !operator==(__arg); }
# 152 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/typeinfo" 3
    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() throw() { }



    virtual ~bad_cast() throw();


    virtual const char* what() const throw();
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () throw() { }



    virtual ~bad_typeid() throw();


    virtual const char* what() const throw();
  };
}

}

#pragma GCC visibility pop
# 109 "/home/marek/devel/nupic/external/common/include/boost/detail/sp_typeinfo.hpp" 2


namespace boost
{

namespace detail
{







typedef std::type_info sp_typeinfo;



}

}
# 27 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/sp_counted_base_gcc_x86.hpp" 2


namespace boost
{

namespace detail
{

inline int atomic_exchange_and_add( int * pw, int dv )
{




    int r;

    __asm__ __volatile__
    (
        "lock\n\t"
        "xadd %1, %0":
        "=m"( *pw ), "=r"( r ):
        "m"( *pw ), "1"( dv ):
        "memory", "cc"
    );

    return r;
}

inline void atomic_increment( int * pw )
{


    __asm__
    (
        "lock\n\t"
        "incl %0":
        "=m"( *pw ):
        "m"( *pw ):
        "cc"
    );
}

inline int atomic_conditional_increment( int * pw )
{




    int rv, tmp;

    __asm__
    (
        "movl %0, %%eax\n\t"
        "0:\n\t"
        "test %%eax, %%eax\n\t"
        "je 1f\n\t"
        "movl %%eax, %2\n\t"
        "incl %2\n\t"
        "lock\n\t"
        "cmpxchgl %2, %0\n\t"
        "jne 0b\n\t"
        "1:":
        "=m"( *pw ), "=&a"( rv ), "=&r"( tmp ):
        "m"( *pw ):
        "cc"
    );

    return rv;
}

class sp_counted_base
{
private:

    sp_counted_base( sp_counted_base const & );
    sp_counted_base & operator= ( sp_counted_base const & );

    int use_count_;
    int weak_count_;

public:

    sp_counted_base(): use_count_( 1 ), weak_count_( 1 )
    {
    }

    virtual ~sp_counted_base()
    {
    }




    virtual void dispose() = 0;



    virtual void destroy()
    {
        delete this;
    }

    virtual void * get_deleter( sp_typeinfo const & ti ) = 0;

    void add_ref_copy()
    {
        atomic_increment( &use_count_ );
    }

    bool add_ref_lock()
    {
        return atomic_conditional_increment( &use_count_ ) != 0;
    }

    void release()
    {
        if( atomic_exchange_and_add( &use_count_, -1 ) == 1 )
        {
            dispose();
            weak_release();
        }
    }

    void weak_add_ref()
    {
        atomic_increment( &weak_count_ );
    }

    void weak_release()
    {
        if( atomic_exchange_and_add( &weak_count_, -1 ) == 1 )
        {
            destroy();
        }
    }

    long use_count() const
    {
        return static_cast<int const volatile &>( use_count_ );
    }
};

}

}
# 36 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/sp_counted_base.hpp" 2
# 29 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/shared_count.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/sp_counted_impl.hpp" 1
# 38 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/sp_counted_impl.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 2 3
# 38 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/sp_counted_impl.hpp" 2


namespace boost
{
# 50 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/sp_counted_impl.hpp"
namespace detail
{

template<class X> class sp_counted_impl_p: public sp_counted_base
{
private:

    X * px_;

    sp_counted_impl_p( sp_counted_impl_p const & );
    sp_counted_impl_p & operator= ( sp_counted_impl_p const & );

    typedef sp_counted_impl_p<X> this_type;

public:

    explicit sp_counted_impl_p( X * px ): px_( px )
    {



    }

    virtual void dispose()
    {



        boost::checked_delete( px_ );
    }

    virtual void * get_deleter( detail::sp_typeinfo const & )
    {
        return 0;
    }
# 113 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/sp_counted_impl.hpp"
};
# 122 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/sp_counted_impl.hpp"
template<class P, class D> class sp_counted_impl_pd: public sp_counted_base
{
private:

    P ptr;
    D del;

    sp_counted_impl_pd( sp_counted_impl_pd const & );
    sp_counted_impl_pd & operator= ( sp_counted_impl_pd const & );

    typedef sp_counted_impl_pd<P, D> this_type;

public:



    sp_counted_impl_pd( P p, D & d ): ptr( p ), del( d )
    {
    }

    sp_counted_impl_pd( P p ): ptr( p ), del()
    {
    }

    virtual void dispose()
    {
        del( ptr );
    }

    virtual void * get_deleter( detail::sp_typeinfo const & ti )
    {
        return ti == typeid(D)? &reinterpret_cast<char&>( del ): 0;
    }
# 183 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/sp_counted_impl.hpp"
};

template<class P, class D, class A> class sp_counted_impl_pda: public sp_counted_base
{
private:

    P p_;
    D d_;
    A a_;

    sp_counted_impl_pda( sp_counted_impl_pda const & );
    sp_counted_impl_pda & operator= ( sp_counted_impl_pda const & );

    typedef sp_counted_impl_pda<P, D, A> this_type;

public:



    sp_counted_impl_pda( P p, D & d, A a ): p_( p ), d_( d ), a_( a )
    {
    }

    sp_counted_impl_pda( P p, A a ): p_( p ), d_(), a_( a )
    {
    }

    virtual void dispose()
    {
        d_( p_ );
    }

    virtual void destroy()
    {
        typedef typename A::template rebind< this_type >::other A2;

        A2 a2( a_ );

        this->~this_type();
        a2.deallocate( this, 1 );
    }

    virtual void * get_deleter( detail::sp_typeinfo const & ti )
    {
        return ti == typeid(D)? &reinterpret_cast<char&>( d_ ): 0;
    }
};





}

}
# 30 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/shared_count.hpp" 2







# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/functional" 1 3
# 47 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/functional" 3
# 37 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/shared_count.hpp" 2



namespace boost
{

namespace detail
{
# 53 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/shared_count.hpp"
struct sp_nothrow_tag {};

template< class D > struct sp_inplace_tag
{
};

class weak_count;

class shared_count
{
private:

    sp_counted_base * pi_;





    friend class weak_count;

public:

    shared_count(): pi_(0)



    {
    }

    template<class Y> explicit shared_count( Y * p ): pi_( 0 )



    {


        try
        {
            pi_ = new sp_counted_impl_p<Y>( p );
        }
        catch(...)
        {
            boost::checked_delete( p );
            throw;
        }
# 110 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/shared_count.hpp"
    }




    template<class P, class D> shared_count( P p, D d ): pi_(0)




    {





        try
        {
            pi_ = new sp_counted_impl_pd<P, D>(p, d);
        }
        catch(...)
        {
            d(p);
            throw;
        }
# 147 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/shared_count.hpp"
    }



    template< class P, class D > shared_count( P p, sp_inplace_tag<D> ): pi_( 0 )



    {


        try
        {
            pi_ = new sp_counted_impl_pd< P, D >( p );
        }
        catch( ... )
        {
            D()( p );
            throw;
        }
# 179 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/shared_count.hpp"
    }



    template<class P, class D, class A> shared_count( P p, D d, A a ): pi_( 0 )



    {
        typedef sp_counted_impl_pda<P, D, A> impl_type;
        typedef typename A::template rebind< impl_type >::other A2;

        A2 a2( a );



        try
        {
            pi_ = a2.allocate( 1, static_cast< impl_type* >( 0 ) );
            new( static_cast< void* >( pi_ ) ) impl_type( p, d, a );
        }
        catch(...)
        {
            d( p );

            if( pi_ != 0 )
            {
                a2.deallocate( static_cast< impl_type* >( pi_ ), 1 );
            }

            throw;
        }
# 227 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/shared_count.hpp"
    }



    template< class P, class D, class A > shared_count( P p, sp_inplace_tag< D >, A a ): pi_( 0 )



    {
        typedef sp_counted_impl_pda< P, D, A > impl_type;
        typedef typename A::template rebind< impl_type >::other A2;

        A2 a2( a );



        try
        {
            pi_ = a2.allocate( 1, static_cast< impl_type* >( 0 ) );
            new( static_cast< void* >( pi_ ) ) impl_type( p, a );
        }
        catch(...)
        {
            D()( p );

            if( pi_ != 0 )
            {
                a2.deallocate( static_cast< impl_type* >( pi_ ), 1 );
            }

            throw;
        }
# 275 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/shared_count.hpp"
    }







    template<class Y>
    explicit shared_count( std::auto_ptr<Y> & r ): pi_( new sp_counted_impl_p<Y>( r.get() ) )



    {
# 298 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/shared_count.hpp"
        r.release();
    }



    ~shared_count()
    {
        if( pi_ != 0 ) pi_->release();



    }

    shared_count(shared_count const & r): pi_(r.pi_)



    {
        if( pi_ != 0 ) pi_->add_ref_copy();
    }
# 331 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/shared_count.hpp"
    explicit shared_count(weak_count const & r);
    shared_count( weak_count const & r, sp_nothrow_tag );

    shared_count & operator= (shared_count const & r)
    {
        sp_counted_base * tmp = r.pi_;

        if( tmp != pi_ )
        {
            if( tmp != 0 ) tmp->add_ref_copy();
            if( pi_ != 0 ) pi_->release();
            pi_ = tmp;
        }

        return *this;
    }

    void swap(shared_count & r)
    {
        sp_counted_base * tmp = r.pi_;
        r.pi_ = pi_;
        pi_ = tmp;
    }

    long use_count() const
    {
        return pi_ != 0? pi_->use_count(): 0;
    }

    bool unique() const
    {
        return use_count() == 1;
    }

    bool empty() const
    {
        return pi_ == 0;
    }

    friend inline bool operator==(shared_count const & a, shared_count const & b)
    {
        return a.pi_ == b.pi_;
    }

    friend inline bool operator<(shared_count const & a, shared_count const & b)
    {
        return std::less<sp_counted_base *>()( a.pi_, b.pi_ );
    }

    void * get_deleter( sp_typeinfo const & ti ) const
    {
        return pi_? pi_->get_deleter( ti ): 0;
    }
};


class weak_count
{
private:

    sp_counted_base * pi_;





    friend class shared_count;

public:

    weak_count(): pi_(0)



    {
    }

    weak_count(shared_count const & r): pi_(r.pi_)



    {
        if(pi_ != 0) pi_->weak_add_ref();
    }

    weak_count(weak_count const & r): pi_(r.pi_)



    {
        if(pi_ != 0) pi_->weak_add_ref();
    }
# 438 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/shared_count.hpp"
    ~weak_count()
    {
        if(pi_ != 0) pi_->weak_release();



    }

    weak_count & operator= (shared_count const & r)
    {
        sp_counted_base * tmp = r.pi_;

        if( tmp != pi_ )
        {
            if(tmp != 0) tmp->weak_add_ref();
            if(pi_ != 0) pi_->weak_release();
            pi_ = tmp;
        }

        return *this;
    }

    weak_count & operator= (weak_count const & r)
    {
        sp_counted_base * tmp = r.pi_;

        if( tmp != pi_ )
        {
            if(tmp != 0) tmp->weak_add_ref();
            if(pi_ != 0) pi_->weak_release();
            pi_ = tmp;
        }

        return *this;
    }

    void swap(weak_count & r)
    {
        sp_counted_base * tmp = r.pi_;
        r.pi_ = pi_;
        pi_ = tmp;
    }

    long use_count() const
    {
        return pi_ != 0? pi_->use_count(): 0;
    }

    bool empty() const
    {
        return pi_ == 0;
    }

    friend inline bool operator==(weak_count const & a, weak_count const & b)
    {
        return a.pi_ == b.pi_;
    }

    friend inline bool operator<(weak_count const & a, weak_count const & b)
    {
        return std::less<sp_counted_base *>()(a.pi_, b.pi_);
    }
};

inline shared_count::shared_count( weak_count const & r ): pi_( r.pi_ )



{
    if( pi_ == 0 || !pi_->add_ref_lock() )
    {
        boost::throw_exception( boost::bad_weak_ptr() );
    }
}

inline shared_count::shared_count( weak_count const & r, sp_nothrow_tag ): pi_( r.pi_ )



{
    if( pi_ != 0 && !pi_->add_ref_lock() )
    {
        pi_ = 0;
    }
}

}

}
# 32 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/sp_convertible.hpp" 1
# 34 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/sp_convertible.hpp"
namespace boost
{

namespace detail
{

template< class Y, class T > struct sp_convertible
{
    typedef char (&yes) [1];
    typedef char (&no) [2];

    static yes f( T* );
    static no f( ... );

    enum _vt { value = sizeof( (f)( static_cast<Y*>(0) ) ) == sizeof(yes) };
};

struct sp_empty
{
};

template< bool > struct sp_enable_if_convertible_impl;

template<> struct sp_enable_if_convertible_impl<true>
{
    typedef sp_empty type;
};

template<> struct sp_enable_if_convertible_impl<false>
{
};

template< class Y, class T > struct sp_enable_if_convertible: public sp_enable_if_convertible_impl< sp_convertible< Y, T >::value >
{
};

}

}
# 34 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp" 2



# 1 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/spinlock_pool.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/spinlock_pool.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/spinlock.hpp" 1
# 41 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/spinlock.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/spinlock_sync.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/spinlock_sync.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/yield_k.hpp" 1
# 91 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/yield_k.hpp"
namespace boost
{

namespace detail
{

inline void yield( unsigned k )
{
    if( k < 4 )
    {
    }

    else if( k < 16 )
    {
        __asm__ __volatile__( "rep; nop" : : : "memory" );
    }

    else if( k < 32 || k & 1 )
    {
        sched_yield();
    }
    else
    {

        struct timespec rqtp = { 0, 0 };




        rqtp.tv_sec = 0;
        rqtp.tv_nsec = 1000;

        nanosleep( &rqtp, 0 );
    }
}

}

}
# 18 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/spinlock_sync.hpp" 2






namespace boost
{

namespace detail
{

class spinlock
{
public:

    int v_;

public:

    bool try_lock()
    {
        int r = __sync_lock_test_and_set( &v_, 1 );
        return r == 0;
    }

    void lock()
    {
        for( unsigned k = 0; !try_lock(); ++k )
        {
            boost::detail::yield( k );
        }
    }

    void unlock()
    {
        __sync_lock_release( &v_ );
    }

public:

    class scoped_lock
    {
    private:

        spinlock & sp_;

        scoped_lock( scoped_lock const & );
        scoped_lock & operator=( scoped_lock const & );

    public:

        explicit scoped_lock( spinlock & sp ): sp_( sp )
        {
            sp.lock();
        }

        ~scoped_lock()
        {
            sp_.unlock();
        }
    };
};

}
}
# 41 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/spinlock.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/spinlock_pool.hpp" 2

# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 2 3
# 26 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/spinlock_pool.hpp" 2


namespace boost
{

namespace detail
{

template< int I > class spinlock_pool
{
private:

    static spinlock pool_[ 41 ];

public:

    static spinlock & spinlock_for( void const * pv )
    {



        std::size_t i = reinterpret_cast< std::size_t >( pv ) % 41;

        return pool_[ i ];
    }

    class scoped_lock
    {
    private:

        spinlock & sp_;

        scoped_lock( scoped_lock const & );
        scoped_lock & operator=( scoped_lock const & );

    public:

        explicit scoped_lock( void const * pv ): sp_( spinlock_for( pv ) )
        {
            sp_.lock();
        }

        ~scoped_lock()
        {
            sp_.unlock();
        }
    };
};

template< int I > spinlock spinlock_pool< I >::pool_[ 41 ] =
{
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}
};

}
}
# 37 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/memory_order.hpp" 1
# 21 "/home/marek/devel/nupic/external/common/include/boost/memory_order.hpp"
namespace boost
{
# 41 "/home/marek/devel/nupic/external/common/include/boost/memory_order.hpp"
enum memory_order
{
    memory_order_relaxed = 0,
    memory_order_acquire = 1,
    memory_order_release = 2,
    memory_order_acq_rel = 3,
    memory_order_seq_cst = 7,
    memory_order_consume = 8
};

}
# 38 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp" 2



# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/algorithm" 1 3
# 59 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/algorithm" 3



# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 1 3
# 59 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdlib" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdlib" 3
# 60 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/algorithmfwd.h" 1 3
# 34 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/algorithmfwd.h" 3








namespace std __attribute__ ((__visibility__ ("default")))
{
# 203 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/algorithmfwd.h" 3
  template<typename _FIter, typename _Tp>
    bool
    binary_search(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    bool
    binary_search(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _IIter, typename _OIter>
    _OIter
    copy(_IIter, _IIter, _OIter);

  template<typename _BIter1, typename _BIter2>
    _BIter2
    copy_backward(_BIter1, _BIter1, _BIter2);
# 232 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/algorithmfwd.h" 3
  template<typename _FIter, typename _Tp>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _FIter, typename _Tp>
    void
    fill(_FIter, _FIter, const _Tp&);

  template<typename _OIter, typename _Size, typename _Tp>
    _OIter
    fill_n(_OIter, _Size, const _Tp&);



  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);
# 271 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/algorithmfwd.h" 3
  template<typename _IIter1, typename _IIter2>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _BIter>
    void
    inplace_merge(_BIter, _BIter, _BIter);

  template<typename _BIter, typename _Compare>
    void
    inplace_merge(_BIter, _BIter, _BIter, _Compare);
# 334 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/algorithmfwd.h" 3
  template<typename _FIter1, typename _FIter2>
    void
    iter_swap(_FIter1, _FIter2);

  template<typename _FIter, typename _Tp>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _RAIter>
    void
    make_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    make_heap(_RAIter, _RAIter, _Compare);

  template<typename _Tp>
    const _Tp&
    max(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    const _Tp&
    max(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    const _Tp&
    min(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    const _Tp&
    min(const _Tp&, const _Tp&, _Compare);
# 419 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/algorithmfwd.h" 3
  template<typename _BIter>
    bool
    next_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    next_permutation(_BIter, _BIter, _Compare);
# 436 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/algorithmfwd.h" 3
  template<typename _IIter, typename _RAIter>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);

  template<typename _IIter, typename _RAIter, typename _Compare>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);
# 457 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/algorithmfwd.h" 3
  template<typename _RAIter>
    void
    pop_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    pop_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter>
    bool
    prev_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    prev_permutation(_BIter, _BIter, _Compare);

  template<typename _RAIter>
    void
    push_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    push_heap(_RAIter, _RAIter, _Compare);



  template<typename _FIter, typename _Tp>
    _FIter
    remove(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Predicate>
    _FIter
    remove_if(_FIter, _FIter, _Predicate);

  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    remove_copy(_IIter, _IIter, _OIter, const _Tp&);

  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);



  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&);

  template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp>
    _OIter
    replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp&);



  template<typename _BIter>
    void
    reverse(_BIter, _BIter);

  template<typename _BIter, typename _OIter>
    _OIter
    reverse_copy(_BIter, _BIter, _OIter);

  template<typename _FIter>
    void
    rotate(_FIter, _FIter, _FIter);

  template<typename _FIter, typename _OIter>
    _OIter
    rotate_copy(_FIter, _FIter, _FIter, _OIter);
# 540 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/algorithmfwd.h" 3
  template<typename _RAIter>
    void
    sort_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    stable_partition(_BIter, _BIter, _Predicate);

  template<typename _Tp>
    void
    swap(_Tp&, _Tp&)




    ;

  template<typename _Tp, size_t _Nm>
    void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])



    ;

  template<typename _FIter1, typename _FIter2>
    _FIter2
    swap_ranges(_FIter1, _FIter1, _FIter2);



  template<typename _FIter>
    _FIter
    unique(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    unique(_FIter, _FIter, _BinaryPredicate);



  template<typename _FIter, typename _Tp>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&, _Compare);





  template<typename _FIter>
    _FIter
    adjacent_find(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    adjacent_find(_FIter, _FIter, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    typename iterator_traits<_IIter>::difference_type
    count(_IIter, _IIter, const _Tp&);

  template<typename _IIter, typename _Predicate>
    typename iterator_traits<_IIter>::difference_type
    count_if(_IIter, _IIter, _Predicate);

  template<typename _IIter1, typename _IIter2>
    bool
    equal(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    bool
    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    _IIter
    find(_IIter, _IIter, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _IIter, typename _Predicate>
    _IIter
    find_if(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Funct>
    _Funct
    for_each(_IIter, _IIter, _Funct);

  template<typename _FIter, typename _Generator>
    void
    generate(_FIter, _FIter, _Generator);

  template<typename _OIter, typename _Size, typename _Generator>
    _OIter
    generate_n(_OIter, _Size, _Generator);

  template<typename _IIter1, typename _IIter2>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _FIter>
    _FIter
    max_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    max_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _FIter>
    _FIter
    min_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    min_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _RAIter>
    void
    nth_element(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    nth_element(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    partial_sort(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    partition(_BIter, _BIter, _Predicate);

  template<typename _RAIter>
    void
    random_shuffle(_RAIter, _RAIter);

  template<typename _RAIter, typename _Generator>
    void
    random_shuffle(_RAIter, _RAIter,



     _Generator&);


  template<typename _FIter, typename _Tp>
    void
    replace(_FIter, _FIter, const _Tp&, const _Tp&);

  template<typename _FIter, typename _Predicate, typename _Tp>
    void
    replace_if(_FIter, _FIter, _Predicate, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _FIter, typename _Size, typename _Tp>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&);

  template<typename _FIter, typename _Size, typename _Tp,
    typename _BinaryPredicate>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&, _BinaryPredicate);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2,
        _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _RAIter>
    void
    sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    stable_sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    stable_sort(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _OIter, typename _UnaryOperation>
    _OIter
    transform(_IIter, _IIter, _OIter, _UnaryOperation);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _BinaryOperation>
    _OIter
    transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);

  template<typename _IIter, typename _OIter>
    _OIter
    unique_copy(_IIter, _IIter, _OIter);

  template<typename _IIter, typename _OIter, typename _BinaryPredicate>
    _OIter
    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);


}
# 61 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_heap.h" 1 3
# 61 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_heap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _RandomAccessIterator, typename _Distance>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__first[__parent] < __first[__child])
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n,
      _Compare __comp)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first[__parent], __first[__child]))
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }



  template<typename _RandomAccessIterator, typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    { return std::__is_heap_until(__first, __n) == __n; }

  template<typename _RandomAccessIterator, typename _Compare,
    typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
    { return std::__is_heap_until(__first, __n, __comp) == __n; }

  template<typename _RandomAccessIterator>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }




  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && *(__first + __parent) < __value)
 {
   *(__first + __holeIndex) = (*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = (__value);
    }
# 154 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;





                                                     ;
                                                  ;

      _ValueType __value = (*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), (__value));
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
    typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
  _Distance __topIndex, _Tp __value, _Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex
      && __comp(*(__first + __parent), __value))
 {
   *(__first + __holeIndex) = (*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = (__value);
    }
# 204 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;




                                                     ;
                                                               ;

      _ValueType __value = (*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), (__value), __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = (*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = (*(__first + (__secondChild - 1)));

   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex,
         (__value));
    }

  template<typename _RandomAccessIterator>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = (*__result);
      *__result = (*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    (__value));
    }
# 279 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                         ;
                                                     ;
                                              ;

      if (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last);
 }
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (__comp(*(__first + __secondChild),
       *(__first + (__secondChild - 1))))
     __secondChild--;
   *(__first + __holeIndex) = (*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = (*(__first + (__secondChild - 1)));

   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex,
         (__value), __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = (*__result);
      *__result = (*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    (__value), __comp);
    }
# 357 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {



                                                     ;
                                                         ;
                                                           ;

      if (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 384 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;





                                                     ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = (*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, (__value));
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 424 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;




                                                     ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = (*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, (__value),
        __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 463 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;
                                              ;

      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last);
 }
    }
# 492 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {



                                                     ;
                                                           ;

      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 590 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_heap.h" 3
}
# 62 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 2 3
# 71 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Iterator>
    void
    __move_median_to_first(_Iterator __result, _Iterator __a,
      _Iterator __b, _Iterator __c)
    {




      if (*__a < *__b)
 {
   if (*__b < *__c)
     std::iter_swap(__result, __b);
   else if (*__a < *__c)
     std::iter_swap(__result, __c);
   else
     std::iter_swap(__result, __a);
 }
      else if (*__a < *__c)
       std::iter_swap(__result, __a);
      else if (*__b < *__c)
 std::iter_swap(__result, __c);
      else
 std::iter_swap(__result, __b);
    }


  template<typename _Iterator, typename _Compare>
    void
    __move_median_to_first(_Iterator __result, _Iterator __a,
      _Iterator __b, _Iterator __c,
      _Compare __comp)
    {





      if (__comp(*__a, *__b))
 {
   if (__comp(*__b, *__c))
     std::iter_swap(__result, __b);
   else if (__comp(*__a, *__c))
     std::iter_swap(__result, __c);
   else
     std::iter_swap(__result, __a);
 }
      else if (__comp(*__a, *__c))
 std::iter_swap(__result, __a);
      else if (__comp(*__b, *__c))
 std::iter_swap(__result, __c);
      else
 std::iter_swap(__result, __b);
    }




  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    __find(_InputIterator __first, _InputIterator __last,
    const _Tp& __val, input_iterator_tag)
    {
      while (__first != __last && !(*__first == __val))
 ++__first;
      return __first;
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !bool(__pred(*__first)))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __find(_RandomAccessIterator __first, _RandomAccessIterator __last,
    const _Tp& __val, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (*__first == __val)
     return __first;
   ++__first;
 case 2:
   if (*__first == __val)
     return __first;
   ++__first;
 case 1:
   if (*__first == __val)
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if_not(_InputIterator __first, _InputIterator __last,
    _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && bool(__pred(*__first)))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if_not(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (!bool(__pred(*__first)))
     return __first;
   ++__first;

   if (!bool(__pred(*__first)))
     return __first;
   ++__first;

   if (!bool(__pred(*__first)))
     return __first;
   ++__first;

   if (!bool(__pred(*__first)))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (!bool(__pred(*__first)))
     return __first;
   ++__first;
 case 2:
   if (!bool(__pred(*__first)))
     return __first;
   ++__first;
 case 1:
   if (!bool(__pred(*__first)))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if_not(_InputIterator __first, _InputIterator __last,
    _Predicate __pred)
    {
      return std::__find_if_not(__first, __last, __pred,
    std::__iterator_category(__first));
    }




  template<typename _InputIterator, typename _Predicate, typename _Distance>
    _InputIterator
    __find_if_not_n(_InputIterator __first, _Distance& __len, _Predicate __pred)
    {
      for (; __len; --__len, ++__first)
 if (!bool(__pred(*__first)))
   break;
      return __first;
    }
# 351 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        std::forward_iterator_tag)
    {
      __first = std::find(__first, __last, __val);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && *__i == __val)
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::find(++__i, __last, __val);
 }
      return __last;
    }






  template<typename _RandomAccessIter, typename _Integer, typename _Tp>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        std::random_access_iterator_tag)
    {

      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      _DistanceType __remainder = __count;

      while (__remainder <= __tailSize)
 {
   __first += __remainder;
   __tailSize -= __remainder;


   _RandomAccessIter __backTrack = __first;
   while (*--__backTrack == __val)
     {
       if (--__remainder == 0)
         return (__first - __count);
     }
   __remainder = __count + 1 - (__first - __backTrack);
 }
      return __last;
    }
# 421 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::forward_iterator_tag)
    {
      while (__first != __last && !bool(__binary_pred(*__first, __val)))
        ++__first;

      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && bool(__binary_pred(*__i, __val)))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = ++__i;
   while (__first != __last
   && !bool(__binary_pred(*__first, __val)))
     ++__first;
 }
      return __last;
    }







  template<typename _RandomAccessIter, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::random_access_iterator_tag)
    {

      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      _DistanceType __remainder = __count;

      while (__remainder <= __tailSize)
 {
   __first += __remainder;
   __tailSize -= __remainder;


   _RandomAccessIter __backTrack = __first;
   while (__binary_pred(*--__backTrack, __val))
     {
       if (--__remainder == 0)
         return (__first - __count);
     }
   __remainder = __count + 1 - (__first - __backTrack);
 }
      return __last;
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2, __last2);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2,
      __last2, __comp);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag)
    {






      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1),
             __rlast1,
             _RevIterator2(__last2),
             __rlast2);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }

  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {






      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
         _RevIterator2(__last2), __rlast2,
         __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
# 645 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {






                                                       ;
                                                       ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2));
    }
# 692 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {






                                                       ;
                                                       ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __comp);
    }
# 871 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {






                                                     ;

      for (; __first != __last; ++__first)
 if (!(*__first == __value))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 908 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {






                                                     ;

      for (; __first != __last; ++__first)
 if (!bool(__pred(*__first)))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 1089 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {





                                                     ;

      __first = std::find(__first, __last, __value);
      if(__first == __last)
        return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for(; __first != __last; ++__first)
        if(!(*__first == __value))
          {
            *__result = (*__first);
            ++__result;
          }
      return __result;
    }
# 1132 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      __first = std::find_if(__first, __last, __pred);
      if(__first == __last)
        return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for(; __first != __last; ++__first)
        if(!bool(__pred(*__first)))
          {
            *__result = (*__first);
            ++__result;
          }
      return __result;
    }
# 1172 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {





                                                     ;


      __first = std::adjacent_find(__first, __last);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!(*__dest == *__first))
   *++__dest = (*__first);
      return ++__dest;
    }
# 1212 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
           _BinaryPredicate __binary_pred)
    {






                                                     ;


      __first = std::adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!bool(__binary_pred(*__dest, *__first)))
   *++__dest = (*__first);
      return ++__dest;
    }






  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result,
    forward_iterator_tag, output_iterator_tag)
    {

      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!(*__first == *__next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }






  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result,
    input_iterator_tag, output_iterator_tag)
    {

      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!(__value == *__first))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }






  template<typename _InputIterator, typename _ForwardIterator>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result,
    input_iterator_tag, forward_iterator_tag)
    {

      *__result = *__first;
      while (++__first != __last)
 if (!(*__result == *__first))
   *++__result = *__first;
      return ++__result;
    }







  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {





      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!bool(__binary_pred(*__first, *__next)))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {





      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!bool(__binary_pred(__value, *__first)))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {





      *__result = *__first;
      while (++__first != __last)
 if (!bool(__binary_pred(*__result, *__first)))
   *++__result = *__first;
      return ++__result;
    }






  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }






  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
# 1440 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {



                                                     ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
# 1467 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
   _OutputIterator __result)
    {





                                                     ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }





  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }


  template<typename _ForwardIterator>
    void
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle || __last == __middle)
 return;

      _ForwardIterator __first2 = __middle;
      do
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      __first2 = __middle;

      while (__first2 != __last)
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
    }


  template<typename _BidirectionalIterator>
    void
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {




      if (__first == __middle || __last == __middle)
 return;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 {
   std::iter_swap(__first, --__last);
   ++__first;
 }

      if (__first == __middle)
 std::__reverse(__middle, __last, bidirectional_iterator_tag());
      else
 std::__reverse(__first, __middle, bidirectional_iterator_tag());
    }


  template<typename _RandomAccessIterator>
    void
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {




      if (__first == __middle || __last == __middle)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      _Distance __n = __last - __first;
      _Distance __k = __middle - __first;

      if (__k == __n - __k)
 {
   std::swap_ranges(__first, __middle, __middle);
   return;
 }

      _RandomAccessIterator __p = __first;

      for (;;)
 {
   if (__k < __n - __k)
     {
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = (*__p);
    std::copy(__p + 1, __p + __n, __p);
    *(__p + __n - 1) = (__t);
    return;
  }
       _RandomAccessIterator __q = __p + __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    std::iter_swap(__p, __q);
    ++__p;
    ++__q;
  }
       __n %= __k;
       if (__n == 0)
  return;
       std::swap(__n, __k);
       __k = __n - __k;
     }
   else
     {
       __k = __n - __k;
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = (*(__p + __n - 1));
    std::copy_backward(__p, __p + __n - 1, __p + __n);
    *__p = (__t);
    return;
  }
       _RandomAccessIterator __q = __p + __n;
       __p = __q - __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    --__p;
    --__q;
    std::iter_swap(__p, __q);
  }
       __n %= __k;
       if (__n == 0)
  return;
       std::swap(__n, __k);
     }
 }
    }
# 1673 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline void
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {



                                                       ;
                                                      ;

      typedef typename iterator_traits<_ForwardIterator>::iterator_category
 _IterType;
      std::__rotate(__first, __middle, __last, _IterType());
    }
# 1709 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                _ForwardIterator __last, _OutputIterator __result)
    {




                                                       ;
                                                      ;

      return std::copy(__first, __middle,
                       std::copy(__middle, __last, __result));
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred, forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     std::iter_swap(__first, __next);
     ++__first;
   }

      return __first;
    }


  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred, bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!bool(__pred(*__last)))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }






  template<typename _ForwardIterator, typename _Predicate, typename _Distance>
    _ForwardIterator
    __inplace_stable_partition(_ForwardIterator __first,
          _Predicate __pred, _Distance __len)
    {
      if (__len == 1)
 return __first;
      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __left_split =
 std::__inplace_stable_partition(__first, __pred, __len / 2);


      _Distance __right_len = __len - __len / 2;
      _ForwardIterator __right_split =
 std::__find_if_not_n(__middle, __right_len, __pred);
      if (__right_len)
 __right_split = std::__inplace_stable_partition(__middle,
       __pred,
       __right_len);
      std::rotate(__left_split, __middle, __right_split);
      std::advance(__left_split, std::distance(__middle, __right_split));
      return __left_split;
    }







  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;



   *__result2 = (*__first);
   ++__result2;
   ++__first;
   for (; __first != __last; ++__first)
     if (__pred(*__first))
       {
  *__result1 = (*__first);
  ++__result1;
       }
     else
       {
  *__result2 = (*__first);
  ++__result2;
       }
   std::copy(__buffer, __result2, __result1);
   return __result1;
 }
      else
 {
   _ForwardIterator __middle = __first;
   std::advance(__middle, __len / 2);
   _ForwardIterator __left_split =
     std::__stable_partition_adaptive(__first, __middle, __pred,
          __len / 2, __buffer,
          __buffer_size);


   _Distance __right_len = __len - __len / 2;
   _ForwardIterator __right_split =
     std::__find_if_not_n(__middle, __right_len, __pred);
   if (__right_len)
     __right_split =
       std::__stable_partition_adaptive(__right_split, __last, __pred,
            __right_len,
            __buffer, __buffer_size);
   std::rotate(__left_split, __middle, __right_split);
   std::advance(__left_split, std::distance(__middle, __right_split));
   return __left_split;
 }
    }
# 1888 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      __first = std::__find_if_not(__first, __last, __pred);

      if (__first == __last)
 return __first;
      else
 {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;
   typedef typename iterator_traits<_ForwardIterator>::difference_type
     _DistanceType;

   _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first,
        __last);
 if (__buf.size() > 0)
   return
     std::__stable_partition_adaptive(__first, __last, __pred,
       _DistanceType(__buf.requested_size()),
       __buf.begin(),
       _DistanceType(__buf.size()));
 else
   return
     std::__inplace_stable_partition(__first, __pred,
      _DistanceType(__buf.requested_size()));
 }
    }


  template<typename _RandomAccessIterator>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last)
    {
      std::make_heap(__first, __middle);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (*__i < *__first)
   std::__pop_heap(__first, __middle, __i);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      std::make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(*__i, *__first))
   std::__pop_heap(__first, __middle, __i, __comp);
    }
# 1972 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
# 1992 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
                                                     ;
                                                                   ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last);
      while (__first != __last)
 {
   if (*__first < *__result_first)
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first));
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last);
      return __result_real_last;
    }
# 2038 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
# 2062 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
                                                     ;
                                                                   ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(*__first, *__result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first),
          __comp);
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }


  template<typename _RandomAccessIterator>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
 __val = (*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__val < *__next)
 {
   *__last = (*__next);
   __last = __next;
   --__next;
 }
      *__last = (__val);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last,
         _Compare __comp)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
 __val = (*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, *__next))
 {
   *__last = (*__next);
   __last = __next;
   --__next;
 }
      *__last = (__val);
    }


  template<typename _RandomAccessIterator>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last)
    {
      if (__first == __last)
 return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   if (*__i < *__first)
     {
       typename iterator_traits<_RandomAccessIterator>::value_type
  __val = (*__i);
       std::copy_backward(__first, __i, __i + 1);
       *__first = (__val);
     }
   else
     std::__unguarded_linear_insert(__i);
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   if (__comp(*__i, *__first))
     {
       typename iterator_traits<_RandomAccessIterator>::value_type
  __val = (*__i);
       std::copy_backward(__first, __i, __i + 1);
       *__first = (__val);
     }
   else
     std::__unguarded_linear_insert(__i, __comp);
 }
    }


  template<typename _RandomAccessIterator>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, __comp);
    }





  enum { _S_threshold = 16 };


  template<typename _RandomAccessIterator>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold));
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last);
 }
      else
 std::__insertion_sort(__first, __last);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }


  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last, const _Tp& __pivot)
    {
      while (true)
 {
   while (*__first < __pivot)
     ++__first;
   --__last;
   while (__pivot < *__last)
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     const _Tp& __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(*__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, *__last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator>
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
    _RandomAccessIterator __last)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_to_first(__first, __first + 1, __mid, (__last - 2));
      return std::__unguarded_partition(__first + 1, __last, *__first);
    }



  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
    _RandomAccessIterator __last, _Compare __comp)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_to_first(__first, __first + 1, __mid, (__last - 2),
      __comp);
      return std::__unguarded_partition(__first + 1, __last, *__first, __comp);
    }


  template<typename _RandomAccessIterator, typename _Size>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit)
    {
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last);
   std::__introsort_loop(__cut, __last, __depth_limit);
   __last = __cut;
 }
    }


  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }



  template<typename _RandomAccessIterator, typename _Size>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last);


       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
# 2423 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;






                    ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 2470 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;




                                                                  ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__val < *__middle)
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2519 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;






                    ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2572 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;





                                                                  ;
                                                                  ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__val < *__middle)
     __len = __half;
   else
     {
       _ForwardIterator __left = std::lower_bound(__first, __middle,
        __val);
       std::advance(__first, __len);
       _ForwardIterator __right = std::upper_bound(++__middle, __first,
         __val);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2634 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;
# 2651 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
                    ;

                    ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       _ForwardIterator __left = std::lower_bound(__first, __middle,
        __val, __comp);
       std::advance(__first, __len);
       _ForwardIterator __right = std::upper_bound(++__middle, __first,
         __val, __comp);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2695 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




                                                                  ;
                                                                  ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val);
      return __i != __last && !(__val < *__i);
    }
# 2728 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;






                    ;

                    ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val, __comp);
      return __i != __last && !bool(__comp(__val, *__i));
    }




  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    void
    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first2 < *__first1)
     {
       *__result = (*__first2);
       ++__first2;
     }
   else
     {
       *__result = (*__first1);
       ++__first1;
     }
   ++__result;
 }
      if (__first1 != __last1)
 std::copy(__first1, __last1, __result);
    }


  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    void
    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first2, *__first1))
     {
       *__result = (*__first2);
       ++__first2;
     }
   else
     {
       *__result = (*__first1);
       ++__first1;
     }
   ++__result;
 }
      if (__first1 != __last1)
 std::copy(__first1, __last1, __result);
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3>
    void
    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result)
    {
      if (__first1 == __last1)
 {
   std::copy_backward(__first2, __last2, __result);
   return;
 }
      else if (__first2 == __last2)
 return;

      --__last1;
      --__last2;
      while (true)
 {
   if (*__last2 < *__last1)
     {
       *--__result = (*__last1);
       if (__first1 == __last1)
  {
    std::copy_backward(__first2, ++__last2, __result);
    return;
  }
       --__last1;
     }
   else
     {
       *--__result = (*__last2);
       if (__first2 == __last2)
  return;
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    void
    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 {
   std::copy_backward(__first2, __last2, __result);
   return;
 }
      else if (__first2 == __last2)
 return;

      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(*__last2, *__last1))
     {
       *--__result = (*__last1);
       if (__first1 == __last1)
  {
    std::copy_backward(__first2, ++__last2, __result);
    return;
  }
       --__last1;
     }
   else
     {
       *--__result = (*__last2);
       if (__first2 == __last2)
  return;
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   if (__len2)
     {
       __buffer_end = std::copy(__middle, __last, __buffer);
       std::copy_backward(__first, __middle, __last);
       return std::copy(__buffer, __buffer_end, __first);
     }
   else
     return __first;
 }
      else if (__len1 <= __buffer_size)
 {
   if (__len1)
     {
       __buffer_end = std::copy(__first, __middle, __buffer);
       std::copy(__middle, __last, __first);
       return std::copy_backward(__buffer, __buffer_end, __last);
     }
   else
     return __last;
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
         __first);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__move_merge_adaptive_backward(__first, __middle, __buffer,
           __buffer_end, __last);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last,
           *__first_cut);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle,
          *__second_cut);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer, __buffer_size);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer, typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
         __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__move_merge_adaptive_backward(__first, __middle, __buffer,
           __buffer_end, __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last, *__first_cut,
           __comp);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle, *__second_cut,
          __comp);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (*__middle < *__first)
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22);
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
                           _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (__comp(*__middle, *__first))
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut,
       __comp);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut,
      __comp);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }
# 3152 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;





                                                  ;
                                                 ;

      if (__first == __middle || __middle == __last)
 return;

      _DistanceType __len1 = std::distance(__first, __middle);
      _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1, __len2);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()));
    }
# 3207 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;






                                                               ;
                                                              ;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1,
        __len2, __comp);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()),
         __comp);
    }



  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    __move_merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first2 < *__first1)
     {
       *__result = (*__first2);
       ++__first2;
     }
   else
     {
       *__result = (*__first1);
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));


    }


  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    __move_merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first2, *__first1))
     {
       *__result = (*__first2);
       ++__first2;
     }
   else
     {
       *__result = (*__first1);
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));


    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result,
        _Distance __step_size)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::__move_merge(__first, __first + __step_size,
           __first + __step_size,
           __first + __two_step, __result);
   __first += __two_step;
 }

      __step_size = std::min(_Distance(__last - __first), __step_size);
      std::__move_merge(__first, __first + __step_size,
   __first + __step_size, __last, __result);
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::__move_merge(__first, __first + __step_size,
           __first + __step_size,
           __first + __two_step,
           __result, __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::__move_merge(__first,__first + __step_size,
   __first + __step_size, __last, __result, __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Pointer>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer, __step_size);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle,
          __buffer, __buffer_size);
   std::__stable_sort_adaptive(__middle, __last,
          __buffer, __buffer_size);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer);
   std::__merge_sort_with_buffer(__middle, __last, __buffer);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size);
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size,
                           _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }


  template<typename _RandomAccessIterator>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle);
      std::__inplace_stable_sort(__middle, __last);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
# 3547 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;






                                                                ;
                                                                ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first2 < *__first1)
   return false;
 else if(*__first1 < *__first2)
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 3597 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 3616 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first2, *__first1))
   return false;
 else if(__comp(*__first1, *__first2))
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 3652 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {





                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__i < *__ii)
     {
       _BidirectionalIterator __j = __last;
       while (!(*__i < *--__j))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3709 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {






                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__i, *__ii))
     {
       _BidirectionalIterator __j = __last;
       while (!bool(__comp(*__i, *--__j)))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3765 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {





                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__ii < *__i)
     {
       _BidirectionalIterator __j = __last;
       while (!(*--__j < *__i))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3822 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {






                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__ii, *__i))
     {
       _BidirectionalIterator __j = __last;
       while (!bool(__comp(*--__j, *__i)))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3882 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {






                                                     ;

      for (; __first != __last; ++__first, ++__result)
 if (*__first == __old_value)
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 3919 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {






                                                     ;

      for (; __first != __last; ++__first, ++__result)
 if (__pred(*__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 4409 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {


                                                     ;
      for (; __first != __last; ++__first)
 __f(*__first);
      return (__f);
    }
# 4430 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {




                                                     ;
      return std::__find(__first, __last, __val,
           std::__iterator_category(__first));
    }
# 4454 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {




                                                     ;
      return std::__find_if(__first, __last, __pred,
       std::__iterator_category(__first));
    }
# 4484 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {






                                                       ;
                                                       ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
# 4524 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {






                                                       ;
                                                       ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
# 4556 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (*__first == *__next)
     return __first;
   __first = __next;
 }
      return __last;
    }
# 4588 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {





                                                     ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (__binary_pred(*__first, *__next))
     return __first;
   __first = __next;
 }
      return __last;
    }
# 4620 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {




                                                     ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (*__first == __value)
   ++__n;
      return __n;
    }
# 4645 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {




                                                     ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(*__first))
   ++__n;
      return __n;
    }
# 4687 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {






                                                       ;
                                                       ;


      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::find(__first1, __last1, *__first2);


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 = std::find(__first1, __last1, *__first2);
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (*__current == *__p)
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 4758 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {






                                                       ;
                                                       ;


      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 {
   while (__first1 != __last1
   && !bool(__predicate(*__first1, *__first2)))
     ++__first1;
   return __first1;
 }


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   while (__first1 != __last1
   && !bool(__predicate(*__first1, *__first2)))
     ++__first1;
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(*__current, *__p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 4833 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {




                                                     ;

      if (__count <= 0)
 return __first;
      if (__count == 1)
 return std::find(__first, __last, __val);
      return std::__search_n(__first, __last, __count, __val,
        std::__iterator_category(__first));
    }
# 4870 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {




                                                     ;

      if (__count <= 0)
 return __first;
      if (__count == 1)
 {
   while (__first != __last && !bool(__binary_pred(*__first, __val)))
     ++__first;
   return __first;
 }
      return std::__search_n(__first, __last, __count, __val, __binary_pred,
        std::__iterator_category(__first));
    }
# 4912 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {





                                                     ;

      for (; __first != __last; ++__first, ++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
# 4949 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {






                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 4982 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {







                                                     ;

      for (; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
# 5014 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {







                                                     ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
# 5046 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {




                                                     ;

      for (; __first != __last; ++__first)
 *__first = __gen();
    }
# 5077 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {





      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __gen();
      return __first;
    }
# 5114 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {






                                                     ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 5153 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {




                                                     ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result, __binary_pred,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 5185 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {



                                                     ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   std::iter_swap(__i, __first + (std::rand() % ((__i - __first) + 1)));
    }
# 5213 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,



     _RandomNumberGenerator& __rand)

    {



                                                     ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __rand((__i - __first) + 1));
    }
# 5249 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }
# 5283 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                       ;
                                                      ;

      std::__heap_select(__first, __middle, __last);
      std::sort_heap(__first, __middle);
    }
# 5322 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;






                                                       ;
                                                      ;

      std::__heap_select(__first, __middle, __last, __comp);
      std::sort_heap(__first, __middle, __comp);
    }
# 5359 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                    ;
                                                   ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2);
    }
# 5398 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;






                                                    ;
                                                   ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2, __comp);
    }
# 5436 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                     ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2);
   std::__final_insertion_sort(__first, __last);
 }
    }
# 5472 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;






                                                     ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2, __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }
# 5514 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5534 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
                                                                ;
                                                                ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5578 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5599 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5638 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;





                                                     ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()));
    }
# 5680 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;







                                                     ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }
# 5726 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5747 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
                                                                ;
                                                                ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first1 < *__first2)
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5793 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5816 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first1, *__first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5860 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5879 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
                                                                ;
                                                                ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   ++__first1;
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5917 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5938 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   ++__first1;
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5975 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5994 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
                                                                ;
                                                                ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 6036 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 6057 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 6094 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 6115 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
                                                                ;
                                                                ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2, std::copy(__first1,
          __last1, __result));
    }
# 6160 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 6184 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 6217 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__first < *__result)
   __result = __first;
      return __result;
    }
# 6245 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {





                                                     ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__first, *__result))
   __result = __first;
      return __result;
    }
# 6273 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__result < *__first)
   __result = __first;
      return __result;
    }
# 6301 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {





                                                     ;

      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__result, *__first))
   __result = __first;
      return __result;
    }


}
# 63 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/algorithm" 2 3
# 41 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp" 2



# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 2 3
# 44 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp" 2
# 54 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp"
namespace boost
{

template<class T> class shared_ptr;
template<class T> class weak_ptr;
template<class T> class enable_shared_from_this;
template<class T> class enable_shared_from_this2;

namespace detail
{

struct static_cast_tag {};
struct const_cast_tag {};
struct dynamic_cast_tag {};
struct polymorphic_cast_tag {};

template<class T> struct shared_ptr_traits
{
    typedef T & reference;
};

template<> struct shared_ptr_traits<void>
{
    typedef void reference;
};



template<> struct shared_ptr_traits<void const>
{
    typedef void reference;
};

template<> struct shared_ptr_traits<void volatile>
{
    typedef void reference;
};

template<> struct shared_ptr_traits<void const volatile>
{
    typedef void reference;
};





template< class X, class Y, class T > inline void sp_enable_shared_from_this( boost::shared_ptr<X> const * ppx, Y const * py, boost::enable_shared_from_this< T > const * pe )
{
    if( pe != 0 )
    {
        pe->_internal_accept_owner( ppx, const_cast< Y* >( py ) );
    }
}

template< class X, class Y, class T > inline void sp_enable_shared_from_this( boost::shared_ptr<X> * ppx, Y const * py, boost::enable_shared_from_this2< T > const * pe )
{
    if( pe != 0 )
    {
        pe->_internal_accept_owner( ppx, const_cast< Y* >( py ) );
    }
}
# 132 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp"
inline void sp_enable_shared_from_this( ... )
{
}







template< class T, class R > struct sp_enable_if_auto_ptr
{
};

template< class T, class R > struct sp_enable_if_auto_ptr< std::auto_ptr< T >, R >
{
    typedef R type;
};



}
# 164 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp"
template<class T> class shared_ptr
{
private:


    typedef shared_ptr<T> this_type;

public:

    typedef T element_type;
    typedef T value_type;
    typedef T * pointer;
    typedef typename boost::detail::shared_ptr_traits<T>::reference reference;

    shared_ptr(): px(0), pn()
    {
    }

    template<class Y>
    explicit shared_ptr( Y * p ): px( p ), pn( p )
    {
        boost::detail::sp_enable_shared_from_this( this, p, p );
    }







    template<class Y, class D> shared_ptr(Y * p, D d): px(p), pn(p, d)
    {
        boost::detail::sp_enable_shared_from_this( this, p, p );
    }



    template<class Y, class D, class A> shared_ptr( Y * p, D d, A a ): px( p ), pn( p, d, a )
    {
        boost::detail::sp_enable_shared_from_this( this, p, p );
    }
# 218 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp"
    template<class Y>
    explicit shared_ptr(weak_ptr<Y> const & r): pn(r.pn)
    {

        px = r.px;
    }

    template<class Y>
    shared_ptr( weak_ptr<Y> const & r, boost::detail::sp_nothrow_tag ): px( 0 ), pn( r.pn, boost::detail::sp_nothrow_tag() )
    {
        if( !pn.empty() )
        {
            px = r.px;
        }
    }

    template<class Y>


    shared_ptr( shared_ptr<Y> const & r, typename boost::detail::sp_enable_if_convertible<Y,T>::type = boost::detail::sp_empty() )






    : px( r.px ), pn( r.pn )
    {
    }


    template< class Y >
    shared_ptr( shared_ptr<Y> const & r, T * p ): px( p ), pn( r.pn )
    {
    }

    template<class Y>
    shared_ptr(shared_ptr<Y> const & r, boost::detail::static_cast_tag): px(static_cast<element_type *>(r.px)), pn(r.pn)
    {
    }

    template<class Y>
    shared_ptr(shared_ptr<Y> const & r, boost::detail::const_cast_tag): px(const_cast<element_type *>(r.px)), pn(r.pn)
    {
    }

    template<class Y>
    shared_ptr(shared_ptr<Y> const & r, boost::detail::dynamic_cast_tag): px(dynamic_cast<element_type *>(r.px)), pn(r.pn)
    {
        if(px == 0)
        {
            pn = boost::detail::shared_count();
        }
    }

    template<class Y>
    shared_ptr(shared_ptr<Y> const & r, boost::detail::polymorphic_cast_tag): px(dynamic_cast<element_type *>(r.px)), pn(r.pn)
    {
        if(px == 0)
        {
            boost::throw_exception(std::bad_cast());
        }
    }



    template<class Y>
    explicit shared_ptr(std::auto_ptr<Y> & r): px(r.get()), pn()
    {
        Y * tmp = r.get();
        pn = boost::detail::shared_count(r);
        boost::detail::sp_enable_shared_from_this( this, tmp, tmp );
    }



    template<class Ap>
    explicit shared_ptr( Ap r, typename boost::detail::sp_enable_if_auto_ptr<Ap, int>::type = 0 ): px( r.get() ), pn()
    {
        typename Ap::element_type * tmp = r.get();
        pn = boost::detail::shared_count( r );
        boost::detail::sp_enable_shared_from_this( this, tmp, tmp );
    }
# 309 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp"
    shared_ptr & operator=( shared_ptr const & r )
    {
        this_type(r).swap(*this);
        return *this;
    }



    template<class Y>
    shared_ptr & operator=(shared_ptr<Y> const & r)
    {
        this_type(r).swap(*this);
        return *this;
    }





    template<class Y>
    shared_ptr & operator=( std::auto_ptr<Y> & r )
    {
        this_type(r).swap(*this);
        return *this;
    }



    template<class Ap>
    typename boost::detail::sp_enable_if_auto_ptr< Ap, shared_ptr & >::type operator=( Ap r )
    {
        this_type( r ).swap( *this );
        return *this;
    }
# 390 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp"
    void reset()
    {
        this_type().swap(*this);
    }

    template<class Y> void reset(Y * p)
    {
        ((p == 0 || p != px) ? static_cast<void> (0) : __assert_fail ("p == 0 || p != px", "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp", 397, __PRETTY_FUNCTION__));
        this_type(p).swap(*this);
    }

    template<class Y, class D> void reset( Y * p, D d )
    {
        this_type( p, d ).swap( *this );
    }

    template<class Y, class D, class A> void reset( Y * p, D d, A a )
    {
        this_type( p, d, a ).swap( *this );
    }

    template<class Y> void reset( shared_ptr<Y> const & r, T * p )
    {
        this_type( r, p ).swap( *this );
    }

    reference operator* () const
    {
        ((px != 0) ? static_cast<void> (0) : __assert_fail ("px != 0", "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp", 418, __PRETTY_FUNCTION__));
        return *px;
    }

    T * operator-> () const
    {
        ((px != 0) ? static_cast<void> (0) : __assert_fail ("px != 0", "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp", 424, __PRETTY_FUNCTION__));
        return px;
    }

    T * get() const
    {
        return px;
    }



# 1 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/operator_bool.hpp" 1
# 43 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/operator_bool.hpp"
    typedef T * this_type::*unspecified_bool_type;

    operator unspecified_bool_type() const
    {
        return px == 0? 0: &this_type::px;
    }




    bool operator! () const
    {
        return px == 0;
    }
# 434 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp" 2


    bool unique() const
    {
        return pn.unique();
    }

    long use_count() const
    {
        return pn.use_count();
    }

    void swap(shared_ptr<T> & other)
    {
        std::swap(px, other.px);
        pn.swap(other.pn);
    }

    template<class Y> bool owner_before( shared_ptr<Y> const & rhs ) const
    {
        return pn < rhs.pn;
    }

    template<class Y> bool owner_before( weak_ptr<Y> const & rhs ) const
    {
        return pn < rhs.pn;
    }

    void * _internal_get_deleter( boost::detail::sp_typeinfo const & ti ) const
    {
        return pn.get_deleter( ti );
    }

    bool _internal_equiv( shared_ptr const & r ) const
    {
        return px == r.px && pn == r.pn;
    }






private:

    template<class Y> friend class shared_ptr;
    template<class Y> friend class weak_ptr;




    T * px;
    boost::detail::shared_count pn;

};

template<class T, class U> inline bool operator==(shared_ptr<T> const & a, shared_ptr<U> const & b)
{
    return a.get() == b.get();
}

template<class T, class U> inline bool operator!=(shared_ptr<T> const & a, shared_ptr<U> const & b)
{
    return a.get() != b.get();
}
# 511 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp"
template<class T, class U> inline bool operator<(shared_ptr<T> const & a, shared_ptr<U> const & b)
{
    return a.owner_before( b );
}

template<class T> inline void swap(shared_ptr<T> & a, shared_ptr<T> & b)
{
    a.swap(b);
}

template<class T, class U> shared_ptr<T> static_pointer_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::static_cast_tag());
}

template<class T, class U> shared_ptr<T> const_pointer_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::const_cast_tag());
}

template<class T, class U> shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::dynamic_cast_tag());
}



template<class T, class U> shared_ptr<T> shared_static_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::static_cast_tag());
}

template<class T, class U> shared_ptr<T> shared_dynamic_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::dynamic_cast_tag());
}

template<class T, class U> shared_ptr<T> shared_polymorphic_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::polymorphic_cast_tag());
}

template<class T, class U> shared_ptr<T> shared_polymorphic_downcast(shared_ptr<U> const & r)
{
    ((dynamic_cast<T *>(r.get()) == r.get()) ? static_cast<void> (0) : __assert_fail ("dynamic_cast<T *>(r.get()) == r.get()", "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp", 555, __PRETTY_FUNCTION__));
    return shared_static_cast<T>(r);
}



template<class T> inline T * get_pointer(shared_ptr<T> const & p)
{
    return p.get();
}
# 588 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp"
template<class E, class T, class Y> std::basic_ostream<E, T> & operator<< (std::basic_ostream<E, T> & os, shared_ptr<Y> const & p)

{
    os << p.get();
    return os;
}
# 618 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_ptr.hpp"
template<class D, class T> D * get_deleter(shared_ptr<T> const & p)
{
    return static_cast<D *>(p._internal_get_deleter(typeid(D)));
}







template<class T> inline bool atomic_is_lock_free( shared_ptr<T> const * )
{
    return false;
}

template<class T> shared_ptr<T> atomic_load( shared_ptr<T> const * p )
{
    boost::detail::spinlock_pool<2>::scoped_lock lock( p );
    return *p;
}

template<class T> inline shared_ptr<T> atomic_load_explicit( shared_ptr<T> const * p, memory_order )
{
    return atomic_load( p );
}

template<class T> void atomic_store( shared_ptr<T> * p, shared_ptr<T> r )
{
    boost::detail::spinlock_pool<2>::scoped_lock lock( p );
    p->swap( r );
}

template<class T> inline void atomic_store_explicit( shared_ptr<T> * p, shared_ptr<T> r, memory_order )
{
    atomic_store( p, r );
}

template<class T> shared_ptr<T> atomic_exchange( shared_ptr<T> * p, shared_ptr<T> r )
{
    boost::detail::spinlock & sp = boost::detail::spinlock_pool<2>::spinlock_for( p );

    sp.lock();
    p->swap( r );
    sp.unlock();

    return r;
}

template<class T> shared_ptr<T> atomic_exchange_explicit( shared_ptr<T> * p, shared_ptr<T> r, memory_order )
{
    return atomic_exchange( p, r );
}

template<class T> bool atomic_compare_exchange( shared_ptr<T> * p, shared_ptr<T> * v, shared_ptr<T> w )
{
    boost::detail::spinlock & sp = boost::detail::spinlock_pool<2>::spinlock_for( p );

    sp.lock();

    if( p->_internal_equiv( *v ) )
    {
        p->swap( w );

        sp.unlock();

        return true;
    }
    else
    {
        shared_ptr<T> tmp( *p );

        sp.unlock();

        tmp.swap( *v );
        return false;
    }
}

template<class T> inline bool atomic_compare_exchange_explicit( shared_ptr<T> * p, shared_ptr<T> * v, shared_ptr<T> w, memory_order , memory_order )
{
    return atomic_compare_exchange( p, v, w );
}





template< class T > struct hash;

template< class T > std::size_t hash_value( boost::shared_ptr<T> const & p )
{
    return boost::hash< T* >()( p.get() );
}

}
# 17 "/home/marek/devel/nupic/external/common/include/boost/shared_ptr.hpp" 2
# 44 "/home/marek/devel/nupic/nta/ntypes/Value.hpp" 2

namespace nta
{
# 64 "/home/marek/devel/nupic/nta/ntypes/Value.hpp"
  class Value
  {
  public:
    Value(boost::shared_ptr<Scalar>& s);
    Value(boost::shared_ptr<Array>& a);
    Value(boost::shared_ptr<std::string>& s);

    enum Category {scalarCategory, arrayCategory, stringCategory};

    bool isArray() const;
    bool isString() const;
    bool isScalar() const;
    Category getCategory() const;

    NTA_BasicType getType() const;

    boost::shared_ptr<Scalar> getScalar() const;

    boost::shared_ptr<Array> getArray() const;

    boost::shared_ptr<std::string> getString() const;

    template <typename T> T getScalarT() const;

    const std::string getDescription() const;

  private:

    Value();
    Category category_;
    boost::shared_ptr<Scalar> scalar_;
    boost::shared_ptr<Array> array_;
    boost::shared_ptr<std::string> string_;
  };


  class ValueMap
  {
  public:
    ValueMap();
    ValueMap(const ValueMap& rhs);
    ~ValueMap();
    void add(const std::string& key, const Value& value);


    bool contains(const std::string& key) const;


    Value& getValue(const std::string& key) const;


    boost::shared_ptr<Array> getArray(const std::string& key) const;
    boost::shared_ptr<Scalar> getScalar(const std::string& key) const;
    boost::shared_ptr<std::string> getString(const std::string& key) const;




    template <typename T> T getScalarT(const std::string& key, T defaultValue) const;


    template <typename T> T getScalarT(const std::string& key) const;

    void dump() const;

    typedef std::map<std::string, Value*>::const_iterator const_iterator;
    const_iterator begin() const;
    const_iterator end() const;

  private:


    typedef std::map<std::string, Value*>::iterator iterator;
    std::map<std::string, Value*> map_;
  };


}
# 34 "/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.hpp" 2

# 1 "/home/marek/devel/nupic/nta/ntypes/ArrayRef.hpp" 1
# 38 "/home/marek/devel/nupic/nta/ntypes/ArrayRef.hpp"
namespace nta
{
  class ArrayRef : public ArrayBase
  {
  public:
    ArrayRef(NTA_BasicType type, void * buffer, size_t count) : ArrayBase(type)
    {
      setBuffer(buffer, count);
    }

    explicit ArrayRef(NTA_BasicType type) : ArrayBase(type)
    {
    }

    ArrayRef(const ArrayRef & other) : ArrayBase(other)
    {
    }

    void invariant()
    {
      if (own_)
        throw nta::LoggingException("/home/marek/devel/nupic/nta/ntypes/ArrayRef.hpp", 59) << "ArrayRef mmust not own its buffer";
    }
  private:

    void allocateBuffer(void * buffer, size_t count);
  };
}
# 36 "/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.hpp" 2
# 1 "/home/marek/devel/nupic/nta/utils/Random.hpp" 1
# 29 "/home/marek/devel/nupic/nta/utils/Random.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdlib" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdlib" 3
# 30 "/home/marek/devel/nupic/nta/utils/Random.hpp" 2






typedef NTA_UInt64 (*RandomSeedFuncPtr)();

namespace nta {
# 74 "/home/marek/devel/nupic/nta/utils/Random.hpp"
  class RandomImpl;

  class Random
  {
  public:




    static RandomSeedFuncPtr getSeeder();

    Random(UInt64 seed = 0);





    Random(const Random&);
    Random& operator=(const Random&);
    ~Random();


    UInt32 getUInt32(UInt32 max = MAX32);
    UInt64 getUInt64(UInt64 max = MAX64);

    Real64 getReal64();


    UInt32 operator()(UInt32 n = MAX32) { return getUInt32(n); }


    UInt64 getSeed() {return seed_;}


    typedef UInt32 argument_type;
    typedef UInt32 result_type;
    result_type max() { return MAX32; }
    result_type min() { return 0; }

    static const UInt32 MAX32;
    static const UInt64 MAX64;



    static void initSeeder(const RandomSeedFuncPtr r);

    static void shutdown();

  protected:



    static Random *theInstanceP_;




    static RandomSeedFuncPtr seeder_;

    void reseed(UInt64 seed);

    RandomImpl *impl_;
    UInt64 seed_;

    friend class RandomTest;
    friend std::ostream& operator<<(std::ostream&, const Random&);
    friend std::istream& operator>>(std::istream&, Random&);
    friend NTA_UInt64 GetRandomSeed();

  };


  std::ostream& operator<<(std::ostream&, const Random&);
  std::istream& operator>>(std::istream&, Random&);







  NTA_UInt64 GetRandomSeed();


}
# 37 "/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.hpp" 2
# 1 "/home/marek/devel/nupic/nta/algorithms/SparsePooler.hpp" 1
# 34 "/home/marek/devel/nupic/nta/algorithms/SparsePooler.hpp"
# 1 "/home/marek/devel/nupic/nta/utils/Random.hpp" 1
# 29 "/home/marek/devel/nupic/nta/utils/Random.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdlib" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdlib" 3
# 30 "/home/marek/devel/nupic/nta/utils/Random.hpp" 2
# 35 "/home/marek/devel/nupic/nta/algorithms/SparsePooler.hpp" 2

# 1 "/home/marek/devel/nupic/nta/math/stl_io.hpp" 1
# 32 "/home/marek/devel/nupic/nta/math/stl_io.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/list" 1 3
# 59 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/list" 3




# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 1 3
# 64 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
  namespace __detail
  {
# 77 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
    struct _List_node_base
    {
      _List_node_base* _M_next;
      _List_node_base* _M_prev;

      static void
      swap(_List_node_base& __x, _List_node_base& __y) throw();

      void
      _M_transfer(_List_node_base* const __first,
    _List_node_base* const __last) throw();

      void
      _M_reverse() throw();

      void
      _M_hook(_List_node_base* const __position) throw();

      void
      _M_unhook() throw();
    };


  }




  template<typename _Tp>
    struct _List_node : public __detail::_List_node_base
    {

      _Tp _M_data;







    };






  template<typename _Tp>
    struct _List_iterator
    {
      typedef _List_iterator<_Tp> _Self;
      typedef _List_node<_Tp> _Node;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;

      _List_iterator()
      : _M_node() { }

      explicit
      _List_iterator(__detail::_List_node_base* __x)
      : _M_node(__x) { }


      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const
      { return std::__addressof(static_cast<_Node*>(_M_node)->_M_data); }

      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }


      __detail::_List_node_base* _M_node;
    };






  template<typename _Tp>
    struct _List_const_iterator
    {
      typedef _List_const_iterator<_Tp> _Self;
      typedef const _List_node<_Tp> _Node;
      typedef _List_iterator<_Tp> iterator;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;

      _List_const_iterator()
      : _M_node() { }

      explicit
      _List_const_iterator(const __detail::_List_node_base* __x)
      : _M_node(__x) { }

      _List_const_iterator(const iterator& __x)
      : _M_node(__x._M_node) { }



      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const
      { return std::__addressof(static_cast<_Node*>(_M_node)->_M_data); }

      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }


      const __detail::_List_node_base* _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _List_iterator<_Val>& __x,
        const _List_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _List_iterator<_Val>& __x,
               const _List_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }



  template<typename _Tp, typename _Alloc>
    class _List_base
    {
    protected:
# 305 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      typedef typename _Alloc::template rebind<_List_node<_Tp> >::other
        _Node_alloc_type;

      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _List_impl
      : public _Node_alloc_type
      {
 __detail::_List_node_base _M_node;

 _List_impl()
 : _Node_alloc_type(), _M_node()
 { }

 _List_impl(const _Node_alloc_type& __a)
 : _Node_alloc_type(__a), _M_node()
 { }






      };

      _List_impl _M_impl;

      _List_node<_Tp>*
      _M_get_node()
      { return _M_impl._Node_alloc_type::allocate(1); }

      void
      _M_put_node(_List_node<_Tp>* __p)
      { _M_impl._Node_alloc_type::deallocate(__p, 1); }

  public:
      typedef _Alloc allocator_type;

      _Node_alloc_type&
      _M_get_Node_allocator()
      { return *static_cast<_Node_alloc_type*>(&_M_impl); }

      const _Node_alloc_type&
      _M_get_Node_allocator() const
      { return *static_cast<const _Node_alloc_type*>(&_M_impl); }

      _Tp_alloc_type
      _M_get_Tp_allocator() const
      { return _Tp_alloc_type(_M_get_Node_allocator()); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Node_allocator()); }

      _List_base()
      : _M_impl()
      { _M_init(); }

      _List_base(const _Node_alloc_type& __a)
      : _M_impl(__a)
      { _M_init(); }
# 377 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      ~_List_base()
      { _M_clear(); }

      void
      _M_clear();

      void
      _M_init()
      {
        this->_M_impl._M_node._M_next = &this->_M_impl._M_node;
        this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;
      }
    };
# 437 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class list : protected _List_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;



      typedef _List_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef typename _Base::_Node_alloc_type _Node_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef _List_iterator<_Tp> iterator;
      typedef _List_const_iterator<_Tp> const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:


      typedef _List_node<_Tp> _Node;

      using _Base::_M_impl;
      using _Base::_M_put_node;
      using _Base::_M_get_node;
      using _Base::_M_get_Tp_allocator;
      using _Base::_M_get_Node_allocator;
# 481 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      _Node*
      _M_create_node(const value_type& __x)
      {
 _Node* __p = this->_M_get_node();
 try
   {
     _M_get_Tp_allocator().construct
       (std::__addressof(__p->_M_data), __x);
   }
 catch(...)
   {
     _M_put_node(__p);
     throw;
   }
 return __p;
      }
# 517 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
    public:





      list()
      : _Base() { }





      explicit
      list(const allocator_type& __a)
      : _Base(_Node_alloc_type(__a)) { }
# 568 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      explicit
      list(size_type __n, const value_type& __value = value_type(),
    const allocator_type& __a = allocator_type())
      : _Base(_Node_alloc_type(__a))
      { _M_fill_initialize(__n, __value); }
# 582 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      list(const list& __x)
      : _Base(__x._M_get_Node_allocator())
      { _M_initialize_dispatch(__x.begin(), __x.end(), __false_type()); }
# 629 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      template<typename _InputIterator>
        list(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
 : _Base(_Node_alloc_type(__a))
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }
# 655 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      list&
      operator=(const list& __x);
# 701 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 724 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
# 748 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }






      iterator
      begin()
      { return iterator(this->_M_impl._M_node._M_next); }






      const_iterator
      begin() const
      { return const_iterator(this->_M_impl._M_node._M_next); }






      iterator
      end()
      { return iterator(&this->_M_impl._M_node); }






      const_iterator
      end() const
      { return const_iterator(&this->_M_impl._M_node); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }
# 867 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      bool
      empty() const
      { return this->_M_impl._M_node._M_next == &this->_M_impl._M_node; }


      size_type
      size() const
      { return std::distance(begin(), end()); }


      size_type
      max_size() const
      { return _M_get_Node_allocator().max_size(); }
# 917 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type());







      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 973 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      void
      push_front(const value_type& __x)
      { this->_M_insert(begin(), __x); }
# 1000 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      void
      pop_front()
      { this->_M_erase(begin()); }
# 1014 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      void
      push_back(const value_type& __x)
      { this->_M_insert(end(), __x); }
# 1040 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      void
      pop_back()
      { this->_M_erase(iterator(this->_M_impl._M_node._M_prev)); }
# 1073 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 1122 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      {
 list __tmp(__n, __x, get_allocator());
 splice(__position, __tmp);
      }
# 1146 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      template<typename _InputIterator>

        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {
   list __tmp(__first, __last, get_allocator());
   splice(__position, __tmp);
 }
# 1171 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      iterator
      erase(iterator __position);
# 1192 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      iterator
      erase(iterator __first, iterator __last)
      {
 while (__first != __last)
   __first = erase(__first);
 return __last;
      }
# 1209 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      void
      swap(list& __x)
      {
 __detail::_List_node_base::swap(this->_M_impl._M_node,
     __x._M_impl._M_node);



 std::__alloc_swap<typename _Base::_Node_alloc_type>::
   _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator());
      }







      void
      clear()
      {
        _Base::_M_clear();
        _Base::_M_init();
      }
# 1246 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      void



      splice(iterator __position, list& __x)

      {
 if (!__x.empty())
   {
     _M_check_equal_allocators(__x);

     this->_M_transfer(__position, __x.begin(), __x.end());
   }
      }
# 1276 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      void



      splice(iterator __position, list& __x, iterator __i)

      {
 iterator __j = __i;
 ++__j;
 if (__position == __i || __position == __j)
   return;

 if (this != &__x)
   _M_check_equal_allocators(__x);

 this->_M_transfer(__position, __i, __j);
      }
# 1312 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      void




      splice(iterator __position, list& __x, iterator __first,
      iterator __last)

      {
 if (__first != __last)
   {
     if (this != &__x)
       _M_check_equal_allocators(__x);

     this->_M_transfer(__position, __first, __last);
   }
      }
# 1347 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      void
      remove(const _Tp& __value);
# 1361 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      template<typename _Predicate>
        void
        remove_if(_Predicate);
# 1375 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      void
      unique();
# 1390 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      template<typename _BinaryPredicate>
        void
        unique(_BinaryPredicate);
# 1411 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      void
      merge(list& __x);
# 1438 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      template<typename _StrictWeakOrdering>
        void
        merge(list& __x, _StrictWeakOrdering __comp);







      void
      reverse()
      { this->_M_impl._M_node._M_reverse(); }







      void
      sort();







      template<typename _StrictWeakOrdering>
        void
        sort(_StrictWeakOrdering);

    protected:






      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        { _M_fill_initialize(static_cast<size_type>(__n), __x); }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   for (; __first != __last; ++__first)



     push_back(*__first);

 }



      void
      _M_fill_initialize(size_type __n, const value_type& __x)
      {
 for (; __n; --__n)
   push_back(__x);
      }
# 1526 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type);



      void
      _M_fill_assign(size_type __n, const value_type& __val);



      void
      _M_transfer(iterator __position, iterator __first, iterator __last)
      { __position._M_node->_M_transfer(__first._M_node, __last._M_node); }



      void
      _M_insert(iterator __position, const value_type& __x)
      {
        _Node* __tmp = _M_create_node(__x);
        __tmp->_M_hook(__position._M_node);
      }
# 1567 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
      void
      _M_erase(iterator __position)
      {
        __position._M_node->_M_unhook();
        _Node* __n = static_cast<_Node*>(__position._M_node);



 _M_get_Tp_allocator().destroy(std::__addressof(__n->_M_data));

        _M_put_node(__n);
      }


      void
      _M_check_equal_allocators(list& __x)
      {
 if (std::__alloc_neq<typename _Base::_Node_alloc_type>::
     _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator()))
   __throw_runtime_error(("list::_M_check_equal_allocators"));
      }
    };
# 1600 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    {
      typedef typename list<_Tp, _Alloc>::const_iterator const_iterator;
      const_iterator __end1 = __x.end();
      const_iterator __end2 = __y.end();

      const_iterator __i1 = __x.begin();
      const_iterator __i2 = __y.begin();
      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)
 {
   ++__i1;
   ++__i2;
 }
      return __i1 == __end1 && __i2 == __end2;
    }
# 1629 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
    { __x.swap(__y); }


}
# 64 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/list" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/list.tcc" 1 3
# 59 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/list.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Alloc>
    void
    _List_base<_Tp, _Alloc>::
    _M_clear()
    {
      typedef _List_node<_Tp> _Node;
      _Node* __cur = static_cast<_Node*>(_M_impl._M_node._M_next);
      while (__cur != &_M_impl._M_node)
 {
   _Node* __tmp = __cur;
   __cur = static_cast<_Node*>(__cur->_M_next);



   _M_get_Tp_allocator().destroy(std::__addressof(__tmp->_M_data));

   _M_put_node(__tmp);
 }
    }
# 96 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/list.tcc" 3
  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      _Node* __tmp = _M_create_node(__x);
      __tmp->_M_hook(__position._M_node);
      return iterator(__tmp);
    }

  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    erase(iterator __position)
    {
      iterator __ret = iterator(__position._M_node->_M_next);
      _M_erase(__position);
      return __ret;
    }
# 166 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/list.tcc" 3
  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    resize(size_type __new_size, value_type __x)
    {
      iterator __i = begin();
      size_type __len = 0;
      for (; __i != end() && __len < __new_size; ++__i, ++__len)
        ;
      if (__len == __new_size)
        erase(__i, end());
      else
        insert(end(), __new_size - __len, __x);
    }


  template<typename _Tp, typename _Alloc>
    list<_Tp, _Alloc>&
    list<_Tp, _Alloc>::
    operator=(const list& __x)
    {
      if (this != &__x)
 {
   iterator __first1 = begin();
   iterator __last1 = end();
   const_iterator __first2 = __x.begin();
   const_iterator __last2 = __x.end();
   for (; __first1 != __last1 && __first2 != __last2;
        ++__first1, ++__first2)
     *__first1 = *__first2;
   if (__first2 == __last2)
     erase(__first1, __last1);
   else
     insert(__last1, __first2, __last2);
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    _M_fill_assign(size_type __n, const value_type& __val)
    {
      iterator __i = begin();
      for (; __i != end() && __n > 0; ++__i, --__n)
        *__i = __val;
      if (__n > 0)
        insert(end(), __n, __val);
      else
        erase(__i, end());
    }

  template<typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      list<_Tp, _Alloc>::
      _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2,
    __false_type)
      {
        iterator __first1 = begin();
        iterator __last1 = end();
        for (; __first1 != __last1 && __first2 != __last2;
      ++__first1, ++__first2)
          *__first1 = *__first2;
        if (__first2 == __last2)
          erase(__first1, __last1);
        else
          insert(__last1, __first2, __last2);
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    remove(const value_type& __value)
    {
      iterator __first = begin();
      iterator __last = end();
      iterator __extra = __last;
      while (__first != __last)
 {
   iterator __next = __first;
   ++__next;
   if (*__first == __value)
     {



       if (std::__addressof(*__first) != std::__addressof(__value))
  _M_erase(__first);
       else
  __extra = __first;
     }
   __first = __next;
 }
      if (__extra != __last)
 _M_erase(__extra);
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    unique()
    {
      iterator __first = begin();
      iterator __last = end();
      if (__first == __last)
 return;
      iterator __next = __first;
      while (++__next != __last)
 {
   if (*__first == *__next)
     _M_erase(__next);
   else
     __first = __next;
   __next = __first;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::



    merge(list& __x)

    {


      if (this != &__x)
 {
   _M_check_equal_allocators(__x);

   iterator __first1 = begin();
   iterator __last1 = end();
   iterator __first2 = __x.begin();
   iterator __last2 = __x.end();
   while (__first1 != __last1 && __first2 != __last2)
     if (*__first2 < *__first1)
       {
  iterator __next = __first2;
  _M_transfer(__first1, __first2, ++__next);
  __first2 = __next;
       }
     else
       ++__first1;
   if (__first2 != __last2)
     _M_transfer(__last1, __first2, __last2);
 }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::



      merge(list& __x, _StrictWeakOrdering __comp)

      {


 if (this != &__x)
   {
     _M_check_equal_allocators(__x);

     iterator __first1 = begin();
     iterator __last1 = end();
     iterator __first2 = __x.begin();
     iterator __last2 = __x.end();
     while (__first1 != __last1 && __first2 != __last2)
       if (__comp(*__first2, *__first1))
  {
    iterator __next = __first2;
    _M_transfer(__first1, __first2, ++__next);
    __first2 = __next;
  }
       else
  ++__first1;
     if (__first2 != __last2)
       _M_transfer(__last1, __first2, __last2);
   }
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    sort()
    {

      if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
   && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
      {
        list __carry;
        list __tmp[64];
        list * __fill = &__tmp[0];
        list * __counter;

        do
   {
     __carry.splice(__carry.begin(), *this, begin());

     for(__counter = &__tmp[0];
  __counter != __fill && !__counter->empty();
  ++__counter)
       {
  __counter->merge(__carry);
  __carry.swap(*__counter);
       }
     __carry.swap(*__counter);
     if (__counter == __fill)
       ++__fill;
   }
 while ( !empty() );

        for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
          __counter->merge(*(__counter - 1));
        swap( *(__fill - 1) );
      }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _Predicate>
      void
      list<_Tp, _Alloc>::
      remove_if(_Predicate __pred)
      {
        iterator __first = begin();
        iterator __last = end();
        while (__first != __last)
   {
     iterator __next = __first;
     ++__next;
     if (__pred(*__first))
       _M_erase(__first);
     __first = __next;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _BinaryPredicate>
      void
      list<_Tp, _Alloc>::
      unique(_BinaryPredicate __binary_pred)
      {
        iterator __first = begin();
        iterator __last = end();
        if (__first == __last)
   return;
        iterator __next = __first;
        while (++__next != __last)
   {
     if (__binary_pred(*__first, *__next))
       _M_erase(__next);
     else
       __first = __next;
     __next = __first;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::
      sort(_StrictWeakOrdering __comp)
      {

 if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
     && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
   {
     list __carry;
     list __tmp[64];
     list * __fill = &__tmp[0];
     list * __counter;

     do
       {
  __carry.splice(__carry.begin(), *this, begin());

  for(__counter = &__tmp[0];
      __counter != __fill && !__counter->empty();
      ++__counter)
    {
      __counter->merge(__carry, __comp);
      __carry.swap(*__counter);
    }
  __carry.swap(*__counter);
  if (__counter == __fill)
    ++__fill;
       }
     while ( !empty() );

     for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
       __counter->merge(*(__counter - 1), __comp);
     swap(*(__fill - 1));
   }
      }


}
# 65 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/list" 2 3
# 33 "/home/marek/devel/nupic/nta/math/stl_io.hpp" 2

# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/set" 1 3
# 59 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/set" 3


# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_set.h" 1 3
# 64 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_set.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 88 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_set.h" 3
  template<typename _Key, typename _Compare = std::less<_Key>,
    typename _Alloc = std::allocator<_Key> >
    class set
    {

      typedef typename _Alloc::value_type _Alloc_value_type;





    public:



      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;


    private:
      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;
      _Rep_type _M_t;

    public:


      typedef typename _Key_alloc_type::pointer pointer;
      typedef typename _Key_alloc_type::const_pointer const_pointer;
      typedef typename _Key_alloc_type::reference reference;
      typedef typename _Key_alloc_type::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;






      set()
      : _M_t() { }






      explicit
      set(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Key_alloc_type(__a)) { }
# 162 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_set.h" 3
      template<typename _InputIterator>
 set(_InputIterator __first, _InputIterator __last)
 : _M_t()
 { _M_t._M_insert_unique(__first, __last); }
# 179 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_set.h" 3
      template<typename _InputIterator>
 set(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Key_alloc_type(__a))
        { _M_t._M_insert_unique(__first, __last); }
# 193 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_set.h" 3
      set(const set& __x)
      : _M_t(__x._M_t) { }
# 232 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_set.h" 3
      set&
      operator=(const set& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 280 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_set.h" 3
      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_t.get_allocator()); }






      iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const
      { return _M_t.rend(); }
# 367 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_set.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 392 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_set.h" 3
      void
      swap(set& __x)
      { _M_t.swap(__x._M_t); }
# 459 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_set.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      {
 std::pair<typename _Rep_type::iterator, bool> __p =
   _M_t._M_insert_unique(__x);
 return std::pair<iterator, bool>(__p.first, __p.second);
      }
# 496 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_set.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x)
      { return _M_t._M_insert_unique_(__position, __x); }
# 515 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_set.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_t._M_insert_unique(__first, __last); }
# 564 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_set.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 580 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_set.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 618 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_set.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 629 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_set.h" 3
      void
      clear()
      { _M_t.clear(); }
# 643 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_set.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
# 661 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_set.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 682 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_set.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 698 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_set.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 723 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_set.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }


      template<typename _K1, typename _C1, typename _A1>
 friend bool
 operator==(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);

      template<typename _K1, typename _C1, typename _A1>
 friend bool
 operator<(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
    };
# 752 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_set.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator==(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 769 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_set.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(set<_Key, _Compare, _Alloc>& __x, set<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


}
# 62 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/set" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multiset.h" 1 3
# 64 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multiset.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 90 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multiset.h" 3
  template <typename _Key, typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<_Key> >
    class multiset
    {

      typedef typename _Alloc::value_type _Alloc_value_type;





    public:

      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;

      _Rep_type _M_t;

    public:
      typedef typename _Key_alloc_type::pointer pointer;
      typedef typename _Key_alloc_type::const_pointer const_pointer;
      typedef typename _Key_alloc_type::reference reference;
      typedef typename _Key_alloc_type::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;





      multiset()
      : _M_t() { }






      explicit
      multiset(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Key_alloc_type(__a)) { }
# 159 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multiset.h" 3
      template<typename _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_equal(__first, __last); }
# 175 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multiset.h" 3
      template<typename _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Key_alloc_type(__a))
        { _M_t._M_insert_equal(__first, __last); }
# 189 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multiset.h" 3
      multiset(const multiset& __x)
      : _M_t(__x._M_t) { }
# 228 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multiset.h" 3
      multiset&
      operator=(const multiset& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 277 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multiset.h" 3
      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_t.get_allocator()); }






      iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const
      { return _M_t.rend(); }
# 364 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multiset.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 389 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multiset.h" 3
      void
      swap(multiset& __x)
      { _M_t.swap(__x._M_t); }
# 453 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multiset.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }
# 483 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multiset.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x)
      { return _M_t._M_insert_equal_(__position, __x); }
# 501 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multiset.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
# 550 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multiset.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 566 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multiset.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 604 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multiset.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 615 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multiset.h" 3
      void
      clear()
      { _M_t.clear(); }
# 626 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multiset.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
# 644 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multiset.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 665 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multiset.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 681 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multiset.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 706 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multiset.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }


      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator==(const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);

      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator< (const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);
    };
# 737 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multiset.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 754 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_multiset.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multiset<_Key, _Compare, _Alloc>& __x,
       const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multiset<_Key,_Compare,_Alloc>& __x,
       const multiset<_Key,_Compare,_Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(multiset<_Key, _Compare, _Alloc>& __x,
  multiset<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


}
# 63 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/set" 2 3
# 35 "/home/marek/devel/nupic/nta/math/stl_io.hpp" 2


# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/iomanip" 1 3
# 37 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/iomanip" 3
# 46 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/iomanip" 3
namespace std __attribute__ ((__visibility__ ("default")))
{





  struct _Resetiosflags { ios_base::fmtflags _M_mask; };
# 62 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/iomanip" 3
  inline _Resetiosflags
  resetiosflags(ios_base::fmtflags __mask)
  { return { __mask }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Resetiosflags __f)
    {
      __is.setf(ios_base::fmtflags(0), __f._M_mask);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Resetiosflags __f)
    {
      __os.setf(ios_base::fmtflags(0), __f._M_mask);
      return __os;
    }


  struct _Setiosflags { ios_base::fmtflags _M_mask; };
# 92 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/iomanip" 3
  inline _Setiosflags
  setiosflags(ios_base::fmtflags __mask)
  { return { __mask }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setiosflags __f)
    {
      __is.setf(__f._M_mask);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setiosflags __f)
    {
      __os.setf(__f._M_mask);
      return __os;
    }


  struct _Setbase { int _M_base; };
# 123 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/iomanip" 3
  inline _Setbase
  setbase(int __base)
  { return { __base }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setbase __f)
    {
      __is.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setbase __f)
    {
      __os.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __os;
    }


  template<typename _CharT>
    struct _Setfill { _CharT _M_c; };
# 160 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/iomanip" 3
  template<typename _CharT>
    inline _Setfill<_CharT>
    setfill(_CharT __c)
    { return { __c }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setfill<_CharT> __f)
    {
      __is.fill(__f._M_c);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setfill<_CharT> __f)
    {
      __os.fill(__f._M_c);
      return __os;
    }


  struct _Setprecision { int _M_n; };
# 191 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/iomanip" 3
  inline _Setprecision
  setprecision(int __n)
  { return { __n }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setprecision __f)
    {
      __is.precision(__f._M_n);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setprecision __f)
    {
      __os.precision(__f._M_n);
      return __os;
    }


  struct _Setw { int _M_n; };
# 221 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/iomanip" 3
  inline _Setw
  setw(int __n)
  { return { __n }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setw __f)
    {
      __is.width(__f._M_n);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setw __f)
    {
      __os.width(__f._M_n);
      return __os;
    }
# 343 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/iomanip" 3
  extern template ostream& operator<<(ostream&, _Setfill<char>);
  extern template ostream& operator<<(ostream&, _Setiosflags);
  extern template ostream& operator<<(ostream&, _Resetiosflags);
  extern template ostream& operator<<(ostream&, _Setbase);
  extern template ostream& operator<<(ostream&, _Setprecision);
  extern template ostream& operator<<(ostream&, _Setw);
  extern template istream& operator>>(istream&, _Setfill<char>);
  extern template istream& operator>>(istream&, _Setiosflags);
  extern template istream& operator>>(istream&, _Resetiosflags);
  extern template istream& operator>>(istream&, _Setbase);
  extern template istream& operator>>(istream&, _Setprecision);
  extern template istream& operator>>(istream&, _Setw);


  extern template wostream& operator<<(wostream&, _Setfill<wchar_t>);
  extern template wostream& operator<<(wostream&, _Setiosflags);
  extern template wostream& operator<<(wostream&, _Resetiosflags);
  extern template wostream& operator<<(wostream&, _Setbase);
  extern template wostream& operator<<(wostream&, _Setprecision);
  extern template wostream& operator<<(wostream&, _Setw);
  extern template wistream& operator>>(wistream&, _Setfill<wchar_t>);
  extern template wistream& operator>>(wistream&, _Setiosflags);
  extern template wistream& operator>>(wistream&, _Resetiosflags);
  extern template wistream& operator>>(wistream&, _Setbase);
  extern template wistream& operator>>(wistream&, _Setprecision);
  extern template wistream& operator>>(wistream&, _Setw);




}
# 38 "/home/marek/devel/nupic/nta/math/stl_io.hpp" 2
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 1
# 13 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_const.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_const.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 10 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/int.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/int.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/int_fwd.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/int_fwd.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/adl_barrier.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/adl_barrier.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/config/adl.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/config/adl.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/config/msvc.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/config/adl.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/config/intel.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/config/adl.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/config/gcc.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/config/adl.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/config/workaround.hpp" 1
# 20 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/config/adl.hpp" 2
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/adl_barrier.hpp" 2
# 33 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/adl_barrier.hpp"
namespace mpl_ { namespace aux {} }
namespace boost { namespace mpl { using namespace mpl_;
namespace aux { using namespace mpl_::aux; }
}}
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/int_fwd.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/nttp_decl.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/nttp_decl.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/config/nttp.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/nttp_decl.hpp" 2
# 18 "/home/marek/devel/nupic/external/common/include/boost/mpl/int_fwd.hpp" 2


namespace mpl_ {

template< int N > struct int_;

}
namespace boost { namespace mpl { using ::mpl_::int_; } }
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/int.hpp" 2



# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/integral_wrapper.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/integral_wrapper.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/integral_c_tag.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/mpl/integral_c_tag.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/config/static_constant.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/mpl/integral_c_tag.hpp" 2


namespace mpl_ {
struct integral_c_tag { static const int value = 0; };
}
namespace boost { namespace mpl { using ::mpl_::integral_c_tag; } }
# 16 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/integral_wrapper.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/static_cast.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/integral_wrapper.hpp" 2





# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 2
# 22 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/integral_wrapper.hpp" 2
# 40 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/integral_wrapper.hpp"
namespace mpl_ {

template< int N >
struct int_
{
    static const int value = N;





    typedef int_ type;

    typedef int value_type;
    typedef integral_c_tag tag;
# 72 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/integral_wrapper.hpp"
    typedef mpl_::int_< static_cast<int>((value + 1)) > next;
    typedef mpl_::int_< static_cast<int>((value - 1)) > prior;






    operator int() const { return static_cast<int>(this->value); }
};


template< int N >
int const mpl_::int_< N >::value;


}
# 20 "/home/marek/devel/nupic/external/common/include/boost/mpl/int.hpp" 2
# 10 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/template_arity_fwd.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/template_arity_fwd.hpp"
namespace boost { namespace mpl { namespace aux {

template< typename F > struct template_arity;

}}}
# 11 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessor/params.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessor/params.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/config/preprocessor.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessor/params.hpp" 2
# 45 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessor/params.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/comma_if.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/comma_if.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/punctuation/comma_if.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/punctuation/comma_if.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/punctuation/comma_if.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/if.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/if.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/if.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/iif.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/iif.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/iif.hpp" 2
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/if.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/logical/bool.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/logical/bool.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/logical/bool.hpp" 2
# 19 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/if.hpp" 2
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/punctuation/comma_if.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/facilities/empty.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/punctuation/comma_if.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/punctuation/comma.hpp" 1
# 20 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/punctuation/comma_if.hpp" 2
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/comma_if.hpp" 2
# 45 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessor/params.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repeat.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repeat.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/repeat.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/repeat.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/repeat.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/repeat.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/debug/error.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/debug/error.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/debug/error.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/debug/error.hpp" 2
# 19 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/repeat.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/auto_rec.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/auto_rec.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/auto_rec.hpp" 2
# 21 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/auto_rec.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/iif.hpp" 1
# 21 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/auto_rec.hpp" 2
# 20 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/repeat.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/eat.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/eat.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/eat.hpp" 2
# 21 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/repeat.hpp" 2
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repeat.hpp" 2
# 46 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessor/params.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/inc.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/inc.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/arithmetic/inc.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/arithmetic/inc.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/arithmetic/inc.hpp" 2
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/inc.hpp" 2
# 47 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessor/params.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 48 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessor/params.hpp" 2
# 12 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/config/lambda.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/config/lambda.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/config/ttp.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/config/lambda.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/config/ctps.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/config/lambda.hpp" 2
# 13 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/config/overload_resolution.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 2
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/lambda_support.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 16 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_const.hpp" 2


namespace boost {
# 33 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_const.hpp"
template< typename T > struct add_const { public: typedef T const type; };






template< typename T > struct add_const<T&> { public: typedef T& type; };


}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 45 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_const.hpp" 2
# 13 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_cv.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_cv.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 17 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_cv.hpp" 2


namespace boost {
# 34 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_cv.hpp"
template< typename T > struct add_cv { public: typedef T const volatile type; };






template< typename T > struct add_cv<T&> { public: typedef T& type; };


}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 46 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_cv.hpp" 2
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_lvalue_reference.hpp" 1








# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_reference.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_reference.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_reference.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_reference.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/config.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_reference.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_lvalue_reference.hpp" 1
# 32 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_lvalue_reference.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/integral_constant.hpp" 1
# 10 "/home/marek/devel/nupic/external/common/include/boost/type_traits/integral_constant.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/bool.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/bool.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/bool_fwd.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/mpl/bool_fwd.hpp"
namespace mpl_ {

template< bool C_ > struct bool_;


typedef bool_<true> true_;
typedef bool_<false> false_;

}

namespace boost { namespace mpl { using ::mpl_::bool_; } }
namespace boost { namespace mpl { using ::mpl_::true_; } }
namespace boost { namespace mpl { using ::mpl_::false_; } }
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/bool.hpp" 2




namespace mpl_ {

template< bool C_ > struct bool_
{
    static const bool value = C_;
    typedef integral_c_tag tag;
    typedef bool_ type;
    typedef bool value_type;
    operator bool() const { return this->value; }
};


template< bool C_ >
bool const bool_<C_>::value;


}
# 10 "/home/marek/devel/nupic/external/common/include/boost/type_traits/integral_constant.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/integral_c.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/integral_c.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/integral_c_fwd.hpp" 1
# 20 "/home/marek/devel/nupic/external/common/include/boost/mpl/integral_c_fwd.hpp"
namespace mpl_ {





template< typename T, T N > struct integral_c;


}
namespace boost { namespace mpl { using ::mpl_::integral_c; } }
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/integral_c.hpp" 2
# 32 "/home/marek/devel/nupic/external/common/include/boost/mpl/integral_c.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/integral_wrapper.hpp" 1
# 22 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/integral_wrapper.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 22 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/integral_wrapper.hpp" 2
# 40 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/integral_wrapper.hpp"
namespace mpl_ {

template< typename T, T N >
struct integral_c
{
    static const T value = N;





    typedef integral_c type;

    typedef T value_type;
    typedef integral_c_tag tag;
# 72 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/integral_wrapper.hpp"
    typedef integral_c< T, static_cast<T>((value + 1)) > next;
    typedef integral_c< T, static_cast<T>((value - 1)) > prior;






    operator T() const { return static_cast<T>(this->value); }
};


template< typename T, T N >
T const integral_c< T, N >::value;


}
# 32 "/home/marek/devel/nupic/external/common/include/boost/mpl/integral_c.hpp" 2





namespace mpl_ {

template< bool C >
struct integral_c<bool, C>
{
    static const bool value = C;
    typedef integral_c_tag tag;
    typedef integral_c type;
    typedef bool value_type;
    operator bool() const { return this->value; }
};
}
# 11 "/home/marek/devel/nupic/external/common/include/boost/type_traits/integral_constant.hpp" 2


namespace boost{




template <class T, T val>

struct integral_constant : public mpl::integral_c<T, val>
{
   typedef integral_constant<T,val> type;
};

template<> struct integral_constant<bool,true> : public mpl::true_
{







   typedef integral_constant<bool,true> type;
};
template<> struct integral_constant<bool,false> : public mpl::false_
{







   typedef integral_constant<bool,false> type;
};

typedef integral_constant<bool,true> true_type;
typedef integral_constant<bool,false> false_type;

}
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 32 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_lvalue_reference.hpp" 2


namespace boost {





template< typename T > struct is_lvalue_reference : public ::boost::integral_constant<bool,false> { public: };
template< typename T > struct is_lvalue_reference< T& > : public ::boost::integral_constant<bool,true> { public: };
# 113 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_lvalue_reference.hpp"
}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 115 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_lvalue_reference.hpp" 2
# 16 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_reference.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_rvalue_reference.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_rvalue_reference.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_rvalue_reference.hpp" 2


namespace boost {

template< typename T > struct is_rvalue_reference : public ::boost::integral_constant<bool,false> { public: };




}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 26 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_rvalue_reference.hpp" 2
# 17 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_reference.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/ice.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/ice.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/yes_no_type.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/yes_no_type.hpp"
namespace boost {
namespace type_traits {

typedef char yes_type;
struct no_type
{
   char padding[8];
};

}
}
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/ice.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/ice_or.hpp" 1
# 13 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/ice_or.hpp"
namespace boost {
namespace type_traits {

template <bool b1, bool b2, bool b3 = false, bool b4 = false, bool b5 = false, bool b6 = false, bool b7 = false>
struct ice_or;

template <bool b1, bool b2, bool b3, bool b4, bool b5, bool b6, bool b7>
struct ice_or
{
    static const bool value = true;
};

template <>
struct ice_or<false, false, false, false, false, false, false>
{
    static const bool value = false;
};

}
}
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/ice.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/ice_and.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/ice_and.hpp"
namespace boost {
namespace type_traits {

template <bool b1, bool b2, bool b3 = true, bool b4 = true, bool b5 = true, bool b6 = true, bool b7 = true>
struct ice_and;

template <bool b1, bool b2, bool b3, bool b4, bool b5, bool b6, bool b7>
struct ice_and
{
    static const bool value = false;
};

template <>
struct ice_and<true, true, true, true, true, true, true>
{
    static const bool value = true;
};

}
}
# 16 "/home/marek/devel/nupic/external/common/include/boost/type_traits/ice.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/ice_not.hpp" 1
# 13 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/ice_not.hpp"
namespace boost {
namespace type_traits {

template <bool b>
struct ice_not
{
    static const bool value = true;
};

template <>
struct ice_not<true>
{
    static const bool value = false;
};

}
}
# 17 "/home/marek/devel/nupic/external/common/include/boost/type_traits/ice.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/ice_eq.hpp" 1
# 13 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/ice_eq.hpp"
namespace boost {
namespace type_traits {

template <int b1, int b2>
struct ice_eq
{
    static const bool value = (b1 == b2);
};

template <int b1, int b2>
struct ice_ne
{
    static const bool value = (b1 != b2);
};


template <int b1, int b2> bool const ice_eq<b1,b2>::value;
template <int b1, int b2> bool const ice_ne<b1,b2>::value;


}
}
# 18 "/home/marek/devel/nupic/external/common/include/boost/type_traits/ice.hpp" 2
# 18 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_reference.hpp" 2



# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 21 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_reference.hpp" 2


namespace boost {

namespace detail {

template <typename T>
struct is_reference_impl
{
   static const bool value = (::boost::type_traits::ice_or< ::boost::is_lvalue_reference<T>::value, ::boost::is_rvalue_reference<T>::value >::value);



};

}

template< typename T > struct is_reference : public ::boost::integral_constant<bool,::boost::detail::is_reference_impl<T>::value> { public: };

}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 42 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_reference.hpp" 2
# 12 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_reference.hpp" 2





# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 17 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_reference.hpp" 2


namespace boost {

namespace detail {
# 59 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_reference.hpp"
template <typename T>
struct add_reference_rvalue_layer
{
    typedef T& type;
};
# 73 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_reference.hpp"
template <typename T>
struct add_reference_impl
{
    typedef typename add_reference_rvalue_layer<T>::type type;
};


template< typename T > struct add_reference_impl<T&> { public: typedef T& type; };





template<> struct add_reference_impl<void> { public: typedef void type; };

template<> struct add_reference_impl<void const> { public: typedef void const type; };
template<> struct add_reference_impl<void volatile> { public: typedef void volatile type; };
template<> struct add_reference_impl<void const volatile> { public: typedef void const volatile type; };


}

template< typename T > struct add_reference { public: typedef typename boost::detail::add_reference_impl<T>::type type; };







}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 105 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_reference.hpp" 2
# 9 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_lvalue_reference.hpp" 2



# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 12 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_lvalue_reference.hpp" 2


namespace boost{

template< typename T > struct add_lvalue_reference { public: typedef typename boost::add_reference<T>::type type; };





}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 24 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_lvalue_reference.hpp" 2
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_pointer.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_pointer.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_reference.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_reference.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/broken_compiler_spec.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_reference.hpp" 2
# 21 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_reference.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 21 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_reference.hpp" 2


namespace boost {



namespace detail{




template <class T>
struct remove_rvalue_ref
{
   typedef T type;
};
# 45 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_reference.hpp"
}

template< typename T > struct remove_reference { public: typedef typename boost::detail::remove_rvalue_ref<T>::type type; };
template< typename T > struct remove_reference<T&> { public: typedef T type; };
# 66 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_reference.hpp"
}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 68 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_reference.hpp" 2
# 12 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_pointer.hpp" 2



# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_pointer.hpp" 2


namespace boost {

namespace detail {
# 55 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_pointer.hpp"
template <typename T>
struct add_pointer_impl
{
    typedef typename remove_reference<T>::type no_ref_type;
    typedef no_ref_type* type;
};



}

template< typename T > struct add_pointer { public: typedef typename boost::detail::add_pointer_impl<T>::type type; };

}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 70 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_pointer.hpp" 2
# 16 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_rvalue_reference.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_rvalue_reference.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_void.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_void.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_void.hpp" 2


namespace boost {





template< typename T > struct is_void : public ::boost::integral_constant<bool,false> { public: };
template<> struct is_void< void > : public ::boost::integral_constant<bool,true> { public: };


template<> struct is_void< void const > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_void< void volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_void< void const volatile > : public ::boost::integral_constant<bool,true> { public: };




}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 36 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_void.hpp" 2
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_rvalue_reference.hpp" 2




# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 19 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_rvalue_reference.hpp" 2
# 34 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_rvalue_reference.hpp"
namespace boost {

namespace type_traits_detail {

    template <typename T, bool b>
    struct add_rvalue_reference_helper
    { typedef T type; };
# 50 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_rvalue_reference.hpp"
    template <typename T>
    struct add_rvalue_reference_imp
    {
       typedef typename boost::type_traits_detail::add_rvalue_reference_helper
                  <T, (!is_void<T>::value && !is_reference<T>::value) >::type type;
    };

}

template< typename T > struct add_rvalue_reference { public: typedef typename boost::type_traits_detail::add_rvalue_reference_imp<T>::type type; };

}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 63 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_rvalue_reference.hpp" 2
# 18 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_volatile.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_volatile.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 16 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_volatile.hpp" 2


namespace boost {
# 33 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_volatile.hpp"
template< typename T > struct add_volatile { public: typedef T volatile type; };






template< typename T > struct add_volatile<T&> { public: typedef T& type; };


}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 45 "/home/marek/devel/nupic/external/common/include/boost/type_traits/add_volatile.hpp" 2
# 19 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/aligned_storage.hpp" 1
# 11 "/home/marek/devel/nupic/external/common/include/boost/type_traits/aligned_storage.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/aligned_storage.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/aligned_storage.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 2 3
# 16 "/home/marek/devel/nupic/external/common/include/boost/aligned_storage.hpp" 2




# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/alignment_of.hpp" 1
# 13 "/home/marek/devel/nupic/external/common/include/boost/type_traits/alignment_of.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 2 3
# 13 "/home/marek/devel/nupic/external/common/include/boost/type_traits/alignment_of.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/intrinsics.hpp" 1
# 127 "/home/marek/devel/nupic/external/common/include/boost/type_traits/intrinsics.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 2 3
# 127 "/home/marek/devel/nupic/external/common/include/boost/type_traits/intrinsics.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_same.hpp" 1
# 31 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_same.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 31 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_same.hpp" 2


namespace boost {



template< typename T, typename U > struct is_same : public ::boost::integral_constant<bool,false> { public: };
template< typename T > struct is_same< T,T > : public ::boost::integral_constant<bool,true> { public: };
# 98 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_same.hpp"
}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 100 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_same.hpp" 2
# 128 "/home/marek/devel/nupic/external/common/include/boost/type_traits/intrinsics.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_volatile.hpp" 1
# 28 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_volatile.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/cv_traits_impl.hpp" 1
# 23 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/cv_traits_impl.hpp"
namespace boost {
namespace detail {







template <typename T> struct cv_traits_imp {};

template <typename T>
struct cv_traits_imp<T*>
{
    static const bool is_const = false;
    static const bool is_volatile = false;
    typedef T unqualified_type;
};

template <typename T>
struct cv_traits_imp<const T*>
{
    static const bool is_const = true;
    static const bool is_volatile = false;
    typedef T unqualified_type;
};

template <typename T>
struct cv_traits_imp<volatile T*>
{
    static const bool is_const = false;
    static const bool is_volatile = true;
    typedef T unqualified_type;
};

template <typename T>
struct cv_traits_imp<const volatile T*>
{
    static const bool is_const = true;
    static const bool is_volatile = true;
    typedef T unqualified_type;
};
# 92 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/cv_traits_impl.hpp"
}
}
# 28 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_volatile.hpp" 2
# 40 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_volatile.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 40 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_volatile.hpp" 2


namespace boost {

namespace detail{
template <class T>
struct is_volatile_rval_filter
{



   static const bool value = ::boost::detail::cv_traits_imp<T*>::is_volatile;

};
# 65 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_volatile.hpp"
}






template< typename T > struct is_volatile : public ::boost::integral_constant<bool,::boost::detail::is_volatile_rval_filter<T>::value> { public: };
template< typename T > struct is_volatile< T& > : public ::boost::integral_constant<bool,false> { public: };
# 148 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_volatile.hpp"
}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_volatile.hpp" 2
# 130 "/home/marek/devel/nupic/external/common/include/boost/type_traits/intrinsics.hpp" 2
# 175 "/home/marek/devel/nupic/external/common/include/boost/type_traits/intrinsics.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_abstract.hpp" 1
# 51 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_abstract.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/intrinsics.hpp" 1
# 51 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_abstract.hpp" 2
# 62 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_abstract.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 62 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_abstract.hpp" 2



namespace boost {
namespace detail{


template <class T>
struct is_abstract_imp
{
   static const bool value = __is_abstract(T);
};
# 141 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_abstract.hpp"
}


template< typename T > struct is_abstract : public ::boost::integral_constant<bool,::boost::detail::is_abstract_imp<T>::value> { public: };




}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 151 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_abstract.hpp" 2
# 175 "/home/marek/devel/nupic/external/common/include/boost/type_traits/intrinsics.hpp" 2
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/alignment_of.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/size_t_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/size_t_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/size_t_trait_def.hpp" 2



# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/size_t.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/size_t.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/size_t_fwd.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/mpl/size_t_fwd.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 2 3
# 19 "/home/marek/devel/nupic/external/common/include/boost/mpl/size_t_fwd.hpp" 2


namespace mpl_ {

template< std::size_t N > struct size_t;

}
namespace boost { namespace mpl { using ::mpl_::size_t; } }
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/size_t.hpp" 2






# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/integral_wrapper.hpp" 1
# 22 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/integral_wrapper.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 22 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/integral_wrapper.hpp" 2
# 40 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/integral_wrapper.hpp"
namespace mpl_ {

template< std::size_t N >
struct size_t
{
    static const std::size_t value = N;





    typedef size_t type;

    typedef std::size_t value_type;
    typedef integral_c_tag tag;
# 72 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/integral_wrapper.hpp"
    typedef mpl_::size_t< static_cast<std::size_t>((value + 1)) > next;
    typedef mpl_::size_t< static_cast<std::size_t>((value - 1)) > prior;






    operator std::size_t() const { return static_cast<std::size_t>(this->value); }
};


template< std::size_t N >
std::size_t const mpl_::size_t< N >::value;


}
# 23 "/home/marek/devel/nupic/external/common/include/boost/mpl/size_t.hpp" 2
# 17 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/size_t_trait_def.hpp" 2


# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 2 3
# 19 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/size_t_trait_def.hpp" 2
# 17 "/home/marek/devel/nupic/external/common/include/boost/type_traits/alignment_of.hpp" 2
# 27 "/home/marek/devel/nupic/external/common/include/boost/type_traits/alignment_of.hpp"
namespace boost {

template <typename T> struct alignment_of;


namespace detail {





template <typename T>
struct alignment_of_hack
{
    char c;
    T t;
    alignment_of_hack();
};




template <unsigned A, unsigned S>
struct alignment_logic
{
    static const std::size_t value = A < S ? A : S;
};


template< typename T >
struct alignment_of_impl
{
# 83 "/home/marek/devel/nupic/external/common/include/boost/type_traits/alignment_of.hpp"
   static const std::size_t value = __alignof(T);

};

}

template< typename T > struct alignment_of : public ::boost::integral_constant<std::size_t,::boost::detail::alignment_of_impl<T>::value> { public: };




template <typename T>
struct alignment_of<T&>
    : public alignment_of<T*>
{
};
# 109 "/home/marek/devel/nupic/external/common/include/boost/type_traits/alignment_of.hpp"
template<> struct alignment_of<void> : public ::boost::integral_constant<std::size_t,0> { public: };

template<> struct alignment_of<void const> : public ::boost::integral_constant<std::size_t,0> { public: };
template<> struct alignment_of<void volatile> : public ::boost::integral_constant<std::size_t,0> { public: };
template<> struct alignment_of<void const volatile> : public ::boost::integral_constant<std::size_t,0> { public: };


}
# 125 "/home/marek/devel/nupic/external/common/include/boost/type_traits/alignment_of.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/size_t_trait_undef.hpp" 1
# 125 "/home/marek/devel/nupic/external/common/include/boost/type_traits/alignment_of.hpp" 2
# 20 "/home/marek/devel/nupic/external/common/include/boost/aligned_storage.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/type_with_alignment.hpp" 1
# 11 "/home/marek/devel/nupic/external/common/include/boost/type_traits/type_with_alignment.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/if.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/if.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/value_wknd.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/value_wknd.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/config/integral.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/value_wknd.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/config/eti.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/value_wknd.hpp" 2
# 73 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/value_wknd.hpp"
namespace boost { namespace mpl { namespace aux {

template< typename T > struct value_type_wknd
{
    typedef typename T::value_type type;
};
# 87 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/value_wknd.hpp"
}}}
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/if.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/na_spec.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/na_spec.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/lambda_fwd.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/lambda_fwd.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/void_fwd.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/mpl/void_fwd.hpp"
namespace mpl_ {

struct void_;

}
namespace boost { namespace mpl { using ::mpl_::void_; } }
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/lambda_fwd.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/na.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/na.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/na_fwd.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/na_fwd.hpp"
namespace mpl_ {


struct na
{
    typedef na type;
    enum { value = 0 };
};

}
namespace boost { namespace mpl { using ::mpl_::na; } }
# 18 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/na.hpp" 2




namespace boost { namespace mpl {

template< typename T >
struct is_na
    : false_
{



};

template<>
struct is_na<na>
    : true_
{



};

template< typename T >
struct is_not_na
    : true_
{



};

template<>
struct is_not_na<na>
    : false_
{



};


template< typename T, typename U > struct if_na
{
    typedef T type;
};

template< typename U > struct if_na<na,U>
{
    typedef U type;
};
# 93 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/na.hpp"
}}
# 18 "/home/marek/devel/nupic/external/common/include/boost/mpl/lambda_fwd.hpp" 2






# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/lambda_arity_param.hpp" 1
# 24 "/home/marek/devel/nupic/external/common/include/boost/mpl/lambda_fwd.hpp" 2



namespace boost { namespace mpl {

template<
      typename T = na
    , typename Tag = void_
    , typename Arity = int_< aux::template_arity<T>::value >


    >
struct lambda;

}}
# 18 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/na_spec.hpp" 2




# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/arity.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/arity.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/config/dtp.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/arity.hpp" 2
# 22 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/na_spec.hpp" 2





# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessor/enum.hpp" 1
# 45 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessor/enum.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/comma_if.hpp" 1
# 45 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessor/enum.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repeat.hpp" 1
# 46 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessor/enum.hpp" 2
# 27 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/na_spec.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/limits/arity.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2




# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/comma_if.hpp" 1
# 21 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/logical/and.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/logical/and.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/logical/and.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/logical/bool.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/logical/and.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/logical/bitand.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/logical/bitand.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/logical/bitand.hpp" 2
# 19 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/logical/and.hpp" 2
# 22 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/identity.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/identity.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/facilities/identity.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/facilities/identity.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/facilities/empty.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/facilities/identity.hpp" 2
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/identity.hpp" 2
# 23 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/empty.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/empty.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/facilities/empty.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/empty.hpp" 2
# 24 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2
# 66 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/arithmetic/add.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/arithmetic/add.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/arithmetic/dec.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/arithmetic/dec.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/arithmetic/dec.hpp" 2
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/arithmetic/add.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/arithmetic/inc.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/arithmetic/add.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/arithmetic/add.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/while.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/while.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/while.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/while.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/debug/error.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/while.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/auto_rec.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/auto_rec.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/auto_rec.hpp" 2
# 20 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/while.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/fold_left.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/fold_left.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/fold_left.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/while.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/fold_left.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/debug/error.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/fold_left.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/auto_rec.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/auto_rec.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/auto_rec.hpp" 2
# 20 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/fold_left.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/fold_left.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/detail/fold_left.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/detail/fold_left.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/expr_iif.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/expr_iif.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/expr_iif.hpp" 2
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/detail/fold_left.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/iif.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/detail/fold_left.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/adt.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/adt.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/adt.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/is_binary.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/is_binary.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/is_binary.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/check.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/check.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/check.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/check.hpp" 2
# 16 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/is_binary.hpp" 2
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/adt.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/logical/compl.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/logical/compl.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/logical/compl.hpp" 2
# 19 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/adt.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/eat.hpp" 1
# 20 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/adt.hpp" 2
# 19 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/detail/fold_left.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/eat.hpp" 1
# 20 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/detail/fold_left.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/fold_left.hpp" 2
# 21 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/while.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/fold_right.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/fold_right.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/fold_right.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/while.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/fold_right.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/debug/error.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/fold_right.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/auto_rec.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/auto_rec.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/auto_rec.hpp" 2
# 20 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/fold_right.hpp" 2
# 37 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/fold_right.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/detail/fold_right.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/detail/fold_right.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/fold_left.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/detail/fold_right.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/reverse.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/reverse.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/reverse.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/fold_left.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/reverse.hpp" 2
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/detail/fold_right.hpp" 2
# 37 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/fold_right.hpp" 2
# 22 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/while.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/logical/bitand.hpp" 1
# 23 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/while.hpp" 2
# 48 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/while.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/detail/while.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/detail/while.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/iif.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/detail/while.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/logical/bool.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/detail/while.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/eat.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/detail/while.hpp" 2
# 48 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/while.hpp" 2
# 20 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/arithmetic/add.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/elem.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/elem.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/elem.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/elem.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/facilities/overload.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/facilities/overload.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/facilities/overload.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/variadic/size.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/variadic/size.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/variadic/size.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/variadic/size.hpp" 2
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/facilities/overload.hpp" 2
# 20 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/elem.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/rem.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/rem.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/rem.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/rem.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/facilities/overload.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/rem.hpp" 2
# 21 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/elem.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/variadic/elem.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/variadic/elem.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/variadic/elem.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/variadic/elem.hpp" 2
# 22 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/elem.hpp" 2
# 21 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/arithmetic/add.hpp" 2
# 66 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/arithmetic/sub.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/arithmetic/sub.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/arithmetic/dec.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/arithmetic/sub.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/arithmetic/sub.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/while.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/arithmetic/sub.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/elem.hpp" 1
# 20 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/arithmetic/sub.hpp" 2
# 67 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/inc.hpp" 1
# 68 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/elem.hpp" 1
# 69 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repeat.hpp" 1
# 70 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 71 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2
# 28 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/na_spec.hpp" 2
# 19 "/home/marek/devel/nupic/external/common/include/boost/mpl/if.hpp" 2






namespace boost { namespace mpl {



template<
      bool C
    , typename T1
    , typename T2
    >
struct if_c
{
    typedef T1 type;
};

template<
      typename T1
    , typename T2
    >
struct if_c<false,T1,T2>
{
    typedef T2 type;
};



template<
      typename T1 = na
    , typename T2 = na
    , typename T3 = na
    >
struct if_
{
 private:

    typedef if_c<



          static_cast<bool>(T1::value)

        , T2
        , T3
        > almost_type_;

 public:
    typedef typename almost_type_::type type;


};
# 131 "/home/marek/devel/nupic/external/common/include/boost/mpl/if.hpp"
template<> struct if_< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : if_< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< if_< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef if_< na , na , na > result_; typedef if_< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< if_< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< if_< na , na , na > > : int_<-1> { }; }

}}
# 11 "/home/marek/devel/nupic/external/common/include/boost/type_traits/type_with_alignment.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/for_each_i.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/for_each_i.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/arithmetic/inc.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/for_each_i.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/for_each_i.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/adt.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/for_each_i.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/for.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/for.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/for.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/debug/error.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/for.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/auto_rec.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/auto_rec.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/auto_rec.hpp" 2
# 19 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/for.hpp" 2
# 42 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/for.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/detail/for.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/detail/for.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/expr_iif.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/detail/for.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/iif.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/detail/for.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/logical/bool.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/detail/for.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/eat.hpp" 1
# 20 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/detail/for.hpp" 2
# 42 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/for.hpp" 2
# 20 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/for_each_i.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/elem.hpp" 1
# 21 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/for_each_i.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/rem.hpp" 1
# 22 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/for_each_i.hpp" 2
# 12 "/home/marek/devel/nupic/external/common/include/boost/type_traits/type_with_alignment.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/to_list.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/to_list.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/to_list.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/to_list.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/facilities/overload.hpp" 1
# 20 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/to_list.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/variadic/size.hpp" 1
# 21 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/to_list.hpp" 2
# 13 "/home/marek/devel/nupic/external/common/include/boost/type_traits/type_with_alignment.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/type_with_alignment.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/transform.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/transform.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/transform.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/fold_right.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/transform.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/elem.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/transform.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/rem.hpp" 1
# 20 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/transform.hpp" 2
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/type_with_alignment.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/append.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/append.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/append.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/fold_right.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/list/append.hpp" 2
# 16 "/home/marek/devel/nupic/external/common/include/boost/type_traits/type_with_alignment.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_pod.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_pod.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_scalar.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_scalar.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_arithmetic.hpp" 1
# 13 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_arithmetic.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_integral.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_integral.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_integral.hpp" 2


namespace boost {







template< typename T > struct is_integral : public ::boost::integral_constant<bool,false> { public: };

template<> struct is_integral< unsigned char > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned char const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned char volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned char const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< unsigned short > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned short const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned short volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned short const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< unsigned int > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned int const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned int volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned int const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< unsigned long > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned long const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned long volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned long const volatile > : public ::boost::integral_constant<bool,true> { public: };

template<> struct is_integral< signed char > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed char const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed char volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed char const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< signed short > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed short const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed short volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed short const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< signed int > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed int const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed int volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed int const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< signed long > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed long const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed long volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed long const volatile > : public ::boost::integral_constant<bool,true> { public: };

template<> struct is_integral< bool > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< bool const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< bool volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< bool const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< char > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< char const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< char volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< char const volatile > : public ::boost::integral_constant<bool,true> { public: };





template<> struct is_integral< wchar_t > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< wchar_t const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< wchar_t volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< wchar_t const volatile > : public ::boost::integral_constant<bool,true> { public: };
# 65 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_integral.hpp"
template<> struct is_integral< ::boost::ulong_long_type > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< ::boost::ulong_long_type const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< ::boost::ulong_long_type volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< ::boost::ulong_long_type const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< ::boost::long_long_type > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< ::boost::long_long_type const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< ::boost::long_long_type volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< ::boost::long_long_type const volatile > : public ::boost::integral_constant<bool,true> { public: };







}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 76 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_integral.hpp" 2
# 13 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_arithmetic.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_float.hpp" 1
# 13 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_float.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 13 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_float.hpp" 2


namespace boost {


template< typename T > struct is_float : public ::boost::integral_constant<bool,false> { public: };
template<> struct is_float< float > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_float< float const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_float< float volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_float< float const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_float< double > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_float< double const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_float< double volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_float< double const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_float< long double > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_float< long double const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_float< long double volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_float< long double const volatile > : public ::boost::integral_constant<bool,true> { public: };

}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_float.hpp" 2
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_arithmetic.hpp" 2






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 20 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_arithmetic.hpp" 2


namespace boost {


namespace detail {

template< typename T >
struct is_arithmetic_impl
{
    static const bool value = (::boost::type_traits::ice_or< ::boost::is_integral<T>::value, ::boost::is_float<T>::value >::value);




};

}






template< typename T > struct is_arithmetic : public ::boost::integral_constant<bool,::boost::detail::is_arithmetic_impl<T>::value> { public: };


}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 49 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_arithmetic.hpp" 2
# 12 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_scalar.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_enum.hpp" 1
# 32 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_enum.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 32 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_enum.hpp" 2


namespace boost {
# 181 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_enum.hpp"
template< typename T > struct is_enum : public ::boost::integral_constant<bool,__is_enum(T)> { public: };



}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 187 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_enum.hpp" 2
# 13 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_scalar.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_pointer.hpp" 1
# 24 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_pointer.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_member_pointer.hpp" 1
# 28 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_member_pointer.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_member_function_pointer.hpp" 1
# 24 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_member_function_pointer.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/is_mem_fun_pointer_impl.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/is_mem_fun_pointer_impl.hpp"
namespace boost {
namespace type_traits {

template <typename T>
struct is_mem_fun_pointer_impl
{
    static const bool value = false;
};





template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) > { static const bool value = true; };



template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() const > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() volatile > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() const volatile > { static const bool value = true; };


template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) const > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) volatile > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) > { static const bool value = true; };



template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) const > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) volatile > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) const volatile > { static const bool value = true; };


template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) const > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) const volatile > { static const bool value = true; };
# 776 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/is_mem_fun_pointer_impl.hpp"
}
}
# 24 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_member_function_pointer.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_cv.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_cv.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 2 3
# 19 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_cv.hpp" 2







# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 26 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_cv.hpp" 2


namespace boost {



namespace detail{

template <class T>
struct rvalue_ref_filter_rem_cv
{
   typedef typename boost::detail::cv_traits_imp<T*>::unqualified_type type;
};
# 52 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_cv.hpp"
}



template< typename T > struct remove_cv { public: typedef typename boost::detail::rvalue_ref_filter_rem_cv<T>::type type; };
template< typename T > struct remove_cv<T&> { public: typedef T& type; };

template< typename T, std::size_t N > struct remove_cv<T const[N]> { public: typedef T type[N]; };
template< typename T, std::size_t N > struct remove_cv<T volatile[N]> { public: typedef T type[N]; };
template< typename T, std::size_t N > struct remove_cv<T const volatile[N]> { public: typedef T type[N]; };
# 80 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_cv.hpp"
}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_cv.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_member_function_pointer.hpp" 2
# 36 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_member_function_pointer.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 36 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_member_function_pointer.hpp" 2


namespace boost {





template< typename T > struct is_member_function_pointer : public ::boost::integral_constant<bool,::boost::type_traits::is_mem_fun_pointer_impl<typename remove_cv<T>::type>::value> { public: };
# 132 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_member_function_pointer.hpp"
}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 134 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_member_function_pointer.hpp" 2
# 28 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_member_pointer.hpp" 2
# 39 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_member_pointer.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 39 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_member_pointer.hpp" 2


namespace boost {
# 50 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_member_pointer.hpp"
template< typename T > struct is_member_pointer : public ::boost::integral_constant<bool,::boost::is_member_function_pointer<T>::value> { public: };
template< typename T, typename U > struct is_member_pointer< U T::* > : public ::boost::integral_constant<bool,true> { public: };


template< typename T, typename U > struct is_member_pointer< U T::*const > : public ::boost::integral_constant<bool,true> { public: };
template< typename T, typename U > struct is_member_pointer< U T::*volatile > : public ::boost::integral_constant<bool,true> { public: };
template< typename T, typename U > struct is_member_pointer< U T::*const volatile > : public ::boost::integral_constant<bool,true> { public: };
# 112 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_member_pointer.hpp"
}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 114 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_member_pointer.hpp" 2
# 24 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_pointer.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_pointer.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_pointer.hpp" 2


namespace boost {





namespace detail {

template< typename T > struct is_pointer_helper
{
    static const bool value = false;
};
# 63 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_pointer.hpp"
template< typename T > struct is_pointer_helper<T*> { static const bool value = true; };



template< typename T >
struct is_pointer_impl
{
# 80 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_pointer.hpp"
    static const bool value = (::boost::type_traits::ice_and< ::boost::detail::is_pointer_helper<typename remove_cv<T>::type>::value , ::boost::type_traits::ice_not< ::boost::is_member_pointer<T>::value >::value >::value);
# 89 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_pointer.hpp"
};

}

template< typename T > struct is_pointer : public ::boost::integral_constant<bool,::boost::detail::is_pointer_impl<T>::value> { public: };
# 158 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_pointer.hpp"
}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 160 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_pointer.hpp" 2
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_scalar.hpp" 2






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 20 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_scalar.hpp" 2


namespace boost {

namespace detail {

template <typename T>
struct is_scalar_impl
{
   static const bool value = (::boost::type_traits::ice_or< ::boost::is_arithmetic<T>::value, ::boost::is_enum<T>::value, ::boost::is_pointer<T>::value, ::boost::is_member_pointer<T>::value >::value);






};



template <> struct is_scalar_impl<void>{ static const bool value = false; };

template <> struct is_scalar_impl<void const>{ static const bool value = false; };
template <> struct is_scalar_impl<void volatile>{ static const bool value = false; };
template <> struct is_scalar_impl<void const volatile>{ static const bool value = false; };


}

template< typename T > struct is_scalar : public ::boost::integral_constant<bool,::boost::detail::is_scalar_impl<T>::value> { public: };

}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 53 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_scalar.hpp" 2
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_pod.hpp" 2




# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 2 3
# 18 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_pod.hpp" 2



# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 21 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_pod.hpp" 2








namespace boost {


template< typename T > struct is_POD;

namespace detail {



template <typename T> struct is_pod_impl
{
    static const bool value = (::boost::type_traits::ice_or< ::boost::is_scalar<T>::value, ::boost::is_void<T>::value, __is_pod(T) >::value);






};


template <typename T, std::size_t sz>
struct is_pod_impl<T[sz]>
    : public is_pod_impl<T>
{
};
# 124 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_pod.hpp"
template<> struct is_pod_impl< void > { public: static const bool value = (true); };


template<> struct is_pod_impl< void const > { public: static const bool value = (true); };
template<> struct is_pod_impl< void volatile > { public: static const bool value = (true); };
template<> struct is_pod_impl< void const volatile > { public: static const bool value = (true); };


}

template< typename T > struct is_POD : public ::boost::integral_constant<bool,::boost::detail::is_pod_impl<T>::value> { public: };
template< typename T > struct is_pod : public ::boost::integral_constant<bool,::boost::detail::is_pod_impl<T>::value> { public: };

}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 139 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_pod.hpp" 2
# 18 "/home/marek/devel/nupic/external/common/include/boost/type_traits/type_with_alignment.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/static_assert.hpp" 1
# 51 "/home/marek/devel/nupic/external/common/include/boost/static_assert.hpp"
namespace boost{


template <bool x> struct STATIC_ASSERTION_FAILURE;

template <> struct STATIC_ASSERTION_FAILURE<true> { enum { value = 1 }; };


template<int x> struct static_assert_test{};

}
# 19 "/home/marek/devel/nupic/external/common/include/boost/type_traits/type_with_alignment.hpp" 2




# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 23 "/home/marek/devel/nupic/external/common/include/boost/type_traits/type_with_alignment.hpp" 2


# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 2 3
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/type_with_alignment.hpp" 2







namespace boost {



namespace detail {

class alignment_dummy;
typedef void (*function_ptr)();
typedef int (alignment_dummy::*member_ptr);
typedef int (alignment_dummy::*member_function_ptr)();
# 101 "/home/marek/devel/nupic/external/common/include/boost/type_traits/type_with_alignment.hpp"
template <bool found, std::size_t target, class TestType>
struct lower_alignment_helper
{
    typedef char type;
    enum { value = true };
};

template <std::size_t target, class TestType>
struct lower_alignment_helper<false,target,TestType>
{
    enum { value = (alignment_of<TestType>::value == target) };
    typedef typename mpl::if_c<value, TestType, char>::type type;
};
# 127 "/home/marek/devel/nupic/external/common/include/boost/type_traits/type_with_alignment.hpp"
template <typename T>
struct has_one_T
{
  T data;
};

template <std::size_t target>
union lower_alignment
{
    enum { found0 = false };

    typename lower_alignment_helper< found0,target,char >::type t0; enum { found1 = lower_alignment_helper<found0,target,char >::value }; typename lower_alignment_helper< found1,target,short >::type t1; enum { found2 = lower_alignment_helper<found1,target,short >::value }; typename lower_alignment_helper< found2,target,int >::type t2; enum { found3 = lower_alignment_helper<found2,target,int >::value }; typename lower_alignment_helper< found3,target,long >::type t3; enum { found4 = lower_alignment_helper<found3,target,long >::value }; typename lower_alignment_helper< found4,target,::boost::long_long_type >::type t4; enum { found5 = lower_alignment_helper<found4,target,::boost::long_long_type >::value }; typename lower_alignment_helper< found5,target,float >::type t5; enum { found6 = lower_alignment_helper<found5,target,float >::value }; typename lower_alignment_helper< found6,target,double >::type t6; enum { found7 = lower_alignment_helper<found6,target,double >::value }; typename lower_alignment_helper< found7,target,long double >::type t7; enum { found8 = lower_alignment_helper<found7,target,long double >::value }; typename lower_alignment_helper< found8,target,void* >::type t8; enum { found9 = lower_alignment_helper<found8,target,void* >::value }; typename lower_alignment_helper< found9,target,function_ptr >::type t9; enum { found10 = lower_alignment_helper<found9,target,function_ptr >::value }; typename lower_alignment_helper< found10,target,member_ptr >::type t10; enum { found11 = lower_alignment_helper<found10,target,member_ptr >::value }; typename lower_alignment_helper< found11,target,member_function_ptr >::type t11; enum { found12 = lower_alignment_helper<found11,target,member_function_ptr >::value }; typename lower_alignment_helper< found12,target,boost::detail::has_one_T< char > >::type t12; enum { found13 = lower_alignment_helper<found12,target,boost::detail::has_one_T< char > >::value }; typename lower_alignment_helper< found13,target,boost::detail::has_one_T< short > >::type t13; enum { found14 = lower_alignment_helper<found13,target,boost::detail::has_one_T< short > >::value }; typename lower_alignment_helper< found14,target,boost::detail::has_one_T< int > >::type t14; enum { found15 = lower_alignment_helper<found14,target,boost::detail::has_one_T< int > >::value }; typename lower_alignment_helper< found15,target,boost::detail::has_one_T< long > >::type t15; enum { found16 = lower_alignment_helper<found15,target,boost::detail::has_one_T< long > >::value }; typename lower_alignment_helper< found16,target,boost::detail::has_one_T< ::boost::long_long_type > >::type t16; enum { found17 = lower_alignment_helper<found16,target,boost::detail::has_one_T< ::boost::long_long_type > >::value }; typename lower_alignment_helper< found17,target,boost::detail::has_one_T< float > >::type t17; enum { found18 = lower_alignment_helper<found17,target,boost::detail::has_one_T< float > >::value }; typename lower_alignment_helper< found18,target,boost::detail::has_one_T< double > >::type t18; enum { found19 = lower_alignment_helper<found18,target,boost::detail::has_one_T< double > >::value }; typename lower_alignment_helper< found19,target,boost::detail::has_one_T< long double > >::type t19; enum { found20 = lower_alignment_helper<found19,target,boost::detail::has_one_T< long double > >::value }; typename lower_alignment_helper< found20,target,boost::detail::has_one_T< void* > >::type t20; enum { found21 = lower_alignment_helper<found20,target,boost::detail::has_one_T< void* > >::value }; typename lower_alignment_helper< found21,target,boost::detail::has_one_T< function_ptr > >::type t21; enum { found22 = lower_alignment_helper<found21,target,boost::detail::has_one_T< function_ptr > >::value }; typename lower_alignment_helper< found22,target,boost::detail::has_one_T< member_ptr > >::type t22; enum { found23 = lower_alignment_helper<found22,target,boost::detail::has_one_T< member_ptr > >::value }; typename lower_alignment_helper< found23,target,boost::detail::has_one_T< member_function_ptr > >::type t23; enum { found24 = lower_alignment_helper<found23,target,boost::detail::has_one_T< member_function_ptr > >::value };




};

union max_align
{
    char t0; short t1; int t2; long t3; ::boost::long_long_type t4; float t5; double t6; long double t7; void* t8; function_ptr t9; member_ptr t10; member_function_ptr t11; boost::detail::has_one_T< char > t12; boost::detail::has_one_T< short > t13; boost::detail::has_one_T< int > t14; boost::detail::has_one_T< long > t15; boost::detail::has_one_T< ::boost::long_long_type > t16; boost::detail::has_one_T< float > t17; boost::detail::has_one_T< double > t18; boost::detail::has_one_T< long double > t19; boost::detail::has_one_T< void* > t20; boost::detail::has_one_T< function_ptr > t21; boost::detail::has_one_T< member_ptr > t22; boost::detail::has_one_T< member_function_ptr > t23;




};
# 161 "/home/marek/devel/nupic/external/common/include/boost/type_traits/type_with_alignment.hpp"
template<std::size_t TAlign, std::size_t Align>
struct is_aligned
{
    static const bool value = (TAlign >= Align) & (TAlign % Align == 0);


};
# 180 "/home/marek/devel/nupic/external/common/include/boost/type_traits/type_with_alignment.hpp"
}


template<std::size_t Align>
struct is_pod< ::boost::detail::lower_alignment<Align> >
{
        static const std::size_t value = true;
};




namespace detail{

template <std::size_t Align>
class type_with_alignment_imp
{
    typedef ::boost::detail::lower_alignment<Align> t1;
    typedef typename mpl::if_c<
          ::boost::detail::is_aligned< ::boost::alignment_of<t1>::value,Align >::value
        , t1
        , ::boost::detail::max_align
        >::type align_t;

    static const std::size_t found = alignment_of<align_t>::value;

    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((found >= Align) == 0 ? false : true) >)> boost_static_assert_typedef_206;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((found % Align == 0) == 0 ? false : true) >)> boost_static_assert_typedef_207;

 public:
    typedef align_t type;
};

}

template <std::size_t Align>
class type_with_alignment
  : public ::boost::detail::type_with_alignment_imp<Align>
{
};


namespace align {
struct __attribute__((__aligned__(2))) a2 {};
struct __attribute__((__aligned__(4))) a4 {};
struct __attribute__((__aligned__(8))) a8 {};
struct __attribute__((__aligned__(16))) a16 {};
struct __attribute__((__aligned__(32))) a32 {};
struct __attribute__((__aligned__(64))) a64 {};
struct __attribute__((__aligned__(128))) a128 {};
}

template<> class type_with_alignment<1> { public: typedef char type; };
template<> class type_with_alignment<2> { public: typedef align::a2 type; };
template<> class type_with_alignment<4> { public: typedef align::a4 type; };
template<> class type_with_alignment<8> { public: typedef align::a8 type; };
template<> class type_with_alignment<16> { public: typedef align::a16 type; };
template<> class type_with_alignment<32> { public: typedef align::a32 type; };
template<> class type_with_alignment<64> { public: typedef align::a64 type; };
template<> class type_with_alignment<128> { public: typedef align::a128 type; };

namespace detail {
template<> struct is_pod_impl< ::boost::align::a2 > { public: static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a4 > { public: static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a8 > { public: static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a16 > { public: static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a32 > { public: static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a64 > { public: static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a128 > { public: static const bool value = (true); };
}
# 389 "/home/marek/devel/nupic/external/common/include/boost/type_traits/type_with_alignment.hpp"
}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 395 "/home/marek/devel/nupic/external/common/include/boost/type_traits/type_with_alignment.hpp" 2
# 21 "/home/marek/devel/nupic/external/common/include/boost/aligned_storage.hpp" 2



# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/eval_if.hpp" 1
# 24 "/home/marek/devel/nupic/external/common/include/boost/mpl/eval_if.hpp"
namespace boost { namespace mpl {

template<
      typename C = na
    , typename F1 = na
    , typename F2 = na
    >
struct eval_if




{
    typedef typename if_<C,F1,F2>::type f_;
    typedef typename f_::type type;





};



template<
      bool C
    , typename F1
    , typename F2
    >
struct eval_if_c




{
    typedef typename if_c<C,F1,F2>::type f_;
    typedef typename f_::type type;




};

template<> struct eval_if< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : eval_if< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< eval_if< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef eval_if< na , na , na > result_; typedef eval_if< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< eval_if< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< eval_if< na , na , na > > : int_<-1> { }; }

}}
# 24 "/home/marek/devel/nupic/external/common/include/boost/aligned_storage.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/identity.hpp" 1
# 20 "/home/marek/devel/nupic/external/common/include/boost/mpl/identity.hpp"
namespace boost { namespace mpl {

template<
      typename T = na
    >
struct identity
{
    typedef T type;

};

template<
      typename T = na
    >
struct make_identity
{
    typedef identity<T> type;

};

template<> struct identity< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : identity< T1 > { }; }; template< typename Tag > struct lambda< identity< na > , Tag , int_<-1> > { typedef false_ is_le; typedef identity< na > result_; typedef identity< na > type; }; namespace aux { template< typename T1 > struct template_arity< identity< T1 > > : int_<1> { }; template<> struct template_arity< identity< na > > : int_<-1> { }; }
template<> struct make_identity< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : make_identity< T1 > { }; }; template< typename Tag > struct lambda< make_identity< na > , Tag , int_<-1> > { typedef false_ is_le; typedef make_identity< na > result_; typedef make_identity< na > type; }; namespace aux { template< typename T1 > struct template_arity< make_identity< T1 > > : int_<1> { }; template<> struct template_arity< make_identity< na > > : int_<-1> { }; }

}}
# 25 "/home/marek/devel/nupic/external/common/include/boost/aligned_storage.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 27 "/home/marek/devel/nupic/external/common/include/boost/aligned_storage.hpp" 2


namespace boost {

namespace detail { namespace aligned_storage {

static const std::size_t alignment_of_max_align = ::boost::alignment_of<max_align>::value;







template <
      std::size_t size_
    , std::size_t alignment_
>
struct aligned_storage_imp
{
    union data_t
    {
        char buf[size_];

        typename mpl::eval_if_c<
              alignment_ == std::size_t(-1)
            , mpl::identity<detail::max_align>
            , type_with_alignment<alignment_>
            >::type align_;
    } data_;
    void* address() const { return const_cast<aligned_storage_imp*>(this); }
};

template< std::size_t alignment_ >
struct aligned_storage_imp<0u,alignment_>
{

    void* address() const { return 0; }
};

}}

template <
      std::size_t size_
    , std::size_t alignment_ = std::size_t(-1)
>
class aligned_storage :

   private



   detail::aligned_storage::aligned_storage_imp<size_, alignment_>
{

public:

    typedef detail::aligned_storage::aligned_storage_imp<size_, alignment_> type;

    static const std::size_t size = size_;



    static const std::size_t alignment = ( alignment_ == std::size_t(-1) ? ::boost::detail::aligned_storage::alignment_of_max_align : alignment_ );
# 104 "/home/marek/devel/nupic/external/common/include/boost/aligned_storage.hpp"
private:

    aligned_storage(const aligned_storage&);
    aligned_storage& operator=(const aligned_storage&);
# 118 "/home/marek/devel/nupic/external/common/include/boost/aligned_storage.hpp"
public:

    aligned_storage()
    {
    }

    ~aligned_storage()
    {
    }

public:

    void* address()
    {
        return static_cast<type*>(this)->address();
    }



    const void* address() const
    {
        return static_cast<const type*>(this)->address();
    }







};
# 168 "/home/marek/devel/nupic/external/common/include/boost/aligned_storage.hpp"
template <std::size_t size_, std::size_t alignment_>
struct is_pod<boost::detail::aligned_storage::aligned_storage_imp<size_,alignment_> >
   : public ::boost::integral_constant<bool,true>
{

};



}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 179 "/home/marek/devel/nupic/external/common/include/boost/aligned_storage.hpp" 2
# 11 "/home/marek/devel/nupic/external/common/include/boost/type_traits/aligned_storage.hpp" 2
# 20 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/common_type.hpp" 1
# 29 "/home/marek/devel/nupic/external/common/include/boost/type_traits/common_type.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/typeof/typeof.hpp" 1
# 208 "/home/marek/devel/nupic/external/common/include/boost/typeof/typeof.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/typeof/message.hpp" 1
# 208 "/home/marek/devel/nupic/external/common/include/boost/typeof/typeof.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/typeof/native.hpp" 1
# 21 "/home/marek/devel/nupic/external/common/include/boost/typeof/native.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_function.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_function.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/false_result.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/false_result.hpp"
namespace boost {
namespace type_traits {


struct false_result
{
    template <typename T> struct result_
    {
        static const bool value = false;
    };
};

}}
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_function.hpp" 2




# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/is_function_ptr_helper.hpp" 1
# 26 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/is_function_ptr_helper.hpp"
namespace boost {
namespace type_traits {

template <class R>
struct is_function_ptr_helper
{
    static const bool value = false;
};




template <class R >
struct is_function_ptr_helper<R (*)()> { static const bool value = true; };

template <class R >
struct is_function_ptr_helper<R (*)( ...)> { static const bool value = true; };

template <class R , class T0>
struct is_function_ptr_helper<R (*)( T0)> { static const bool value = true; };

template <class R , class T0>
struct is_function_ptr_helper<R (*)( T0 ...)> { static const bool value = true; };

template <class R , class T0 , class T1>
struct is_function_ptr_helper<R (*)( T0 , T1)> { static const bool value = true; };

template <class R , class T0 , class T1>
struct is_function_ptr_helper<R (*)( T0 , T1 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...)> { static const bool value = true; };
# 203 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/is_function_ptr_helper.hpp"
}
}
# 19 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_function.hpp" 2







# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 26 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_function.hpp" 2








namespace boost {



namespace detail {


template<bool is_ref = true>
struct is_function_chooser
    : public ::boost::type_traits::false_result
{
};

template <>
struct is_function_chooser<false>
{
    template< typename T > struct result_
        : public ::boost::type_traits::is_function_ptr_helper<T*>
    {
    };
};

template <typename T>
struct is_function_impl
    : public is_function_chooser< ::boost::is_reference<T>::value >
        ::template result_<T>
{
};
# 90 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_function.hpp"
}






template< typename T > struct is_function : public ::boost::integral_constant<bool,::boost::detail::is_function_impl<T>::value> { public: };




}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 104 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_function.hpp" 2
# 21 "/home/marek/devel/nupic/external/common/include/boost/typeof/native.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/utility/enable_if.hpp" 1
# 24 "/home/marek/devel/nupic/external/common/include/boost/utility/enable_if.hpp"
namespace boost
{

  template <bool B, class T = void>
  struct enable_if_c {
    typedef T type;
  };

  template <class T>
  struct enable_if_c<false, T> {};

  template <class Cond, class T = void>
  struct enable_if : public enable_if_c<Cond::value, T> {};

  template <bool B, class T>
  struct lazy_enable_if_c {
    typedef typename T::type type;
  };

  template <class T>
  struct lazy_enable_if_c<false, T> {};

  template <class Cond, class T>
  struct lazy_enable_if : public lazy_enable_if_c<Cond::value, T> {};


  template <bool B, class T = void>
  struct disable_if_c {
    typedef T type;
  };

  template <class T>
  struct disable_if_c<true, T> {};

  template <class Cond, class T = void>
  struct disable_if : public disable_if_c<Cond::value, T> {};

  template <bool B, class T>
  struct lazy_disable_if_c {
    typedef typename T::type type;
  };

  template <class T>
  struct lazy_disable_if_c<true, T> {};

  template <class Cond, class T>
  struct lazy_disable_if : public lazy_disable_if_c<Cond::value, T> {};

}
# 22 "/home/marek/devel/nupic/external/common/include/boost/typeof/native.hpp" 2


namespace boost { namespace type_of {




    template<typename T>
        typename enable_if<is_function<T>, T&>::type
        ensure_obj(T&);

    template<typename T>
        typename disable_if<is_function<T>, T&>::type
        ensure_obj(const T&);

}}
# 209 "/home/marek/devel/nupic/external/common/include/boost/typeof/typeof.hpp" 2
# 29 "/home/marek/devel/nupic/external/common/include/boost/type_traits/common_type.hpp" 2
# 54 "/home/marek/devel/nupic/external/common/include/boost/type_traits/common_type.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/utility/declval.hpp" 1
# 38 "/home/marek/devel/nupic/external/common/include/boost/utility/declval.hpp"
namespace boost {


    template <typename T>
    typename add_rvalue_reference<T>::type declval() ;




}
# 54 "/home/marek/devel/nupic/external/common/include/boost/type_traits/common_type.hpp" 2
# 66 "/home/marek/devel/nupic/external/common/include/boost/type_traits/common_type.hpp"
namespace boost {






    template <class T, class U = void, class V = void>
    struct common_type
    {
    public:
        typedef typename common_type<typename common_type<T, U>::type, V>::type type;
    };




    template<typename T>



    struct common_type<T, void, void>


    {
        typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((sizeof(T) > 0) == 0 ? false : true) >)> boost_static_assert_typedef_91;
    public:
        typedef T type;
    };


namespace type_traits_detail {

    template <class T, class U>
    struct common_type_2
    {
    private:
        typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((sizeof(T) > 0) == 0 ? false : true) >)> boost_static_assert_typedef_103;
        typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((sizeof(U) > 0) == 0 ? false : true) >)> boost_static_assert_typedef_104;
        static bool declval_bool();
        static typename add_rvalue_reference<T>::type declval_T();
        static typename add_rvalue_reference<U>::type declval_U();
        static typename add_rvalue_reference<bool>::type declval_b();
# 120 "/home/marek/devel/nupic/external/common/include/boost/type_traits/common_type.hpp"
    public:
        typedef __typeof__(boost::type_of::ensure_obj(declval_b() ? declval_T() : declval_U())) type;






    };

    template <class T>
    struct common_type_2<T, T>
    {
        typedef T type;
    };
    }





    template <class T, class U>
    struct common_type<T, U, void>

    : public type_traits_detail::common_type_2<T,U>
    { };
# 156 "/home/marek/devel/nupic/external/common/include/boost/type_traits/common_type.hpp"
}
# 22 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/conditional.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/conditional.hpp"
namespace boost {

template <bool b, class T, class U>
struct conditional : public mpl::if_c<b, T, U>
{
};

}
# 23 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/decay.hpp" 1
# 13 "/home/marek/devel/nupic/external/common/include/boost/type_traits/decay.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_array.hpp" 1
# 24 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_array.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 2 3
# 24 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_array.hpp" 2



# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 27 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_array.hpp" 2


namespace boost {




template< typename T > struct is_array : public ::boost::integral_constant<bool,false> { public: };

template< typename T, std::size_t N > struct is_array< T[N] > : public ::boost::integral_constant<bool,true> { public: };
template< typename T, std::size_t N > struct is_array< T const[N] > : public ::boost::integral_constant<bool,true> { public: };
template< typename T, std::size_t N > struct is_array< T volatile[N] > : public ::boost::integral_constant<bool,true> { public: };
template< typename T, std::size_t N > struct is_array< T const volatile[N] > : public ::boost::integral_constant<bool,true> { public: };

template< typename T > struct is_array< T[] > : public ::boost::integral_constant<bool,true> { public: };
template< typename T > struct is_array< T const[] > : public ::boost::integral_constant<bool,true> { public: };
template< typename T > struct is_array< T volatile[] > : public ::boost::integral_constant<bool,true> { public: };
template< typename T > struct is_array< T const volatile[] > : public ::boost::integral_constant<bool,true> { public: };
# 87 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_array.hpp"
}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 89 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_array.hpp" 2
# 13 "/home/marek/devel/nupic/external/common/include/boost/type_traits/decay.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_bounds.hpp" 1
# 13 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_bounds.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 2 3
# 13 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_bounds.hpp" 2








# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 21 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_bounds.hpp" 2




namespace boost {

template< typename T > struct remove_bounds { public: typedef T type; };


template< typename T, std::size_t N > struct remove_bounds<T[N]> { public: typedef T type; };
template< typename T, std::size_t N > struct remove_bounds<T const[N]> { public: typedef T const type; };
template< typename T, std::size_t N > struct remove_bounds<T volatile[N]> { public: typedef T volatile type; };
template< typename T, std::size_t N > struct remove_bounds<T const volatile[N]> { public: typedef T const volatile type; };

template< typename T > struct remove_bounds<T[]> { public: typedef T type; };
template< typename T > struct remove_bounds<T const[]> { public: typedef T const type; };
template< typename T > struct remove_bounds<T volatile[]> { public: typedef T volatile type; };
template< typename T > struct remove_bounds<T const volatile[]> { public: typedef T const volatile type; };



}




# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 46 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_bounds.hpp" 2
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/decay.hpp" 2






namespace boost
{

    template< class T >
    struct decay
    {
    private:
        typedef typename remove_reference<T>::type Ty;
    public:
        typedef typename mpl::eval_if<
            is_array<Ty>,
            mpl::identity<typename remove_bounds<Ty>::type*>,
            typename mpl::eval_if<
                is_function<Ty>,
                add_pointer<Ty>,
                mpl::identity<Ty>
            >
        >::type type;
    };

}
# 24 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/extent.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/extent.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/size_t_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/size_t_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/size_t_trait_def.hpp" 2





# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 2 3
# 19 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/size_t_trait_def.hpp" 2
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/extent.hpp" 2


namespace boost {

namespace detail{
# 29 "/home/marek/devel/nupic/external/common/include/boost/type_traits/extent.hpp"
template <class T, std::size_t N>
struct extent_imp
{
   static const std::size_t value = 0;
};

template <class T, std::size_t R, std::size_t N>
struct extent_imp<T[R], N>
{
   static const std::size_t value = (::boost::detail::extent_imp<T, N-1>::value);
};

template <class T, std::size_t R, std::size_t N>
struct extent_imp<T const[R], N>
{
   static const std::size_t value = (::boost::detail::extent_imp<T, N-1>::value);
};

template <class T, std::size_t R, std::size_t N>
struct extent_imp<T volatile[R], N>
{
   static const std::size_t value = (::boost::detail::extent_imp<T, N-1>::value);
};

template <class T, std::size_t R, std::size_t N>
struct extent_imp<T const volatile[R], N>
{
   static const std::size_t value = (::boost::detail::extent_imp<T, N-1>::value);
};

template <class T, std::size_t R>
struct extent_imp<T[R],0>
{
   static const std::size_t value = R;
};

template <class T, std::size_t R>
struct extent_imp<T const[R], 0>
{
   static const std::size_t value = R;
};

template <class T, std::size_t R>
struct extent_imp<T volatile[R], 0>
{
   static const std::size_t value = R;
};

template <class T, std::size_t R>
struct extent_imp<T const volatile[R], 0>
{
   static const std::size_t value = R;
};


template <class T, std::size_t N>
struct extent_imp<T[], N>
{
   static const std::size_t value = (::boost::detail::extent_imp<T, N-1>::value);
};
template <class T, std::size_t N>
struct extent_imp<T const[], N>
{
   static const std::size_t value = (::boost::detail::extent_imp<T, N-1>::value);
};
template <class T, std::size_t N>
struct extent_imp<T volatile[], N>
{
   static const std::size_t value = (::boost::detail::extent_imp<T, N-1>::value);
};
template <class T, std::size_t N>
struct extent_imp<T const volatile[], N>
{
   static const std::size_t value = (::boost::detail::extent_imp<T, N-1>::value);
};
template <class T>
struct extent_imp<T[], 0>
{
   static const std::size_t value = 0;
};
template <class T>
struct extent_imp<T const[], 0>
{
   static const std::size_t value = 0;
};
template <class T>
struct extent_imp<T volatile[], 0>
{
   static const std::size_t value = 0;
};
template <class T>
struct extent_imp<T const volatile[], 0>
{
   static const std::size_t value = 0;
};




}

template <class T, std::size_t N = 0>
struct extent
   : public ::boost::integral_constant<std::size_t, ::boost::detail::extent_imp<T,N>::value>
{





};

}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/size_t_trait_undef.hpp" 1
# 143 "/home/marek/devel/nupic/external/common/include/boost/type_traits/extent.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/floating_point_promotion.hpp" 1
# 21 "/home/marek/devel/nupic/external/common/include/boost/type_traits/floating_point_promotion.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 21 "/home/marek/devel/nupic/external/common/include/boost/type_traits/floating_point_promotion.hpp" 2


namespace boost {

namespace type_traits { namespace detail {



template<class T>
struct floating_point_promotion
{
    typedef T type;
};

template<>
struct floating_point_promotion<float>
{
    typedef double type;
};

template<>
struct floating_point_promotion<float const>
{
    typedef double const type;
};

template<>
struct floating_point_promotion<float volatile>
{
    typedef double volatile type;
};

template<>
struct floating_point_promotion<float const volatile>
{
    typedef double const volatile type;
};
# 78 "/home/marek/devel/nupic/external/common/include/boost/type_traits/floating_point_promotion.hpp"
} }

template< typename T > struct floating_point_promotion { public: typedef typename boost::type_traits::detail::floating_point_promotion<T>::type type; };





}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 88 "/home/marek/devel/nupic/external/common/include/boost/type_traits/floating_point_promotion.hpp" 2
# 26 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/function_traits.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/type_traits/function_traits.hpp"
namespace boost {


namespace detail {

template<typename Function> struct function_traits_helper;

template<typename R>
struct function_traits_helper<R (*)(void)>
{
  static const unsigned arity = 0;
  typedef R result_type;
};

template<typename R, typename T1>
struct function_traits_helper<R (*)(T1)>
{
  static const unsigned arity = 1;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T1 argument_type;
};

template<typename R, typename T1, typename T2>
struct function_traits_helper<R (*)(T1, T2)>
{
  static const unsigned arity = 2;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T1 first_argument_type;
  typedef T2 second_argument_type;
};

template<typename R, typename T1, typename T2, typename T3>
struct function_traits_helper<R (*)(T1, T2, T3)>
{
  static const unsigned arity = 3;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4>
struct function_traits_helper<R (*)(T1, T2, T3, T4)>
{
  static const unsigned arity = 4;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5)>
{
  static const unsigned arity = 5;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6)>
{
  static const unsigned arity = 6;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7)>
{
  static const unsigned arity = 7;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7, typename T8>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7, T8)>
{
  static const unsigned arity = 8;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
  typedef T8 arg8_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7, typename T8, typename T9>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7, T8, T9)>
{
  static const unsigned arity = 9;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
  typedef T8 arg8_type;
  typedef T9 arg9_type;
};

template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7, typename T8, typename T9,
         typename T10>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
{
  static const unsigned arity = 10;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
  typedef T8 arg8_type;
  typedef T9 arg9_type;
  typedef T10 arg10_type;
};

}

template<typename Function>
struct function_traits :
  public boost::detail::function_traits_helper<typename boost::add_pointer<Function>::type>
{
};
# 234 "/home/marek/devel/nupic/external/common/include/boost/type_traits/function_traits.hpp"
}
# 27 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_new_operator.hpp" 1
# 13 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_new_operator.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 2 3
# 13 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_new_operator.hpp" 2






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 19 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_new_operator.hpp" 2


namespace boost {
namespace detail {
    template <class U, U x>
    struct test;

    template <typename T>
    struct has_new_operator_impl {
        template<class U>
        static type_traits::yes_type check_sig1(
            U*,
            test<
            void *(*)(std::size_t),
                &U::operator new
            >* = __null
        );
        template<class U>
        static type_traits::no_type check_sig1(...);

        template<class U>
        static type_traits::yes_type check_sig2(
            U*,
            test<
            void *(*)(std::size_t, const std::nothrow_t&),
                &U::operator new
            >* = __null
        );
        template<class U>
        static type_traits::no_type check_sig2(...);

        template<class U>
        static type_traits::yes_type check_sig3(
            U*,
            test<
            void *(*)(std::size_t, void*),
                &U::operator new
            >* = __null
        );
        template<class U>
        static type_traits::no_type check_sig3(...);


        template<class U>
        static type_traits::yes_type check_sig4(
            U*,
            test<
            void *(*)(std::size_t),
                &U::operator new[]
            >* = __null
        );
        template<class U>
        static type_traits::no_type check_sig4(...);

        template<class U>
        static type_traits::yes_type check_sig5(
            U*,
            test<
            void *(*)(std::size_t, const std::nothrow_t&),
                &U::operator new[]
            >* = __null
        );
        template<class U>
        static type_traits::no_type check_sig5(...);

        template<class U>
        static type_traits::yes_type check_sig6(
            U*,
            test<
            void *(*)(std::size_t, void*),
                &U::operator new[]
            >* = __null
        );
        template<class U>
        static type_traits::no_type check_sig6(...);




            static const unsigned s1 = sizeof(has_new_operator_impl<T>::template check_sig1<T>(0));
            static const unsigned s2 = sizeof(has_new_operator_impl<T>::template check_sig2<T>(0));
            static const unsigned s3 = sizeof(has_new_operator_impl<T>::template check_sig3<T>(0));
            static const unsigned s4 = sizeof(has_new_operator_impl<T>::template check_sig4<T>(0));
            static const unsigned s5 = sizeof(has_new_operator_impl<T>::template check_sig5<T>(0));
            static const unsigned s6 = sizeof(has_new_operator_impl<T>::template check_sig6<T>(0));
# 121 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_new_operator.hpp"
        static const bool value = (::boost::type_traits::ice_or< (s1 == sizeof(type_traits::yes_type)), (s2 == sizeof(type_traits::yes_type)), (s3 == sizeof(type_traits::yes_type)), (s4 == sizeof(type_traits::yes_type)), (s5 == sizeof(type_traits::yes_type)), (s6 == sizeof(type_traits::yes_type)) >::value);
# 131 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_new_operator.hpp"
    };
}

template< typename T > struct has_new_operator : public ::boost::integral_constant<bool,::boost::detail::has_new_operator_impl<T>::value> { public: };

}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 138 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_new_operator.hpp" 2
# 29 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_nothrow_assign.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_nothrow_assign.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_trivial_assign.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_trivial_assign.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_const.hpp" 1
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_const.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_const.hpp" 2


namespace boost {







namespace detail{




template <class T>
struct is_const_rvalue_filter
{



   static const bool value = ::boost::detail::cv_traits_imp<T*>::is_const;

};







}


template< typename T > struct is_const : public ::boost::integral_constant<bool,::boost::detail::is_const_rvalue_filter<T>::value> { public: };
template< typename T > struct is_const< T& > : public ::boost::integral_constant<bool,false> { public: };
# 160 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_const.hpp"
}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 162 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_const.hpp" 2
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_trivial_assign.hpp" 2







# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 22 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_trivial_assign.hpp" 2


namespace boost {

namespace detail {

template <typename T>
struct has_trivial_assign_impl
{

   static const bool value = (__has_trivial_assign(T) && !is_volatile<T>::value);
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_trivial_assign.hpp"
};

}

template< typename T > struct has_trivial_assign : public ::boost::integral_constant<bool,::boost::detail::has_trivial_assign_impl<T>::value> { public: };
template<> struct has_trivial_assign< void > : public ::boost::integral_constant<bool,false> { public: };

template<> struct has_trivial_assign< void const > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_trivial_assign< void const volatile > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_trivial_assign< void volatile > : public ::boost::integral_constant<bool,false> { public: };


}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 55 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_trivial_assign.hpp" 2
# 12 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_nothrow_assign.hpp" 2



# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_nothrow_assign.hpp" 2


namespace boost {

namespace detail{

template <class T>
struct has_nothrow_assign_imp{



   static const bool value = (__has_nothrow_assign(T) && !is_volatile<T>::value);

};

}

template< typename T > struct has_nothrow_assign : public ::boost::integral_constant<bool,::boost::detail::has_nothrow_assign_imp<T>::value> { public: };
template<> struct has_nothrow_assign< void > : public ::boost::integral_constant<bool,false> { public: };

template<> struct has_nothrow_assign< void const > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_assign< void const volatile > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_assign< void volatile > : public ::boost::integral_constant<bool,false> { public: };


}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 42 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_nothrow_assign.hpp" 2
# 31 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_nothrow_constructor.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_nothrow_constructor.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_trivial_constructor.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_trivial_constructor.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 18 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_trivial_constructor.hpp" 2


namespace boost {

namespace detail {

template <typename T>
struct has_trivial_ctor_impl
{

   static const bool value = (::boost::type_traits::ice_or< ::boost::is_pod<T>::value, __has_trivial_constructor(T) >::value);
# 40 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_trivial_constructor.hpp"
};

}

template< typename T > struct has_trivial_constructor : public ::boost::integral_constant<bool,::boost::detail::has_trivial_ctor_impl<T>::value> { public: };
template< typename T > struct has_trivial_default_constructor : public ::boost::integral_constant<bool,::boost::detail::has_trivial_ctor_impl<T>::value> { public: };

}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 49 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_trivial_constructor.hpp" 2
# 12 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_nothrow_constructor.hpp" 2



# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_nothrow_constructor.hpp" 2


namespace boost {

namespace detail{

template <class T>
struct has_nothrow_constructor_imp{

   static const bool value = __has_nothrow_constructor(T);



};

}

template< typename T > struct has_nothrow_constructor : public ::boost::integral_constant<bool,::boost::detail::has_nothrow_constructor_imp<T>::value> { public: };
template< typename T > struct has_nothrow_default_constructor : public ::boost::integral_constant<bool,::boost::detail::has_nothrow_constructor_imp<T>::value> { public: };

template<> struct has_nothrow_constructor< void > : public ::boost::integral_constant<bool,false> { public: };

template<> struct has_nothrow_constructor< void const > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_constructor< void const volatile > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_constructor< void volatile > : public ::boost::integral_constant<bool,false> { public: };


template<> struct has_nothrow_default_constructor< void > : public ::boost::integral_constant<bool,false> { public: };

template<> struct has_nothrow_default_constructor< void const > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_default_constructor< void const volatile > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_default_constructor< void volatile > : public ::boost::integral_constant<bool,false> { public: };


}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 51 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_nothrow_constructor.hpp" 2
# 32 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_nothrow_copy.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_nothrow_copy.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_trivial_copy.hpp" 1
# 21 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_trivial_copy.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 21 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_trivial_copy.hpp" 2


namespace boost {

namespace detail {

template <typename T>
struct has_trivial_copy_impl
{

   static const bool value = (__has_trivial_copy(T) && !is_reference<T>::value && !is_volatile<T>::value);







};

}

template< typename T > struct has_trivial_copy : public ::boost::integral_constant<bool,::boost::detail::has_trivial_copy_impl<T>::value> { public: };
template< typename T > struct has_trivial_copy_constructor : public ::boost::integral_constant<bool,::boost::detail::has_trivial_copy_impl<T>::value> { public: };

template<> struct has_trivial_copy< void > : public ::boost::integral_constant<bool,false> { public: };

template<> struct has_trivial_copy< void const > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_trivial_copy< void const volatile > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_trivial_copy< void volatile > : public ::boost::integral_constant<bool,false> { public: };


template<> struct has_trivial_copy_constructor< void > : public ::boost::integral_constant<bool,false> { public: };

template<> struct has_trivial_copy_constructor< void const > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_trivial_copy_constructor< void const volatile > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_trivial_copy_constructor< void volatile > : public ::boost::integral_constant<bool,false> { public: };


}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 62 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_trivial_copy.hpp" 2
# 12 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_nothrow_copy.hpp" 2



# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_nothrow_copy.hpp" 2


namespace boost {

namespace detail{

template <class T>
struct has_nothrow_copy_imp{

   static const bool value = (__has_nothrow_copy(T) && !is_volatile<T>::value && !is_reference<T>::value);



};

}

template< typename T > struct has_nothrow_copy : public ::boost::integral_constant<bool,::boost::detail::has_nothrow_copy_imp<T>::value> { public: };
template< typename T > struct has_nothrow_copy_constructor : public ::boost::integral_constant<bool,::boost::detail::has_nothrow_copy_imp<T>::value> { public: };

template<> struct has_nothrow_copy< void > : public ::boost::integral_constant<bool,false> { public: };

template<> struct has_nothrow_copy< void const > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_copy< void const volatile > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_copy< void volatile > : public ::boost::integral_constant<bool,false> { public: };


template<> struct has_nothrow_copy_constructor< void > : public ::boost::integral_constant<bool,false> { public: };

template<> struct has_nothrow_copy_constructor< void const > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_copy_constructor< void const volatile > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_copy_constructor< void volatile > : public ::boost::integral_constant<bool,false> { public: };


}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 51 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_nothrow_copy.hpp" 2
# 33 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_nothrow_destructor.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_nothrow_destructor.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_trivial_destructor.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_trivial_destructor.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 18 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_trivial_destructor.hpp" 2


namespace boost {

namespace detail {

template <typename T>
struct has_trivial_dtor_impl
{

   static const bool value = __has_trivial_destructor(T);



};

}

template< typename T > struct has_trivial_destructor : public ::boost::integral_constant<bool,::boost::detail::has_trivial_dtor_impl<T>::value> { public: };

template<> struct has_trivial_destructor< void > : public ::boost::integral_constant<bool,false> { public: };

template<> struct has_trivial_destructor< void const > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_trivial_destructor< void const volatile > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_trivial_destructor< void volatile > : public ::boost::integral_constant<bool,false> { public: };


}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 47 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_trivial_destructor.hpp" 2
# 12 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_nothrow_destructor.hpp" 2



# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_nothrow_destructor.hpp" 2


namespace boost {

template< typename T > struct has_nothrow_destructor : public ::boost::integral_constant<bool,::boost::has_trivial_destructor<T>::value> { public: };

}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 23 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_nothrow_destructor.hpp" 2
# 34 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_bit_and.hpp" 1
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_bit_and.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_base_of.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_base_of.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_base_and_derived.hpp" 1
# 24 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_base_and_derived.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 24 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_base_and_derived.hpp" 2


namespace boost {

namespace detail {
# 222 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_base_and_derived.hpp"
template <typename B, typename D>
struct is_base_and_derived_impl
{
    typedef typename remove_cv<B>::type ncvB;
    typedef typename remove_cv<D>::type ncvD;

    static const bool value = ((__is_base_of(B,D) && !is_same<B,D>::value) && ! ::boost::is_same<ncvB,ncvD>::value);
};

}

template< typename Base, typename Derived > struct is_base_and_derived : public ::boost::integral_constant<bool,(::boost::detail::is_base_and_derived_impl<Base,Derived>::value)> { public: };







template< typename Base, typename Derived > struct is_base_and_derived< Base&,Derived > : public ::boost::integral_constant<bool,false> { public: };
template< typename Base, typename Derived > struct is_base_and_derived< Base,Derived& > : public ::boost::integral_constant<bool,false> { public: };
template< typename Base, typename Derived > struct is_base_and_derived< Base&,Derived& > : public ::boost::integral_constant<bool,false> { public: };






}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 252 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_base_and_derived.hpp" 2
# 12 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_base_of.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_class.hpp" 1
# 37 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_class.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 37 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_class.hpp" 2


namespace boost {

namespace detail {
# 120 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_class.hpp"
template <typename T>
struct is_class_impl
{
    static const bool value = __is_class(T);
};


}





template< typename T > struct is_class : public ::boost::integral_constant<bool,::boost::detail::is_class_impl<T>::value> { public: };


}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 138 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_class.hpp" 2
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_base_of.hpp" 2





# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 19 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_base_of.hpp" 2


namespace boost {

   namespace detail{
      template <class B, class D>
      struct is_base_of_imp
      {
          typedef typename remove_cv<B>::type ncvB;
          typedef typename remove_cv<D>::type ncvD;
          static const bool value = (::boost::type_traits::ice_or< (::boost::detail::is_base_and_derived_impl<ncvB,ncvD>::value), (::boost::type_traits::ice_and< ::boost::is_same<ncvB,ncvD>::value, ::boost::is_class<ncvB>::value>::value)>::value);


      };
   }

template< typename Base, typename Derived > struct is_base_of : public ::boost::integral_constant<bool,(::boost::detail::is_base_of_imp<Base, Derived>::value)> { public: };






template< typename Base, typename Derived > struct is_base_of< Base&,Derived > : public ::boost::integral_constant<bool,false> { public: };
template< typename Base, typename Derived > struct is_base_of< Base,Derived& > : public ::boost::integral_constant<bool,false> { public: };
template< typename Base, typename Derived > struct is_base_of< Base&,Derived& > : public ::boost::integral_constant<bool,false> { public: };


}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 49 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_base_of.hpp" 2
# 12 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_convertible.hpp" 1
# 37 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_convertible.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 37 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_convertible.hpp" 2


namespace boost {
# 423 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_convertible.hpp"
template< typename From, typename To > struct is_convertible : public ::boost::integral_constant<bool,(__is_convertible_to(From,To) && !::boost::is_abstract<To>::value)> { public: };



}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 429 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_convertible.hpp" 2
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_fundamental.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_fundamental.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 17 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_fundamental.hpp" 2


namespace boost {

namespace detail {

template <typename T>
struct is_fundamental_impl
    : public ::boost::type_traits::ice_or<
          ::boost::is_arithmetic<T>::value
        , ::boost::is_void<T>::value
        >
{
};

}





template< typename T > struct is_fundamental : public ::boost::integral_constant<bool,::boost::detail::is_fundamental_impl<T>::value> { public: };


}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_fundamental.hpp" 2
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_pointer.hpp" 1
# 26 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_pointer.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 26 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_pointer.hpp" 2


namespace boost {
# 76 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_pointer.hpp"
template< typename T > struct remove_pointer { public: typedef T type; };
template< typename T > struct remove_pointer<T*> { public: typedef T type; };
template< typename T > struct remove_pointer<T* const> { public: typedef T type; };
template< typename T > struct remove_pointer<T* volatile> { public: typedef T type; };
template< typename T > struct remove_pointer<T* const volatile> { public: typedef T type; };







}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 90 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_pointer.hpp" 2
# 21 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2




# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_bit_and_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator & (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() & make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() & make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() & make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_fundamental< Rhs_nocv >::value, ::boost::type_traits::ice_or< ::boost::type_traits::ice_not< ::boost::is_integral< Lhs_noref >::value >::value, ::boost::type_traits::ice_not< ::boost::is_integral< Rhs_noref >::value >::value >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_pointer< Rhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Rhs_nocv >::value, ::boost::is_pointer< Lhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_pointer< Rhs_noref >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_bit_and_impl::dont_care > struct has_bit_and : public ::boost::integral_constant<bool,(::boost::detail::has_bit_and_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_bit_and.hpp" 2
# 12 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_bit_and_assign.hpp" 1
# 49 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_bit_and_assign.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_bit_and_assign_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator &= (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() &= make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() &= make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() &= make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_fundamental< Rhs_nocv >::value, ::boost::type_traits::ice_or< ::boost::type_traits::ice_not< ::boost::is_integral< Lhs_noref >::value >::value, ::boost::type_traits::ice_not< ::boost::is_integral< Rhs_noref >::value >::value >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_pointer< Rhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Rhs_nocv >::value, ::boost::is_pointer< Lhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_pointer< Rhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_fundamental< Rhs_nocv >::value, ::boost::is_const< Lhs_noref >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_bit_and_assign_impl::dont_care > struct has_bit_and_assign : public ::boost::integral_constant<bool,(::boost::detail::has_bit_and_assign_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 49 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_bit_and_assign.hpp" 2
# 13 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_bit_or.hpp" 1
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_bit_or.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_bit_or_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator | (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() | make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() | make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() | make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_fundamental< Rhs_nocv >::value, ::boost::type_traits::ice_or< ::boost::type_traits::ice_not< ::boost::is_integral< Lhs_noref >::value >::value, ::boost::type_traits::ice_not< ::boost::is_integral< Rhs_noref >::value >::value >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_pointer< Rhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Rhs_nocv >::value, ::boost::is_pointer< Lhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_pointer< Rhs_noref >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_bit_or_impl::dont_care > struct has_bit_or : public ::boost::integral_constant<bool,(::boost::detail::has_bit_or_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_bit_or.hpp" 2
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_bit_or_assign.hpp" 1
# 49 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_bit_or_assign.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_bit_or_assign_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator |= (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() |= make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() |= make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() |= make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_fundamental< Rhs_nocv >::value, ::boost::type_traits::ice_or< ::boost::type_traits::ice_not< ::boost::is_integral< Lhs_noref >::value >::value, ::boost::type_traits::ice_not< ::boost::is_integral< Rhs_noref >::value >::value >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_pointer< Rhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Rhs_nocv >::value, ::boost::is_pointer< Lhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_pointer< Rhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_fundamental< Rhs_nocv >::value, ::boost::is_const< Lhs_noref >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_bit_or_assign_impl::dont_care > struct has_bit_or_assign : public ::boost::integral_constant<bool,(::boost::detail::has_bit_or_assign_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 49 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_bit_or_assign.hpp" 2
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_bit_xor.hpp" 1
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_bit_xor.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_bit_xor_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator ^ (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() ^ make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() ^ make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() ^ make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_fundamental< Rhs_nocv >::value, ::boost::type_traits::ice_or< ::boost::type_traits::ice_not< ::boost::is_integral< Lhs_noref >::value >::value, ::boost::type_traits::ice_not< ::boost::is_integral< Rhs_noref >::value >::value >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_pointer< Rhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Rhs_nocv >::value, ::boost::is_pointer< Lhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_pointer< Rhs_noref >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_bit_xor_impl::dont_care > struct has_bit_xor : public ::boost::integral_constant<bool,(::boost::detail::has_bit_xor_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_bit_xor.hpp" 2
# 16 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_bit_xor_assign.hpp" 1
# 49 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_bit_xor_assign.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_bit_xor_assign_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator ^= (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() ^= make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() ^= make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() ^= make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_fundamental< Rhs_nocv >::value, ::boost::type_traits::ice_or< ::boost::type_traits::ice_not< ::boost::is_integral< Lhs_noref >::value >::value, ::boost::type_traits::ice_not< ::boost::is_integral< Rhs_noref >::value >::value >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_pointer< Rhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Rhs_nocv >::value, ::boost::is_pointer< Lhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_pointer< Rhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_fundamental< Rhs_nocv >::value, ::boost::is_const< Lhs_noref >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_bit_xor_assign_impl::dont_care > struct has_bit_xor_assign : public ::boost::integral_constant<bool,(::boost::detail::has_bit_xor_assign_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 49 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_bit_xor_assign.hpp" 2
# 17 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_complement.hpp" 1
# 26 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_complement.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 1
# 23 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 23 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 2
# 35 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_complement_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator ~ (const any&);
# 76 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((~ make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Rhs >
struct operator_returns_Ret < Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Rhs >
struct operator_returns_Ret < Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Rhs >
struct operator_returns_Ret < Rhs, void, true > {
   static const bool value = true;
};

template < typename Rhs >
struct operator_returns_Ret < Rhs, void, false > {
   static const bool value = false;
};

template < typename Rhs, typename Ret >
struct operator_returns_Ret < Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Rhs, typename Ret >
struct operator_returns_Ret < Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(~ make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 144 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((~ make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 163 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3
template < typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Rhs, typename Ret >
struct trait_impl1 < Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Rhs, typename Ret >
struct trait_impl1 < Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Rhs >::value, operator_returns_Ret < Rhs, Ret, operator_returns_void < Rhs >::value >::value >::value );







};


template < typename Ret >
struct trait_impl1 < void, Ret, false > {
   static const bool value = false;
};


template < typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::is_pointer< Rhs_noref >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Rhs_noref >::value, ::boost::type_traits::ice_not< ::boost::is_integral< Rhs_noref >::value >::value >::value >::value >::value);
};

}
}


template< typename Rhs, typename Ret=::boost::detail::has_complement_impl::dont_care > struct has_complement : public ::boost::integral_constant<bool,(::boost::detail::has_complement_impl::trait_impl < Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 210 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 2 3
# 26 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_complement.hpp" 2
# 18 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_dereference.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_dereference.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 1
# 23 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 23 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 2
# 35 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_dereference_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator * (const any&);
# 76 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((* make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Rhs >
struct operator_returns_Ret < Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Rhs >
struct operator_returns_Ret < Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Rhs >
struct operator_returns_Ret < Rhs, void, true > {
   static const bool value = true;
};

template < typename Rhs >
struct operator_returns_Ret < Rhs, void, false > {
   static const bool value = false;
};

template < typename Rhs, typename Ret >
struct operator_returns_Ret < Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Rhs, typename Ret >
struct operator_returns_Ret < Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(* make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 144 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((* make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 163 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3
template < typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Rhs, typename Ret >
struct trait_impl1 < Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Rhs, typename Ret >
struct trait_impl1 < Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Rhs >::value, operator_returns_Ret < Rhs, Ret, operator_returns_void < Rhs >::value >::value >::value );







};


template < typename Ret >
struct trait_impl1 < void, Ret, false > {
   static const bool value = false;
};


template < typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_pointer< Rhs_noref >::value, ::boost::is_void< Rhs_noptr >::value >::value, ::boost::is_fundamental< Rhs_nocv >::value >::value >::value);
};

}
}


template< typename Rhs, typename Ret=::boost::detail::has_dereference_impl::dont_care > struct has_dereference : public ::boost::integral_constant<bool,(::boost::detail::has_dereference_impl::trait_impl < Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 210 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 2 3
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_dereference.hpp" 2
# 19 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_divides.hpp" 1
# 34 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_divides.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_divides_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator / (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() / make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() / make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() / make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::type_traits::ice_or< ::boost::is_fundamental< Rhs_nocv >::value, ::boost::is_pointer< Rhs_noref >::value >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Rhs_noref >::value, ::boost::type_traits::ice_or< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_pointer< Lhs_noref >::value >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_divides_impl::dont_care > struct has_divides : public ::boost::integral_constant<bool,(::boost::detail::has_divides_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 34 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_divides.hpp" 2
# 20 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_divides_assign.hpp" 1
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_divides_assign.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_divides_assign_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator /= (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() /= make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() /= make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() /= make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_const< Lhs_noref >::value, ::boost::is_fundamental< Rhs_nocv >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::type_traits::ice_or< ::boost::is_fundamental< Rhs_nocv >::value, ::boost::is_pointer< Rhs_noref >::value >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Rhs_noref >::value, ::boost::type_traits::ice_or< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_pointer< Lhs_noref >::value >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_divides_assign_impl::dont_care > struct has_divides_assign : public ::boost::integral_constant<bool,(::boost::detail::has_divides_assign_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_divides_assign.hpp" 2
# 21 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_equal_to.hpp" 1
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_equal_to.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_equal_to_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator == (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() == make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() == make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() == make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_fundamental< Rhs_nocv >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Rhs_noref >::value, ::boost::is_fundamental< Lhs_nocv >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_pointer< Rhs_noref >::value, ::boost::type_traits::ice_not< ::boost::type_traits::ice_or< ::boost::is_base_of< Lhs_noptr, Rhs_noptr >::value, ::boost::is_base_of< Rhs_noptr, Lhs_noptr >::value, ::boost::is_same< Lhs_noptr, Rhs_noptr >::value, ::boost::is_void< Lhs_noptr >::value, ::boost::is_void< Rhs_noptr >::value >::value >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_equal_to_impl::dont_care > struct has_equal_to : public ::boost::integral_constant<bool,(::boost::detail::has_equal_to_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_equal_to.hpp" 2
# 22 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_greater.hpp" 1
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_greater.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_greater_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator > (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() > make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() > make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() > make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_fundamental< Rhs_nocv >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Rhs_noref >::value, ::boost::is_fundamental< Lhs_nocv >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_pointer< Rhs_noref >::value, ::boost::type_traits::ice_not< ::boost::type_traits::ice_or< ::boost::is_base_of< Lhs_noptr, Rhs_noptr >::value, ::boost::is_base_of< Rhs_noptr, Lhs_noptr >::value, ::boost::is_same< Lhs_noptr, Rhs_noptr >::value, ::boost::is_void< Lhs_noptr >::value, ::boost::is_void< Rhs_noptr >::value >::value >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_greater_impl::dont_care > struct has_greater : public ::boost::integral_constant<bool,(::boost::detail::has_greater_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_greater.hpp" 2
# 23 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_greater_equal.hpp" 1
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_greater_equal.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_greater_equal_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator >= (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() >= make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() >= make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() >= make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_fundamental< Rhs_nocv >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Rhs_noref >::value, ::boost::is_fundamental< Lhs_nocv >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_pointer< Rhs_noref >::value, ::boost::type_traits::ice_not< ::boost::type_traits::ice_or< ::boost::is_base_of< Lhs_noptr, Rhs_noptr >::value, ::boost::is_base_of< Rhs_noptr, Lhs_noptr >::value, ::boost::is_same< Lhs_noptr, Rhs_noptr >::value, ::boost::is_void< Lhs_noptr >::value, ::boost::is_void< Rhs_noptr >::value >::value >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_greater_equal_impl::dont_care > struct has_greater_equal : public ::boost::integral_constant<bool,(::boost::detail::has_greater_equal_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_greater_equal.hpp" 2
# 24 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_left_shift.hpp" 1
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_left_shift.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_left_shift_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator << (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() << make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() << make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() << make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_fundamental< Rhs_nocv >::value, ::boost::type_traits::ice_or< ::boost::type_traits::ice_not< ::boost::is_integral< Lhs_noref >::value >::value, ::boost::type_traits::ice_not< ::boost::is_integral< Rhs_noref >::value >::value >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_pointer< Rhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Rhs_nocv >::value, ::boost::is_pointer< Lhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_pointer< Rhs_noref >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_left_shift_impl::dont_care > struct has_left_shift : public ::boost::integral_constant<bool,(::boost::detail::has_left_shift_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_left_shift.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_left_shift_assign.hpp" 1
# 49 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_left_shift_assign.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_left_shift_assign_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator <<= (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() <<= make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() <<= make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() <<= make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_fundamental< Rhs_nocv >::value, ::boost::type_traits::ice_or< ::boost::type_traits::ice_not< ::boost::is_integral< Lhs_noref >::value >::value, ::boost::type_traits::ice_not< ::boost::is_integral< Rhs_noref >::value >::value >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_pointer< Rhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Rhs_nocv >::value, ::boost::is_pointer< Lhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_pointer< Rhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_fundamental< Rhs_nocv >::value, ::boost::is_const< Lhs_noref >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_left_shift_assign_impl::dont_care > struct has_left_shift_assign : public ::boost::integral_constant<bool,(::boost::detail::has_left_shift_assign_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 49 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_left_shift_assign.hpp" 2
# 26 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_less.hpp" 1
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_less.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_less_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator < (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() < make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() < make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() < make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_fundamental< Rhs_nocv >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Rhs_noref >::value, ::boost::is_fundamental< Lhs_nocv >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_pointer< Rhs_noref >::value, ::boost::type_traits::ice_not< ::boost::type_traits::ice_or< ::boost::is_base_of< Lhs_noptr, Rhs_noptr >::value, ::boost::is_base_of< Rhs_noptr, Lhs_noptr >::value, ::boost::is_same< Lhs_noptr, Rhs_noptr >::value, ::boost::is_void< Lhs_noptr >::value, ::boost::is_void< Rhs_noptr >::value >::value >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_less_impl::dont_care > struct has_less : public ::boost::integral_constant<bool,(::boost::detail::has_less_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_less.hpp" 2
# 27 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_less_equal.hpp" 1
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_less_equal.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_less_equal_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator <= (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() <= make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() <= make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() <= make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_fundamental< Rhs_nocv >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Rhs_noref >::value, ::boost::is_fundamental< Lhs_nocv >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_pointer< Rhs_noref >::value, ::boost::type_traits::ice_not< ::boost::type_traits::ice_or< ::boost::is_base_of< Lhs_noptr, Rhs_noptr >::value, ::boost::is_base_of< Rhs_noptr, Lhs_noptr >::value, ::boost::is_same< Lhs_noptr, Rhs_noptr >::value, ::boost::is_void< Lhs_noptr >::value, ::boost::is_void< Rhs_noptr >::value >::value >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_less_equal_impl::dont_care > struct has_less_equal : public ::boost::integral_constant<bool,(::boost::detail::has_less_equal_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_less_equal.hpp" 2
# 28 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_logical_and.hpp" 1
# 34 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_logical_and.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_logical_and_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator && (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() && make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() && make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() && make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Rhs_nocv >::value, ::boost::type_traits::ice_not< ::boost::is_convertible< Rhs_nocv, bool >::value >::value >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Rhs_noref >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::type_traits::ice_not< ::boost::is_convertible< Lhs_nocv, bool >::value >::value >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_logical_and_impl::dont_care > struct has_logical_and : public ::boost::integral_constant<bool,(::boost::detail::has_logical_and_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 34 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_logical_and.hpp" 2
# 29 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_logical_not.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_logical_not.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 1
# 23 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 23 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 2
# 35 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_logical_not_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator ! (const any&);
# 76 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((! make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Rhs >
struct operator_returns_Ret < Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Rhs >
struct operator_returns_Ret < Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Rhs >
struct operator_returns_Ret < Rhs, void, true > {
   static const bool value = true;
};

template < typename Rhs >
struct operator_returns_Ret < Rhs, void, false > {
   static const bool value = false;
};

template < typename Rhs, typename Ret >
struct operator_returns_Ret < Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Rhs, typename Ret >
struct operator_returns_Ret < Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(! make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 144 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((! make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 163 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3
template < typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Rhs, typename Ret >
struct trait_impl1 < Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Rhs, typename Ret >
struct trait_impl1 < Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Rhs >::value, operator_returns_Ret < Rhs, Ret, operator_returns_void < Rhs >::value >::value >::value );







};


template < typename Ret >
struct trait_impl1 < void, Ret, false > {
   static const bool value = false;
};


template < typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Rhs_noref, Ret, false >::value);
};

}
}


template< typename Rhs, typename Ret=::boost::detail::has_logical_not_impl::dont_care > struct has_logical_not : public ::boost::integral_constant<bool,(::boost::detail::has_logical_not_impl::trait_impl < Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 210 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 2 3
# 17 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_logical_not.hpp" 2
# 30 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_logical_or.hpp" 1
# 34 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_logical_or.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_logical_or_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator || (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() || make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() || make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() || make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Rhs_nocv >::value, ::boost::type_traits::ice_not< ::boost::is_convertible< Rhs_nocv, bool >::value >::value >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Rhs_noref >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::type_traits::ice_not< ::boost::is_convertible< Lhs_nocv, bool >::value >::value >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_logical_or_impl::dont_care > struct has_logical_or : public ::boost::integral_constant<bool,(::boost::detail::has_logical_or_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 34 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_logical_or.hpp" 2
# 31 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_minus.hpp" 1
# 54 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_minus.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_minus_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator - (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() - make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() - make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() - make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_fundamental< Rhs_nocv >::value, ::boost::type_traits::ice_not< ::boost::is_integral< Rhs_noref >::value >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_void< Lhs_noptr >::value, ::boost::type_traits::ice_or< ::boost::is_fundamental< Rhs_nocv >::value, ::boost::is_pointer< Rhs_noref >::value >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Rhs_noref >::value, ::boost::is_void< Rhs_noptr >::value, ::boost::type_traits::ice_or< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_pointer< Lhs_noref >::value >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_pointer< Rhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_pointer< Rhs_noref >::value, ::boost::type_traits::ice_not< ::boost::is_same< Lhs_nocv, Rhs_nocv >::value >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_minus_impl::dont_care > struct has_minus : public ::boost::integral_constant<bool,(::boost::detail::has_minus_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 54 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_minus.hpp" 2
# 32 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_minus_assign.hpp" 1
# 59 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_minus_assign.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_minus_assign_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator -= (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() -= make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() -= make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() -= make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_fundamental< Rhs_nocv >::value, ::boost::type_traits::ice_not< ::boost::is_integral< Rhs_noref >::value >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_void< Lhs_noptr >::value, ::boost::is_fundamental< Rhs_nocv >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Rhs_noref >::value, ::boost::is_void< Rhs_noptr >::value, ::boost::is_fundamental< Lhs_nocv >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_pointer< Rhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_pointer< Rhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::type_traits::ice_or< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_pointer< Lhs_noref >::value >::value, ::boost::type_traits::ice_or< ::boost::is_fundamental< Rhs_nocv >::value, ::boost::is_pointer< Rhs_noref >::value >::value, ::boost::is_const< Lhs_noref >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_minus_assign_impl::dont_care > struct has_minus_assign : public ::boost::integral_constant<bool,(::boost::detail::has_minus_assign_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 59 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_minus_assign.hpp" 2
# 33 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_modulus.hpp" 1
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_modulus.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_modulus_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator % (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() % make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() % make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() % make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_fundamental< Rhs_nocv >::value, ::boost::type_traits::ice_or< ::boost::type_traits::ice_not< ::boost::is_integral< Lhs_noref >::value >::value, ::boost::type_traits::ice_not< ::boost::is_integral< Rhs_noref >::value >::value >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_pointer< Rhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Rhs_nocv >::value, ::boost::is_pointer< Lhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_pointer< Rhs_noref >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_modulus_impl::dont_care > struct has_modulus : public ::boost::integral_constant<bool,(::boost::detail::has_modulus_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_modulus.hpp" 2
# 34 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_modulus_assign.hpp" 1
# 49 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_modulus_assign.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_modulus_assign_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator %= (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() %= make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() %= make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() %= make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_fundamental< Rhs_nocv >::value, ::boost::type_traits::ice_or< ::boost::type_traits::ice_not< ::boost::is_integral< Lhs_noref >::value >::value, ::boost::type_traits::ice_not< ::boost::is_integral< Rhs_noref >::value >::value >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_pointer< Rhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Rhs_nocv >::value, ::boost::is_pointer< Lhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_pointer< Rhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_fundamental< Rhs_nocv >::value, ::boost::is_const< Lhs_noref >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_modulus_assign_impl::dont_care > struct has_modulus_assign : public ::boost::integral_constant<bool,(::boost::detail::has_modulus_assign_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 49 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_modulus_assign.hpp" 2
# 35 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_multiplies.hpp" 1
# 34 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_multiplies.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_multiplies_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator * (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() * make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() * make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() * make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::type_traits::ice_or< ::boost::is_fundamental< Rhs_nocv >::value, ::boost::is_pointer< Rhs_noref >::value >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Rhs_noref >::value, ::boost::type_traits::ice_or< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_pointer< Lhs_noref >::value >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_multiplies_impl::dont_care > struct has_multiplies : public ::boost::integral_constant<bool,(::boost::detail::has_multiplies_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 34 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_multiplies.hpp" 2
# 36 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_multiplies_assign.hpp" 1
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_multiplies_assign.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_multiplies_assign_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator *= (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() *= make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() *= make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() *= make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_const< Lhs_noref >::value, ::boost::is_fundamental< Rhs_nocv >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::type_traits::ice_or< ::boost::is_fundamental< Rhs_nocv >::value, ::boost::is_pointer< Rhs_noref >::value >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Rhs_noref >::value, ::boost::type_traits::ice_or< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_pointer< Lhs_noref >::value >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_multiplies_assign_impl::dont_care > struct has_multiplies_assign : public ::boost::integral_constant<bool,(::boost::detail::has_multiplies_assign_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_multiplies_assign.hpp" 2
# 37 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_negate.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_negate.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 1
# 23 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 23 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 2
# 35 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_negate_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator - (const any&);
# 76 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((- make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Rhs >
struct operator_returns_Ret < Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Rhs >
struct operator_returns_Ret < Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Rhs >
struct operator_returns_Ret < Rhs, void, true > {
   static const bool value = true;
};

template < typename Rhs >
struct operator_returns_Ret < Rhs, void, false > {
   static const bool value = false;
};

template < typename Rhs, typename Ret >
struct operator_returns_Ret < Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Rhs, typename Ret >
struct operator_returns_Ret < Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(- make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 144 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((- make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 163 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3
template < typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Rhs, typename Ret >
struct trait_impl1 < Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Rhs, typename Ret >
struct trait_impl1 < Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Rhs >::value, operator_returns_Ret < Rhs, Ret, operator_returns_void < Rhs >::value >::value >::value );







};


template < typename Ret >
struct trait_impl1 < void, Ret, false > {
   static const bool value = false;
};


template < typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Rhs_noref, Ret, ::boost::is_pointer< Rhs_noref >::value >::value);
};

}
}


template< typename Rhs, typename Ret=::boost::detail::has_negate_impl::dont_care > struct has_negate : public ::boost::integral_constant<bool,(::boost::detail::has_negate_impl::trait_impl < Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 210 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 2 3
# 19 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_negate.hpp" 2
# 38 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_not_equal_to.hpp" 1
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_not_equal_to.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_not_equal_to_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator != (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() != make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() != make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() != make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_fundamental< Rhs_nocv >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Rhs_noref >::value, ::boost::is_fundamental< Lhs_nocv >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_pointer< Rhs_noref >::value, ::boost::type_traits::ice_not< ::boost::type_traits::ice_or< ::boost::is_base_of< Lhs_noptr, Rhs_noptr >::value, ::boost::is_base_of< Rhs_noptr, Lhs_noptr >::value, ::boost::is_same< Lhs_noptr, Rhs_noptr >::value, ::boost::is_void< Lhs_noptr >::value, ::boost::is_void< Rhs_noptr >::value >::value >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_not_equal_to_impl::dont_care > struct has_not_equal_to : public ::boost::integral_constant<bool,(::boost::detail::has_not_equal_to_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_not_equal_to.hpp" 2
# 39 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_plus.hpp" 1
# 48 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_plus.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_plus_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator + (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() + make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() + make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() + make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_pointer< Rhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_void< Lhs_noptr >::value, ::boost::is_fundamental< Rhs_nocv >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Rhs_noref >::value, ::boost::is_void< Rhs_noptr >::value, ::boost::is_fundamental< Lhs_nocv >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_fundamental< Rhs_nocv >::value, ::boost::type_traits::ice_not< ::boost::is_integral< Rhs_noref >::value >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Rhs_noref >::value, ::boost::is_fundamental< Lhs_nocv >::value, ::boost::type_traits::ice_not< ::boost::is_integral< Lhs_noref >::value >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_plus_impl::dont_care > struct has_plus : public ::boost::integral_constant<bool,(::boost::detail::has_plus_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 48 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_plus.hpp" 2
# 40 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_plus_assign.hpp" 1
# 60 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_plus_assign.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_plus_assign_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator += (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() += make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() += make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() += make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_pointer< Rhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_void< Lhs_noptr >::value, ::boost::is_fundamental< Rhs_nocv >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Rhs_noref >::value, ::boost::is_void< Rhs_noptr >::value, ::boost::is_fundamental< Lhs_nocv >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_fundamental< Rhs_nocv >::value, ::boost::type_traits::ice_not< ::boost::is_integral< Rhs_noref >::value >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Rhs_noref >::value, ::boost::is_fundamental< Lhs_nocv >::value, ::boost::type_traits::ice_not< ::boost::is_same< Lhs_nocv, bool >::value >::value >::value, ::boost::type_traits::ice_and< ::boost::type_traits::ice_or< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_pointer< Lhs_noref >::value >::value, ::boost::type_traits::ice_or< ::boost::is_fundamental< Rhs_nocv >::value, ::boost::is_pointer< Rhs_noref >::value >::value, ::boost::is_const< Lhs_noref >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_plus_assign_impl::dont_care > struct has_plus_assign : public ::boost::integral_constant<bool,(::boost::detail::has_plus_assign_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 60 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_plus_assign.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_post_decrement.hpp" 1
# 34 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_post_decrement.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_postfix_operator.hpp" 1
# 22 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_postfix_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 22 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_postfix_operator.hpp" 2
# 27 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_postfix_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_post_decrement_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator -- (const any&, int);
# 68 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_postfix_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() --,returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs >
struct operator_returns_Ret < Lhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs >
struct operator_returns_Ret < Lhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs >
struct operator_returns_Ret < Lhs, void, true > {
   static const bool value = true;
};

template < typename Lhs >
struct operator_returns_Ret < Lhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct operator_returns_Ret < Lhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Ret >
struct operator_returns_Ret < Lhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() --))==sizeof(::boost::type_traits::yes_type));
};
# 136 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_postfix_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() --),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 155 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_postfix_operator.hpp" 3
template < typename Lhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs >::value, operator_returns_Ret < Lhs, Ret, operator_returns_void < Lhs >::value >::value >::value );







};


template < typename Ret >
struct trait_impl1 < void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::is_same< bool, Lhs_nocv >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_void< Lhs_noptr >::value >::value, ::boost::type_traits::ice_and< ::boost::type_traits::ice_or< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_pointer< Lhs_noref >::value >::value, ::boost::is_const< Lhs_noref >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Ret=::boost::detail::has_post_decrement_impl::dont_care > struct has_post_decrement : public ::boost::integral_constant<bool,(::boost::detail::has_post_decrement_impl::trait_impl< Lhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 202 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_postfix_operator.hpp" 2 3
# 34 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_post_decrement.hpp" 2
# 42 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_post_increment.hpp" 1
# 34 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_post_increment.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_postfix_operator.hpp" 1
# 22 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_postfix_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 22 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_postfix_operator.hpp" 2
# 27 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_postfix_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_post_increment_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator ++ (const any&, int);
# 68 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_postfix_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() ++,returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs >
struct operator_returns_Ret < Lhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs >
struct operator_returns_Ret < Lhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs >
struct operator_returns_Ret < Lhs, void, true > {
   static const bool value = true;
};

template < typename Lhs >
struct operator_returns_Ret < Lhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct operator_returns_Ret < Lhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Ret >
struct operator_returns_Ret < Lhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() ++))==sizeof(::boost::type_traits::yes_type));
};
# 136 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_postfix_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() ++),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 155 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_postfix_operator.hpp" 3
template < typename Lhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs >::value, operator_returns_Ret < Lhs, Ret, operator_returns_void < Lhs >::value >::value >::value );







};


template < typename Ret >
struct trait_impl1 < void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::is_same< bool, Lhs_nocv >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_void< Lhs_noptr >::value >::value, ::boost::type_traits::ice_and< ::boost::type_traits::ice_or< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_pointer< Lhs_noref >::value >::value, ::boost::is_const< Lhs_noref >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Ret=::boost::detail::has_post_increment_impl::dont_care > struct has_post_increment : public ::boost::integral_constant<bool,(::boost::detail::has_post_increment_impl::trait_impl< Lhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 202 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_postfix_operator.hpp" 2 3
# 34 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_post_increment.hpp" 2
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_pre_decrement.hpp" 1
# 34 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_pre_decrement.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 1
# 23 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 23 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 2
# 35 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_pre_decrement_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator -- (const any&);
# 76 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((-- make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Rhs >
struct operator_returns_Ret < Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Rhs >
struct operator_returns_Ret < Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Rhs >
struct operator_returns_Ret < Rhs, void, true > {
   static const bool value = true;
};

template < typename Rhs >
struct operator_returns_Ret < Rhs, void, false > {
   static const bool value = false;
};

template < typename Rhs, typename Ret >
struct operator_returns_Ret < Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Rhs, typename Ret >
struct operator_returns_Ret < Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(-- make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 144 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((-- make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 163 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3
template < typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Rhs, typename Ret >
struct trait_impl1 < Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Rhs, typename Ret >
struct trait_impl1 < Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Rhs >::value, operator_returns_Ret < Rhs, Ret, operator_returns_void < Rhs >::value >::value >::value );







};


template < typename Ret >
struct trait_impl1 < void, Ret, false > {
   static const bool value = false;
};


template < typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::is_same< bool, Rhs_nocv >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Rhs_noref >::value, ::boost::is_void< Rhs_noptr >::value >::value, ::boost::type_traits::ice_and< ::boost::type_traits::ice_or< ::boost::is_fundamental< Rhs_nocv >::value, ::boost::is_pointer< Rhs_noref >::value >::value, ::boost::is_const< Rhs_noref >::value >::value >::value >::value);
};

}
}


template< typename Rhs, typename Ret=::boost::detail::has_pre_decrement_impl::dont_care > struct has_pre_decrement : public ::boost::integral_constant<bool,(::boost::detail::has_pre_decrement_impl::trait_impl < Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 210 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 2 3
# 34 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_pre_decrement.hpp" 2
# 44 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_pre_increment.hpp" 1
# 34 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_pre_increment.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 1
# 23 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 23 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 2
# 35 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_pre_increment_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator ++ (const any&);
# 76 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((++ make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Rhs >
struct operator_returns_Ret < Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Rhs >
struct operator_returns_Ret < Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Rhs >
struct operator_returns_Ret < Rhs, void, true > {
   static const bool value = true;
};

template < typename Rhs >
struct operator_returns_Ret < Rhs, void, false > {
   static const bool value = false;
};

template < typename Rhs, typename Ret >
struct operator_returns_Ret < Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Rhs, typename Ret >
struct operator_returns_Ret < Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(++ make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 144 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((++ make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 163 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3
template < typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Rhs, typename Ret >
struct trait_impl1 < Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Rhs, typename Ret >
struct trait_impl1 < Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Rhs >::value, operator_returns_Ret < Rhs, Ret, operator_returns_void < Rhs >::value >::value >::value );







};


template < typename Ret >
struct trait_impl1 < void, Ret, false > {
   static const bool value = false;
};


template < typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::is_same< bool, Rhs_nocv >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Rhs_noref >::value, ::boost::is_void< Rhs_noptr >::value >::value, ::boost::type_traits::ice_and< ::boost::type_traits::ice_or< ::boost::is_fundamental< Rhs_nocv >::value, ::boost::is_pointer< Rhs_noref >::value >::value, ::boost::is_const< Rhs_noref >::value >::value >::value >::value);
};

}
}


template< typename Rhs, typename Ret=::boost::detail::has_pre_increment_impl::dont_care > struct has_pre_increment : public ::boost::integral_constant<bool,(::boost::detail::has_pre_increment_impl::trait_impl < Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 210 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 2 3
# 34 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_pre_increment.hpp" 2
# 45 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_right_shift.hpp" 1
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_right_shift.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_right_shift_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator >> (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() >> make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() >> make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() >> make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_fundamental< Rhs_nocv >::value, ::boost::type_traits::ice_or< ::boost::type_traits::ice_not< ::boost::is_integral< Lhs_noref >::value >::value, ::boost::type_traits::ice_not< ::boost::is_integral< Rhs_noref >::value >::value >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_pointer< Rhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Rhs_nocv >::value, ::boost::is_pointer< Lhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_pointer< Rhs_noref >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_right_shift_impl::dont_care > struct has_right_shift : public ::boost::integral_constant<bool,(::boost::detail::has_right_shift_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_right_shift.hpp" 2
# 46 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_right_shift_assign.hpp" 1
# 49 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_right_shift_assign.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2
# 41 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_right_shift_assign_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator >>= (const any&, const any&);
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Lhs, typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((make<Lhs>() >>= make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Lhs, typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, true > {
   static const bool value = true;
};

template < typename Lhs, typename Rhs >
struct operator_returns_Ret < Lhs, Rhs, void, false > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Lhs, typename Rhs, typename Ret >
struct operator_returns_Ret < Lhs, Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(make<Lhs>() >>= make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 150 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Lhs, typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((make<Lhs>() >>= make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 169 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 3
template < typename Lhs, typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl1 < Lhs, Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Lhs, Rhs >::value, operator_returns_Ret < Lhs, Rhs, Ret, operator_returns_void < Lhs, Rhs >::value >::value >::value );







};


template < typename Rhs, typename Ret >
struct trait_impl1 < void, Rhs, Ret, false > {
   static const bool value = false;
};

template < typename Lhs, typename Ret >
struct trait_impl1 < Lhs, void, Ret, false > {
   static const bool value = false;
};

template < typename Ret >
struct trait_impl1 < void, void, Ret, false > {
   static const bool value = false;
};


template < typename Lhs, typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Lhs>::type Lhs_noref;
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Lhs_noref>::type Lhs_nocv;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Lhs_noref>::type >::type >::type Lhs_noptr;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Lhs_noref, Rhs_noref, Ret, ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_fundamental< Rhs_nocv >::value, ::boost::type_traits::ice_or< ::boost::type_traits::ice_not< ::boost::is_integral< Lhs_noref >::value >::value, ::boost::type_traits::ice_not< ::boost::is_integral< Rhs_noref >::value >::value >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_pointer< Rhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Rhs_nocv >::value, ::boost::is_pointer< Lhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_pointer< Lhs_noref >::value, ::boost::is_pointer< Rhs_noref >::value >::value, ::boost::type_traits::ice_and< ::boost::is_fundamental< Lhs_nocv >::value, ::boost::is_fundamental< Rhs_nocv >::value, ::boost::is_const< Lhs_noref >::value >::value >::value >::value);
};

}
}


template< typename Lhs, typename Rhs=Lhs, typename Ret=::boost::detail::has_right_shift_assign_impl::dont_care > struct has_right_shift_assign : public ::boost::integral_constant<bool,(::boost::detail::has_right_shift_assign_impl::trait_impl < Lhs, Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 229 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_binary_operator.hpp" 2 3
# 49 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_right_shift_assign.hpp" 2
# 47 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_unary_minus.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_unary_minus.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 1
# 23 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 23 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 2
# 35 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_unary_minus_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator - (const any&);
# 76 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((- make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Rhs >
struct operator_returns_Ret < Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Rhs >
struct operator_returns_Ret < Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Rhs >
struct operator_returns_Ret < Rhs, void, true > {
   static const bool value = true;
};

template < typename Rhs >
struct operator_returns_Ret < Rhs, void, false > {
   static const bool value = false;
};

template < typename Rhs, typename Ret >
struct operator_returns_Ret < Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Rhs, typename Ret >
struct operator_returns_Ret < Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(- make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 144 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((- make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 163 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3
template < typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Rhs, typename Ret >
struct trait_impl1 < Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Rhs, typename Ret >
struct trait_impl1 < Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Rhs >::value, operator_returns_Ret < Rhs, Ret, operator_returns_void < Rhs >::value >::value >::value );







};


template < typename Ret >
struct trait_impl1 < void, Ret, false > {
   static const bool value = false;
};


template < typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Rhs_noref, Ret, ::boost::is_pointer< Rhs_noref >::value >::value);
};

}
}


template< typename Rhs, typename Ret=::boost::detail::has_unary_minus_impl::dont_care > struct has_unary_minus : public ::boost::integral_constant<bool,(::boost::detail::has_unary_minus_impl::trait_impl < Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 210 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 2 3
# 19 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_unary_minus.hpp" 2
# 48 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_unary_plus.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_unary_plus.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 1
# 23 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 23 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 2
# 35 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3





namespace boost {
namespace detail {


namespace has_unary_plus_impl {



template <typename T> T &make();







struct no_operator { };




struct any { template <class T> any(T const&); };


no_operator operator + (const any&);
# 76 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3
struct returns_void_t { };
template <typename T> int operator,(const T&, returns_void_t);
template <typename T> int operator,(const volatile T&, returns_void_t);




template < typename Rhs >
struct operator_returns_void {


   static ::boost::type_traits::yes_type returns_void(returns_void_t);
   static ::boost::type_traits::no_type returns_void(int);
   static const bool value = (sizeof(::boost::type_traits::yes_type)==sizeof(returns_void((+ make<Rhs>(),returns_void_t()))));
};





struct dont_care { };

template < typename Rhs, typename Ret, bool Returns_void >
struct operator_returns_Ret;

template < typename Rhs >
struct operator_returns_Ret < Rhs, dont_care, true > {
   static const bool value = true;
};

template < typename Rhs >
struct operator_returns_Ret < Rhs, dont_care, false > {
   static const bool value = true;
};

template < typename Rhs >
struct operator_returns_Ret < Rhs, void, true > {
   static const bool value = true;
};

template < typename Rhs >
struct operator_returns_Ret < Rhs, void, false > {
   static const bool value = false;
};

template < typename Rhs, typename Ret >
struct operator_returns_Ret < Rhs, Ret, true > {
   static const bool value = false;
};




template < typename Rhs, typename Ret >
struct operator_returns_Ret < Rhs, Ret, false > {
   static ::boost::type_traits::yes_type is_convertible_to_Ret(Ret);
   static ::boost::type_traits::no_type is_convertible_to_Ret(...);

   static const bool value = (sizeof(is_convertible_to_Ret(+ make<Rhs>()))==sizeof(::boost::type_traits::yes_type));
};
# 144 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3
struct has_operator { };
no_operator operator,(no_operator, has_operator);

template < typename Rhs >
struct operator_exists {
   static ::boost::type_traits::yes_type check(has_operator);
   static ::boost::type_traits::no_type check(no_operator);

   static const bool value = (sizeof(check(((+ make<Rhs>()),make<has_operator>())))==sizeof(::boost::type_traits::yes_type));
};
# 163 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 3
template < typename Rhs, typename Ret, bool Forbidden_if >
struct trait_impl1;

template < typename Rhs, typename Ret >
struct trait_impl1 < Rhs, Ret, true > {
   static const bool value = false;
};

template < typename Rhs, typename Ret >
struct trait_impl1 < Rhs, Ret, false > {
   static const bool value = ( ::boost::type_traits::ice_and< operator_exists < Rhs >::value, operator_returns_Ret < Rhs, Ret, operator_returns_void < Rhs >::value >::value >::value );







};


template < typename Ret >
struct trait_impl1 < void, Ret, false > {
   static const bool value = false;
};


template < typename Rhs, typename Ret >
struct trait_impl {
   typedef typename ::boost::remove_reference<Rhs>::type Rhs_noref;
   typedef typename ::boost::remove_cv<Rhs_noref>::type Rhs_nocv;
   typedef typename ::boost::remove_cv< typename ::boost::remove_reference< typename ::boost::remove_pointer<Rhs_noref>::type >::type >::type Rhs_noptr;
   static const bool value = (trait_impl1 < Rhs_noref, Ret, false >::value);
};

}
}


template< typename Rhs, typename Ret=::boost::detail::has_unary_plus_impl::dont_care > struct has_unary_plus : public ::boost::integral_constant<bool,(::boost::detail::has_unary_plus_impl::trait_impl < Rhs, Ret >::value)> { public: };

}






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 210 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/has_prefix_operator.hpp" 2 3
# 17 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_unary_plus.hpp" 2
# 49 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_operator.hpp" 2
# 35 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2





# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_virtual_destructor.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_virtual_destructor.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 15 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_virtual_destructor.hpp" 2


namespace boost {


template< typename T > struct has_virtual_destructor : public ::boost::integral_constant<bool,__has_virtual_destructor(T)> { public: };




}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 27 "/home/marek/devel/nupic/external/common/include/boost/type_traits/has_virtual_destructor.hpp" 2
# 40 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2







# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_complex.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_complex.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/complex" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/complex" 3




# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cmath" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cmath" 3




# 1 "/usr/include/math.h" 1 3 4
# 28 "/usr/include/math.h" 3 4
extern "C" {




# 1 "/usr/include/bits/huge_val.h" 1 3 4
# 33 "/usr/include/math.h" 2 3 4

# 1 "/usr/include/bits/huge_valf.h" 1 3 4
# 35 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/huge_vall.h" 1 3 4
# 36 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/inf.h" 1 3 4
# 39 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/nan.h" 1 3 4
# 42 "/usr/include/math.h" 2 3 4



# 1 "/usr/include/bits/mathdef.h" 1 3 4
# 28 "/usr/include/bits/mathdef.h" 3 4
typedef float float_t;
typedef double double_t;
# 46 "/usr/include/math.h" 2 3 4
# 69 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 54 "/usr/include/bits/mathcalls.h" 3 4
extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();




extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ();






extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();







extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw () __attribute__ ((__nonnull__ (2)));




extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();

extern double pow10 (double __x) throw (); extern double __pow10 (double __x) throw ();





extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();






extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();
# 153 "/usr/include/bits/mathcalls.h" 3 4
extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();





extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();






extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();
# 178 "/usr/include/bits/mathcalls.h" 3 4
extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();




extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));





extern int isinf (double __value) throw () __attribute__ ((__const__));


extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();





extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));






extern double nan (const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnan (double __value) throw () __attribute__ ((__const__));



extern int isnan (double __value) throw () __attribute__ ((__const__));


extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();






extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();






extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();






extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();







extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw () __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) throw () __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) throw () __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) throw () __attribute__ ((__const__));



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
__extension__
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
__extension__
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmax (double __x, double __y) throw () __attribute__ ((__const__));


extern double fmin (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmin (double __x, double __y) throw () __attribute__ ((__const__));



extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();
# 365 "/usr/include/bits/mathcalls.h" 3 4
extern int __issignaling (double __value) throw ()
     __attribute__ ((__const__));




extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
# 70 "/usr/include/math.h" 2 3 4
# 88 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 54 "/usr/include/bits/mathcalls.h" 3 4
extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();




extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ();






extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();







extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw () __attribute__ ((__nonnull__ (2)));




extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();

extern float pow10f (float __x) throw (); extern float __pow10f (float __x) throw ();





extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();






extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();
# 153 "/usr/include/bits/mathcalls.h" 3 4
extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();





extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();






extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();
# 178 "/usr/include/bits/mathcalls.h" 3 4
extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();




extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));





extern int isinff (float __value) throw () __attribute__ ((__const__));


extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();





extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));






extern float nanf (const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanf (float __value) throw () __attribute__ ((__const__));



extern int isnanf (float __value) throw () __attribute__ ((__const__));


extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();






extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();






extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();






extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();







extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) throw () __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__));



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
__extension__
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
__extension__
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminf (float __x, float __y) throw () __attribute__ ((__const__));



extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();
# 365 "/usr/include/bits/mathcalls.h" 3 4
extern int __issignalingf (float __value) throw ()
     __attribute__ ((__const__));




extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
# 89 "/usr/include/math.h" 2 3 4
# 132 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 54 "/usr/include/bits/mathcalls.h" 3 4
extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();




extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ();






extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();







extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw () __attribute__ ((__nonnull__ (2)));




extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();

extern long double pow10l (long double __x) throw (); extern long double __pow10l (long double __x) throw ();





extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();






extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();
# 153 "/usr/include/bits/mathcalls.h" 3 4
extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();





extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();






extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();
# 178 "/usr/include/bits/mathcalls.h" 3 4
extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();




extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));





extern int isinfl (long double __value) throw () __attribute__ ((__const__));


extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();





extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));






extern long double nanl (const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanl (long double __value) throw () __attribute__ ((__const__));



extern int isnanl (long double __value) throw () __attribute__ ((__const__));


extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();






extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();






extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();






extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();







extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
__extension__
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
__extension__
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();
# 365 "/usr/include/bits/mathcalls.h" 3 4
extern int __issignalingl (long double __value) throw ()
     __attribute__ ((__const__));




extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
# 133 "/usr/include/math.h" 2 3 4
# 148 "/usr/include/math.h" 3 4
extern int signgam;
# 189 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 301 "/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 324 "/usr/include/math.h" 3 4
struct __exception



  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };


extern int matherr (struct __exception *__exc) throw ();
# 488 "/usr/include/math.h" 3 4
}
# 45 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cmath" 2 3
# 75 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  inline double
  abs(double __x)
  { return __builtin_fabs(__x); }



  inline float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    abs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::acos;


  inline float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline float
  log(float __x)
  { return __builtin_logf(__x); }

  inline long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }




  inline double
  pow(double __x, int __i)
  { return __builtin_powi(__x, __i); }

  inline float
  pow(float __x, int __n)
  { return __builtin_powif(__x, __n); }

  inline long double
  pow(long double __x, int __n)
  { return __builtin_powil(__x, __n); }



  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }


}
# 555 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 805 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cmath" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    fpclassify(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_fpclassify(0, 1, 4,
      3, 2, __type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isfinite(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isfinite(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isinf(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isinf(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isnan(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isnan(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isnormal(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isnormal(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    signbit(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_signbit(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isgreater(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isgreater(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isgreaterequal(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isgreaterequal(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isless(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isless(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    islessequal(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_islessequal(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    islessgreater(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_islessgreater(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isunordered(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isunordered(__type(__f1), __type(__f2));
    }




}
# 45 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/complex" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{
# 63 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/complex" 3
  template<typename _Tp> class complex;
  template<> class complex<float>;
  template<> class complex<double>;
  template<> class complex<long double>;


  template<typename _Tp> _Tp abs(const complex<_Tp>&);

  template<typename _Tp> _Tp arg(const complex<_Tp>&);

  template<typename _Tp> _Tp norm(const complex<_Tp>&);


  template<typename _Tp> complex<_Tp> conj(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> polar(const _Tp&, const _Tp& = 0);



  template<typename _Tp> complex<_Tp> cos(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> cosh(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> exp(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> log(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> log10(const complex<_Tp>&);



  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, int);


  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, const _Tp&);

  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&,
                                          const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> pow(const _Tp&, const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sin(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sinh(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sqrt(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> tan(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> tanh(const complex<_Tp>&);
# 124 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/complex" 3
  template<typename _Tp>
    struct complex
    {

      typedef _Tp value_type;



                         complex(const _Tp& __r = _Tp(), const _Tp& __i = _Tp())
      : _M_real(__r), _M_imag(__i) { }




      template<typename _Up>
                           complex(const complex<_Up>& __z)
 : _M_real(__z.real()), _M_imag(__z.imag()) { }
# 154 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/complex" 3
      _Tp&
      real() { return _M_real; }


      const _Tp&
      real() const { return _M_real; }


      _Tp&
      imag() { return _M_imag; }


      const _Tp&
      imag() const { return _M_imag; }




      void
      real(_Tp __val) { _M_real = __val; }

      void
      imag(_Tp __val) { _M_imag = __val; }


      complex<_Tp>& operator=(const _Tp&);



      complex<_Tp>&
      operator+=(const _Tp& __t)
      {
 _M_real += __t;
 return *this;
      }



      complex<_Tp>&
      operator-=(const _Tp& __t)
      {
 _M_real -= __t;
 return *this;
      }


      complex<_Tp>& operator*=(const _Tp&);

      complex<_Tp>& operator/=(const _Tp&);





      template<typename _Up>
        complex<_Tp>& operator=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator+=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator-=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator*=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator/=(const complex<_Up>&);

      const complex __rep() const
      { return *this; }

    private:
      _Tp _M_real;
      _Tp _M_imag;
    };

  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator=(const _Tp& __t)
    {
     _M_real = __t;
     _M_imag = _Tp();
     return *this;
    }


  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator*=(const _Tp& __t)
    {
      _M_real *= __t;
      _M_imag *= __t;
      return *this;
    }


  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator/=(const _Tp& __t)
    {
      _M_real /= __t;
      _M_imag /= __t;
      return *this;
    }

  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator=(const complex<_Up>& __z)
    {
      _M_real = __z.real();
      _M_imag = __z.imag();
      return *this;
    }


  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator+=(const complex<_Up>& __z)
    {
      _M_real += __z.real();
      _M_imag += __z.imag();
      return *this;
    }


  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator-=(const complex<_Up>& __z)
    {
      _M_real -= __z.real();
      _M_imag -= __z.imag();
      return *this;
    }



  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator*=(const complex<_Up>& __z)
    {
      const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
      _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
      _M_real = __r;
      return *this;
    }



  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator/=(const complex<_Up>& __z)
    {
      const _Tp __r = _M_real * __z.real() + _M_imag * __z.imag();
      const _Tp __n = std::norm(__z);
      _M_imag = (_M_imag * __z.real() - _M_real * __z.imag()) / __n;
      _M_real = __r / __n;
      return *this;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r += __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r += __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator+(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __y;
      __r += __x;
      return __r;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r -= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r -= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator-(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r(__x, -__y.imag());
      __r -= __y.real();
      return __r;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator*(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r *= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator*(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r *= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator*(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __y;
      __r *= __x;
      return __r;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator/(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator/(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator/(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }



  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x)
    { return __x; }


  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x)
    { return complex<_Tp>(-__x.real(), -__x.imag()); }



  template<typename _Tp>
    inline bool
    operator==(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x.real() == __y.real() && __x.imag() == __y.imag(); }

  template<typename _Tp>
    inline bool
    operator==(const complex<_Tp>& __x, const _Tp& __y)
    { return __x.real() == __y && __x.imag() == _Tp(); }

  template<typename _Tp>
    inline bool
    operator==(const _Tp& __x, const complex<_Tp>& __y)
    { return __x == __y.real() && _Tp() == __y.imag(); }




  template<typename _Tp>
    inline bool
    operator!=(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x.real() != __y.real() || __x.imag() != __y.imag(); }

  template<typename _Tp>
    inline bool
    operator!=(const complex<_Tp>& __x, const _Tp& __y)
    { return __x.real() != __y || __x.imag() != _Tp(); }

  template<typename _Tp>
    inline bool
    operator!=(const _Tp& __x, const complex<_Tp>& __y)
    { return __x != __y.real() || _Tp() != __y.imag(); }



  template<typename _Tp, typename _CharT, class _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, complex<_Tp>& __x)
    {
      _Tp __re_x, __im_x;
      _CharT __ch;
      __is >> __ch;
      if (__ch == '(')
 {
   __is >> __re_x >> __ch;
   if (__ch == ',')
     {
       __is >> __im_x >> __ch;
       if (__ch == ')')
  __x = complex<_Tp>(__re_x, __im_x);
       else
  __is.setstate(ios_base::failbit);
     }
   else if (__ch == ')')
     __x = __re_x;
   else
     __is.setstate(ios_base::failbit);
 }
      else
 {
   __is.putback(__ch);
   __is >> __re_x;
   __x = __re_x;
 }
      return __is;
    }


  template<typename _Tp, typename _CharT, class _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const complex<_Tp>& __x)
    {
      basic_ostringstream<_CharT, _Traits> __s;
      __s.flags(__os.flags());
      __s.imbue(__os.getloc());
      __s.precision(__os.precision());
      __s << '(' << __x.real() << ',' << __x.imag() << ')';
      return __os << __s.str();
    }
# 546 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/complex" 3
  template<typename _Tp>
    inline _Tp&
    real(complex<_Tp>& __z)
    { return __z.real(); }

  template<typename _Tp>
    inline const _Tp&
    real(const complex<_Tp>& __z)
    { return __z.real(); }

  template<typename _Tp>
    inline _Tp&
    imag(complex<_Tp>& __z)
    { return __z.imag(); }

  template<typename _Tp>
    inline const _Tp&
    imag(const complex<_Tp>& __z)
    { return __z.imag(); }



  template<typename _Tp>
    inline _Tp
    __complex_abs(const complex<_Tp>& __z)
    {
      _Tp __x = __z.real();
      _Tp __y = __z.imag();
      const _Tp __s = std::max(abs(__x), abs(__y));
      if (__s == _Tp())
        return __s;
      __x /= __s;
      __y /= __s;
      return __s * sqrt(__x * __x + __y * __y);
    }


  inline float
  __complex_abs(__complex__ float __z) { return __builtin_cabsf(__z); }

  inline double
  __complex_abs(__complex__ double __z) { return __builtin_cabs(__z); }

  inline long double
  __complex_abs(const __complex__ long double& __z)
  { return __builtin_cabsl(__z); }

  template<typename _Tp>
    inline _Tp
    abs(const complex<_Tp>& __z) { return __complex_abs(__z.__rep()); }
# 604 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/complex" 3
  template<typename _Tp>
    inline _Tp
    __complex_arg(const complex<_Tp>& __z)
    { return atan2(__z.imag(), __z.real()); }


  inline float
  __complex_arg(__complex__ float __z) { return __builtin_cargf(__z); }

  inline double
  __complex_arg(__complex__ double __z) { return __builtin_carg(__z); }

  inline long double
  __complex_arg(const __complex__ long double& __z)
  { return __builtin_cargl(__z); }

  template<typename _Tp>
    inline _Tp
    arg(const complex<_Tp>& __z) { return __complex_arg(__z.__rep()); }
# 634 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/complex" 3
  template<bool>
    struct _Norm_helper
    {
      template<typename _Tp>
        static inline _Tp _S_do_it(const complex<_Tp>& __z)
        {
          const _Tp __x = __z.real();
          const _Tp __y = __z.imag();
          return __x * __x + __y * __y;
        }
    };

  template<>
    struct _Norm_helper<true>
    {
      template<typename _Tp>
        static inline _Tp _S_do_it(const complex<_Tp>& __z)
        {
          _Tp __res = std::abs(__z);
          return __res * __res;
        }
    };

  template<typename _Tp>
    inline _Tp
    norm(const complex<_Tp>& __z)
    {
      return _Norm_helper<__is_floating<_Tp>::__value
 && !0>::_S_do_it(__z);
    }

  template<typename _Tp>
    inline complex<_Tp>
    polar(const _Tp& __rho, const _Tp& __theta)
    { return complex<_Tp>(__rho * cos(__theta), __rho * sin(__theta)); }

  template<typename _Tp>
    inline complex<_Tp>
    conj(const complex<_Tp>& __z)
    { return complex<_Tp>(__z.real(), -__z.imag()); }




  template<typename _Tp>
    inline complex<_Tp>
    __complex_cos(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(cos(__x) * cosh(__y), -sin(__x) * sinh(__y));
    }


  inline __complex__ float
  __complex_cos(__complex__ float __z) { return __builtin_ccosf(__z); }

  inline __complex__ double
  __complex_cos(__complex__ double __z) { return __builtin_ccos(__z); }

  inline __complex__ long double
  __complex_cos(const __complex__ long double& __z)
  { return __builtin_ccosl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    cos(const complex<_Tp>& __z) { return __complex_cos(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_cosh(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(cosh(__x) * cos(__y), sinh(__x) * sin(__y));
    }


  inline __complex__ float
  __complex_cosh(__complex__ float __z) { return __builtin_ccoshf(__z); }

  inline __complex__ double
  __complex_cosh(__complex__ double __z) { return __builtin_ccosh(__z); }

  inline __complex__ long double
  __complex_cosh(const __complex__ long double& __z)
  { return __builtin_ccoshl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    cosh(const complex<_Tp>& __z) { return __complex_cosh(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_exp(const complex<_Tp>& __z)
    { return std::polar(exp(__z.real()), __z.imag()); }


  inline __complex__ float
  __complex_exp(__complex__ float __z) { return __builtin_cexpf(__z); }

  inline __complex__ double
  __complex_exp(__complex__ double __z) { return __builtin_cexp(__z); }

  inline __complex__ long double
  __complex_exp(const __complex__ long double& __z)
  { return __builtin_cexpl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    exp(const complex<_Tp>& __z) { return __complex_exp(__z.__rep()); }
# 765 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_log(const complex<_Tp>& __z)
    { return complex<_Tp>(log(std::abs(__z)), std::arg(__z)); }


  inline __complex__ float
  __complex_log(__complex__ float __z) { return __builtin_clogf(__z); }

  inline __complex__ double
  __complex_log(__complex__ double __z) { return __builtin_clog(__z); }

  inline __complex__ long double
  __complex_log(const __complex__ long double& __z)
  { return __builtin_clogl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    log(const complex<_Tp>& __z) { return __complex_log(__z.__rep()); }






  template<typename _Tp>
    inline complex<_Tp>
    log10(const complex<_Tp>& __z)
    { return std::log(__z) / log(_Tp(10.0)); }


  template<typename _Tp>
    inline complex<_Tp>
    __complex_sin(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(sin(__x) * cosh(__y), cos(__x) * sinh(__y));
    }


  inline __complex__ float
  __complex_sin(__complex__ float __z) { return __builtin_csinf(__z); }

  inline __complex__ double
  __complex_sin(__complex__ double __z) { return __builtin_csin(__z); }

  inline __complex__ long double
  __complex_sin(const __complex__ long double& __z)
  { return __builtin_csinl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sin(const complex<_Tp>& __z) { return __complex_sin(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_sinh(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(sinh(__x) * cos(__y), cosh(__x) * sin(__y));
    }


  inline __complex__ float
  __complex_sinh(__complex__ float __z) { return __builtin_csinhf(__z); }

  inline __complex__ double
  __complex_sinh(__complex__ double __z) { return __builtin_csinh(__z); }

  inline __complex__ long double
  __complex_sinh(const __complex__ long double& __z)
  { return __builtin_csinhl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sinh(const complex<_Tp>& __z) { return __complex_sinh(__z.__rep()); }
# 857 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/complex" 3
  template<typename _Tp>
    complex<_Tp>
    __complex_sqrt(const complex<_Tp>& __z)
    {
      _Tp __x = __z.real();
      _Tp __y = __z.imag();

      if (__x == _Tp())
        {
          _Tp __t = sqrt(abs(__y) / 2);
          return complex<_Tp>(__t, __y < _Tp() ? -__t : __t);
        }
      else
        {
          _Tp __t = sqrt(2 * (std::abs(__z) + abs(__x)));
          _Tp __u = __t / 2;
          return __x > _Tp()
            ? complex<_Tp>(__u, __y / __t)
            : complex<_Tp>(abs(__y) / __t, __y < _Tp() ? -__u : __u);
        }
    }


  inline __complex__ float
  __complex_sqrt(__complex__ float __z) { return __builtin_csqrtf(__z); }

  inline __complex__ double
  __complex_sqrt(__complex__ double __z) { return __builtin_csqrt(__z); }

  inline __complex__ long double
  __complex_sqrt(const __complex__ long double& __z)
  { return __builtin_csqrtl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sqrt(const complex<_Tp>& __z) { return __complex_sqrt(__z.__rep()); }
# 901 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_tan(const complex<_Tp>& __z)
    { return std::sin(__z) / std::cos(__z); }


  inline __complex__ float
  __complex_tan(__complex__ float __z) { return __builtin_ctanf(__z); }

  inline __complex__ double
  __complex_tan(__complex__ double __z) { return __builtin_ctan(__z); }

  inline __complex__ long double
  __complex_tan(const __complex__ long double& __z)
  { return __builtin_ctanl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    tan(const complex<_Tp>& __z) { return __complex_tan(__z.__rep()); }
# 929 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_tanh(const complex<_Tp>& __z)
    { return std::sinh(__z) / std::cosh(__z); }


  inline __complex__ float
  __complex_tanh(__complex__ float __z) { return __builtin_ctanhf(__z); }

  inline __complex__ double
  __complex_tanh(__complex__ double __z) { return __builtin_ctanh(__z); }

  inline __complex__ long double
  __complex_tanh(const __complex__ long double& __z)
  { return __builtin_ctanhl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    tanh(const complex<_Tp>& __z) { return __complex_tanh(__z.__rep()); }
# 959 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/complex" 3
  template<typename _Tp>
    complex<_Tp>
    __complex_pow_unsigned(complex<_Tp> __x, unsigned __n)
    {
      complex<_Tp> __y = __n % 2 ? __x : complex<_Tp>(1);

      while (__n >>= 1)
        {
          __x *= __x;
          if (__n % 2)
            __y *= __x;
        }

      return __y;
    }



  template<typename _Tp>
    inline complex<_Tp>
    pow(const complex<_Tp>& __z, int __n)
    {
      return __n < 0
 ? complex<_Tp>(1) / std::__complex_pow_unsigned(__z, -(unsigned)__n)
        : std::__complex_pow_unsigned(__z, __n);
    }


  template<typename _Tp>
    complex<_Tp>
    pow(const complex<_Tp>& __x, const _Tp& __y)
    {




      if (__x.imag() == _Tp() && __x.real() > _Tp())
        return pow(__x.real(), __y);

      complex<_Tp> __t = std::log(__x);
      return std::polar(exp(__y * __t.real()), __y * __t.imag());
    }

  template<typename _Tp>
    inline complex<_Tp>
    __complex_pow(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x == _Tp() ? _Tp() : std::exp(__y * std::log(__x)); }


  inline __complex__ float
  __complex_pow(__complex__ float __x, __complex__ float __y)
  { return __builtin_cpowf(__x, __y); }

  inline __complex__ double
  __complex_pow(__complex__ double __x, __complex__ double __y)
  { return __builtin_cpow(__x, __y); }

  inline __complex__ long double
  __complex_pow(const __complex__ long double& __x,
  const __complex__ long double& __y)
  { return __builtin_cpowl(__x, __y); }

  template<typename _Tp>
    inline complex<_Tp>
    pow(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __complex_pow(__x.__rep(), __y.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    pow(const _Tp& __x, const complex<_Tp>& __y)
    {
      return __x > _Tp() ? std::polar(pow(__x, __y.real()),
          __y.imag() * log(__x))
                  : std::pow(complex<_Tp>(__x), __y);
    }



  template<>
    struct complex<float>
    {
      typedef float value_type;
      typedef __complex__ float _ComplexT;

                         complex(_ComplexT __z) : _M_value(__z) { }

                         complex(float __r = 0.0f, float __i = 0.0f)



      {
 __real__ _M_value = __r;
 __imag__ _M_value = __i;
      }


      explicit complex(const complex<double>&);
      explicit complex(const complex<long double>&);
# 1075 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/complex" 3
      float&
      real() { return __real__ _M_value; }

      const float&
      real() const { return __real__ _M_value; }

      float&
      imag() { return __imag__ _M_value; }

      const float&
      imag() const { return __imag__ _M_value; }




      void
      real(float __val) { __real__ _M_value = __val; }

      void
      imag(float __val) { __imag__ _M_value = __val; }

      complex&
      operator=(float __f)
      {
 _M_value = __f;
 return *this;
      }

      complex&
      operator+=(float __f)
      {
 _M_value += __f;
 return *this;
      }

      complex&
      operator-=(float __f)
      {
 _M_value -= __f;
 return *this;
      }

      complex&
      operator*=(float __f)
      {
 _M_value *= __f;
 return *this;
      }

      complex&
      operator/=(float __f)
      {
 _M_value /= __f;
 return *this;
      }





      template<typename _Tp>
        complex&
        operator=(const complex<_Tp>& __z)
 {
   __real__ _M_value = __z.real();
   __imag__ _M_value = __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator+=(const complex<_Tp>& __z)
 {
   __real__ _M_value += __z.real();
   __imag__ _M_value += __z.imag();
   return *this;
 }

      template<class _Tp>
        complex&
        operator-=(const complex<_Tp>& __z)
 {
   __real__ _M_value -= __z.real();
   __imag__ _M_value -= __z.imag();
   return *this;
 }

      template<class _Tp>
        complex&
        operator*=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value *= __t;
   return *this;
 }

      template<class _Tp>
        complex&
        operator/=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value /= __t;
   return *this;
 }

      const _ComplexT __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  template<>
    struct complex<double>
    {
      typedef double value_type;
      typedef __complex__ double _ComplexT;

                         complex(_ComplexT __z) : _M_value(__z) { }

                         complex(double __r = 0.0, double __i = 0.0)



      {
 __real__ _M_value = __r;
 __imag__ _M_value = __i;
      }


                         complex(const complex<float>& __z)
      : _M_value(__z.__rep()) { }

      explicit complex(const complex<long double>&);
# 1226 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/complex" 3
      double&
      real() { return __real__ _M_value; }

      const double&
      real() const { return __real__ _M_value; }

      double&
      imag() { return __imag__ _M_value; }

      const double&
      imag() const { return __imag__ _M_value; }




      void
      real(double __val) { __real__ _M_value = __val; }

      void
      imag(double __val) { __imag__ _M_value = __val; }

      complex&
      operator=(double __d)
      {
 _M_value = __d;
 return *this;
      }

      complex&
      operator+=(double __d)
      {
 _M_value += __d;
 return *this;
      }

      complex&
      operator-=(double __d)
      {
 _M_value -= __d;
 return *this;
      }

      complex&
      operator*=(double __d)
      {
 _M_value *= __d;
 return *this;
      }

      complex&
      operator/=(double __d)
      {
 _M_value /= __d;
 return *this;
      }




      template<typename _Tp>
        complex&
        operator=(const complex<_Tp>& __z)
 {
   __real__ _M_value = __z.real();
   __imag__ _M_value = __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator+=(const complex<_Tp>& __z)
 {
   __real__ _M_value += __z.real();
   __imag__ _M_value += __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator-=(const complex<_Tp>& __z)
 {
   __real__ _M_value -= __z.real();
   __imag__ _M_value -= __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator*=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value *= __t;
   return *this;
 }

      template<typename _Tp>
        complex&
        operator/=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value /= __t;
   return *this;
 }

      const _ComplexT __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  template<>
    struct complex<long double>
    {
      typedef long double value_type;
      typedef __complex__ long double _ComplexT;

                         complex(_ComplexT __z) : _M_value(__z) { }

                         complex(long double __r = 0.0L,
     long double __i = 0.0L)



      {
 __real__ _M_value = __r;
 __imag__ _M_value = __i;
      }


                         complex(const complex<float>& __z)
      : _M_value(__z.__rep()) { }

                         complex(const complex<double>& __z)
      : _M_value(__z.__rep()) { }
# 1378 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/complex" 3
      long double&
      real() { return __real__ _M_value; }

      const long double&
      real() const { return __real__ _M_value; }

      long double&
      imag() { return __imag__ _M_value; }

      const long double&
      imag() const { return __imag__ _M_value; }




      void
      real(long double __val) { __real__ _M_value = __val; }

      void
      imag(long double __val) { __imag__ _M_value = __val; }

      complex&
      operator=(long double __r)
      {
 _M_value = __r;
 return *this;
      }

      complex&
      operator+=(long double __r)
      {
 _M_value += __r;
 return *this;
      }

      complex&
      operator-=(long double __r)
      {
 _M_value -= __r;
 return *this;
      }

      complex&
      operator*=(long double __r)
      {
 _M_value *= __r;
 return *this;
      }

      complex&
      operator/=(long double __r)
      {
 _M_value /= __r;
 return *this;
      }




      template<typename _Tp>
        complex&
        operator=(const complex<_Tp>& __z)
 {
   __real__ _M_value = __z.real();
   __imag__ _M_value = __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
 operator+=(const complex<_Tp>& __z)
 {
   __real__ _M_value += __z.real();
   __imag__ _M_value += __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
 operator-=(const complex<_Tp>& __z)
 {
   __real__ _M_value -= __z.real();
   __imag__ _M_value -= __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
 operator*=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value *= __t;
   return *this;
 }

      template<typename _Tp>
        complex&
 operator/=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value /= __t;
   return *this;
 }

      const _ComplexT __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  inline
  complex<float>::complex(const complex<double>& __z)
  : _M_value(__z.__rep()) { }

  inline
  complex<float>::complex(const complex<long double>& __z)
  : _M_value(__z.__rep()) { }

  inline
  complex<double>::complex(const complex<long double>& __z)
  : _M_value(__z.__rep()) { }





  extern template istream& operator>>(istream&, complex<float>&);
  extern template ostream& operator<<(ostream&, const complex<float>&);
  extern template istream& operator>>(istream&, complex<double>&);
  extern template ostream& operator<<(ostream&, const complex<double>&);
  extern template istream& operator>>(istream&, complex<long double>&);
  extern template ostream& operator<<(ostream&, const complex<long double>&);


  extern template wistream& operator>>(wistream&, complex<float>&);
  extern template wostream& operator<<(wostream&, const complex<float>&);
  extern template wistream& operator>>(wistream&, complex<double>&);
  extern template wostream& operator<<(wostream&, const complex<double>&);
  extern template wistream& operator>>(wistream&, complex<long double>&);
  extern template wostream& operator<<(wostream&, const complex<long double>&);






}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp, typename _Up>
    struct __promote_2<std::complex<_Tp>, _Up>
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };

  template<typename _Tp, typename _Up>
    struct __promote_2<_Tp, std::complex<_Up> >
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };

  template<typename _Tp, typename _Up>
    struct __promote_2<std::complex<_Tp>, std::complex<_Up> >
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };


}
# 12 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_complex.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_complex.hpp" 2



namespace boost {
namespace detail{

struct is_convertible_from_tester
{
   template <class T>
   is_convertible_from_tester(const std::complex<T>&);
};

}

template< typename T > struct is_complex : public ::boost::integral_constant<bool,(::boost::is_convertible<T, boost::detail::is_convertible_from_tester>::value)> { public: };

}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 32 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_complex.hpp" 2
# 47 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_compound.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_compound.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 17 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_compound.hpp" 2


namespace boost {


namespace detail {

template <typename T>
struct is_compound_impl
{
   static const bool value = (::boost::type_traits::ice_not< ::boost::is_fundamental<T>::value >::value);



};

}





template< typename T > struct is_compound : public ::boost::integral_constant<bool,::boost::detail::is_compound_impl<T>::value> { public: };


}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 44 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_compound.hpp" 2
# 48 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2



# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_empty.hpp" 1
# 32 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_empty.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 32 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_empty.hpp" 2








namespace boost {

namespace detail {
# 51 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_empty.hpp"
template <typename T>
struct empty_helper_t1 : public T
{
    empty_helper_t1();
    int i[256];
private:

   empty_helper_t1(const empty_helper_t1&);
   empty_helper_t1& operator=(const empty_helper_t1&);
};





struct empty_helper_t2 { int i[256]; };



template <typename T, bool is_a_class = false>
struct empty_helper
{
    static const bool value = false;
};

template <typename T>
struct empty_helper<T, true>
{
    static const bool value = (sizeof(empty_helper_t1<T>) == sizeof(empty_helper_t2));


};

template <typename T>
struct is_empty_impl
{
    typedef typename remove_cv<T>::type cvt;
    static const bool value = ( ::boost::type_traits::ice_or< ::boost::detail::empty_helper<cvt,::boost::is_class<T>::value>::value , false >::value );






};
# 211 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_empty.hpp"
template<> struct is_empty_impl< void > { public: static const bool value = (false); };

template<> struct is_empty_impl< void const > { public: static const bool value = (false); };
template<> struct is_empty_impl< void volatile > { public: static const bool value = (false); };
template<> struct is_empty_impl< void const volatile > { public: static const bool value = (false); };


}

template< typename T > struct is_empty : public ::boost::integral_constant<bool,::boost::detail::is_empty_impl<T>::value> { public: };

}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 224 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_empty.hpp" 2
# 51 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2



# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_floating_point.hpp" 1
# 13 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_floating_point.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 13 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_floating_point.hpp" 2


namespace boost {


template< typename T > struct is_floating_point : public ::boost::integral_constant<bool,false> { public: };
template<> struct is_floating_point< float > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_floating_point< float const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_floating_point< float volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_floating_point< float const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_floating_point< double > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_floating_point< double const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_floating_point< double volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_floating_point< double const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_floating_point< long double > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_floating_point< long double const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_floating_point< long double volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_floating_point< long double const volatile > : public ::boost::integral_constant<bool,true> { public: };

}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_floating_point.hpp" 2
# 54 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2






# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_member_object_pointer.hpp" 1
# 20 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_member_object_pointer.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 20 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_member_object_pointer.hpp" 2


namespace boost {

namespace detail{

template <typename T>
struct is_member_object_pointer_impl
{
   static const bool value = (::boost::type_traits::ice_and< ::boost::is_member_pointer<T>::value, ::boost::type_traits::ice_not< ::boost::is_member_function_pointer<T>::value >::value >::value );






};

}

template< typename T > struct is_member_object_pointer : public ::boost::integral_constant<bool,::boost::detail::is_member_object_pointer_impl<T>::value> { public: };

}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 44 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_member_object_pointer.hpp" 2
# 60 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_object.hpp" 1
# 20 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_object.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 20 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_object.hpp" 2


namespace boost {

namespace detail {

template <typename T>
struct is_object_impl
{

   static const bool value = (::boost::type_traits::ice_and< ::boost::type_traits::ice_not< ::boost::is_reference<T>::value>::value, ::boost::type_traits::ice_not< ::boost::is_void<T>::value>::value, ::boost::type_traits::ice_not< ::boost::is_function<T>::value>::value >::value);
# 43 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_object.hpp"
};

}

template< typename T > struct is_object : public ::boost::integral_constant<bool,::boost::detail::is_object_impl<T>::value> { public: };

}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 51 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_object.hpp" 2
# 62 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_polymorphic.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_polymorphic.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 17 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_polymorphic.hpp" 2



namespace boost{
# 106 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_polymorphic.hpp"
template< typename T > struct is_polymorphic : public ::boost::integral_constant<bool,__is_polymorphic(T)> { public: };



}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 112 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_polymorphic.hpp" 2
# 64 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2




# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_signed.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_signed.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 19 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_signed.hpp" 2


namespace boost {



namespace detail{



template <class T>
struct is_signed_values
{





   typedef typename remove_cv<T>::type no_cv_t;
   static const no_cv_t minus_one = (static_cast<no_cv_t>(-1));
   static const no_cv_t zero = (static_cast<no_cv_t>(0));
};

template <class T>
struct is_signed_helper
{
   typedef typename remove_cv<T>::type no_cv_t;
   static const bool value = (!(::boost::detail::is_signed_values<T>::minus_one > boost::detail::is_signed_values<T>::zero));
};

template <bool integral_type>
struct is_signed_select_helper
{
   template <class T>
   struct rebind
   {
      typedef is_signed_helper<T> type;
   };
};

template <>
struct is_signed_select_helper<false>
{
   template <class T>
   struct rebind
   {
      typedef false_type type;
   };
};

template <class T>
struct is_signed_imp
{
   typedef is_signed_select_helper<
      ::boost::type_traits::ice_or<
         ::boost::is_integral<T>::value,
         ::boost::is_enum<T>::value>::value
   > selector;
   typedef typename selector::template rebind<T> binder;
   typedef typename binder::type type;



   static const bool value = type::value;

};
# 126 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_signed.hpp"
}






template< typename T > struct is_signed : public ::boost::integral_constant<bool,::boost::detail::is_signed_imp<T>::value> { public: };


}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 138 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_signed.hpp" 2
# 68 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2



# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_stateless.hpp" 1
# 21 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_stateless.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 21 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_stateless.hpp" 2


namespace boost {

namespace detail {

template <typename T>
struct is_stateless_impl
{
  static const bool value = (::boost::type_traits::ice_and< ::boost::has_trivial_constructor<T>::value, ::boost::has_trivial_copy<T>::value, ::boost::has_trivial_destructor<T>::value, ::boost::is_class<T>::value, ::boost::is_empty<T>::value >::value);







};

}

template< typename T > struct is_stateless : public ::boost::integral_constant<bool,::boost::detail::is_stateless_impl<T>::value> { public: };

}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 46 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_stateless.hpp" 2
# 71 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_union.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_union.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 19 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_union.hpp" 2


namespace boost {

namespace detail {
# 40 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_union.hpp"
template <typename T> struct is_union_impl
{

   static const bool value = __is_union(T);



};

}

template< typename T > struct is_union : public ::boost::integral_constant<bool,::boost::detail::is_union_impl<T>::value> { public: };

}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 55 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_union.hpp" 2
# 72 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_unsigned.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_unsigned.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 19 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_unsigned.hpp" 2


namespace boost {



namespace detail{



template <class T>
struct is_unsigned_values
{





   typedef typename remove_cv<T>::type no_cv_t;
   static const no_cv_t minus_one = (static_cast<no_cv_t>(-1));
   static const no_cv_t zero = (static_cast<no_cv_t>(0));
};

template <class T>
struct is_ununsigned_helper
{
   static const bool value = (::boost::detail::is_unsigned_values<T>::minus_one > ::boost::detail::is_unsigned_values<T>::zero);
};

template <bool integral_type>
struct is_ununsigned_select_helper
{
   template <class T>
   struct rebind
   {
      typedef is_ununsigned_helper<T> type;
   };
};

template <>
struct is_ununsigned_select_helper<false>
{
   template <class T>
   struct rebind
   {
      typedef false_type type;
   };
};

template <class T>
struct is_unsigned_imp
{
   typedef is_ununsigned_select_helper<
      ::boost::type_traits::ice_or<
         ::boost::is_integral<T>::value,
         ::boost::is_enum<T>::value>::value
   > selector;
   typedef typename selector::template rebind<T> binder;
   typedef typename binder::type type;
   static const bool value = type::value;
};
# 121 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_unsigned.hpp"
}






template< typename T > struct is_unsigned : public ::boost::integral_constant<bool,::boost::detail::is_unsigned_imp<T>::value> { public: };


}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1
# 133 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_unsigned.hpp" 2
# 73 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_virtual_base_of.hpp" 1
# 13 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_virtual_base_of.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/and.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/and.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/config/use_preprocessed.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/mpl/and.hpp" 2






# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/nested_type_wknd.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/nested_type_wknd.hpp"
namespace boost { namespace mpl { namespace aux {
template< typename T > struct nested_type_wknd
    : T::type
{
};
}}}
# 23 "/home/marek/devel/nupic/external/common/include/boost/mpl/and.hpp" 2
# 42 "/home/marek/devel/nupic/external/common/include/boost/mpl/and.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/config/compiler.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/include_preprocessed.hpp" 2



# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/include_preprocessed.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/stringize.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/stringize.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/stringize.hpp" 2
# 20 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessed/gcc/and.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessed/gcc/and.hpp"
namespace boost { namespace mpl {

namespace aux {

template< bool C_, typename T1, typename T2, typename T3, typename T4 >
struct and_impl
    : false_
{
};

template< typename T1, typename T2, typename T3, typename T4 >
struct and_impl< true,T1,T2,T3,T4 >
    : and_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4
        , true_
        >
{
};

template<>
struct and_impl<
          true
        , true_, true_, true_, true_
        >
    : true_
{
};

}

template<
      typename T1 = na
    , typename T2 = na
    , typename T3 = true_, typename T4 = true_, typename T5 = true_
    >
struct and_

    : aux::and_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4, T5
        >

{





};

template<> struct and_< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : and_< T1 , T2 > { }; }; template< typename Tag > struct lambda< and_< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef and_< na , na > result_; typedef and_< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< and_< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< and_< na , na > > : int_<-1> { }; }





}}
# 37 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 42 "/home/marek/devel/nupic/external/common/include/boost/mpl/and.hpp" 2
# 13 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_virtual_base_of.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/not.hpp" 1
# 23 "/home/marek/devel/nupic/external/common/include/boost/mpl/not.hpp"
namespace boost { namespace mpl {

namespace aux {

template< long C_ >
struct not_impl
    : bool_<!C_>
{
};

}


template<
      typename T = na
    >
struct not_
    : aux::not_impl<
          ::boost::mpl::aux::nested_type_wknd<T>::value
        >
{

};

template<> struct not_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : not_< T1 > { }; }; template< typename Tag > struct lambda< not_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef not_< na > result_; typedef not_< na > type; }; namespace aux { template< typename T1 > struct template_arity< not_< T1 > > : int_<1> { }; template<> struct template_arity< not_< na > > : int_<-1> { }; }

}}
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_virtual_base_of.hpp" 2



# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_def.hpp" 2
# 17 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_virtual_base_of.hpp" 2


namespace boost {
namespace detail {
# 28 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_virtual_base_of.hpp" 3


template<typename Base, typename Derived, typename tag>
struct is_virtual_base_of_impl
{
    static const bool value = false;
};

template<typename Base, typename Derived>
struct is_virtual_base_of_impl<Base, Derived, mpl::true_>
{
# 55 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_virtual_base_of.hpp" 3
    struct boost_type_traits_internal_struct_X : public Derived, virtual Base
    {
       boost_type_traits_internal_struct_X();
       boost_type_traits_internal_struct_X(const boost_type_traits_internal_struct_X&);
       boost_type_traits_internal_struct_X& operator=(const boost_type_traits_internal_struct_X&);
       ~boost_type_traits_internal_struct_X()throw();
    };
    struct boost_type_traits_internal_struct_Y : public Derived
    {
       boost_type_traits_internal_struct_Y();
       boost_type_traits_internal_struct_Y(const boost_type_traits_internal_struct_Y&);
       boost_type_traits_internal_struct_Y& operator=(const boost_type_traits_internal_struct_Y&);
       ~boost_type_traits_internal_struct_Y()throw();
    };

    static const bool value = (sizeof(boost_type_traits_internal_struct_X)==sizeof(boost_type_traits_internal_struct_Y));
};

template<typename Base, typename Derived>
struct is_virtual_base_of_impl2
{
   typedef typename mpl::and_<is_base_of<Base, Derived>, mpl::not_<is_same<Base, Derived> > >::type tag_type;
   typedef is_virtual_base_of_impl<Base, Derived, tag_type> imp;
   static const bool value = imp::value;
};





}

template< typename Base, typename Derived > struct is_virtual_base_of : public ::boost::integral_constant<bool,(::boost::detail::is_virtual_base_of_impl2<Base,Derived>::value)> { public: };







template< typename Base, typename Derived > struct is_virtual_base_of< Base&,Derived > : public ::boost::integral_constant<bool,false> { public: };
template< typename Base, typename Derived > struct is_virtual_base_of< Base,Derived& > : public ::boost::integral_constant<bool,false> { public: };
template< typename Base, typename Derived > struct is_virtual_base_of< Base&,Derived& > : public ::boost::integral_constant<bool,false> { public: };


}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3
# 102 "/home/marek/devel/nupic/external/common/include/boost/type_traits/is_virtual_base_of.hpp" 2 3
# 75 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/make_unsigned.hpp" 1
# 29 "/home/marek/devel/nupic/external/common/include/boost/type_traits/make_unsigned.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 29 "/home/marek/devel/nupic/external/common/include/boost/type_traits/make_unsigned.hpp" 2


namespace boost {

namespace detail {

template <class T>
struct make_unsigned_imp
{
   typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (((::boost::type_traits::ice_or< ::boost::is_integral<T>::value, ::boost::is_enum<T>::value>::value)) == 0 ? false : true) >)> boost_static_assert_typedef_39;


   typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (((::boost::type_traits::ice_not< ::boost::is_same< typename remove_cv<T>::type, bool>::value>::value)) == 0 ? false : true) >)> boost_static_assert_typedef_43;




   typedef typename remove_cv<T>::type t_no_cv;
   typedef typename mpl::if_c<
      (::boost::type_traits::ice_and<
         ::boost::is_unsigned<T>::value,
         ::boost::is_integral<T>::value,
         ::boost::type_traits::ice_not< ::boost::is_same<t_no_cv, char>::value>::value,
         ::boost::type_traits::ice_not< ::boost::is_same<t_no_cv, wchar_t>::value>::value,
         ::boost::type_traits::ice_not< ::boost::is_same<t_no_cv, bool>::value>::value >::value),
      T,
      typename mpl::if_c<
         (::boost::type_traits::ice_and<
            ::boost::is_integral<T>::value,
            ::boost::type_traits::ice_not< ::boost::is_same<t_no_cv, char>::value>::value,
            ::boost::type_traits::ice_not< ::boost::is_same<t_no_cv, wchar_t>::value>::value,
            ::boost::type_traits::ice_not< ::boost::is_same<t_no_cv, bool>::value>::value>
         ::value),
         typename mpl::if_<
            is_same<t_no_cv, signed char>,
            unsigned char,
            typename mpl::if_<
               is_same<t_no_cv, short>,
               unsigned short,
               typename mpl::if_<
                  is_same<t_no_cv, int>,
                  unsigned int,
                  typename mpl::if_<
                     is_same<t_no_cv, long>,
                     unsigned long,

                     boost::ulong_long_type





                  >::type
               >::type
            >::type
         >::type,

         typename mpl::if_c<
            sizeof(t_no_cv) == sizeof(unsigned char),
            unsigned char,
            typename mpl::if_c<
               sizeof(t_no_cv) == sizeof(unsigned short),
               unsigned short,
               typename mpl::if_c<
                  sizeof(t_no_cv) == sizeof(unsigned int),
                  unsigned int,
                  typename mpl::if_c<
                     sizeof(t_no_cv) == sizeof(unsigned long),
                     unsigned long,

                     boost::ulong_long_type





                  >::type
               >::type
            >::type
         >::type
      >::type
   >::type base_integer_type;


   typedef typename mpl::if_<
      is_const<T>,
      typename add_const<base_integer_type>::type,
      base_integer_type
   >::type const_base_integer_type;


   typedef typename mpl::if_<
      is_volatile<T>,
      typename add_volatile<const_base_integer_type>::type,
      const_base_integer_type
   >::type type;
};


}

template< typename T > struct make_unsigned { public: typedef typename boost::detail::make_unsigned_imp<T>::type type; };

}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 134 "/home/marek/devel/nupic/external/common/include/boost/type_traits/make_unsigned.hpp" 2
# 77 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/make_signed.hpp" 1
# 29 "/home/marek/devel/nupic/external/common/include/boost/type_traits/make_signed.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 29 "/home/marek/devel/nupic/external/common/include/boost/type_traits/make_signed.hpp" 2


namespace boost {

namespace detail {

template <class T>
struct make_signed_imp
{
   typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (((::boost::type_traits::ice_or< ::boost::is_integral<T>::value, ::boost::is_enum<T>::value>::value)) == 0 ? false : true) >)> boost_static_assert_typedef_39;


   typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (((::boost::type_traits::ice_not< ::boost::is_same< typename remove_cv<T>::type, bool>::value>::value)) == 0 ? false : true) >)> boost_static_assert_typedef_43;




   typedef typename remove_cv<T>::type t_no_cv;
   typedef typename mpl::if_c<
      (::boost::type_traits::ice_and<
         ::boost::is_signed<T>::value,
         ::boost::is_integral<T>::value,
         ::boost::type_traits::ice_not< ::boost::is_same<t_no_cv, char>::value>::value,
         ::boost::type_traits::ice_not< ::boost::is_same<t_no_cv, wchar_t>::value>::value,
         ::boost::type_traits::ice_not< ::boost::is_same<t_no_cv, bool>::value>::value >::value),
      T,
      typename mpl::if_c<
         (::boost::type_traits::ice_and<
            ::boost::is_integral<T>::value,
            ::boost::type_traits::ice_not< ::boost::is_same<t_no_cv, char>::value>::value,
            ::boost::type_traits::ice_not< ::boost::is_same<t_no_cv, wchar_t>::value>::value,
            ::boost::type_traits::ice_not< ::boost::is_same<t_no_cv, bool>::value>::value>
         ::value),
         typename mpl::if_<
            is_same<t_no_cv, unsigned char>,
            signed char,
            typename mpl::if_<
               is_same<t_no_cv, unsigned short>,
               signed short,
               typename mpl::if_<
                  is_same<t_no_cv, unsigned int>,
                  int,
                  typename mpl::if_<
                     is_same<t_no_cv, unsigned long>,
                     long,

                     boost::long_long_type





                  >::type
               >::type
            >::type
         >::type,

         typename mpl::if_c<
            sizeof(t_no_cv) == sizeof(unsigned char),
            signed char,
            typename mpl::if_c<
               sizeof(t_no_cv) == sizeof(unsigned short),
               signed short,
               typename mpl::if_c<
                  sizeof(t_no_cv) == sizeof(unsigned int),
                  int,
                  typename mpl::if_c<
                     sizeof(t_no_cv) == sizeof(unsigned long),
                     long,

                     boost::long_long_type





                  >::type
               >::type
            >::type
         >::type
      >::type
   >::type base_integer_type;


   typedef typename mpl::if_<
      is_const<T>,
      typename add_const<base_integer_type>::type,
      base_integer_type
   >::type const_base_integer_type;


   typedef typename mpl::if_<
      is_volatile<T>,
      typename add_volatile<const_base_integer_type>::type,
      const_base_integer_type
   >::type type;
};


}

template< typename T > struct make_signed { public: typedef typename boost::detail::make_signed_imp<T>::type type; };

}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 134 "/home/marek/devel/nupic/external/common/include/boost/type_traits/make_signed.hpp" 2
# 78 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/rank.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/rank.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/size_t_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/size_t_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/size_t_trait_def.hpp" 2





# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 2 3
# 19 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/size_t_trait_def.hpp" 2
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/rank.hpp" 2


namespace boost {



namespace detail{

template <class T, std::size_t N>
struct rank_imp
{
   static const std::size_t value = N;
};

template <class T, std::size_t R, std::size_t N>
struct rank_imp<T[R], N>
{
   static const std::size_t value = (::boost::detail::rank_imp<T, N+1>::value);
};

template <class T, std::size_t R, std::size_t N>
struct rank_imp<T const[R], N>
{
   static const std::size_t value = (::boost::detail::rank_imp<T, N+1>::value);
};

template <class T, std::size_t R, std::size_t N>
struct rank_imp<T volatile[R], N>
{
   static const std::size_t value = (::boost::detail::rank_imp<T, N+1>::value);
};

template <class T, std::size_t R, std::size_t N>
struct rank_imp<T const volatile[R], N>
{
   static const std::size_t value = (::boost::detail::rank_imp<T, N+1>::value);
};


template <class T, std::size_t N>
struct rank_imp<T[], N>
{
   static const std::size_t value = (::boost::detail::rank_imp<T, N+1>::value);
};
template <class T, std::size_t N>
struct rank_imp<T const[], N>
{
   static const std::size_t value = (::boost::detail::rank_imp<T, N+1>::value);
};
template <class T, std::size_t N>
struct rank_imp<T volatile[], N>
{
   static const std::size_t value = (::boost::detail::rank_imp<T, N+1>::value);
};
template <class T, std::size_t N>
struct rank_imp<T const volatile[], N>
{
   static const std::size_t value = (::boost::detail::rank_imp<T, N+1>::value);
};


}






template< typename T > struct rank : public ::boost::integral_constant<std::size_t,(::boost::detail::rank_imp<T,0>::value)> { public: };


}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/size_t_trait_undef.hpp" 1
# 87 "/home/marek/devel/nupic/external/common/include/boost/type_traits/rank.hpp" 2
# 79 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_extent.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_extent.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 2 3
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_extent.hpp" 2







# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 21 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_extent.hpp" 2




namespace boost {

template< typename T > struct remove_extent { public: typedef T type; };


template< typename T, std::size_t N > struct remove_extent<T[N]> { public: typedef T type; };
template< typename T, std::size_t N > struct remove_extent<T const[N]> { public: typedef T const type; };
template< typename T, std::size_t N > struct remove_extent<T volatile[N]> { public: typedef T volatile type; };
template< typename T, std::size_t N > struct remove_extent<T const volatile[N]> { public: typedef T const volatile type; };

template< typename T > struct remove_extent<T[]> { public: typedef T type; };
template< typename T > struct remove_extent<T const[]> { public: typedef T const type; };
template< typename T > struct remove_extent<T volatile[]> { public: typedef T volatile type; };
template< typename T > struct remove_extent<T const volatile[]> { public: typedef T const volatile type; };



}




# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 46 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_extent.hpp" 2
# 81 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_all_extents.hpp" 1
# 13 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_all_extents.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 2 3
# 13 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_all_extents.hpp" 2








# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 21 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_all_extents.hpp" 2




namespace boost {

template< typename T > struct remove_all_extents { public: typedef T type; };


template< typename T, std::size_t N > struct remove_all_extents<T[N]> { public: typedef typename boost::remove_all_extents<T>::type type; };
template< typename T, std::size_t N > struct remove_all_extents<T const[N]> { public: typedef typename boost::remove_all_extents<T const>::type type; };
template< typename T, std::size_t N > struct remove_all_extents<T volatile[N]> { public: typedef typename boost::remove_all_extents<T volatile>::type type; };
template< typename T, std::size_t N > struct remove_all_extents<T const volatile[N]> { public: typedef typename boost::remove_all_extents<T const volatile>::type type; };

template< typename T > struct remove_all_extents<T[]> { public: typedef typename boost::remove_all_extents<T>::type type; };
template< typename T > struct remove_all_extents<T const[]> { public: typedef typename boost::remove_all_extents<T const>::type type; };
template< typename T > struct remove_all_extents<T volatile[]> { public: typedef typename boost::remove_all_extents<T volatile>::type type; };
template< typename T > struct remove_all_extents<T const volatile[]> { public: typedef typename boost::remove_all_extents<T const volatile>::type type; };



}




# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 46 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_all_extents.hpp" 2
# 82 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_const.hpp" 1
# 20 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_const.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 2 3
# 20 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_const.hpp" 2







# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 27 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_const.hpp" 2


namespace boost {



namespace detail {

template <typename T, bool is_vol>
struct remove_const_helper
{
    typedef T type;
};

template <typename T>
struct remove_const_helper<T, true>
{
    typedef T volatile type;
};


template <typename T>
struct remove_const_impl
{
    typedef typename remove_const_helper<
          typename cv_traits_imp<T*>::unqualified_type
        , ::boost::is_volatile<T>::value
        >::type type;
};
# 69 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_const.hpp"
}



template< typename T > struct remove_const { public: typedef typename boost::detail::remove_const_impl<T>::type type; };
template< typename T > struct remove_const<T&> { public: typedef T& type; };

template< typename T, std::size_t N > struct remove_const<T const[N]> { public: typedef T type[N]; };
template< typename T, std::size_t N > struct remove_const<T const volatile[N]> { public: typedef T volatile type[N]; };
# 86 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_const.hpp"
}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 88 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_const.hpp" 2
# 83 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2




# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_volatile.hpp" 1
# 20 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_volatile.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 2 3
# 20 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_volatile.hpp" 2







# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 27 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_volatile.hpp" 2


namespace boost {



namespace detail {

template <typename T, bool is_const>
struct remove_volatile_helper
{
    typedef T type;
};

template <typename T>
struct remove_volatile_helper<T,true>
{
    typedef T const type;
};

template <typename T>
struct remove_volatile_impl
{
    typedef typename remove_volatile_helper<
          typename cv_traits_imp<T*>::unqualified_type
        , ::boost::is_const<T>::value
        >::type type;
};
# 67 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_volatile.hpp"
}



template< typename T > struct remove_volatile { public: typedef typename boost::detail::remove_volatile_impl<T>::type type; };
template< typename T > struct remove_volatile<T&> { public: typedef T& type; };

template< typename T, std::size_t N > struct remove_volatile<T volatile[N]> { public: typedef T type[N]; };
template< typename T, std::size_t N > struct remove_volatile<T const volatile[N]> { public: typedef T const type[N]; };
# 84 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_volatile.hpp"
}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 86 "/home/marek/devel/nupic/external/common/include/boost/type_traits/remove_volatile.hpp" 2
# 87 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2



# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/integral_promotion.hpp" 1
# 20 "/home/marek/devel/nupic/external/common/include/boost/type_traits/integral_promotion.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 20 "/home/marek/devel/nupic/external/common/include/boost/type_traits/integral_promotion.hpp" 2


namespace boost {

namespace type_traits { namespace detail {


template <class T> struct need_promotion : public boost::is_enum<T> {};


template<> struct need_promotion<char > : public true_type {};
template<> struct need_promotion<signed char > : public true_type {};
template<> struct need_promotion<unsigned char > : public true_type {};
template<> struct need_promotion<signed short int > : public true_type {};
template<> struct need_promotion<unsigned short int> : public true_type {};
# 63 "/home/marek/devel/nupic/external/common/include/boost/type_traits/integral_promotion.hpp"
template<> struct need_promotion<boost::ulong_long_type> : public integral_constant<bool, (sizeof(boost::ulong_long_type) < sizeof(int))> {};
template<> struct need_promotion<boost::long_long_type> : public integral_constant<bool, (sizeof(boost::long_long_type) < sizeof(int))> {};
# 75 "/home/marek/devel/nupic/external/common/include/boost/type_traits/integral_promotion.hpp"
template<> struct need_promotion<wchar_t> : public true_type {};





template<> struct need_promotion<bool> : public true_type {};




template<int Index, int IsConst, int IsVolatile> struct promote_from_index;
# 95 "/home/marek/devel/nupic/external/common/include/boost/type_traits/integral_promotion.hpp"
template<> struct promote_from_index<1,0,0> { typedef int type; }; template<> struct promote_from_index<1,0,1> { typedef int volatile type; }; template<> struct promote_from_index<1,1,0> { typedef int const type; }; template<> struct promote_from_index<1,1,1> { typedef int const volatile type; };
template<> struct promote_from_index<2,0,0> { typedef unsigned int type; }; template<> struct promote_from_index<2,0,1> { typedef unsigned int volatile type; }; template<> struct promote_from_index<2,1,0> { typedef unsigned int const type; }; template<> struct promote_from_index<2,1,1> { typedef unsigned int const volatile type; };
template<> struct promote_from_index<3,0,0> { typedef long type; }; template<> struct promote_from_index<3,0,1> { typedef long volatile type; }; template<> struct promote_from_index<3,1,0> { typedef long const type; }; template<> struct promote_from_index<3,1,1> { typedef long const volatile type; };
template<> struct promote_from_index<4,0,0> { typedef unsigned long type; }; template<> struct promote_from_index<4,0,1> { typedef unsigned long volatile type; }; template<> struct promote_from_index<4,1,0> { typedef unsigned long const type; }; template<> struct promote_from_index<4,1,1> { typedef unsigned long const volatile type; };
# 107 "/home/marek/devel/nupic/external/common/include/boost/type_traits/integral_promotion.hpp"
template<> struct promote_from_index<5,0,0> { typedef boost::long_long_type type; }; template<> struct promote_from_index<5,0,1> { typedef boost::long_long_type volatile type; }; template<> struct promote_from_index<5,1,0> { typedef boost::long_long_type const type; }; template<> struct promote_from_index<5,1,1> { typedef boost::long_long_type const volatile type; };
template<> struct promote_from_index<6,0,0> { typedef boost::ulong_long_type type; }; template<> struct promote_from_index<6,0,1> { typedef boost::ulong_long_type volatile type; }; template<> struct promote_from_index<6,1,0> { typedef boost::ulong_long_type const type; }; template<> struct promote_from_index<6,1,1> { typedef boost::ulong_long_type const volatile type; };
# 120 "/home/marek/devel/nupic/external/common/include/boost/type_traits/integral_promotion.hpp"
template<int N>
struct sized_type_for_promotion
{
    typedef char (&type)[N];
};
# 136 "/home/marek/devel/nupic/external/common/include/boost/type_traits/integral_promotion.hpp"
sized_type_for_promotion<1>::type promoted_index_tester(int);
sized_type_for_promotion<2>::type promoted_index_tester(unsigned int);
sized_type_for_promotion<3>::type promoted_index_tester(long);
sized_type_for_promotion<4>::type promoted_index_tester(unsigned long);


sized_type_for_promotion<5>::type promoted_index_tester(boost::long_long_type);
sized_type_for_promotion<6>::type promoted_index_tester(boost::ulong_long_type);
# 154 "/home/marek/devel/nupic/external/common/include/boost/type_traits/integral_promotion.hpp"
template<class T>
struct promoted_index
{
    static T testee;
    static const int value = sizeof(promoted_index_tester(+testee));

};

template<class T>
struct integral_promotion_impl
{
    typedef typename promote_from_index<
        (boost::type_traits::detail::promoted_index<T>::value)
      , (boost::is_const<T>::value)
      , (boost::is_volatile<T>::value)
      >::type type;
};

template<class T>
struct integral_promotion
  : public boost::mpl::eval_if<
        need_promotion<typename remove_cv<T>::type>
      , integral_promotion_impl<T>
      , boost::mpl::identity<T>
      >
{
};

} }

template< typename T > struct integral_promotion { public: typedef typename boost::type_traits::detail::integral_promotion<T>::type type; };





}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 192 "/home/marek/devel/nupic/external/common/include/boost/type_traits/integral_promotion.hpp" 2
# 90 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/promote.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/promote.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/template_arity_spec.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_def.hpp" 2
# 14 "/home/marek/devel/nupic/external/common/include/boost/type_traits/promote.hpp" 2


namespace boost {

namespace detail {

template<class T>
struct promote_impl
  : public integral_promotion<
        typename floating_point_promotion<T>::type
      >
{
};

}

template< typename T > struct promote { public: typedef typename boost::detail::promote_impl<T>::type type; };




}


# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/detail/type_trait_undef.hpp" 1
# 37 "/home/marek/devel/nupic/external/common/include/boost/type_traits/promote.hpp" 2
# 91 "/home/marek/devel/nupic/external/common/include/boost/type_traits.hpp" 2
# 39 "/home/marek/devel/nupic/nta/math/stl_io.hpp" 2



# 1 "/home/marek/devel/nupic/nta/math/array_algo.hpp" 1
# 34 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/iterator" 1 3
# 59 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/iterator" 3







# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stream_iterator.h" 1 3
# 34 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stream_iterator.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{
# 47 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stream_iterator.h" 3
  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t>
    class istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Dist, const _Tp*, const _Tp&>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_istream<_CharT, _Traits> istream_type;

    private:
      istream_type* _M_stream;
      _Tp _M_value;
      bool _M_ok;

    public:

                         istream_iterator()
      : _M_stream(0), _M_value(), _M_ok(false) {}


      istream_iterator(istream_type& __s)
      : _M_stream(&__s)
      { _M_read(); }

      istream_iterator(const istream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_value(__obj._M_value),
        _M_ok(__obj._M_ok)
      { }

      const _Tp&
      operator*() const
      {


                        ;
 return _M_value;
      }

      const _Tp*
      operator->() const { return &(operator*()); }

      istream_iterator&
      operator++()
      {


                        ;
 _M_read();
 return *this;
      }

      istream_iterator
      operator++(int)
      {


                        ;
 istream_iterator __tmp = *this;
 _M_read();
 return __tmp;
      }

      bool
      _M_equal(const istream_iterator& __x) const
      { return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream); }

    private:
      void
      _M_read()
      {
 _M_ok = (_M_stream && *_M_stream) ? true : false;
 if (_M_ok)
   {
     *_M_stream >> _M_value;
     _M_ok = *_M_stream ? true : false;
   }
      }
    };


  template<typename _Tp, typename _CharT, typename _Traits, typename _Dist>
    inline bool
    operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return __x._M_equal(__y); }


  template <class _Tp, class _CharT, class _Traits, class _Dist>
    inline bool
    operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return !__x._M_equal(__y); }
# 152 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stream_iterator.h" 3
  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT> >
    class ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:


      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


    private:
      ostream_type* _M_stream;
      const _CharT* _M_string;

    public:

      ostream_iterator(ostream_type& __s) : _M_stream(&__s), _M_string(0) {}
# 183 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stream_iterator.h" 3
      ostream_iterator(ostream_type& __s, const _CharT* __c)
      : _M_stream(&__s), _M_string(__c) { }


      ostream_iterator(const ostream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_string(__obj._M_string) { }



      ostream_iterator&
      operator=(const _Tp& __value)
      {


                        ;
 *_M_stream << __value;
 if (_M_string) *_M_stream << _M_string;
 return *this;
      }

      ostream_iterator&
      operator*()
      { return *this; }

      ostream_iterator&
      operator++()
      { return *this; }

      ostream_iterator&
      operator++(int)
      { return *this; }
    };




}
# 67 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/iterator" 2 3
# 35 "/home/marek/devel/nupic/nta/math/array_algo.hpp" 2


# 1 "/home/marek/devel/nupic/nta/utils/Random.hpp" 1
# 29 "/home/marek/devel/nupic/nta/utils/Random.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdlib" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdlib" 3
# 30 "/home/marek/devel/nupic/nta/utils/Random.hpp" 2
# 38 "/home/marek/devel/nupic/nta/math/array_algo.hpp" 2
# 1 "/home/marek/devel/nupic/nta/math/math.hpp" 1
# 35 "/home/marek/devel/nupic/nta/math/math.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/numeric" 1 3
# 59 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/numeric" 3



# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_numeric.h" 1 3
# 103 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_numeric.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 118 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _Tp
    accumulate(_InputIterator __first, _InputIterator __last, _Tp __init)
    {


                                                     ;

      for (; __first != __last; ++__first)
 __init = __init + *__first;
      return __init;
    }
# 144 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _Tp, typename _BinaryOperation>
    inline _Tp
    accumulate(_InputIterator __first, _InputIterator __last, _Tp __init,
        _BinaryOperation __binary_op)
    {


                                                     ;

      for (; __first != __last; ++__first)
 __init = __binary_op(__init, *__first);
      return __init;
    }
# 172 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_numeric.h" 3
  template<typename _InputIterator1, typename _InputIterator2, typename _Tp>
    inline _Tp
    inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
    _InputIterator2 __first2, _Tp __init)
    {



                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 __init = __init + (*__first1 * *__first2);
      return __init;
    }
# 203 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_numeric.h" 3
  template<typename _InputIterator1, typename _InputIterator2, typename _Tp,
    typename _BinaryOperation1, typename _BinaryOperation2>
    inline _Tp
    inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
    _InputIterator2 __first2, _Tp __init,
    _BinaryOperation1 __binary_op1,
    _BinaryOperation2 __binary_op2)
    {



                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 __init = __binary_op1(__init, __binary_op2(*__first1, *__first2));
      return __init;
    }
# 235 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    partial_sum(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;





                                                     ;

      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   __value = __value + *__first;
   *++__result = __value;
 }
      return ++__result;
    }
# 275 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryOperation>
    _OutputIterator
    partial_sum(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, _BinaryOperation __binary_op)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;





                                                     ;

      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   __value = __binary_op(__value, *__first);
   *++__result = __value;
 }
      return ++__result;
    }
# 315 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    adjacent_difference(_InputIterator __first,
   _InputIterator __last, _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;





                                                     ;

      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   _ValueType __tmp = *__first;
   *++__result = __tmp - __value;
   __value = (__tmp);
 }
      return ++__result;
    }
# 357 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_numeric.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryOperation>
    _OutputIterator
    adjacent_difference(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result, _BinaryOperation __binary_op)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;





                                                     ;

      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   _ValueType __tmp = *__first;
   *++__result = __binary_op(__tmp, __value);
   __value = (__tmp);
 }
      return ++__result;
    }


}
# 63 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/numeric" 2 3
# 36 "/home/marek/devel/nupic/nta/math/math.hpp" 2

# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/limits" 1 3
# 41 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/limits" 3
# 147 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/limits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 191 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/limits" 3
  struct __numeric_limits_base
  {


    static const bool is_specialized = false;




    static const int digits = 0;


    static const int digits10 = 0;
# 212 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/limits" 3
    static const bool is_signed = false;


    static const bool is_integer = false;




    static const bool is_exact = false;



    static const int radix = 0;



    static const int min_exponent = 0;



    static const int min_exponent10 = 0;




    static const int max_exponent = 0;



    static const int max_exponent10 = 0;


    static const bool has_infinity = false;



    static const bool has_quiet_NaN = false;



    static const bool has_signaling_NaN = false;


    static const float_denorm_style has_denorm = denorm_absent;



    static const bool has_denorm_loss = false;



    static const bool is_iec559 = false;




    static const bool is_bounded = false;
# 277 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/limits" 3
    static const bool is_modulo = false;


    static const bool traps = false;


    static const bool tinyness_before = false;




    static const float_round_style round_style =
          round_toward_zero;
  };
# 303 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static _Tp
      min() throw() { return _Tp(); }


      static _Tp
      max() throw() { return _Tp(); }
# 324 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/limits" 3
      static _Tp
      epsilon() throw() { return _Tp(); }


      static _Tp
      round_error() throw() { return _Tp(); }


      static _Tp
      infinity() throw() { return _Tp(); }



      static _Tp
      quiet_NaN() throw() { return _Tp(); }



      static _Tp
      signaling_NaN() throw() { return _Tp(); }




      static _Tp
      denorm_min() throw() { return _Tp(); }
    };
# 370 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/limits" 3
  template<>
    struct numeric_limits<bool>
    {
      static const bool is_specialized = true;

      static bool
      min() throw() { return false; }

      static bool
      max() throw() { return true; }





      static const int digits = 1;
      static const int digits10 = 0;



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static bool
      epsilon() throw() { return false; }

      static bool
      round_error() throw() { return false; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static bool
      infinity() throw() { return false; }

      static bool
      quiet_NaN() throw() { return false; }

      static bool
      signaling_NaN() throw() { return false; }

      static bool
      denorm_min() throw() { return false; }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;




      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static const bool is_specialized = true;

      static char
      min() throw() { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static char
      max() throw() { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }






      static const int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static const int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = ((char)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static char
      epsilon() throw() { return 0; }

      static char
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static
      char infinity() throw() { return char(); }

      static char
      quiet_NaN() throw() { return char(); }

      static char
      signaling_NaN() throw() { return char(); }

      static char
      denorm_min() throw() { return static_cast<char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = !is_signed;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static const bool is_specialized = true;

      static signed char
      min() throw() { return -127 - 1; }

      static signed char
      max() throw() { return 127; }






      static const int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static const int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static signed char
      epsilon() throw() { return 0; }

      static signed char
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static signed char
      infinity() throw() { return static_cast<signed char>(0); }

      static signed char
      quiet_NaN() throw() { return static_cast<signed char>(0); }

      static signed char
      signaling_NaN() throw()
      { return static_cast<signed char>(0); }

      static signed char
      denorm_min() throw()
      { return static_cast<signed char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static const bool is_specialized = true;

      static unsigned char
      min() throw() { return 0; }

      static unsigned char
      max() throw() { return 127 * 2U + 1; }






      static const int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned char
      epsilon() throw() { return 0; }

      static unsigned char
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned char
      infinity() throw()
      { return static_cast<unsigned char>(0); }

      static unsigned char
      quiet_NaN() throw()
      { return static_cast<unsigned char>(0); }

      static unsigned char
      signaling_NaN() throw()
      { return static_cast<unsigned char>(0); }

      static unsigned char
      denorm_min() throw()
      { return static_cast<unsigned char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static const bool is_specialized = true;

      static wchar_t
      min() throw() { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static wchar_t
      max() throw() { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }






      static const int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static const int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = ((wchar_t)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static wchar_t
      epsilon() throw() { return 0; }

      static wchar_t
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static wchar_t
      infinity() throw() { return wchar_t(); }

      static wchar_t
      quiet_NaN() throw() { return wchar_t(); }

      static wchar_t
      signaling_NaN() throw() { return wchar_t(); }

      static wchar_t
      denorm_min() throw() { return wchar_t(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = !is_signed;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };
# 841 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/limits" 3
  template<>
    struct numeric_limits<short>
    {
      static const bool is_specialized = true;

      static short
      min() throw() { return -32767 - 1; }

      static short
      max() throw() { return 32767; }






      static const int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static const int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static short
      epsilon() throw() { return 0; }

      static short
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static short
      infinity() throw() { return short(); }

      static short
      quiet_NaN() throw() { return short(); }

      static short
      signaling_NaN() throw() { return short(); }

      static short
      denorm_min() throw() { return short(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static const bool is_specialized = true;

      static unsigned short
      min() throw() { return 0; }

      static unsigned short
      max() throw() { return 32767 * 2U + 1; }






      static const int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned short
      epsilon() throw() { return 0; }

      static unsigned short
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned short
      infinity() throw()
      { return static_cast<unsigned short>(0); }

      static unsigned short
      quiet_NaN() throw()
      { return static_cast<unsigned short>(0); }

      static unsigned short
      signaling_NaN() throw()
      { return static_cast<unsigned short>(0); }

      static unsigned short
      denorm_min() throw()
      { return static_cast<unsigned short>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static const bool is_specialized = true;

      static int
      min() throw() { return -2147483647 - 1; }

      static int
      max() throw() { return 2147483647; }






      static const int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static const int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static int
      epsilon() throw() { return 0; }

      static int
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static int
      infinity() throw() { return static_cast<int>(0); }

      static int
      quiet_NaN() throw() { return static_cast<int>(0); }

      static int
      signaling_NaN() throw() { return static_cast<int>(0); }

      static int
      denorm_min() throw() { return static_cast<int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static const bool is_specialized = true;

      static unsigned int
      min() throw() { return 0; }

      static unsigned int
      max() throw() { return 2147483647 * 2U + 1; }






      static const int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned int
      epsilon() throw() { return 0; }

      static unsigned int
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned int
      infinity() throw() { return static_cast<unsigned int>(0); }

      static unsigned int
      quiet_NaN() throw()
      { return static_cast<unsigned int>(0); }

      static unsigned int
      signaling_NaN() throw()
      { return static_cast<unsigned int>(0); }

      static unsigned int
      denorm_min() throw()
      { return static_cast<unsigned int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static const bool is_specialized = true;

      static long
      min() throw() { return -9223372036854775807L - 1; }

      static long
      max() throw() { return 9223372036854775807L; }






      static const int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static const int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static long
      epsilon() throw() { return 0; }

      static long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static long
      infinity() throw() { return static_cast<long>(0); }

      static long
      quiet_NaN() throw() { return static_cast<long>(0); }

      static long
      signaling_NaN() throw() { return static_cast<long>(0); }

      static long
      denorm_min() throw() { return static_cast<long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static const bool is_specialized = true;

      static unsigned long
      min() throw() { return 0; }

      static unsigned long
      max() throw() { return 9223372036854775807L * 2UL + 1; }






      static const int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned long
      epsilon() throw() { return 0; }

      static unsigned long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long
      infinity() throw()
      { return static_cast<unsigned long>(0); }

      static unsigned long
      quiet_NaN() throw()
      { return static_cast<unsigned long>(0); }

      static unsigned long
      signaling_NaN() throw()
      { return static_cast<unsigned long>(0); }

      static unsigned long
      denorm_min() throw()
      { return static_cast<unsigned long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static const bool is_specialized = true;

      static long long
      min() throw() { return -9223372036854775807LL - 1; }

      static long long
      max() throw() { return 9223372036854775807LL; }






      static const int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static const int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static long long
      epsilon() throw() { return 0; }

      static long long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static long long
      infinity() throw() { return static_cast<long long>(0); }

      static long long
      quiet_NaN() throw() { return static_cast<long long>(0); }

      static long long
      signaling_NaN() throw()
      { return static_cast<long long>(0); }

      static long long
      denorm_min() throw() { return static_cast<long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static const bool is_specialized = true;

      static unsigned long long
      min() throw() { return 0; }

      static unsigned long long
      max() throw() { return 9223372036854775807LL * 2ULL + 1; }






      static const int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned long long
      epsilon() throw() { return 0; }

      static unsigned long long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long long
      infinity() throw()
      { return static_cast<unsigned long long>(0); }

      static unsigned long long
      quiet_NaN() throw()
      { return static_cast<unsigned long long>(0); }

      static unsigned long long
      signaling_NaN() throw()
      { return static_cast<unsigned long long>(0); }

      static unsigned long long
      denorm_min() throw()
      { return static_cast<unsigned long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<__int128>
    {
      static const bool is_specialized = true;

      static __int128
      min() throw() { return (((__int128)(-1) < 0) ? -(((__int128)(-1) < 0) ? (((((__int128)1 << ((sizeof(__int128) * 8 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0) - 1 : (__int128)0); }

      static __int128
      max() throw() { return (((__int128)(-1) < 0) ? (((((__int128)1 << ((sizeof(__int128) * 8 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0); }






      static const int digits
       = (sizeof(__int128) * 8 - ((__int128)(-1) < 0));
      static const int digits10
       = ((sizeof(__int128) * 8 - ((__int128)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static __int128
      epsilon() throw() { return 0; }

      static __int128
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static __int128
      infinity() throw()
      { return static_cast<__int128>(0); }

      static __int128
      quiet_NaN() throw()
      { return static_cast<__int128>(0); }

      static __int128
      signaling_NaN() throw()
      { return static_cast<__int128>(0); }

      static __int128
      denorm_min() throw()
      { return static_cast<__int128>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps
       = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned __int128>
    {
      static const bool is_specialized = true;

      static unsigned __int128
      min() throw() { return 0; }

      static unsigned __int128
      max() throw() { return (((unsigned __int128)(-1) < 0) ? (((((unsigned __int128)1 << ((sizeof(unsigned __int128) * 8 - ((unsigned __int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned __int128)0); }






      static const int digits
       = (sizeof(unsigned __int128) * 8 - ((unsigned __int128)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned __int128) * 8 - ((unsigned __int128)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned __int128
      epsilon() throw() { return 0; }

      static unsigned __int128
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned __int128
      infinity() throw()
      { return static_cast<unsigned __int128>(0); }

      static unsigned __int128
      quiet_NaN() throw()
      { return static_cast<unsigned __int128>(0); }

      static unsigned __int128
      signaling_NaN() throw()
      { return static_cast<unsigned __int128>(0); }

      static unsigned __int128
      denorm_min() throw()
      { return static_cast<unsigned __int128>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<float>
    {
      static const bool is_specialized = true;

      static float
      min() throw() { return 1.17549435e-38F; }

      static float
      max() throw() { return 3.40282347e+38F; }






      static const int digits = 24;
      static const int digits10 = 6;




      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;

      static float
      epsilon() throw() { return 1.19209290e-7F; }

      static float
      round_error() throw() { return 0.5F; }

      static const int min_exponent = (-125);
      static const int min_exponent10 = (-37);
      static const int max_exponent = 128;
      static const int max_exponent10 = 38;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
       = false;

      static float
      infinity() throw() { return __builtin_huge_valf(); }

      static float
      quiet_NaN() throw() { return __builtin_nanf(""); }

      static float
      signaling_NaN() throw() { return __builtin_nansf(""); }

      static float
      denorm_min() throw() { return 1.40129846e-45F; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before
       = false;
      static const float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static const bool is_specialized = true;

      static double
      min() throw() { return 2.2250738585072014e-308; }

      static double
      max() throw() { return 1.7976931348623157e+308; }






      static const int digits = 53;
      static const int digits10 = 15;




      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;

      static double
      epsilon() throw() { return 2.2204460492503131e-16; }

      static double
      round_error() throw() { return 0.5; }

      static const int min_exponent = (-1021);
      static const int min_exponent10 = (-307);
      static const int max_exponent = 1024;
      static const int max_exponent10 = 308;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
        = false;

      static double
      infinity() throw() { return __builtin_huge_val(); }

      static double
      quiet_NaN() throw() { return __builtin_nan(""); }

      static double
      signaling_NaN() throw() { return __builtin_nans(""); }

      static double
      denorm_min() throw() { return 4.9406564584124654e-324; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before
       = false;
      static const float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static const bool is_specialized = true;

      static long double
      min() throw() { return 3.36210314311209350626e-4932L; }

      static long double
      max() throw() { return 1.18973149535723176502e+4932L; }






      static const int digits = 64;
      static const int digits10 = 18;




      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;

      static long double
      epsilon() throw() { return 1.08420217248550443401e-19L; }

      static long double
      round_error() throw() { return 0.5L; }

      static const int min_exponent = (-16381);
      static const int min_exponent10 = (-4931);
      static const int max_exponent = 16384;
      static const int max_exponent10 = 4932;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
 = false;

      static long double
      infinity() throw() { return __builtin_huge_vall(); }

      static long double
      quiet_NaN() throw() { return __builtin_nanl(""); }

      static long double
      signaling_NaN() throw() { return __builtin_nansl(""); }

      static long double
      denorm_min() throw() { return 3.64519953188247460253e-4951L; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before =
      false;
      static const float_round_style round_style =
            round_to_nearest;
    };






}
# 38 "/home/marek/devel/nupic/nta/math/math.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/concept_check.hpp" 1
# 20 "/home/marek/devel/nupic/external/common/include/boost/concept_check.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/concept/assert.hpp" 1
# 36 "/home/marek/devel/nupic/external/common/include/boost/concept/assert.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/concept/detail/general.hpp" 1






# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 7 "/home/marek/devel/nupic/external/common/include/boost/concept/detail/general.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/concept/detail/backward_compatibility.hpp" 1






namespace boost
{
  namespace concepts {}




}
# 8 "/home/marek/devel/nupic/external/common/include/boost/concept/detail/general.hpp" 2



# 1 "/home/marek/devel/nupic/external/common/include/boost/concept/detail/has_constraints.hpp" 1
# 11 "/home/marek/devel/nupic/external/common/include/boost/concept/detail/has_constraints.hpp"
namespace boost { namespace concepts {

namespace detail
{



  typedef char yes;
  typedef char (&no)[2];

  template <class Model, void (Model::*)()>
  struct wrap_constraints {};
# 31 "/home/marek/devel/nupic/external/common/include/boost/concept/detail/has_constraints.hpp"
  template <class Model>
  inline yes has_constraints_(Model*, wrap_constraints<Model,&Model::constraints>* = 0);
  inline no has_constraints_(...);

}



template <class Model>
struct not_satisfied
{
    static const bool value = sizeof( detail::has_constraints_((Model*)0) ) == sizeof(detail::yes);


    typedef mpl::bool_<value> type;
};

}}
# 11 "/home/marek/devel/nupic/external/common/include/boost/concept/detail/general.hpp" 2






namespace boost { namespace concepts {

template <class ModelFn>
struct requirement_;

namespace detail
{
  template <void(*)()> struct instantiate {};
}

template <class Model>
struct requirement
{
    static void failed() { ((Model*)0)->~Model(); }
};

struct failed {};

template <class Model>
struct requirement<failed ************ Model::************>
{
    static void failed() { ((Model*)0)->~Model(); }
};



template <class Model>
struct constraint
{
    static void failed() { ((Model*)0)->constraints(); }
};

template <class Model>
struct requirement_<void(*)(Model)>
  : mpl::if_<
        concepts::not_satisfied<Model>
      , constraint<Model>
      , requirement<failed ************ Model::************>
    >::type
{};
# 73 "/home/marek/devel/nupic/external/common/include/boost/concept/detail/general.hpp"
}}
# 36 "/home/marek/devel/nupic/external/common/include/boost/concept/assert.hpp" 2
# 20 "/home/marek/devel/nupic/external/common/include/boost/concept_check.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/iterator.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/iterator.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 2 3
# 18 "/home/marek/devel/nupic/external/common/include/boost/iterator.hpp" 2



namespace boost
{
# 39 "/home/marek/devel/nupic/external/common/include/boost/iterator.hpp"
  namespace detail {
   template <class Category, class T, class Distance, class Pointer, class Reference>

   struct iterator_base : std::iterator<Category, T, Distance, Pointer, Reference> {};
# 51 "/home/marek/devel/nupic/external/common/include/boost/iterator.hpp"
  }

  template <class Category, class T, class Distance = std::ptrdiff_t,
            class Pointer = T*, class Reference = T&>
  struct iterator : boost::detail::iterator_base<Category, T, Distance, Pointer, Reference> {};

}
# 22 "/home/marek/devel/nupic/external/common/include/boost/concept_check.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/conversion_traits.hpp" 1
# 23 "/home/marek/devel/nupic/external/common/include/boost/concept_check.hpp" 2




# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/assert.hpp" 1
# 20 "/home/marek/devel/nupic/external/common/include/boost/mpl/assert.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/yes_no.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/yes_no.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/config/arrays.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/yes_no.hpp" 2





namespace boost { namespace mpl { namespace aux {

typedef char (&no_tag)[1];
typedef char (&yes_tag)[2];

template< bool C_ > struct yes_no_tag
{
    typedef no_tag type;
};

template<> struct yes_no_tag<true>
{
    typedef yes_tag type;
};


template< long n > struct weighted_tag
{

    typedef char (&type)[n];




};
# 56 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/yes_no.hpp"
}}}
# 20 "/home/marek/devel/nupic/external/common/include/boost/mpl/assert.hpp" 2
# 29 "/home/marek/devel/nupic/external/common/include/boost/mpl/assert.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/config/pp_counter.hpp" 1
# 29 "/home/marek/devel/nupic/external/common/include/boost/mpl/assert.hpp" 2



# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 32 "/home/marek/devel/nupic/external/common/include/boost/mpl/assert.hpp" 2



# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 2 3
# 35 "/home/marek/devel/nupic/external/common/include/boost/mpl/assert.hpp" 2
# 62 "/home/marek/devel/nupic/external/common/include/boost/mpl/assert.hpp"
namespace mpl_ {

struct failed {};
# 75 "/home/marek/devel/nupic/external/common/include/boost/mpl/assert.hpp"
template< bool C > struct assert { typedef void* type; };
template<> struct assert<false> { typedef assert type; };

template< bool C >
int assertion_failed( typename assert<C>::type );

template< bool C >
struct assertion
{
    static int failed( assert<false> );
};

template<>
struct assertion<true>
{
    static int failed( void* );
};

struct assert_
{

    template< typename T1, typename T2 = na, typename T3 = na, typename T4 = na > struct types {};

    static assert_ const arg;
    enum relations { equal = 1, not_equal, greater, greater_equal, less, less_equal };
};
# 123 "/home/marek/devel/nupic/external/common/include/boost/mpl/assert.hpp"
boost::mpl::aux::weighted_tag<1>::type operator==( assert_, assert_ );
boost::mpl::aux::weighted_tag<2>::type operator!=( assert_, assert_ );
boost::mpl::aux::weighted_tag<3>::type operator>( assert_, assert_ );
boost::mpl::aux::weighted_tag<4>::type operator>=( assert_, assert_ );
boost::mpl::aux::weighted_tag<5>::type operator<( assert_, assert_ );
boost::mpl::aux::weighted_tag<6>::type operator<=( assert_, assert_ );

template< assert_::relations r, long x, long y > struct assert_relation {};






template< bool > struct assert_arg_pred_impl { typedef int type; };
template<> struct assert_arg_pred_impl<true> { typedef void* type; };

template< typename P > struct assert_arg_pred
{
    typedef typename P::type p_type;
    typedef typename assert_arg_pred_impl< p_type::value >::type type;
};

template< typename P > struct assert_arg_pred_not
{
    typedef typename P::type p_type;
    enum { p = !p_type::value };
    typedef typename assert_arg_pred_impl<p>::type type;
};

template< typename Pred >
failed ************ (Pred::************
      assert_arg( void (*)(Pred), typename assert_arg_pred<Pred>::type )
    );

template< typename Pred >
failed ************ (boost::mpl::not_<Pred>::************
      assert_not_arg( void (*)(Pred), typename assert_arg_pred_not<Pred>::type )
    );

template< typename Pred >
assert<false>
assert_arg( void (*)(Pred), typename assert_arg_pred_not<Pred>::type );

template< typename Pred >
assert<false>
assert_not_arg( void (*)(Pred), typename assert_arg_pred<Pred>::type );
# 212 "/home/marek/devel/nupic/external/common/include/boost/mpl/assert.hpp"
}
# 27 "/home/marek/devel/nupic/external/common/include/boost/concept_check.hpp" 2



# 1 "/home/marek/devel/nupic/external/common/include/boost/detail/iterator.hpp" 1
# 77 "/home/marek/devel/nupic/external/common/include/boost/detail/iterator.hpp"
namespace boost { namespace detail {


template <class Iterator>
struct iterator_traits
    : std::iterator_traits<Iterator>
{};
using std::distance;

}}
# 30 "/home/marek/devel/nupic/external/common/include/boost/concept_check.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/concept/usage.hpp" 1
# 11 "/home/marek/devel/nupic/external/common/include/boost/concept/usage.hpp"
namespace boost { namespace concepts {







template <class Model>
struct usage_requirements
{
    ~usage_requirements() { ((Model*)0)->~Model(); }
};
# 42 "/home/marek/devel/nupic/external/common/include/boost/concept/usage.hpp"
}}
# 32 "/home/marek/devel/nupic/external/common/include/boost/concept_check.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/concept/detail/concept_def.hpp" 1





# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/for_each_i.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/for_each_i.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/arithmetic/dec.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/for_each_i.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/arithmetic/inc.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/for_each_i.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/for_each_i.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/for.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/for_each_i.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/seq.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/seq.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/seq.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/elem.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/elem.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/elem.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/elem.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/facilities/empty.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/elem.hpp" 2
# 16 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/seq.hpp" 2
# 19 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/for_each_i.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/size.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/size.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/size.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/size.hpp" 2
# 20 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/for_each_i.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/elem.hpp" 1
# 21 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/for_each_i.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/rem.hpp" 1
# 22 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/for_each_i.hpp" 2
# 6 "/home/marek/devel/nupic/external/common/include/boost/concept/detail/concept_def.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/enum.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/enum.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/enum.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/enum.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/size.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/enum.hpp" 2
# 7 "/home/marek/devel/nupic/external/common/include/boost/concept/detail/concept_def.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/comma_if.hpp" 1
# 8 "/home/marek/devel/nupic/external/common/include/boost/concept/detail/concept_def.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 9 "/home/marek/devel/nupic/external/common/include/boost/concept/detail/concept_def.hpp" 2
# 33 "/home/marek/devel/nupic/external/common/include/boost/concept_check.hpp" 2


namespace boost
{





  template <class Model>
  inline void function_requires(Model* = 0)
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Model)>::failed> boost_concept_check45;
  }
  template <class T> inline void ignore_unused_variable_warning(T const&) {}
# 65 "/home/marek/devel/nupic/external/common/include/boost/concept_check.hpp"
  template < typename T > struct Integer; template < typename T > struct IntegerConcept : Integer< T > { }; template < typename T > struct Integer
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Integer>)>::failed> boost_concept_check67; ~Integer()
        {
            x.error_type_must_be_an_integer_type();
        }
   private:
      T x;
  };

  template <> struct Integer<char> {};
  template <> struct Integer<signed char> {};
  template <> struct Integer<unsigned char> {};
  template <> struct Integer<short> {};
  template <> struct Integer<unsigned short> {};
  template <> struct Integer<int> {};
  template <> struct Integer<unsigned int> {};
  template <> struct Integer<long> {};
  template <> struct Integer<unsigned long> {};

  template <> struct Integer< ::boost::long_long_type> {};
  template <> struct Integer< ::boost::ulong_long_type> {};





  template < typename T > struct SignedInteger; template < typename T > struct SignedIntegerConcept : SignedInteger< T > { }; template < typename T > struct SignedInteger {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SignedInteger>)>::failed> boost_concept_check93; ~SignedInteger() {
      x.error_type_must_be_a_signed_integer_type();
    }
   private:
    T x;
  };
  template <> struct SignedInteger<signed char> { };
  template <> struct SignedInteger<short> {};
  template <> struct SignedInteger<int> {};
  template <> struct SignedInteger<long> {};

  template <> struct SignedInteger< ::boost::long_long_type> {};




  template < typename T > struct UnsignedInteger; template < typename T > struct UnsignedIntegerConcept : UnsignedInteger< T > { }; template < typename T > struct UnsignedInteger {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<UnsignedInteger>)>::failed> boost_concept_check110; ~UnsignedInteger() {
      x.error_type_must_be_an_unsigned_integer_type();
    }
   private:
    T x;
  };

  template <> struct UnsignedInteger<unsigned char> {};
  template <> struct UnsignedInteger<unsigned short> {};
  template <> struct UnsignedInteger<unsigned int> {};
  template <> struct UnsignedInteger<unsigned long> {};

  template <> struct UnsignedInteger< ::boost::ulong_long_type> {};







  template < typename TT > struct DefaultConstructible; template < typename TT > struct DefaultConstructibleConcept : DefaultConstructible< TT > { }; template < typename TT > struct DefaultConstructible
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<DefaultConstructible>)>::failed> boost_concept_check132; ~DefaultConstructible() {
      TT a;
      ignore_unused_variable_warning(a);
    }
  };

  template < typename TT > struct Assignable; template < typename TT > struct AssignableConcept : Assignable< TT > { }; template < typename TT > struct Assignable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Assignable>)>::failed> boost_concept_check140; ~Assignable() {

      a = b;

      const_constraints(b);
    }
   private:
    void const_constraints(const TT& x) {

      a = x;



    }
   private:
    TT a;
    TT b;
  };


  template < typename TT > struct CopyConstructible; template < typename TT > struct CopyConstructibleConcept : CopyConstructible< TT > { }; template < typename TT > struct CopyConstructible
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<CopyConstructible>)>::failed> boost_concept_check162; ~CopyConstructible() {
      TT a(b);
      TT* ptr = &a;
      const_constraints(a);
      ignore_unused_variable_warning(ptr);
    }
   private:
    void const_constraints(const TT& a) {
      TT c(a);
      const TT* ptr = &a;
      ignore_unused_variable_warning(c);
      ignore_unused_variable_warning(ptr);
    }
    TT b;
  };







  template < typename TT > struct SGIAssignable; template < typename TT > struct SGIAssignableConcept : SGIAssignable< TT > { }; template < typename TT > struct SGIAssignable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SGIAssignable>)>::failed> boost_concept_check186; ~SGIAssignable() {
      TT c(a);

      a = b;

      const_constraints(b);
      ignore_unused_variable_warning(c);
    }
   private:
    void const_constraints(const TT& x) {
      TT c(x);

      a = x;

      ignore_unused_variable_warning(c);
    }
    TT a;
    TT b;
  };




  template < typename X , typename Y > struct Convertible; template < typename X , typename Y > struct ConvertibleConcept : Convertible< X, Y > { }; template < typename X , typename Y > struct Convertible
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Convertible>)>::failed> boost_concept_check211; ~Convertible() {
      Y y = x;
      ignore_unused_variable_warning(y);
    }
   private:
    X x;
  };
# 228 "/home/marek/devel/nupic/external/common/include/boost/concept_check.hpp"
  template <class TT>
  void require_boolean_expr(const TT& t) {
    bool x = t;
    ignore_unused_variable_warning(x);
  }

  template < typename TT > struct EqualityComparable; template < typename TT > struct EqualityComparableConcept : EqualityComparable< TT > { }; template < typename TT > struct EqualityComparable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<EqualityComparable>)>::failed> boost_concept_check236; ~EqualityComparable() {
      require_boolean_expr(a == b);
      require_boolean_expr(a != b);
    }
   private:
    TT a, b;
  };

  template < typename TT > struct LessThanComparable; template < typename TT > struct LessThanComparableConcept : LessThanComparable< TT > { }; template < typename TT > struct LessThanComparable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<LessThanComparable>)>::failed> boost_concept_check246; ~LessThanComparable() {
      require_boolean_expr(a < b);
    }
   private:
    TT a, b;
  };


  template < typename TT > struct Comparable; template < typename TT > struct ComparableConcept : Comparable< TT > { }; template < typename TT > struct Comparable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Comparable>)>::failed> boost_concept_check256; ~Comparable() {
      require_boolean_expr(a < b);
      require_boolean_expr(a > b);
      require_boolean_expr(a <= b);
      require_boolean_expr(a >= b);
    }
   private:
    TT a, b;
  };
# 286 "/home/marek/devel/nupic/external/common/include/boost/concept_check.hpp"
  template < typename First , typename Second > struct EqualOp; template < typename First , typename Second > struct EqualOpConcept : EqualOp< First, Second > { }; template < typename First , typename Second > struct EqualOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<EqualOp>)>::failed> boost_concept_check286; ~EqualOp() { (void)constraints_(); } private: bool constraints_() { return a == b; } First a; Second b; };
  template < typename First , typename Second > struct NotEqualOp; template < typename First , typename Second > struct NotEqualOpConcept : NotEqualOp< First, Second > { }; template < typename First , typename Second > struct NotEqualOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<NotEqualOp>)>::failed> boost_concept_check287; ~NotEqualOp() { (void)constraints_(); } private: bool constraints_() { return a != b; } First a; Second b; };
  template < typename First , typename Second > struct LessThanOp; template < typename First , typename Second > struct LessThanOpConcept : LessThanOp< First, Second > { }; template < typename First , typename Second > struct LessThanOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<LessThanOp>)>::failed> boost_concept_check288; ~LessThanOp() { (void)constraints_(); } private: bool constraints_() { return a < b; } First a; Second b; };
  template < typename First , typename Second > struct LessEqualOp; template < typename First , typename Second > struct LessEqualOpConcept : LessEqualOp< First, Second > { }; template < typename First , typename Second > struct LessEqualOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<LessEqualOp>)>::failed> boost_concept_check289; ~LessEqualOp() { (void)constraints_(); } private: bool constraints_() { return a <= b; } First a; Second b; };
  template < typename First , typename Second > struct GreaterThanOp; template < typename First , typename Second > struct GreaterThanOpConcept : GreaterThanOp< First, Second > { }; template < typename First , typename Second > struct GreaterThanOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<GreaterThanOp>)>::failed> boost_concept_check290; ~GreaterThanOp() { (void)constraints_(); } private: bool constraints_() { return a > b; } First a; Second b; };
  template < typename First , typename Second > struct GreaterEqualOp; template < typename First , typename Second > struct GreaterEqualOpConcept : GreaterEqualOp< First, Second > { }; template < typename First , typename Second > struct GreaterEqualOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<GreaterEqualOp>)>::failed> boost_concept_check291; ~GreaterEqualOp() { (void)constraints_(); } private: bool constraints_() { return a >= b; } First a; Second b; };

  template < typename Ret , typename First , typename Second > struct PlusOp; template < typename Ret , typename First , typename Second > struct PlusOpConcept : PlusOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct PlusOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<PlusOp>)>::failed> boost_concept_check293; ~PlusOp() { (void)constraints_(); } private: Ret constraints_() { return a + b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct TimesOp; template < typename Ret , typename First , typename Second > struct TimesOpConcept : TimesOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct TimesOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<TimesOp>)>::failed> boost_concept_check294; ~TimesOp() { (void)constraints_(); } private: Ret constraints_() { return a * b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct DivideOp; template < typename Ret , typename First , typename Second > struct DivideOpConcept : DivideOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct DivideOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<DivideOp>)>::failed> boost_concept_check295; ~DivideOp() { (void)constraints_(); } private: Ret constraints_() { return a / b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct SubtractOp; template < typename Ret , typename First , typename Second > struct SubtractOpConcept : SubtractOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct SubtractOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SubtractOp>)>::failed> boost_concept_check296; ~SubtractOp() { (void)constraints_(); } private: Ret constraints_() { return a - b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct ModOp; template < typename Ret , typename First , typename Second > struct ModOpConcept : ModOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct ModOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ModOp>)>::failed> boost_concept_check297; ~ModOp() { (void)constraints_(); } private: Ret constraints_() { return a % b; } First a; Second b; };




  template < typename Func , typename Return > struct Generator; template < typename Func , typename Return > struct GeneratorConcept : Generator< Func, Return > { }; template < typename Func , typename Return > struct Generator
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Generator>)>::failed> boost_concept_check304; ~Generator() { test(is_void<Return>()); }

   private:
      void test(boost::mpl::false_)
      {

          const Return& r = f();
          ignore_unused_variable_warning(r);
      }

      void test(boost::mpl::true_)
      {
          f();
      }

      Func f;
  };

  template < typename Func , typename Return , typename Arg > struct UnaryFunction; template < typename Func , typename Return , typename Arg > struct UnaryFunctionConcept : UnaryFunction< Func, Return, Arg > { }; template < typename Func , typename Return , typename Arg > struct UnaryFunction
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<UnaryFunction>)>::failed> boost_concept_check324; ~UnaryFunction() { test(is_void<Return>()); }

   private:
      void test(boost::mpl::false_)
      {
          f(arg);
          Return r = f(arg);
          ignore_unused_variable_warning(r);
      }

      void test(boost::mpl::true_)
      {
          f(arg);
      }







      UnaryFunction();


      Func f;
      Arg arg;
  };

  template < typename Func , typename Return , typename First , typename Second > struct BinaryFunction; template < typename Func , typename Return , typename First , typename Second > struct BinaryFunctionConcept : BinaryFunction< Func, Return, First, Second > { }; template < typename Func , typename Return , typename First , typename Second > struct BinaryFunction
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BinaryFunction>)>::failed> boost_concept_check354; ~BinaryFunction() { test(is_void<Return>()); }
   private:
      void test(boost::mpl::false_)
      {
          f(first,second);
          Return r = f(first, second);
          (void)r;
      }

      void test(boost::mpl::true_)
      {
          f(first,second);
      }







      BinaryFunction();


      Func f;
      First first;
      Second second;
  };

  template < typename Func , typename Arg > struct UnaryPredicate; template < typename Func , typename Arg > struct UnaryPredicateConcept : UnaryPredicate< Func, Arg > { }; template < typename Func , typename Arg > struct UnaryPredicate
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<UnaryPredicate>)>::failed> boost_concept_check384; ~UnaryPredicate() {
      require_boolean_expr(f(arg));
    }
   private:






      UnaryPredicate();


    Func f;
    Arg arg;
  };

  template < typename Func , typename First , typename Second > struct BinaryPredicate; template < typename Func , typename First , typename Second > struct BinaryPredicateConcept : BinaryPredicate< Func, First, Second > { }; template < typename Func , typename First , typename Second > struct BinaryPredicate
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BinaryPredicate>)>::failed> boost_concept_check403; ~BinaryPredicate() {
      require_boolean_expr(f(a, b));
    }
   private:






      BinaryPredicate();

    Func f;
    First a;
    Second b;
  };


  template < typename Func , typename First , typename Second > struct Const_BinaryPredicate; template < typename Func , typename First , typename Second > struct Const_BinaryPredicateConcept : Const_BinaryPredicate< Func, First, Second > { }; template < typename Func , typename First , typename Second > struct Const_BinaryPredicate
    : BinaryPredicate<Func, First, Second>
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Const_BinaryPredicate>)>::failed> boost_concept_check424; ~Const_BinaryPredicate() {
      const_constraints(f);
    }
   private:
    void const_constraints(const Func& fun) {

      require_boolean_expr(fun(a, b));
    }






      Const_BinaryPredicate();


    Func f;
    First a;
    Second b;
  };

  template < typename Func , typename Return > struct AdaptableGenerator; template < typename Func , typename Return > struct AdaptableGeneratorConcept : AdaptableGenerator< Func, Return > { }; template < typename Func , typename Return > struct AdaptableGenerator
    : Generator<Func, typename Func::result_type>
  {
      typedef typename Func::result_type result_type;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<AdaptableGenerator>)>::failed> boost_concept_check451; ~AdaptableGenerator()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<result_type, Return>)>::failed> boost_concept_check453;
      }
  };

  template < typename Func , typename Return , typename Arg > struct AdaptableUnaryFunction; template < typename Func , typename Return , typename Arg > struct AdaptableUnaryFunctionConcept : AdaptableUnaryFunction< Func, Return, Arg > { }; template < typename Func , typename Return , typename Arg > struct AdaptableUnaryFunction
    : UnaryFunction<Func, typename Func::result_type, typename Func::argument_type>
  {
      typedef typename Func::argument_type argument_type;
      typedef typename Func::result_type result_type;

      ~AdaptableUnaryFunction()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<result_type, Return>)>::failed> boost_concept_check465;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<Arg, argument_type>)>::failed> boost_concept_check466;
      }
  };

  template < typename Func , typename Return , typename First , typename Second > struct AdaptableBinaryFunction; template < typename Func , typename Return , typename First , typename Second > struct AdaptableBinaryFunctionConcept : AdaptableBinaryFunction< Func, Return, First, Second > { }; template < typename Func , typename Return , typename First , typename Second > struct AdaptableBinaryFunction
    : BinaryFunction<
          Func
        , typename Func::result_type
        , typename Func::first_argument_type
        , typename Func::second_argument_type
      >
  {
      typedef typename Func::first_argument_type first_argument_type;
      typedef typename Func::second_argument_type second_argument_type;
      typedef typename Func::result_type result_type;

      ~AdaptableBinaryFunction()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<result_type, Return>)>::failed> boost_concept_check484;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<First, first_argument_type>)>::failed> boost_concept_check485;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<Second, second_argument_type>)>::failed> boost_concept_check486;
      }
  };

  template < typename Func , typename Arg > struct AdaptablePredicate; template < typename Func , typename Arg > struct AdaptablePredicateConcept : AdaptablePredicate< Func, Arg > { }; template < typename Func , typename Arg > struct AdaptablePredicate
    : UnaryPredicate<Func, Arg>
    , AdaptableUnaryFunction<Func, bool, Arg>
  {
  };

  template < typename Func , typename First , typename Second > struct AdaptableBinaryPredicate; template < typename Func , typename First , typename Second > struct AdaptableBinaryPredicateConcept : AdaptableBinaryPredicate< Func, First, Second > { }; template < typename Func , typename First , typename Second > struct AdaptableBinaryPredicate
    : BinaryPredicate<Func, First, Second>
    , AdaptableBinaryFunction<Func, bool, First, Second>
  {
  };




  template < typename TT > struct InputIterator; template < typename TT > struct InputIteratorConcept : InputIterator< TT > { }; template < typename TT > struct InputIterator
    : Assignable<TT>
    , EqualityComparable<TT>
  {
      typedef typename boost::detail::iterator_traits<TT>::value_type value_type;
      typedef typename boost::detail::iterator_traits<TT>::difference_type difference_type;
      typedef typename boost::detail::iterator_traits<TT>::reference reference;
      typedef typename boost::detail::iterator_traits<TT>::pointer pointer;
      typedef typename boost::detail::iterator_traits<TT>::iterator_category iterator_category;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<InputIterator>)>::failed> boost_concept_check515; ~InputIterator()
      {
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(SignedInteger<difference_type>)>::failed> boost_concept_check517;
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<iterator_category, std::input_iterator_tag>)>::failed> boost_concept_check518;

        TT j(i);
        (void)*i;
        ++j;
        i++;
      }
   private:
    TT i;
  };

  template < typename TT , typename ValueT > struct OutputIterator; template < typename TT , typename ValueT > struct OutputIteratorConcept : OutputIterator< TT, ValueT > { }; template < typename TT , typename ValueT > struct OutputIterator
    : Assignable<TT>
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<OutputIterator>)>::failed> boost_concept_check532; ~OutputIterator() {

      ++i;
      i++;
      *i++ = t;
    }
   private:
    TT i, j;
    ValueT t;
  };

  template < typename TT > struct ForwardIterator; template < typename TT > struct ForwardIteratorConcept : ForwardIterator< TT > { }; template < typename TT > struct ForwardIterator
    : InputIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ForwardIterator>)>::failed> boost_concept_check546; ~ForwardIterator()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible< typename ForwardIterator::iterator_category , std::forward_iterator_tag >)>::failed> boost_concept_check551;




          typename InputIterator<TT>::reference r = *i;
          ignore_unused_variable_warning(r);
      }

   private:
      TT i;
  };

  template < typename TT > struct Mutable_ForwardIterator; template < typename TT > struct Mutable_ForwardIteratorConcept : Mutable_ForwardIterator< TT > { }; template < typename TT > struct Mutable_ForwardIterator
    : ForwardIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_ForwardIterator>)>::failed> boost_concept_check564; ~Mutable_ForwardIterator() {
        *i++ = *i;
      }
   private:
      TT i;
  };

  template < typename TT > struct BidirectionalIterator; template < typename TT > struct BidirectionalIteratorConcept : BidirectionalIterator< TT > { }; template < typename TT > struct BidirectionalIterator
    : ForwardIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BidirectionalIterator>)>::failed> boost_concept_check574; ~BidirectionalIterator()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible< typename BidirectionalIterator::iterator_category , std::bidirectional_iterator_tag >)>::failed> boost_concept_check579;




          --i;
          i--;
      }
   private:
      TT i;
  };

  template < typename TT > struct Mutable_BidirectionalIterator; template < typename TT > struct Mutable_BidirectionalIteratorConcept : Mutable_BidirectionalIterator< TT > { }; template < typename TT > struct Mutable_BidirectionalIterator
    : BidirectionalIterator<TT>
    , Mutable_ForwardIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_BidirectionalIterator>)>::failed> boost_concept_check592; ~Mutable_BidirectionalIterator()
      {
          *i-- = *i;
      }
   private:
      TT i;
  };

  template < typename TT > struct RandomAccessIterator; template < typename TT > struct RandomAccessIteratorConcept : RandomAccessIterator< TT > { }; template < typename TT > struct RandomAccessIterator
    : BidirectionalIterator<TT>
    , Comparable<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<RandomAccessIterator>)>::failed> boost_concept_check604; ~RandomAccessIterator()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible< typename BidirectionalIterator<TT>::iterator_category , std::random_access_iterator_tag >)>::failed> boost_concept_check609;




          i += n;
          i = i + n; i = n + i;
          i -= n;
          i = i - n;
          n = i - j;
          (void)i[n];
      }

   private:
    TT a, b;
    TT i, j;
      typename boost::detail::iterator_traits<TT>::difference_type n;
  };

  template < typename TT > struct Mutable_RandomAccessIterator; template < typename TT > struct Mutable_RandomAccessIteratorConcept : Mutable_RandomAccessIterator< TT > { }; template < typename TT > struct Mutable_RandomAccessIterator
    : RandomAccessIterator<TT>
    , Mutable_BidirectionalIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_RandomAccessIterator>)>::failed> boost_concept_check629; ~Mutable_RandomAccessIterator()
      {
          i[n] = *i;
      }
   private:
    TT i;
    typename boost::detail::iterator_traits<TT>::difference_type n;
  };




  template < typename C > struct Container; template < typename C > struct ContainerConcept : Container< C > { }; template < typename C > struct Container
    : Assignable<C>
  {
    typedef typename C::value_type value_type;
    typedef typename C::difference_type difference_type;
    typedef typename C::size_type size_type;
    typedef typename C::const_reference const_reference;
    typedef typename C::const_pointer const_pointer;
    typedef typename C::const_iterator const_iterator;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Container>)>::failed> boost_concept_check651; ~Container()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(InputIterator<const_iterator>)>::failed> boost_concept_check653;
          const_constraints(c);
      }

   private:
      void const_constraints(const C& cc) {
          i = cc.begin();
          i = cc.end();
          n = cc.size();
          n = cc.max_size();
          b = cc.empty();
      }
      C c;
      bool b;
      const_iterator i;
      size_type n;
  };

  template < typename C > struct Mutable_Container; template < typename C > struct Mutable_ContainerConcept : Mutable_Container< C > { }; template < typename C > struct Mutable_Container
    : Container<C>
  {
      typedef typename C::reference reference;
      typedef typename C::iterator iterator;
      typedef typename C::pointer pointer;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_Container>)>::failed> boost_concept_check678; ~Mutable_Container()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Assignable<typename Mutable_Container::value_type>)>::failed> boost_concept_check681;


          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(InputIterator<iterator>)>::failed> boost_concept_check683;

          i = c.begin();
          i = c.end();
          c.swap(c2);
      }

   private:
      iterator i;
      C c, c2;
  };

  template < typename C > struct ForwardContainer; template < typename C > struct ForwardContainerConcept : ForwardContainer< C > { }; template < typename C > struct ForwardContainer
    : Container<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ForwardContainer>)>::failed> boost_concept_check698; ~ForwardContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( ForwardIterator< typename ForwardContainer::const_iterator >)>::failed> boost_concept_check703;



      }
  };

  template < typename C > struct Mutable_ForwardContainer; template < typename C > struct Mutable_ForwardContainerConcept : Mutable_ForwardContainer< C > { }; template < typename C > struct Mutable_ForwardContainer
    : ForwardContainer<C>
    , Mutable_Container<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_ForwardContainer>)>::failed> boost_concept_check711; ~Mutable_ForwardContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Mutable_ForwardIterator< typename Mutable_ForwardContainer::iterator >)>::failed> boost_concept_check716;



      }
  };

  template < typename C > struct ReversibleContainer; template < typename C > struct ReversibleContainerConcept : ReversibleContainer< C > { }; template < typename C > struct ReversibleContainer
    : ForwardContainer<C>
  {
      typedef typename
        C::const_reverse_iterator
      const_reverse_iterator;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ReversibleContainer>)>::failed> boost_concept_check727; ~ReversibleContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( BidirectionalIterator< typename ReversibleContainer::const_iterator>)>::failed> boost_concept_check731;



          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(BidirectionalIterator<const_reverse_iterator>)>::failed> boost_concept_check733;

          const_constraints(c);
      }
   private:
      void const_constraints(const C& cc)
      {
          const_reverse_iterator i = cc.rbegin();
          i = cc.rend();
      }
      C c;
  };

  template < typename C > struct Mutable_ReversibleContainer; template < typename C > struct Mutable_ReversibleContainerConcept : Mutable_ReversibleContainer< C > { }; template < typename C > struct Mutable_ReversibleContainer
    : Mutable_ForwardContainer<C>
    , ReversibleContainer<C>
  {
      typedef typename C::reverse_iterator reverse_iterator;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_ReversibleContainer>)>::failed> boost_concept_check752; ~Mutable_ReversibleContainer()
      {
          typedef typename Mutable_ForwardContainer<C>::iterator iterator;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Mutable_BidirectionalIterator<iterator>)>::failed> boost_concept_check755;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Mutable_BidirectionalIterator<reverse_iterator>)>::failed> boost_concept_check756;

          reverse_iterator i = c.rbegin();
          i = c.rend();
      }
   private:
      C c;
  };

  template < typename C > struct RandomAccessContainer; template < typename C > struct RandomAccessContainerConcept : RandomAccessContainer< C > { }; template < typename C > struct RandomAccessContainer
    : ReversibleContainer<C>
  {
      typedef typename C::size_type size_type;
      typedef typename C::const_reference const_reference;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<RandomAccessContainer>)>::failed> boost_concept_check771; ~RandomAccessContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( RandomAccessIterator< typename RandomAccessContainer::const_iterator >)>::failed> boost_concept_check776;




          const_constraints(c);
      }
   private:
      void const_constraints(const C& cc)
      {
          const_reference r = cc[n];
          ignore_unused_variable_warning(r);
      }

      C c;
      size_type n;
  };

  template < typename C > struct Mutable_RandomAccessContainer; template < typename C > struct Mutable_RandomAccessContainerConcept : Mutable_RandomAccessContainer< C > { }; template < typename C > struct Mutable_RandomAccessContainer
    : Mutable_ReversibleContainer<C>
    , RandomAccessContainer<C>
  {
   private:
      typedef Mutable_RandomAccessContainer self;
   public:
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_RandomAccessContainer>)>::failed> boost_concept_check798; ~Mutable_RandomAccessContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Mutable_RandomAccessIterator<typename self::iterator>)>::failed> boost_concept_check800;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Mutable_RandomAccessIterator<typename self::reverse_iterator>)>::failed> boost_concept_check801;

          typename self::reference r = c[i];
          ignore_unused_variable_warning(r);
      }

   private:
      typename Mutable_ReversibleContainer<C>::size_type i;
      C c;
  };


  template < typename S > struct Sequence; template < typename S > struct SequenceConcept : Sequence< S > { }; template < typename S > struct Sequence
    : Mutable_ForwardContainer<S>



    , DefaultConstructible<S>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Sequence>)>::failed> boost_concept_check820; ~Sequence()
      {
          S
              c(n),
              c2(n, t),
              c3(first, last);

          c.insert(p, t);
          c.insert(p, n, t);
          c.insert(p, first, last);

          c.erase(p);
          c.erase(p, q);

          typename Sequence::reference r = c.front();

          ignore_unused_variable_warning(c);
          ignore_unused_variable_warning(c2);
          ignore_unused_variable_warning(c3);
          ignore_unused_variable_warning(r);
          const_constraints(c);
      }
   private:
      void const_constraints(const S& c) {
          typename Sequence::const_reference r = c.front();
          ignore_unused_variable_warning(r);
      }

      typename S::value_type t;
      typename S::size_type n;
      typename S::value_type* first, *last;
      typename S::iterator p, q;
  };

  template < typename S > struct FrontInsertionSequence; template < typename S > struct FrontInsertionSequenceConcept : FrontInsertionSequence< S > { }; template < typename S > struct FrontInsertionSequence
    : Sequence<S>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<FrontInsertionSequence>)>::failed> boost_concept_check857; ~FrontInsertionSequence()
      {
          c.push_front(t);
          c.pop_front();
      }
   private:
      S c;
      typename S::value_type t;
  };

  template < typename S > struct BackInsertionSequence; template < typename S > struct BackInsertionSequenceConcept : BackInsertionSequence< S > { }; template < typename S > struct BackInsertionSequence
    : Sequence<S>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BackInsertionSequence>)>::failed> boost_concept_check870; ~BackInsertionSequence()
      {
          c.push_back(t);
          c.pop_back();
          typename BackInsertionSequence::reference r = c.back();
          ignore_unused_variable_warning(r);
          const_constraints(c);
      }
   private:
      void const_constraints(const S& cc) {
          typename BackInsertionSequence::const_reference
              r = cc.back();
          ignore_unused_variable_warning(r);
      };
      S c;
      typename S::value_type t;
  };

  template < typename C > struct AssociativeContainer; template < typename C > struct AssociativeContainerConcept : AssociativeContainer< C > { }; template < typename C > struct AssociativeContainer
    : ForwardContainer<C>
    , DefaultConstructible<C>
  {
      typedef typename C::key_type key_type;
      typedef typename C::key_compare key_compare;
      typedef typename C::value_compare value_compare;
      typedef typename C::iterator iterator;

      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<AssociativeContainer>)>::failed> boost_concept_check897; ~AssociativeContainer()
      {
          i = c.find(k);
          r = c.equal_range(k);
          c.erase(k);
          c.erase(i);
          c.erase(r.first, r.second);
          const_constraints(c);
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(BinaryPredicate<key_compare,key_type,key_type>)>::failed> boost_concept_check905;

          typedef typename AssociativeContainer::value_type value_type_;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(BinaryPredicate<value_compare,value_type_,value_type_>)>::failed> boost_concept_check908;
      }


      typedef typename C::const_iterator const_iterator;
   private:
      void const_constraints(const C& cc)
      {
          ci = cc.find(k);
          n = cc.count(k);
          cr = cc.equal_range(k);
      }

      C c;
      iterator i;
      std::pair<iterator,iterator> r;
      const_iterator ci;
      std::pair<const_iterator,const_iterator> cr;
      typename C::key_type k;
      typename C::size_type n;
  };

  template < typename C > struct UniqueAssociativeContainer; template < typename C > struct UniqueAssociativeContainerConcept : UniqueAssociativeContainer< C > { }; template < typename C > struct UniqueAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<UniqueAssociativeContainer>)>::failed> boost_concept_check933; ~UniqueAssociativeContainer()
      {
          C c(first, last);

          pos_flag = c.insert(t);
          c.insert(first, last);

          ignore_unused_variable_warning(c);
      }
   private:
      std::pair<typename C::iterator, bool> pos_flag;
      typename C::value_type t;
      typename C::value_type* first, *last;
  };

  template < typename C > struct MultipleAssociativeContainer; template < typename C > struct MultipleAssociativeContainerConcept : MultipleAssociativeContainer< C > { }; template < typename C > struct MultipleAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<MultipleAssociativeContainer>)>::failed> boost_concept_check951; ~MultipleAssociativeContainer()
      {
          C c(first, last);

          pos = c.insert(t);
          c.insert(first, last);

          ignore_unused_variable_warning(c);
          ignore_unused_variable_warning(pos);
      }
   private:
      typename C::iterator pos;
      typename C::value_type t;
      typename C::value_type* first, *last;
  };

  template < typename C > struct SimpleAssociativeContainer; template < typename C > struct SimpleAssociativeContainerConcept : SimpleAssociativeContainer< C > { }; template < typename C > struct SimpleAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SimpleAssociativeContainer>)>::failed> boost_concept_check970; ~SimpleAssociativeContainer()
      {
          typedef typename C::key_type key_type;
          typedef typename C::value_type value_type;
          enum { mpl_assertion_in_line_974 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (boost::is_same<key_type,value_type>))0, 1 ) ) ) };
      }
  };

  template < typename C > struct PairAssociativeContainer; template < typename C > struct PairAssociativeContainerConcept : PairAssociativeContainer< C > { }; template < typename C > struct PairAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<PairAssociativeContainer>)>::failed> boost_concept_check981; ~PairAssociativeContainer()
      {
          typedef typename C::key_type key_type;
          typedef typename C::value_type value_type;
          typedef typename C::mapped_type mapped_type;
          typedef std::pair<const key_type, mapped_type> required_value_type;
          enum { mpl_assertion_in_line_987 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (boost::is_same<value_type,required_value_type>))0, 1 ) ) ) };
      }
  };

  template < typename C > struct SortedAssociativeContainer; template < typename C > struct SortedAssociativeContainerConcept : SortedAssociativeContainer< C > { }; template < typename C > struct SortedAssociativeContainer
    : AssociativeContainer<C>
    , ReversibleContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SortedAssociativeContainer>)>::failed> boost_concept_check995; ~SortedAssociativeContainer()
      {
          C
              c(kc),
              c2(first, last),
              c3(first, last, kc);

          p = c.upper_bound(k);
          p = c.lower_bound(k);
          r = c.equal_range(k);

          c.insert(p, t);

          ignore_unused_variable_warning(c);
          ignore_unused_variable_warning(c2);
          ignore_unused_variable_warning(c3);
          const_constraints(c);
      }

      void const_constraints(const C& c)
      {
          kc = c.key_comp();
          vc = c.value_comp();

          cp = c.upper_bound(k);
          cp = c.lower_bound(k);
          cr = c.equal_range(k);
      }

   private:
      typename C::key_compare kc;
      typename C::value_compare vc;
      typename C::value_type t;
      typename C::key_type k;
      typedef typename C::iterator iterator;
      typedef typename C::const_iterator const_iterator;

      typedef SortedAssociativeContainer self;
      iterator p;
      const_iterator cp;
      std::pair<typename self::iterator,typename self::iterator> r;
      std::pair<typename self::const_iterator,typename self::const_iterator> cr;
      typename C::value_type* first, *last;
  };



  template < typename C > struct Collection; template < typename C > struct CollectionConcept : Collection< C > { }; template < typename C > struct Collection
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Collection>)>::failed> boost_concept_check1044; ~Collection()
      {
        boost::function_requires<boost::InputIteratorConcept<iterator> >();
        boost::function_requires<boost::InputIteratorConcept<const_iterator> >();
        boost::function_requires<boost::CopyConstructibleConcept<value_type> >();
        const_constraints(c);
        i = c.begin();
        i = c.end();
        c.swap(c);
      }

      void const_constraints(const C& cc) {
        ci = cc.begin();
        ci = cc.end();
        n = cc.size();
        b = cc.empty();
      }

    private:
      typedef typename C::value_type value_type;
      typedef typename C::iterator iterator;
      typedef typename C::const_iterator const_iterator;
      typedef typename C::reference reference;
      typedef typename C::const_reference const_reference;

      typedef typename C::difference_type difference_type;
      typedef typename C::size_type size_type;

      C c;
      bool b;
      iterator i;
      const_iterator ci;
      size_type n;
  };
}


# 1 "/home/marek/devel/nupic/external/common/include/boost/concept/detail/concept_undef.hpp" 1
# 1080 "/home/marek/devel/nupic/external/common/include/boost/concept_check.hpp" 2
# 40 "/home/marek/devel/nupic/nta/math/math.hpp" 2


# 1 "/home/marek/devel/nupic/nta/math/utils.hpp" 1
# 31 "/home/marek/devel/nupic/nta/math/utils.hpp"
# 1 "/usr/include/assert.h" 1 3 4
# 64 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 32 "/home/marek/devel/nupic/nta/math/utils.hpp" 2
# 44 "/home/marek/devel/nupic/nta/math/utils.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdlib" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdlib" 3
# 45 "/home/marek/devel/nupic/nta/math/utils.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/shared_array.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/shared_array.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_array.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_array.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/assert.hpp" 1
# 50 "/home/marek/devel/nupic/external/common/include/boost/assert.hpp"
# 1 "/usr/include/assert.h" 1 3 4
# 64 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 50 "/home/marek/devel/nupic/external/common/include/boost/assert.hpp" 2
# 25 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_array.hpp" 2






# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 2 3
# 31 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_array.hpp" 2




namespace boost
{
# 46 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_array.hpp"
template<class T> class shared_array
{
private:


    typedef checked_array_deleter<T> deleter;
    typedef shared_array<T> this_type;

public:

    typedef T element_type;

    explicit shared_array(T * p = 0): px(p), pn(p, deleter())
    {
    }







    template<class D> shared_array(T * p, D d): px(p), pn(p, d)
    {
    }
# 86 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_array.hpp"
    shared_array & operator=( shared_array const & r )
    {
        this_type( r ).swap( *this );
        return *this;
    }

    void reset(T * p = 0)
    {
        ((p == 0 || p != px) ? static_cast<void> (0) : __assert_fail ("p == 0 || p != px", "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_array.hpp", 94, __PRETTY_FUNCTION__));
        this_type(p).swap(*this);
    }

    template <class D> void reset(T * p, D d)
    {
        this_type(p, d).swap(*this);
    }

    T & operator[] (std::ptrdiff_t i) const
    {
        ((px != 0) ? static_cast<void> (0) : __assert_fail ("px != 0", "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_array.hpp", 105, __PRETTY_FUNCTION__));
        ((i >= 0) ? static_cast<void> (0) : __assert_fail ("i >= 0", "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_array.hpp", 106, __PRETTY_FUNCTION__));
        return px[i];
    }

    T * get() const
    {
        return px;
    }



# 1 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/operator_bool.hpp" 1
# 43 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/detail/operator_bool.hpp"
    typedef T * this_type::*unspecified_bool_type;

    operator unspecified_bool_type() const
    {
        return px == 0? 0: &this_type::px;
    }




    bool operator! () const
    {
        return px == 0;
    }
# 116 "/home/marek/devel/nupic/external/common/include/boost/smart_ptr/shared_array.hpp" 2


    bool unique() const
    {
        return pn.unique();
    }

    long use_count() const
    {
        return pn.use_count();
    }

    void swap(shared_array<T> & other)
    {
        std::swap(px, other.px);
        pn.swap(other.pn);
    }

    void * _internal_get_deleter( boost::detail::sp_typeinfo const & ti ) const
    {
        return pn.get_deleter( ti );
    }

private:

    T * px;
    detail::shared_count pn;

};

template<class T> inline bool operator==(shared_array<T> const & a, shared_array<T> const & b)
{
    return a.get() == b.get();
}

template<class T> inline bool operator!=(shared_array<T> const & a, shared_array<T> const & b)
{
    return a.get() != b.get();
}

template<class T> inline bool operator<(shared_array<T> const & a, shared_array<T> const & b)
{
    return std::less<T*>()(a.get(), b.get());
}

template<class T> void swap(shared_array<T> & a, shared_array<T> & b)
{
    a.swap(b);
}

template< class D, class T > D * get_deleter( shared_array<T> const & p )
{
    return static_cast< D * >( p._internal_get_deleter( typeid(D) ) );
}

}
# 17 "/home/marek/devel/nupic/external/common/include/boost/shared_array.hpp" 2
# 47 "/home/marek/devel/nupic/nta/math/utils.hpp" 2




namespace nta {
# 66 "/home/marek/devel/nupic/nta/math/utils.hpp"
  template <typename SizeType>
  inline const SizeType padding(const SizeType& s1, const SizeType& s2)
  {
    if(s2) {
      SizeType extra = s1 % s2;
      return extra == 0 ? 0 : s2 - extra;
    }
    else return 0;
  }

  inline bool IsSystemLittleEndian()
    { static const char test[2] = { 1, 0 }; return (*(short *) test) == 1; }

  template<typename T>
  inline void SwapBytesInPlace(T *pxIn, Size n)
  {
    union SwapType { T x; unsigned char b[sizeof(T)]; };
    SwapType *px = reinterpret_cast<SwapType *>(pxIn);
    SwapType *pxend = px + n;
    const int stop = sizeof(T) / 2;
    for(; px!=pxend; ++px) {
      for(int j=0; j<stop; ++j) std::swap(px->b[j], px->b[sizeof(T)-j-1]);
    }
  }

  template<typename T>
  inline void SwapBytes(T *pxOut, Size n, const T *pxIn)
  {
    if (pxOut != pxIn) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/utils.hpp", 94) << "ASSERTION FAILED: \"" << "pxOut != pxIn" << "\" " << "Use swapBytesInPlace() instead.";
    if (!(((pxOut > pxIn) && (pxOut < (pxIn+n))) || ((pxIn > pxOut) && (pxIn < (pxOut+n))))) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/utils.hpp", 96) << "ASSERTION FAILED: \"" << "!(((pxOut > pxIn) && (pxOut < (pxIn+n))) || ((pxIn > pxOut) && (pxIn < (pxOut+n))))" << "\" " << "Overlapping ranges not supported.";


    union SwapType { T x; unsigned char b[sizeof(T)]; };
    const SwapType *px0 = reinterpret_cast<SwapType *>(pxIn);
    const SwapType *pxend = px0 + n;
    SwapType *px1 = reinterpret_cast<SwapType *>(pxOut);
    for(; px0!=pxend; ++px0, ++px1) {
      for(int j=0; j<sizeof(T); ++j) px1->b[j] = px0->b[sizeof(T)-j-1];
    }
  }
# 124 "/home/marek/devel/nupic/nta/math/utils.hpp"
  extern size_t GetTypeSize(const std::string &name, bool& isNumeric);
# 143 "/home/marek/devel/nupic/nta/math/utils.hpp"
  extern size_t GetTypeSize(NTA_BasicType type, bool& isNumeric);







  extern std::string GetTypeName(NTA_BasicType type);




  template <typename T>
  inline void utilsPrintArray_(std::ostream& out, const void* theBeginP,
          const void* theEndP)
  {
    const T* beginP = (T*)theBeginP;
    const T* endP = (T*)theEndP;

    for ( ; beginP != endP; ++beginP)
      out << *beginP << " ";
  }
# 176 "/home/marek/devel/nupic/nta/math/utils.hpp"
  template <typename T>
  inline void utilsSetArray_(std::istream& in, void* theBeginP, void* theEndP)
  {
    T* beginP = (T*)theBeginP;
    T* endP = (T*)theEndP;

    for ( ; beginP != endP && in.good(); ++beginP)
      in >> *beginP;
    if (beginP != endP && !in.eof())
      throw nta::LoggingException("/home/marek/devel/nupic/nta/math/utils.hpp", 185) << "UtilsSetArray() - error reading stream of values";
  }
# 210 "/home/marek/devel/nupic/nta/math/utils.hpp"
  extern std::string PrintVariableArray (std::ostream& outStream, const Byte* beginP,
          const Byte* endP, const std::string& dataType="");
# 227 "/home/marek/devel/nupic/nta/math/utils.hpp"
   extern void SetVariableArray (std::istream& inStream, Byte* beginP,
           Byte* endP, const std::string& dataType);
# 342 "/home/marek/devel/nupic/nta/math/utils.hpp"
  template <class Pair>
  struct select1st
    : public std::unary_function<Pair, typename Pair::first_type>
  {
    inline const typename Pair::first_type& operator()(const Pair& x) const
    {
      return x.first;
    }
  };







  template <class Pair>
  struct select2nd
    : public std::unary_function<Pair, typename Pair::second_type>
  {
    inline const typename Pair::second_type& operator()(const Pair& x) const
    {
      return x.second;
    }
  };

};
# 43 "/home/marek/devel/nupic/nta/math/math.hpp" 2
# 75 "/home/marek/devel/nupic/nta/math/math.hpp"
namespace nta {
# 85 "/home/marek/devel/nupic/nta/math/math.hpp"
  inline bool INVARIANT(bool cond, const char* msg)
  {

    if (!(cond)) {
      nta::LogItem("/home/marek/devel/nupic/nta/math/math.hpp", 89, nta::LogItem::info).stream() << msg;
      return false;
    }

    return true;
  }
# 103 "/home/marek/devel/nupic/nta/math/math.hpp"
  template <typename It>
  void ASSERT_VALID_RANGE(It begin, It end, const char* message)
  {
    if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/math.hpp", 106) << "ASSERTION FAILED: \"" << "begin <= end" << "\" " << "Invalid iterators: " << message;
  }
# 117 "/home/marek/devel/nupic/nta/math/math.hpp"
  static const nta::Real Epsilon = nta::Real(1e-6);





  template <typename T>
  inline bool strictlyNegative(const T& a)
  {
    return a < -nta::Epsilon;
  }


  template <typename T>
  inline bool strictlyPositive(const T& a)
  {
    return a > nta::Epsilon;
  }


  template <typename T>
  inline bool negative(const T& a)
  {
    return a <= nta::Epsilon;
  }


  template <typename T>
  inline bool positive(const T& a)
  {
    return a >= -nta::Epsilon;
  }







  template <typename T>
  struct DistanceToZero
  {
    typedef T argument_type;
    typedef T result_type;

    inline T operator()(const T& x) const
    {
      return x >= 0 ? x : -x;
    }
  };





  template<>
  inline
  UInt DistanceToZero<UInt>::operator()(const UInt &x) const { return x; }





  template <typename T>
  struct DistanceToZeroPositive : public std::unary_function<T, T>
  {
    inline T operator()(const T& x) const
    {
      return x;
    }
  };





  template <typename T>
  struct DistanceToOne
  {
    typedef T argument_type;
    typedef T result_type;

    inline T operator()(const T& x) const
    {
      return x > (T) 1 ? x - (T) 1 : (T) 1 - x;
    }
  };






  template <typename D>
  struct IsNearlyZero
  {
    typedef typename D::result_type value_type;

    D dist_;



    inline IsNearlyZero()
      : dist_()
    {}

    inline IsNearlyZero(const IsNearlyZero& other)
      : dist_(other.dist_)
    {}

    inline IsNearlyZero& operator=(const IsNearlyZero& other)
    {
      if (this != &other)
 dist_ = other.dist_;

      return *this;
    }

    inline bool operator()(const typename D::argument_type& x) const
    {
      return dist_(x) <= nta::Epsilon;
    }
  };
# 276 "/home/marek/devel/nupic/nta/math/math.hpp"
  template <typename T>
  inline bool nearlyZero(const T& a, const T& epsilon =T(nta::Epsilon))
  {
    return a >= -epsilon && a <= epsilon;
  }


  template <typename T>
  inline bool nearlyEqual(const T& a, const T& b, const T& epsilon =nta::Epsilon)
  {
    return nearlyZero((b-a), epsilon);
  }
# 304 "/home/marek/devel/nupic/nta/math/math.hpp"
  template <typename C1, typename Selector, bool f =false>
  struct IsIncluded
  {
    IsIncluded(const C1& container)
      : sel_(),
        container_(container)
    {}

    template <typename T>
    inline bool operator()(const T& p) const
    {
      if (f)
        return container_.find(sel_(p)) == container_.end();
      else
        return container_.find(sel_(p)) != container_.end();
    }

    Selector sel_;
    const C1& container_;
  };
# 333 "/home/marek/devel/nupic/nta/math/math.hpp"
  template <typename T1, typename T2>
  struct lexicographic_2
    : public std::binary_function<bool, std::pair<T1, T2>, std::pair<T1, T2> >
  {
    inline bool operator()(const std::pair<T1, T2>& a, const std::pair<T1, T2>& b) const
    {
      if (a.first < b.first)
        return true;
      else if (a.first == b.first)
        if (a.second < b.second)
          return true;
      return false;
    }
  };






  template <typename T1, typename T2>
  struct less_1st
    : public std::binary_function<bool, std::pair<T1, T2>, std::pair<T1, T2> >
  {
    inline bool operator()(const std::pair<T1, T2>& a, const std::pair<T1, T2>& b) const
    {
      return a.first < b.first;
    }
  };






  template <typename T1, typename T2>
  struct less_2nd
    : public std::binary_function<bool, std::pair<T1, T2>, std::pair<T1, T2> >
  {
    inline bool operator()(const std::pair<T1, T2>& a, const std::pair<T1, T2>& b) const
    {
      return a.second < b.second;
    }
  };






  template <typename T1, typename T2>
  struct greater_1st
    : public std::binary_function<bool, std::pair<T1, T2>, std::pair<T1, T2> >
  {
    inline bool operator()(const std::pair<T1, T2>& a, const std::pair<T1, T2>& b) const
    {
      return a.first > b.first;
    }
  };






  template <typename T1, typename T2>
  struct greater_2nd
    : public std::binary_function<bool, std::pair<T1, T2>, std::pair<T1, T2> >
  {
    inline bool operator()(const std::pair<T1, T2>& a, const std::pair<T1, T2>& b) const
    {
      return a.second > b.second;
    }
  };


  template <typename T1, typename T2>
  struct greater_2nd_p
    : public std::binary_function<bool, std::pair<T1, T2*>, std::pair<T1, T2*> >
  {
    inline bool operator()(const std::pair<T1, T2*>& a, const std::pair<T1, T2*>& b) const
    {
      return *(a.second) > *(b.second);
    }
  };





  template <typename T1, typename T2>
  struct greater_2nd_no_ties
    : public std::binary_function<bool, std::pair<T1, T2>, std::pair<T1, T2> >
  {
    inline bool operator()(const std::pair<T1, T2>& a, const std::pair<T1, T2>& b) const
    {
      if (a.second > b.second)
        return true;
      else if (a.second == b.second)
        if (a.first < b.first)
          return true;
      return false;
    }
  };


  template <typename T1, typename T2, typename RND>
  struct greater_2nd_rnd_ties
    : public std::binary_function<bool, std::pair<T1, T2>, std::pair<T1, T2> >
  {
    RND& rng;

    inline greater_2nd_rnd_ties(RND& _rng) : rng(_rng) {}

    inline bool operator()(const std::pair<T1, T2>& a, const std::pair<T1, T2>& b) const
    {
      T2 val_a = a.second, val_b = b.second;
      if (val_a > val_b)
        return true;
      else if (val_a == val_b)
        return rng.getReal64() >= .5;
      return false;
    }
  };







  template <typename T1, typename T2>
  class ijv
  {
    typedef T1 size_type;
    typedef T2 value_type;

  private:
    size_type i_, j_;
    value_type v_;

  public:
    inline ijv()
      : i_(0), j_(0), v_(0) {}

    inline ijv(size_type i, size_type j, value_type v)
      : i_(i), j_(j), v_(v) {}

    inline ijv(const ijv& o)
      : i_(o.i_), j_(o.j_), v_(o.v_) {}

    inline ijv& operator=(const ijv& o)
    {
      i_ = o.i_;
      j_ = o.j_;
      v_ = o.v_;
      return *this;
    }

    inline size_type i() const { return i_; }
    inline size_type j() const { return j_; }
    inline value_type v() const { return v_; }
    inline void i(size_type ii) { i_ = ii; }
    inline void j(size_type jj) { j_ = jj; }
    inline void v(value_type vv) { v_ = vv; }





    struct lexicographic : public std::binary_function<bool, ijv, ijv>
    {
      inline bool operator()(const ijv& a, const ijv& b) const
      {
        if (a.i() < b.i())
          return true;
        else if (a.i() == b.i())
          if (a.j() < b.j())
            return true;
        return false;
      }
    };





    struct less_value : public std::binary_function<bool, ijv, ijv>
    {
      inline bool operator()(const ijv& a, const ijv& b) const
      {
        return a.v() < b.v();
      }
    };





    struct greater_value : public std::binary_function<bool, ijv, ijv>
    {
      inline bool operator()(const ijv& a, const ijv& b) const
      {
        return a.v() > b.v();
      }
    };
  };
# 551 "/home/marek/devel/nupic/nta/math/math.hpp"
  template <typename T>
  struct Identity : public std::unary_function<T,T>
  {
    inline T& operator()(T& x) const { return x; }
    inline const T& operator()(const T& x) const { return x; }
  };

  template <typename T>
  struct Negate : public std::unary_function<T,T>
  {
    inline T operator()(const T& x) const { return -x; }
  };

  template <typename T>
  struct Abs : public std::unary_function<T,T>
  {
    inline T operator()(const T& x) const { return x > 0.0 ? x : -x; }
  };

  template <typename T>
  struct Square : public std::unary_function<T,T>
  {
    inline T operator()(const T& x) const { return x*x; }
  };

  template <typename T>
  struct Cube : public std::unary_function<T,T>
  {
    inline T operator()(const T& x) const { return x*x*x; }
  };

  template <typename T>
  struct Inverse : public std::unary_function<T,T>
  {
    inline T operator()(const T& x) const { return 1.0/x; }
  };

  template <typename T>
  struct Sqrt : public std::unary_function<T,T>
  {};

  template <>
  struct Sqrt<float> : public std::unary_function<float,float>
  {
    inline float operator()(const float& x) const { return sqrtf(x); }
  };

  template <>
  struct Sqrt<double> : public std::unary_function<double,double>
  {
    inline double operator()(const double& x) const { return sqrt(x); }
  };

  template <>
  struct Sqrt<long double> : public std::unary_function<long double,long double>
  {
    inline long double operator()(const long double& x) const { return sqrtl(x); }
  };

  template <typename T>
  struct Exp : public std::unary_function<T,T>
  {};

  template <>
  struct Exp<float> : public std::unary_function<float,float>
  {






    inline float operator()(const float& x) const { return expf(x); }
  };

  template <>
  struct Exp<double> : public std::unary_function<double,double>
  {
    inline double operator()(const double& x) const { return exp(x); }
  };

  template <>
  struct Exp<long double> : public std::unary_function<long double,long double>
  {
    inline long double operator()(const long double& x) const { return expl(x); }
  };

  template <typename T>
  struct Log : public std::unary_function<T,T>
  {};

  template <>
  struct Log<float> : public std::unary_function<float,float>
  {
    inline float operator()(const float& x) const { return logf(x); }
  };

  template <>
  struct Log<double> : public std::unary_function<double,double>
  {
    inline double operator()(const double& x) const { return log(x); }
  };

  template <>
  struct Log<long double> : public std::unary_function<long double,long double>
  {
    inline long double operator()(const long double& x) const { return logl(x); }
  };

  template <typename T>
  struct Log2 : public std::unary_function<T,T>
  {};

  template <>
  struct Log2<float> : public std::unary_function<float,float>
  {
    inline float operator()(const float& x) const
    {



      return log2f(x);

    }
  };

  template <>
  struct Log2<double> : public std::unary_function<double,double>
  {
    inline double operator()(const double& x) const
    {



      return log2(x);

    }
  };

  template <>
  struct Log2<long double> : public std::unary_function<long double,long double>
  {
    inline long double operator()(const long double& x) const
    {



      return log2l(x);

    }
  };

  template <typename T>
  struct Log10 : public std::unary_function<T,T>
  {};

  template <>
  struct Log10<float> : public std::unary_function<float,float>
  {
    inline float operator()(const float& x) const
    {



      return log10f(x);

    }
  };

  template <>
  struct Log10<double> : public std::unary_function<double,double>
  {
    inline double operator()(const double& x) const
    {



      return log10(x);

    }
  };

  template <>
  struct Log10<long double> : public std::unary_function<long double,long double>
  {
    inline long double operator()(const long double& x) const
    {



      return log10l(x);

    }
  };

  template <typename T>
  struct Log1p : public std::unary_function<T,T>
  {};

  template <>
  struct Log1p<float> : public std::unary_function<float,float>
  {
    inline float operator()(const float& x) const
    {



      return log1pf(x);

    }
  };

  template <>
  struct Log1p<double> : public std::unary_function<double,double>
  {
    inline double operator()(const double& x) const
    {



      return log1p(x);

    }
  };

  template <>
  struct Log1p<long double> : public std::unary_function<long double,long double>
  {
    inline long double operator()(const long double& x) const
    {



      return log1pl(x);

    }
  };





  template <typename Float, typename F>
  struct Derivative : public std::unary_function<Float, Float>
  {
    Derivative(const F& f) : f_(f) {}

    F f_;




    inline const Float operator()(const Float& x) const
    {
      const Float h = nta::Epsilon;
      return (-f_(x+2*h)+8*f_(x+h)-8*f_(x-h)+f_(x-2*h))/(12*h);
    }
  };




  template <typename T>
  struct Assign : public std::binary_function<T,T,T>
  {
    inline T operator()(T& x, const T& y) const { x = y; return x; }
  };

  template <typename T>
  struct Plus : public std::binary_function<T,T,T>
  {
    inline T operator()(const T& x, const T& y) const { return x + y; }
  };

  template <typename T>
  struct Minus : public std::binary_function<T,T,T>
  {
    inline T operator()(const T& x, const T& y) const { return x - y; }
  };

  template <typename T>
  struct Multiplies : public std::binary_function<T,T,T>
  {
    inline T operator()(const T& x, const T& y) const { return x * y; }
  };

  template <typename T>
  struct Divides : public std::binary_function<T,T,T>
  {
    inline T operator()(const T& x, const T& y) const { return x / y; }
  };

  template <typename T>
  struct Pow : public std::binary_function<T,T,T>
  {};

  template <>
  struct Pow<float> : public std::binary_function<float,float,float>
  {
    inline float operator()(const float& x, const float& y) const
    {
      return powf(x,y);
    }
  };

  template <>
  struct Pow<double> : public std::binary_function<double,double,double>
  {
    inline double operator()(const double& x, const double& y) const
    {
      return pow(x,y);
    }
  };

  template <>
  struct Pow<long double>
    : public std::binary_function<long double,long double,long double>
  {
    inline long double operator()(const long double& x, const long double& y) const
    {
      return powl(x,y);
    }
  };

  template <typename T>
  struct Logk : public std::binary_function<T,T,T>
  {};

  template <>
  struct Logk<float> : public std::binary_function<float,float,float>
  {
    inline float operator()(const float& x, const float& y) const
    {
      return logf(x)/logf(y);
    }
  };

  template <>
  struct Logk<double> : public std::binary_function<double,double,double>
  {
    inline double operator()(const double& x, const double& y) const
    {
      return log(x)/log(y);
    }
  };

  template <>
  struct Logk<long double>
    : public std::binary_function<long double,long double,long double>
  {
    inline long double operator()(const long double& x, const long double& y) const
    {
      return logl(x)/logl(y);
    }
  };

  template <typename T>
  struct Max : public std::binary_function<T,T,T>
  {
    inline T operator()(const T& x, const T& y) const { return x > y ? x : y; }
  };

  template <typename T>
  struct Min : public std::binary_function<T,T,T>
  {
    inline T operator()(const T& x, const T& y) const { return x < y ? x : y; }
  };






  template <typename T>
  struct Gaussian : public std::unary_function<T, T>
  {
    T k1, k2, mu;

    inline Gaussian(T m, T s)
      : k1(0.0),
        k2(0.0),
        mu(m)
    {



      k1 = 1.0 / sqrt(2.0 * 3.1415926535);
      k2 = -1.0 / (2.0 * s * s);
    }

    inline Gaussian(const Gaussian& o)
      : k1(o.k1), k2(o.k2), mu(o.mu)
    {}

    inline Gaussian& operator=(const Gaussian& o)
    {
      if (&o != this) {
        k1 = o.k1;
        k2 = o.k2;
        mu = o.mu;
      }

      return *this;
    }

    inline T operator()(T x) const
    {
      T v = x - mu;
      return k1 * exp(k2 * v * v);
    }
  };





  template <typename T>
  struct Gaussian2D
  {
    T c_x, c_y, s00, s01, s10, s11, s2, k1;

    inline Gaussian2D(T c_x_, T c_y_, T s00_, T s01_, T s10_, T s11_)
      : c_x(c_x_), c_y(c_y_),
        s00(s00_), s01(s01_), s10(s10_), s11(s11_), s2(s10 + s01),
        k1(0.0)
    {



      k1 = 1.0/(2.0 * 3.1415926535 * sqrt(s00 * s11 - s10 * s01));
      T d = -2.0 * (s00 * s11 - s10 * s01);
      s00 /= d;
      s01 /= d;
      s10 /= d;
      s11 /= d;
      s2 /= d;
    }

    inline Gaussian2D(const Gaussian2D& o)
      : c_x(o.c_x), c_y(o.c_y),
        s00(o.s00), s01(o.s01), s10(o.s10), s11(o.s11), s2(o.s2),
        k1(o.k1)
    {}

    inline Gaussian2D& operator=(const Gaussian2D& o)
    {
      if (&o != this) {
        c_x = o.c_x; c_y = o.c_y;
        s00 = o.s00; s01 = o.s01; s10 = o.s10; s11 = o.s11;
        s2 = o.s2;
        k1 = o.k1;
      }

      return *this;
    }

    inline T operator()(T x, T y) const
    {
      T v0 = x - c_x, v1 = y - c_y;
      return k1 * exp(s11 * v0 * v0 + s2 * v0 * v1 + s00 * v1 * v1);
    }
  };





  template <typename F1, typename F2>
  struct unary_compose
    : public std::unary_function<typename F1::argument_type, typename F2::result_type>
  {
    typedef typename F1::argument_type argument_type;
    typedef typename F2::result_type result_type;

    F1 f1;
    F2 f2;

    inline result_type operator()(const argument_type& x) const
    {
      return f2(f1(x));
    }
  };







  template <typename O, typename S>
  struct predicate_compose
    : public std::binary_function<typename S::argument_type,
      typename S::argument_type,
      bool>
  {
    typedef bool result_type;
    typedef typename S::argument_type argument_type;

    O o;
    S s;

    inline result_type operator()(const argument_type& x, const argument_type& y) const
    {
      return o(s(x), s(y));
    }
  };
# 1065 "/home/marek/devel/nupic/nta/math/math.hpp"
  template <typename T>
  inline std::binder2nd<nta::Assign<T> > AssignVal(const T& v)
  {
    return std::bind2nd(nta::Assign<T>(), v);
  }

  template <typename T>
  inline std::binder2nd<nta::Plus<T> > PlusVal(const T& v)
  {
    return std::bind2nd(nta::Plus<T>(), v);
  }

  template <typename T>
  inline std::binder2nd<nta::Minus<T> > MinusVal(const T& v)
  {
    return std::bind2nd(nta::Minus<T>(), v);
  }

  template <typename T>
  inline std::binder2nd<nta::Multiplies<T> > MultipliesByVal(const T& v)
  {
    return std::bind2nd(nta::Multiplies<T>(), v);
  }

  template <typename T>
  inline std::binder2nd<nta::Divides<T> > DividesByVal(const T& v)
  {
    if (!nta::nearlyZero(v)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/math.hpp", 1092) << "ASSERTION FAILED: \"" << "!nta::nearlyZero(v)" << "\" "
      << "dividesByVal: "
      << "Division by zero";

    return std::bind2nd(nta::Divides<T>(), v);
  }

  template <typename T>
  inline std::binder2nd<nta::Pow<T> > PowVal(const T& v)
  {
    return std::bind2nd(nta::Pow<T>(), v);
  }

  template <typename T>
  inline std::binder2nd<nta::Logk<T> > LogkVal(const T& v)
  {
    return std::bind2nd(nta::Logk<T>(), v);
  }







  template <typename T>
  inline bool isSafeForDivision(const T& x)
  {
    Log<T> log_f;
    return log_f(x) >= std::numeric_limits<T>::min_exponent10;
  }





  template <typename T>
  struct ClipAbove : public std::unary_function<T, T>
  {
    inline ClipAbove(const T& val)
      : val_(val)
    {}

    inline ClipAbove(const ClipAbove& c)
      : val_(c.val_)
    {}

    inline ClipAbove& operator=(const ClipAbove& c)
    {
      if (this != &c)
 val_ = c.val_;

      return *this;
    }

    inline T operator()(const T& x) const
    {
      return x >= val_ ? val_ : x;
    }

    T val_;
  };





  template <typename T>
  struct ClipBelow : public std::unary_function<T, T>
  {
    inline ClipBelow(const T& val)
      : val_(val)
    {}

    inline ClipBelow(const ClipBelow& c)
      : val_(c.val_)
    {}

    inline ClipBelow& operator=(const ClipBelow& c)
    {
      if (this != &c)
 val_ = c.val_;

      return *this;
    }

    inline T operator()(const T& x) const
    {
      return x < val_ ? val_ : x;
    }

    T val_;
  };



};
# 39 "/home/marek/devel/nupic/nta/math/array_algo.hpp" 2
# 1 "/home/marek/devel/nupic/nta/math/types.hpp" 1
# 41 "/home/marek/devel/nupic/nta/math/types.hpp"
namespace nta {
# 51 "/home/marek/devel/nupic/nta/math/types.hpp"
  struct ByteVector : public std::vector<nta::Byte>
  {
    inline ByteVector(size_t n =0)
      : std::vector<nta::Byte>(n, (nta::Byte)0)
    {}






    template <typename It>
    inline ByteVector(It begin, size_t n)
      : std::vector<nta::Byte>(n, 0)
    {
      for (size_t i = 0; i != this->size(); ++i)
        (*this)[i] = *begin++ != 0;
    }

    template <typename It>
    inline void toDense(It begin, It end)
    {
      for (size_t i = 0; i != this->size(); ++i)
        *begin++ = (*this)[i] != 0;
    }
  };
# 86 "/home/marek/devel/nupic/nta/math/types.hpp"
  template <typename T>
  struct Buffer : public std::vector<T>
  {
    typedef size_t size_type;
    typedef T value_type;

    size_type nnz;

    inline Buffer(size_type _s =0)
      : std::vector<T>(_s),
        nnz(0)
    {}

    inline void clear()
    {
      nnz = 0;
    }

    inline void adjust_nnz(size_t n)
    {
      nnz = std::min(nnz, n);
    }

    inline bool empty() const
    {
      return nnz == 0;
    }

    inline void push_back(const T& x)
    {
      (*this)[nnz++] = x;
    }

    inline typename std::vector<T>::iterator nnz_end()
    {
      return this->begin() + nnz;
    }

    inline typename std::vector<T>::const_iterator nnz_end() const
    {
      return this->begin() + nnz;
    }
  };
# 142 "/home/marek/devel/nupic/nta/math/types.hpp"
  template <typename I, typename T>
  struct DirectAccess
  {
    typedef I size_type;
    typedef T value_type;

    std::vector<T> board;
    std::vector<size_type> who;

    inline void resize(size_type m, size_type n =0)
    {

      board.resize(m, T());
      who.reserve(n == 0 ? m : n);

      ((who.size() == 0) ? static_cast<void> (0) : __assert_fail ("who.size() == 0", "/home/marek/devel/nupic/nta/math/types.hpp", 157, __PRETTY_FUNCTION__));
    }

    inline void set(size_type w, const T& v = T(1))
    {
      ((w < board.size()) ? static_cast<void> (0) : __assert_fail ("w < board.size()", "/home/marek/devel/nupic/nta/math/types.hpp", 162, __PRETTY_FUNCTION__));
      ((v != T()) ? static_cast<void> (0) : __assert_fail ("v != T()", "/home/marek/devel/nupic/nta/math/types.hpp", 163, __PRETTY_FUNCTION__));
      ((who.size() < who.capacity()) ? static_cast<void> (0) : __assert_fail ("who.size() < who.capacity()", "/home/marek/devel/nupic/nta/math/types.hpp", 164, __PRETTY_FUNCTION__));

      if (board[w] == T()) {
        who.push_back(w);

      }

      board[w] = v;
    }

    inline T get(size_type w) const
    {
      ((w < board.size()) ? static_cast<void> (0) : __assert_fail ("w < board.size()", "/home/marek/devel/nupic/nta/math/types.hpp", 176, __PRETTY_FUNCTION__));

      return board[w];
    }



    inline const T& operator[](size_type w) const
    {
      return board[w];
    }

    inline void increment(size_type w)
    {
      ((w < board.size()) ? static_cast<void> (0) : __assert_fail ("w < board.size()", "/home/marek/devel/nupic/nta/math/types.hpp", 190, __PRETTY_FUNCTION__));

      if (board[w] == T()) {
        who.push_back(w);

      }

      ++ board[w];
    }


    inline void decrement(size_type w)
    {
      ((w < board.size()) ? static_cast<void> (0) : __assert_fail ("w < board.size()", "/home/marek/devel/nupic/nta/math/types.hpp", 203, __PRETTY_FUNCTION__));

      if (board[w] == T()) {
        who.push_back(w);

      }

      -- board[w];



      if (board[w] == T()) {
        size_type i = 0;
        while (who[i] != w)
          ++i;
        std::swap(who[i], who[who.size()-1]);
        who.pop_back();
      }
    }



    inline void update(size_type w, const value_type& v)
    {
      ((w < board.size()) ? static_cast<void> (0) : __assert_fail ("w < board.size()", "/home/marek/devel/nupic/nta/math/types.hpp", 227, __PRETTY_FUNCTION__));

      if (board[w] == T()) {
        who.push_back(w);

      }

      board[w] += v;



      if (board[w] == T()) {
        size_type i = 0;
        while (who[i] != w)
          ++i;
        std::swap(who[i], who[who.size()-1]);
        who.pop_back();
      }
    }



    inline void clear()
    {
      size_type* w = &who[0], *w_end = w + who.size();

      while (w != w_end)

        board[*w++] = T();
      who.resize(0);
    }




    inline void threshold(const T& t, bool sorted =false)
    {
      int n = who.size();
      int i = 0;

      while (i < n)
        if (board[who[i]] < t)
          std::swap(who[i], who[--n]);
        else
          ++i;

      who.resize(n);

      if (sorted)
        std::sort(who.begin(), who.end());
    }
  };





  template <typename I, typename T>
  struct Indicator;

  template <typename I>
  struct Indicator<I, unsigned short>
  {
    typedef I size_type;

    std::vector<unsigned short> board;
    unsigned short color;

    inline void resize(size_type m)
    {
      color = 0;
      board.resize(m, color);
    }

    inline void set(size_type w)
    {
      if (w < board.size()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/types.hpp", 303) << "ASSERTION FAILED: \"" << "w < board.size()" << "\" ";

      board[w] = color;
    }

    inline bool is_on(size_type w) const
    {
      if (w < board.size()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/types.hpp", 310) << "ASSERTION FAILED: \"" << "w < board.size()" << "\" ";

      return board[w] == color;
    }

    inline bool operator[](size_type w) const
    {
      if (w < board.size()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/types.hpp", 317) << "ASSERTION FAILED: \"" << "w < board.size()" << "\" ";

      return is_on(w);
    }

    inline void clear()
    {
      if (color < std::numeric_limits<unsigned short>::max())
        ++color;
      else {
        color = 0;
        std::fill(board.begin(), board.end(), color);
      }
    }

    template <typename It>
    inline void set_from_sparse(It begin, It end)
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/types.hpp", 335) << "ASSERTION FAILED: \"" << "begin <= end" << "\" ";

      this->clear();
      while (begin != end)
        this->set(*begin++);
    }
  };






  template <typename T1, typename T2>
  struct SparseVector : public Buffer<std::pair<T1,T2> >
  {
    typedef T1 size_type;
    typedef T2 value_type;

    inline SparseVector(size_type s =0)
      : Buffer<std::pair<T1,T2> >(s)
    {}
  };


};
# 40 "/home/marek/devel/nupic/nta/math/array_algo.hpp" 2
# 51 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
namespace nta {
# 66 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  static int checkSSE()
  {
    unsigned int c = 0, d = 0;
    const unsigned int SSE= 1<<25,
   SSE2= 1<<26,
   SSE3= 1<<0,
   SSE41=1<<19,
   SSE42=1<<20;
# 100 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
    int ret = -1;
    if (d & SSE) ret = 1;
    if (d & SSE2) ret = 2;
    if (c & SSE3) ret = 3;
    if (c & SSE41) ret = 41;
    if (c & SSE42) ret = 42;

    return ret;
  }







  static const int SSE_LEVEL = checkSSE();







  template <typename It>
  inline bool
  nearlyZeroRange(It begin, It end,
                  const typename std::iterator_traits<It>::value_type epsilon =nta::Epsilon)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 130) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "nearlyZeroRange: Invalid input range";
    }

    while (begin != end)
      if (!nearlyZero(*begin++, epsilon))
        return false;
    return true;
  }


  template <typename It1, typename It2>
  inline bool
  nearlyEqualRange(It1 begin1, It1 end1, It2 begin2, It2 end2,
                   const typename std::iterator_traits<It1>::value_type epsilon =nta::Epsilon)
  {
    {
      if (begin1 <= end1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 147) << "ASSERTION FAILED: \"" << "begin1 <= end1" << "\" "
        << "nearlyZeroRange: Invalid first input range";
      if (begin2 <= end2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 149) << "ASSERTION FAILED: \"" << "begin2 <= end2" << "\" "
        << "nearlyZeroRange: Invalid second input range";
      if (end1 - begin1 <= end2 - begin2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 151) << "ASSERTION FAILED: \"" << "end1 - begin1 <= end2 - begin2" << "\" "
        << "nearlyZeroRange: Incompatible ranges";
    }

    while (begin1 != end1)
      if (!nearlyEqual(*begin1++, *begin2++, epsilon))
        return false;
    return true;
  }


  template <typename Container1, typename Container2>
  inline bool
  nearlyEqualVector(const Container1& c1, const Container2& c2,
                    const typename Container1::value_type& epsilon =nta::Epsilon)
  {
    typedef typename Container1::value_type T1;
    typedef typename Container2::value_type T2;

    if (c1.size() != c2.size())
      return false;

    return nearlyEqualRange(c1.begin(), c1.end(), c2.begin(), c2.end());
  }




  template <typename T>
  inline bool is_zero(const T& x)
  {
    return x == 0;
  }


  template <typename T1, typename T2>
  inline bool is_zero(const std::pair<T1,T2>& x)
  {
    return x.first == 0 && x.second == 0;
  }


  template <typename T>
  inline bool is_zero(const std::vector<T>& x)
  {
    for (size_t i = 0; i != x.size(); ++i)
      if (!is_zero(x[i]))
        return false;
    return true;
  }
# 217 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename InputIterator>
  inline bool isZero_01(InputIterator x, InputIterator x_end)
  {
    {
      if (x <= x_end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 221) << "ASSERTION FAILED: \"" << "x <= x_end" << "\" ";
    }
# 304 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
    for (; x != x_end; ++x)
      if (*x > 0)
        return false;
    return true;

  }





  inline bool
  is_zero_01(const ByteVector& x, size_t begin, size_t end)
  {
    const Byte* x_beg = &x[begin];
    const Byte* x_end = &x[end];
# 401 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
    for (; x_beg != x_end; ++x_beg)
      if (*x_beg > 0)
        return false;
    return true;

  }


  template <typename InIter>
  inline bool
  positive_less_than(InIter begin, InIter end,
                     const typename std::iterator_traits<InIter>::value_type threshold)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 415) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "positive_less_than: Invalid input range";
    }

    for (; begin != end; ++begin)
      if (*begin > threshold)
        return false;
    return true;
  }


  template <typename T>
  inline void print_bits(const T& x)
  {
    for (int i = sizeof(T) - 1; 0 <= i; --i) {
      unsigned char* b = (unsigned char*)(&x) + i;
      for (int j = 7; 0 <= j; --j)
        std::cout << ((*b & (1 << j)) / (1 << j));
      std::cout << ' ';
    }
  }







  template <typename T>
  inline size_t n_bytes(const T&)
  {
    return sizeof(T);
  }


  template <typename T1, typename T2>
  inline size_t n_bytes(const std::pair<T1,T2>& p)
  {
    size_t n = n_bytes(p.first) + n_bytes(p.second);
    return n;
  }
# 467 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename T>
  inline size_t n_bytes(const std::vector<T>& a, size_t alignment =16)
  {
    size_t n1 = a.capacity() * sizeof(T);
    if (n1 % alignment != 0)
      n1 = alignment * (n1 / alignment + 1);

    size_t n2 = sizeof(std::vector<T>);
    if (n2 % alignment != 0)
      n2 = alignment * (n2 / alignment + 1);

    return n1 + n2;
  }


  template <typename T>
  inline size_t n_bytes(const std::vector<std::vector<T> >& a, size_t alignment =16)
  {
    size_t n = sizeof(std::vector<std::vector<T> >);
    if (n % alignment != 0)
      n = alignment * (n / alignment + 1);

    for (size_t i = 0; i != a.size(); ++i)
      n += n_bytes(a[i]);

    return n;
  }


  template <typename T>
  inline float load_factor(const std::vector<T>& x)
  {
    return (float) x.size() / (float) x.capacity();
  }


  template <typename T>
  inline void adjust_load_factor(std::vector<T>& x, float target)
  {
    if (0.0 <= target && target <= 1.0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 506) << "ASSERTION FAILED: \"" << "0.0 <= target && target <= 1.0" << "\" ";

    size_t new_capacity = (size_t)((float)x.size() / target);

    std::vector<T> y;
    y.reserve(new_capacity);
    y.resize(x.size());
    std::copy(x.begin(), x.end(), y.begin());
    x.swap(y);
  }




  inline std::string operator+(const std::string& str, size_t idx)
  {
    std::stringstream buff;
    buff << str << idx;
    return buff.str();
  }


  template <typename T>
  inline void append(const std::vector<T>& a, std::vector<T>& b)
  {
    b.insert(b.end(), a.begin(), a.end());
  }


  template <typename T>
  inline std::vector<T>& operator+=(std::vector<T>& b, const std::vector<T>& a)
  {
    append(a, b);
    return b;
  }


  template <typename T>
  inline void append(const std::set<T>& a, std::set<T>& b)
  {
    b.insert(a.begin(), a.end());
  }


  template <typename T>
  inline std::set<T>& operator+=(std::set<T>& b, const std::set<T>& a)
  {
    append(a, b);
    return b;
  }



  template <typename T1, typename T2>
  inline void increment(std::map<T1,T2>& m, const T1& key, const T2& init =1)
  {
    typename std::map<T1,T2>::iterator it = m.find(key);
    if (it != m.end())
      ++ it->second;
    else
      m[key] = init;
  }


  template <typename K, typename V>
  inline bool is_in(const K& key, const std::map<K,V>& m)
  {
    return m.find(key) != m.end();
  }



  template <typename K, typename V, typename C =std::less<K>,
            typename A =std::allocator<std::pair<const K, V> > >
  struct dict : public std::map<K,V,C,A>
  {
    inline bool has_key(const K& key) const
    {
      return is_in(key, *this);
    }


    inline void increment(const K& key, const V& init =1)
    {
      nta::increment(*this, key, init);
    }



    inline bool insert_once(const K& key, const V& v)
    {
      if (has_key(key))
        return false;
      else
        this->insert(std::make_pair(key, v));
      return true;
    }
# 617 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  };




  template <typename T>
  struct vector_init_list
  {
    std::vector<T>& v;

    inline vector_init_list(std::vector<T>& v_ref) : v(v_ref) {}
    inline vector_init_list(const vector_init_list& o) : v(o.v) {}

    inline vector_init_list& operator=(const vector_init_list& o)
    { v(o.v); return *this; }

    template <typename T2>
    inline vector_init_list<T>& operator,(const T2& x)
    {
      v.push_back((T)x);
      return *this;
    }
  };


  template <typename T, typename T2>
  inline vector_init_list<T> operator+=(std::vector<T>& v, const T2& x)
  {
    v.push_back((T)x);
    return vector_init_list<T>(v);
  }




  template <typename T>
  struct set_init_list
  {
    std::set<T>& v;

    inline set_init_list(std::set<T>& v_ref) : v(v_ref) {}
    inline set_init_list(const set_init_list& o) : v(o.v) {}

    inline set_init_list& operator=(const set_init_list& o)
    { v(o.v); return *this; }

    template <typename T2>
    inline set_init_list<T>& operator,(const T2& x)
    {
      v.insert((T)x);
      return *this;
    }
  };


  template <typename T, typename T2>
  inline set_init_list<T> operator+=(std::set<T>& v, const T2& x)
  {
    v.insert((T)x);
    return set_init_list<T>(v);
  }





  template <typename T1, typename T2>
  inline int find_index(const T1& x, const std::vector<T2>& v)
  {
    for (size_t i = 0; i != v.size(); ++i)
      if (v[i] == x)
        return (int) i;
    return -1;
  }


  template <typename T1, typename T2>
  inline int find_index(const T1& x, const std::vector<std::pair<T1,T2> >& v)
  {
    for (size_t i = 0; i != v.size(); ++i)
      if (v[i].first == x)
        return (int) i;
    return -1;
  }


  template <typename T>
  inline bool not_in(const T& x, const std::vector<T>& v)
  {
    return std::find(v.begin(), v.end(), x) == v.end();
  }


  template <typename T1, typename T2>
  inline bool not_in(const T1& x, const std::vector<std::pair<T1,T2> >& v)
  {
    typename std::vector<std::pair<T1,T2> >::const_iterator it;
    for (it = v.begin(); it != v.end(); ++it)
      if (it->first == x)
        return false;
    return true;
  }


  template <typename T>
  inline bool not_in(const T& x, const std::set<T>& s)
  {
    return s.find(x) == s.end();
  }


  template <typename T>
  inline bool is_in(const T& x, const std::vector<T>& v)
  {
    return ! not_in(x, v);
  }


  template <typename T1, typename T2>
  inline bool is_in(const T1& x, const std::vector<std::pair<T1,T2> >& v)
  {
    return ! not_in(x, v);
  }


  template <typename T>
  inline bool is_in(const T& x, const std::set<T>& s)
  {
    return ! not_in(x, s);
  }


  template <typename It>
  inline bool is_sorted(It begin, It end, bool ascending =true, bool unique =true)
  {
    for (It prev = begin, it = ++begin; it < end; ++it, ++prev)

      if (ascending) {
        if (unique) {
          if (*prev >= *it)
            return false;
        } else {
          if (*prev > *it)
            return false;
        }
      } else {
        if (unique) {
          if (*prev <= *it)
            return false;
        } else {
          if (*prev < *it)
            return false;
        }
      }

    return true;
  }


  template <typename T>
  inline bool is_sorted(const std::vector<T>& x, bool ascending =true, bool unique =true)
  {
    return is_sorted(x.begin(), x.end(), ascending, unique);
  }


  template <typename T>
  inline bool operator==(const std::vector<T>& a, const std::vector<T>& b)
  {
    if (a.size() == b.size()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 786) << "ASSERTION FAILED: \"" << "a.size() == b.size()" << "\" ";
    if (a.size() != b.size())
      return false;
    for (size_t i = 0; i != a.size(); ++i)
      if (a[i] != b[i])
        return false;
    return true;
  }


  template <typename T>
  inline bool operator!=(const std::vector<T>& a, const std::vector<T>& b)
  {
    return !(a == b);
  }


  template <typename T1, typename T2>
  inline bool operator==(const std::map<T1,T2>& a, const std::map<T1,T2>& b)
  {
    typename std::map<T1,T2>::const_iterator ita = a.begin(), itb = b.begin();
    for (; ita != a.end(); ++ita, ++itb)
      if (ita->first != itb->first || ita->second != itb->second)
        return false;
    return true;
  }


  template <typename T1, typename T2>
  inline bool operator!=(const std::map<T1,T2>& a, const std::map<T1,T2>& b)
  {
    return !(a == b);
  }






  template <typename Iterator>
  struct inserter_second
  {
    typedef typename std::iterator_traits<Iterator>::value_type pair_type;
    typedef typename pair_type::second_type second_type;
    typedef second_type value_type;

    Iterator it;

    inline inserter_second(Iterator _it) : it(_it) {}
    inline second_type& operator*() { return it->second; }
    inline void operator++() { ++it; }
  };

  template <typename Iterator>
  inserter_second<Iterator> insert_2nd(Iterator it)
  {
    return inserter_second<Iterator>(it);
  }
# 852 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename Iterator>
  struct inserter_second_incrementer_first
  {
    typedef typename std::iterator_traits<Iterator>::value_type pair_type;
    typedef typename pair_type::second_type second_type;
    typedef second_type value_type;

    Iterator it;
    size_t i;

    inline inserter_second_incrementer_first(Iterator _it)
      : it(_it), i(0) {}
    inline second_type& operator*() { return it->second; }
    inline void operator++() { it->first = i++; ++it; }
  };

  template <typename Iterator>
  inserter_second_incrementer_first<Iterator> insert_2nd_inc(Iterator it)
  {
    return inserter_second_incrementer_first<Iterator>(it);
  }


  template <typename T1, typename T2>
  inline T2 dot(const std::vector<T1>& x, const Buffer<T2>& y)
  {
    size_t n1 = x.size(), n2 = y.nnz, i1 = 0, i2 = 0;
    T2 s = 0;

    while (i1 != n1 && i2 != n2)
      if (x[i1] < y[i2]) {
        ++i1;
      } else if (y[i2] < x[i1]) {
        ++i2;
      } else {
        ++s;
        ++i1; ++i2;
      }

    return s;
  }


  inline float dot(const float* x, const float* x_end, const float* y)
  {
    float result = 0;



    for (; x != x_end; ++x, ++y)
      result += *x * *y;

    return result;
  }




  template <typename It1, typename It2>
  inline void copy(It1 begin, It1 end, It2 out_begin, It2 out_end)
  {
    std::copy(begin, end, out_begin);
  }
# 926 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename T1, typename T2>
  inline void copy(const T1& a, T2& b)
  {
    b.resize(a.size());
    copy(a.begin(), a.end(), b.begin(), b.end());
  }


  template <typename T1, typename T2>
  inline void copy(const std::vector<T1>& a, size_t n, std::vector<T2>& b, size_t o =0)
  {
    if (o + n <= b.size()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 937) << "ASSERTION FAILED: \"" << "o + n <= b.size()" << "\" ";
    std::copy(a.begin(), a.begin() + n, b.begin() + o);
  }


  template <typename T1, typename T2>
  inline void copy(const std::vector<T1>& a, size_t i, size_t j, std::vector<T2>& b)
  {
    std::copy(a.begin() + i, a.begin() + j, b.begin() + i);
  }


  template <typename T1, typename T2>
  inline void copy(const std::vector<T1>& a, std::vector<T2>& b, size_t offset)
  {
    if (offset + a.size() <= b.size()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 952) << "ASSERTION FAILED: \"" << "offset + a.size() <= b.size()" << "\" ";
    std::copy(a.begin(), a.end(), b.begin() + offset);
  }


  template <typename I, typename T>
  inline void copy_indices(const SparseVector<I,T>& x, Buffer<I>& y)
  {
    if (x.nnz <= y.size()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 960) << "ASSERTION FAILED: \"" << "x.nnz <= y.size()" << "\" ";

    for (size_t i = 0; i != x.nnz; ++i)
      y[i] = x[i].first;
    y.nnz = x.nnz;
  }




  template <typename It1, typename It2>
  inline void to_dense_01(It1 ind, It1 ind_end, It2 dense, It2 dense_end)
  {
    {
      if (ind <= ind_end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 974) << "ASSERTION FAILED: \"" << "ind <= ind_end" << "\" "
        << "to_dense: Mismatched iterators";
      if (dense <= dense_end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 976) << "ASSERTION FAILED: \"" << "dense <= dense_end" << "\" "
        << "to_dense: Mismatched iterators";
      if (ind_end - ind <= dense_end - dense) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 978) << "ASSERTION FAILED: \"" << "ind_end - ind <= dense_end - dense" << "\" "
        << "to_dense: Not enough memory";
    }

    typedef typename std::iterator_traits<It2>::value_type value_type;



    std::fill(dense, dense_end, (value_type) 0);

    for (; ind != ind_end; ++ind)
      *(dense + *ind) = (value_type) 1;
  }


  template <typename T1, typename T2>
  inline void to_dense_01(const std::vector<T1>& sparse, std::vector<T2>& dense)
  {
    to_dense_01(sparse.begin(), sparse.end(), dense.begin(), dense.end());
  }


  template <typename T, typename OutIt>
  inline void to_dense_01(const Buffer<T>& buffer, OutIt y, OutIt y_end)
  {
    typedef typename std::iterator_traits<OutIt>::value_type value_type;

    std::fill(y, y_end, (value_type) 0);

    for (size_t i = 0; i != buffer.nnz; ++i)
      y[buffer[i]] = (value_type) 1;
  }


  template <typename It, typename T>
  inline void to_dense_01(It begin, It end, std::vector<T>& dense)
  {
    to_dense_01(begin, end, dense.begin(), dense.end());
  }


  template <typename I, typename T, typename OutIt>
  inline void to_dense_1st_01(const SparseVector<I,T>& x, OutIt y, OutIt y_end)
  {
    typedef typename std::iterator_traits<OutIt>::value_type value_type;

    std::fill(y, y_end, (value_type) 0);

    for (size_t i = 0; i != x.nnz; ++i)
      y[x[i].first] = (value_type) 1;
  }


  template <typename T, typename OutIt>
  inline void
  to_dense_01(size_t n, const std::vector<T>& buffer, OutIt y, OutIt y_end)
  {
    if (n <= buffer.size()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1035) << "ASSERTION FAILED: \"" << "n <= buffer.size()" << "\" ";

    typedef typename std::iterator_traits<OutIt>::value_type value_type;

    std::fill(y, y_end, (value_type) 0);

    const T* b = &buffer[0], *b_end = b + n;
    for (; b != b_end; ++b) {
      if (*b < (size_t)(y_end - y)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1043) << "ASSERTION FAILED: \"" << "*b < (size_t)(y_end - y)" << "\" ";
      y[*b] = (value_type) 1;
    }
  }






  template <typename It1, typename It2, typename It3>
  inline void to_dense(It1 ind, It1 ind_end, It2 nz, It2 nz_end,
                       It3 dense, It3 dense_end)
  {
    {
      if (ind <= ind_end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1058) << "ASSERTION FAILED: \"" << "ind <= ind_end" << "\" "
        << "to_dense: Mismatched ind iterators";
      if (dense <= dense_end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1060) << "ASSERTION FAILED: \"" << "dense <= dense_end" << "\" "
        << "to_dense: Mismatched dense iterators";
      if (ind_end - ind <= dense_end - dense) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1062) << "ASSERTION FAILED: \"" << "ind_end - ind <= dense_end - dense" << "\" "
        << "to_dense: Not enough memory";
      if (nz_end - nz == ind_end - ind) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1064) << "ASSERTION FAILED: \"" << "nz_end - nz == ind_end - ind" << "\" "
        << "to_dense: Mismatched ind and nz ranges";
    }

    typedef typename std::iterator_traits<It3>::value_type value_type;

    std::fill(dense, dense + (ind_end - ind), (value_type) 0);

    for (; ind != ind_end; ++ind, ++nz)
      *(dense + *ind) = *nz;
  }





  template <typename It>
  inline void in_place_sparse_to_dense_01(int n, It begin, It end)
  {
    for (int i = n - 1; i >= 0; --i) {
      int p = (int) *(begin + i);
      std::fill(begin + p, end, 0);
      *(begin + p) = 1;
      end = begin + p;
    }

    std::fill(begin, end, 0);
  }





  template <typename T>
  inline void in_place_sparse_to_dense_01(int n, std::vector<T>& x)
  {
    in_place_sparse_to_dense_01(n, x.begin(), x.end());
  }
# 1114 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It1, typename It2, typename It3>
  inline void
  from_dense(It1 begin, It1 end, It2 ind, It3 nz,
             typename std::iterator_traits<It1>::value_type eps = nta::Epsilon)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1120) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "from_dense: Mismatched dense iterators";
    }

    typedef size_t size_type;
    typedef typename std::iterator_traits<It1>::value_type value_type;

    Abs<value_type> abs_f;

    for (It1 it = begin; it != end; ++it) {
      value_type val = *it;
      if (abs_f(val) > eps) {
        *ind = (size_type) (it - begin);
        *nz = val;
        ++ind; ++nz;
      }
    }
  }


  template <typename It, typename T>
  inline void from_dense(It begin, It end, Buffer<T>& buffer)
  {
    if ((size_t)(end - begin) <= buffer.size()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1143) << "ASSERTION FAILED: \"" << "(size_t)(end - begin) <= buffer.size()" << "\" ";

    typename Buffer<T>::iterator it2 = buffer.begin();

    for (It it = begin; it != end; ++it)
      if (*it != 0) {
        *it2++ = (T)(it - begin);
      }

    buffer.nnz = it2 - buffer.begin();
  }
# 1166 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename T>
  inline void remove(const T& del, std::vector<T>& v)
  {
    v.erase(std::remove(v.begin(), v.end(), del), v.end());
  }


  template <typename T>
  inline void remove(const std::vector<T>& del, std::vector<T>& b)
  {
    for (size_t i = 0; i != del.size(); ++i)
      remove(del[i], b);
  }


  template <typename T1, typename T2>
  inline void remove_for_pairs(const T1& key, std::vector<std::pair<T1,T2> >& v)
  {
    typename std::vector<std::pair<T1,T2> >::const_iterator it;
    for (it = v.begin(); it != v.end() && it->first != key; ++it);
    remove(*it, v);
  }


  template <typename T>
  inline void remove_from_end(const T& elt, std::vector<T>& a)
  {
    for (int i = a.size() - 1; i >= 0; --i) {
      if (a[i] == elt) {
        for (size_t j = i; j < a.size() - 1; ++j)
          a[j] = a[j+1];
        a.resize(a.size() - 1);
        return;
      }
    }
  }
# 1211 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename I, typename T1, typename T2>
  inline void
  remove_for_pairs(const std::vector<I>& del, std::vector<std::pair<T1, T2> >& a)
  {
    if (std::set<I>(del.begin(),del.end()).size() == del.size()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1215) << "ASSERTION FAILED: \"" << "std::set<I>(del.begin(),del.end()).size() == del.size()" << "\" ";

    if (del.empty())
      return;

    size_t old = del[0] + 1, cur = del[0], d = 1;

    while (old < a.size() && d < del.size()) {
      if (old == (size_t) del[d]) {
        ++d; ++old;
      } else if ((size_t) del[d] < old) {
        ++d;
      } else {
        a[cur++] = a[old++];
      }
    }

    while (old < a.size())
      a[cur++] = a[old++];

    a.resize(a.size() - del.size());
  }







  template <typename I, typename T>
  inline void
  remove_at(const std::vector<I>& del, std::vector<T>& a)
  {
    if (std::set<I>(del.begin(),del.end()).size() == del.size()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1248) << "ASSERTION FAILED: \"" << "std::set<I>(del.begin(),del.end()).size() == del.size()" << "\" ";

    if (del.empty())
      return;

    size_t old = del[0] + 1, cur = del[0], d = 1;

    while (old < a.size() && d < del.size()) {
      if (old == (size_t) del[d]) {
        ++d; ++old;
      } else if ((size_t) del[d] < old) {
        ++d;
      } else {
        a[cur++] = a[old++];
      }
    }

    while (old < a.size())
      a[cur++] = a[old++];

    a.resize(a.size() - del.size());
  }





  template <typename T1, typename T2>
  inline void remove(const T2& elt, std::vector<T1>& a, const std::vector<T2>& ref)
  {
    a.erase(a.begin() + find_index(elt, ref));
  }


  template <typename T>
  inline void remove(const std::vector<T>& del, std::set<T>& a)
  {
    for (size_t i = 0; i != del.size(); ++i)
      a.erase(del[i]);
  }


  template <typename T>
  inline void remove(const std::set<T>& y, std::vector<T>& x)
  {
    std::vector<T> del;

    for (size_t i = 0; i != x.size(); ++i)
      if (y.find(x[i]) != y.end()) {
        if (not_in(x[i], del)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1297) << "ASSERTION FAILED: \"" << "not_in(x[i], del)" << "\" ";
        del.push_back(x[i]);
      }

    nta::remove(del, x);
  }


  template <typename T>
  inline std::set<T>& operator-=(std::set<T>& a, const std::vector<T>& b)
  {
    remove(b, a);
    return a;
  }


  template <typename T>
  inline std::vector<T>& operator-=(std::vector<T>& a, const std::vector<T>& b)
  {
    remove(b, a);
    return a;
  }
# 1327 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename T>
  inline void
  find_all_differences(const std::vector<T>& x, const std::vector<T>& y,
                       std::vector<size_t>& diffs)
  {
    if (x.size() == y.size()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1332) << "ASSERTION FAILED: \"" << "x.size() == y.size()" << "\" ";
    diffs.clear();
    for (size_t i = 0; i != x.size(); ++i)
      if (x[i] != y[i])
        diffs.push_back(i);
  }
# 1348 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename T>
  inline void fill(T& a, const typename T::value_type& val)
  {
    typename T::iterator i = a.begin(), e = a.end();

    for (; i != e; ++i)
      *i = val;
  }
# 1364 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It>
  inline void zero(It begin, It end)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1368) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "zero: Invalid input range";
    }

    typedef typename std::iterator_traits<It>::value_type T;

    for (; begin != end; ++begin)
      *begin = T(0);
  }







  template <typename T>
  inline void zero(T& a)
  {
    zero(a.begin(), a.end());
  }


  template <typename T>
  inline void set_to_zero(T& a)
  {
    zero(a);
  }


  template <typename T>
  inline void set_to_zero(std::vector<T>& a, size_t begin, size_t end)
  {
    zero(a.begin() + begin, a.begin() + end);
  }
# 1411 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It>
  inline void ones(It begin, It end)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1415) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "ones: Invalid input range";
    }

    typedef typename std::iterator_traits<It>::value_type T;

    for (; begin != end; ++begin)
      *begin = T(1);
  }







  template <typename T>
  inline void ones(T& a)
  {
    ones(a.begin(), a.end());
  }


  template <typename T>
  inline void set_to_one(std::vector<T>& a)
  {
    ones(a);
  }


  template <typename T>
  inline void set_to_one(std::vector<T>& a, size_t begin, size_t end)
  {
    ones(a.begin() + begin, a.begin() + end);
  }
# 1460 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It>
  inline void dirac(size_t pos, It begin, It end,
                    typename std::iterator_traits<It>::value_type val =1)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1465) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "dirac: Invalid input range";

      if (0 <= pos && pos < (size_t)(end - begin)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1468) << "ASSERTION FAILED: \"" << "0 <= pos && pos < (size_t)(end - begin)" << "\" "
        << "dirac: Invalid position: " << pos
        << " - Should be between 0 and: " << (size_t)(end - begin);
    }

    typedef typename std::iterator_traits<It>::value_type value_type;

    std::fill(begin, end, (value_type) 0);
    *(begin + pos) = val;
  }
# 1487 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename C>
  inline void dirac(size_t pos, C& c, typename C::value_type val =1)
  {
    {
      if (pos >= 0 && pos < c.size()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1491) << "ASSERTION FAILED: \"" << "pos >= 0 && pos < c.size()" << "\" "
        << "dirac: Can't set Dirac at pos: " << pos
        << " when container has size: " << c.size();
    }

    dirac(pos, c.begin(), c.end(), val);
  }
# 1507 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It1, typename It2>
  inline void cumulative(It1 begin1, It1 end1, It2 begin2, It2 end2)
  {
    {
      if (begin1 <= end1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1511) << "ASSERTION FAILED: \"" << "begin1 <= end1" << "\" "
        << "cumulative: Invalid input range";
      if (begin2 <= end2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1513) << "ASSERTION FAILED: \"" << "begin2 <= end2" << "\" "
        << "cumulative: Invalid output range";
      if (end1 - begin1 == end2 - begin2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1515) << "ASSERTION FAILED: \"" << "end1 - begin1 == end2 - begin2" << "\" "
        << "cumulative: Incompatible sizes";
    }

    typedef typename std::iterator_traits<It2>::value_type value_type;

    It2 prev = begin2;
    *begin2++ = (value_type) *begin1++;
    for (; begin1 < end1; ++begin1, ++begin2, ++prev)
      *begin2 = *prev + (value_type) *begin1;
  }
# 1534 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename C1, typename C2>
  inline void cumulative(const C1& pmf, C2& cdf)
  {
    cumulative(pmf.begin(), pmf.end(), cdf.begin(), cdf.end());
  }





  template <typename It1, typename It2>
  inline void percentiles(size_t n_percentiles,
                          It1 begin1, It1 end1,
                          It2 begin2, It2 end2,
                          bool alreadyNormalized =false)
  {
    {
      if (begin1 <= end1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1551) << "ASSERTION FAILED: \"" << "begin1 <= end1" << "\" "
        << "percentiles: Invalid input range";
      if (begin2 <= end2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1553) << "ASSERTION FAILED: \"" << "begin2 <= end2" << "\" "
        << "percentiles: Invalid output range";
      if (end1 - begin1 == end2 - begin2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1555) << "ASSERTION FAILED: \"" << "end1 - begin1 == end2 - begin2" << "\" "
        << "percentiles: Mismatched ranges";
    }

    typedef typename std::iterator_traits<It1>::value_type value_type;
    typedef typename std::iterator_traits<It2>::value_type size_type;

    value_type n = (value_type) (alreadyNormalized ? 1.0f : 0.0f);

    if (!alreadyNormalized)
      for (It1 it = begin1; it != end1; ++it)
        n += *it;

    value_type increment = n/value_type(n_percentiles);
    value_type sum = (value_type) 0.0f;
    size_type p = (size_type) 0;

    for (value_type v = increment; v < n; v += increment) {
      for (; sum < v; ++p)
        sum += *begin1++;
      *begin2++ = p;
    }
  }


  template <typename C1, typename C2>
  inline void percentiles(size_t n_percentiles, const C1& pmf, C2& pcts)
  {
    percentiles(n_percentiles, pmf.begin(), pmf.end(), pcts.begin());
  }


  template <typename It, typename RNG>
  inline void rand_range(It begin, It end,
                         const typename std::iterator_traits<It>::value_type& min_,
                         const typename std::iterator_traits<It>::value_type& max_,
                         RNG& rng)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1594) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "rand_range: Invalid input range";
      if (min_ < max_) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1596) << "ASSERTION FAILED: \"" << "min_ < max_" << "\" "
        << "rand_range: Invalid min/max: " << min_ << " " << max_;
    }

    typedef typename std::iterator_traits<It>::value_type value_type;

    double range = double(max_ - min_) / double(rng.max() - rng.min());
    for (; begin != end; ++begin)
      *begin = value_type(double(rng()) * range + min_);
  }
# 1616 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It>
  inline void rand_range(It begin, It end,
                         const typename std::iterator_traits<It>::value_type& min_,
                         const typename std::iterator_traits<It>::value_type& max_)
  {
    nta::Random rng;
    rand_range(begin, end, min_, max_, rng);
  }


  template <typename T, typename RNG>
  inline void rand_range(T& a,
                         const typename T::value_type& min,
                         const typename T::value_type& max,
                         RNG& rng)
  {
    rand_range(a.begin(), a.end(), min, max, rng);
  }
# 1643 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename T>
  inline void rand_range(T& a,
                         const typename T::value_type& min,
                         const typename T::value_type& max)
  {
    rand_range(a.begin(), a.end(), min, max);
  }


  template <typename T, typename RNG>
  inline void rand_float_range(std::vector<T>& x, size_t start, size_t end, RNG& rng)
  {
    for (size_t i = start; i != end; ++i)
      x[i] = (float) rng.getReal64();
  }
# 1668 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It>
  inline void normal_range(It begin, It end,
                           const typename std::iterator_traits<It>::value_type& mean,
                           const typename std::iterator_traits<It>::value_type& stddev)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1674) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "normal_range: Invalid input range";
    }

    typedef typename std::iterator_traits<It>::value_type value_type;

  }


  template <typename It, typename RNG>
  inline void rand_range_01(It begin, It end, double pct, RNG& rng)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1687) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "rand_range_01: Invalid input range";
      if (0 <= pct && pct < 1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1689) << "ASSERTION FAILED: \"" << "0 <= pct && pct < 1" << "\" "
        << "rand_range_01: Invalid threshold: " << pct
        << " - Should be between 0 and 1";
    }

    typedef typename std::iterator_traits<It>::value_type value_type;

    for (; begin != end; ++begin)
      *begin = (value_type)(double(rng()) / double(rng.max() - rng.min()) > pct);
  }
# 1708 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It>
  inline void rand_range_01(It begin, It end, double pct =.5)
  {
    nta::Random rng;
    rand_range_01(begin, end, pct, rng);
  }


  template <typename T, typename RNG>
  inline void rand_range_01(T& a, double pct, RNG& rng)
  {
    rand_range_01(a.begin(), a.end(), pct, rng);
  }
# 1729 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename T>
  inline void rand_range_01(T& a, double pct =.5)
  {
    nta::Random rng;
    rand_range_01(a.begin(), a.end(), pct, rng);
  }
# 1745 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It, typename T>
  inline void ramp_range(It begin, It end, T start =0, T step =1)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1749) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "ramp_range: Invalid input range";
    }

    for (; begin != end; ++begin, start += step)
      *begin = start;
  }
# 1765 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename T>
  inline void ramp_range(T& a,
                         typename T::value_type start =0,
                         typename T::value_type step =1)
  {
    ramp_range(a.begin(), a.end(), start);
  }
# 1783 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It1, typename It2, typename RNG>
  inline void rand_enum_range(It1 begin, It1 end, It2 enum_begin, It2 enum_end,
                              bool replace, RNG& rng)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1788) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "rand_enum_range: Invalid input range";

      if (enum_begin <= enum_end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1791) << "ASSERTION FAILED: \"" << "enum_begin <= enum_end" << "\" "
        << "rand_enum_range: Invalid values range";
    }

    typedef typename std::iterator_traits<It1>::value_type value_type;

    size_t n = (size_t)(enum_end - enum_begin);

    if (replace) {

      for (; begin != end; ++begin)
        *begin = (value_type) *(enum_begin + rng() % n);

    } else {

      std::vector<size_t> ind(n);
      ramp_range(ind);

      for (; begin != end; ++begin) {
        size_t p = rng() % ind.size();
        *begin = (value_type) *(enum_begin + p);
        remove(p, ind);
      }
    }
  }
# 1827 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It1, typename It2>
  inline void rand_enum_range(It1 begin, It1 end, It2 enum_begin, It2 enum_end,
                              bool replace =false)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1832) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "rand_enum_range: Invalid input range";
      if (enum_begin <= enum_end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1834) << "ASSERTION FAILED: \"" << "enum_begin <= enum_end" << "\" "
        << "rand_enum_range: Invalid enum range";
    }

    nta::Random rng;
    rand_enum_range(begin, end, enum_begin, enum_end, replace, rng);
  }
# 1850 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename C1, typename C2>
  inline void rand_enum_range(C1& a, const C2& b, bool replace =false)
  {
    rand_enum_range(a.begin(), a.end(), b.begin(), b.end(), replace);
  }


  template <typename C1, typename C2, typename RNG>
  inline void rand_enum_range(C1& a, const C2& b, bool replace, RNG& rng)
  {
    rand_enum_range(a.begin(), a.end(), b.begin(), b.end(), replace, rng);
  }
# 1872 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It, typename RNG>
  inline void
  random_perm_interval(It begin, It end,
                       typename std::iterator_traits<It>::value_type start,
                       typename std::iterator_traits<It>::value_type step,
                       RNG& rng)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1880) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "random_perm_interval 1: Invalid input range";
    }

    ramp_range(begin, end, start, step);
    std::random_shuffle(begin, end, rng);
  }
# 1897 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It>
  inline void
  random_perm_interval(It begin, It end,
                       typename std::iterator_traits<It>::value_type start =0,
                       typename std::iterator_traits<It>::value_type step =1)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1904) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "random_perm_interval 2: Invalid input range";
    }

    nta::Random rng;
    random_perm_interval(begin, end, start, step, rng);
  }
# 1920 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename C>
  inline void random_perm_interval(C& c,
                                   typename C::value_type start =0,
                                   typename C::value_type step =1)
  {
    random_perm_interval(c.begin(), c.end(), start, step);
  }


  template <typename C, typename RNG>
  inline void random_perm_interval(C& c,
                                   typename C::value_type start,
                                   typename C::value_type step,
                                   RNG& rng)
  {
    random_perm_interval(c.begin(), c.end(), start, step, rng);
  }
# 1949 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It1, typename It2, typename RNG>
  inline void random_sample(It1 begin1, It1 end1, It2 begin2, It2 end2, RNG& rng)
  {
    {
      if (begin1 <= end1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1953) << "ASSERTION FAILED: \"" << "begin1 <= end1" << "\" "
        << "random_sample 1: Invalid value range";
      if (begin2 <= end2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1955) << "ASSERTION FAILED: \"" << "begin2 <= end2" << "\" "
        << "random_sample 1: Invalid output range";
    }

    size_t n1 = (size_t) (end1 - begin1);
    std::vector<size_t> perm(n1);
    random_perm_interval(perm, 0, n1, rng);
    for (size_t p = 0; begin2 != end2; ++begin2, ++p)
      *begin2 = *(begin1 + p);
  }
# 1977 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It1, typename It2>
  inline void random_sample(It1 begin1, It1 end1, It2 begin2, It2 end2)
  {
    {
      if (begin1 <= end1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1981) << "ASSERTION FAILED: \"" << "begin1 <= end1" << "\" "
        << "random_sample 2: Invalid value range";
      if (begin2 <= end2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 1983) << "ASSERTION FAILED: \"" << "begin2 <= end2" << "\" "
        << "random_sample 2: Invalid output range";
    }

    nta::Random rng;
    random_sample(begin1, end1, begin2, end2, rng);
  }
# 1999 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename T1, typename T2>
  inline void random_sample(const std::vector<T1>& c1, std::vector<T2>& c2)
  {
    random_sample(c1.begin(), c1.end(), c2.begin(), c2.end());
  }


  template <typename T1, typename T2, typename RNG>
  inline void random_sample(const std::vector<T1>& c1, std::vector<T2>& c2, RNG& rng)
  {
    random_sample(c1.begin(), c1.end(), c2.begin(), c2.end(), rng);
  }
# 2022 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename T, typename RNG>
  inline void random_sample(std::vector<T>& c,
                            size_t size,
                            size_t start,
                            size_t step,
                            RNG& rng)
  {
    ramp_range(c, start, step);
    std::random_shuffle(c.begin(), c.end(), rng);
  }


  template <typename T>
  inline void random_sample(std::vector<T>& c,
                            size_t size,
                            size_t start =0,
                            size_t step =1)
  {
    nta::Random rng;
    random_sample(c, size, start, step, rng);
  }


  template <typename T>
  inline void random_sample(size_t n, std::vector<T>& a)
  {
    if (0 < a.size()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2048) << "ASSERTION FAILED: \"" << "0 < a.size()" << "\" ";

    std::vector<size_t> x(n);
    for (size_t i = 0; i != n; ++i)
      x[i] = i;
    std::random_shuffle(x.begin(), x.end());
    std::copy(x.begin(), x.begin() + a.size(), a.begin());
  }


  template <typename T>
  inline void random_sample(std::vector<T>& a)
  {
    random_sample(a, a.size());
  }


  template <typename T>
  inline void random_sample(const std::set<T>& a, std::vector<T>& b)
  {
    if (0 < b.size()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2068) << "ASSERTION FAILED: \"" << "0 < b.size()" << "\" ";

    std::vector<T> aa(a.begin(), a.end());
    std::random_shuffle(aa.begin(), aa.end());
    std::copy(aa.begin(), aa.begin() + b.size(), b.begin());
  }


  template <typename T>
  inline void random_binary(float proba, std::vector<T>& x)
  {
    size_t threshold = (size_t) (proba * 65535);
    std::fill(x.begin(), x.end(), 0);
    for (size_t i = 0; i != x.size(); ++i)
      x[i] = ((size_t) rand() % 65535 < threshold) ? 1 : 0;
  }
# 2092 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename T1, typename T2>
  inline void
  random_pair_sample(size_t nrows, size_t ncols, size_t nnzpr,
                     std::vector<std::pair<T1, T2> >& a,
                     const T2& init_nz_val,
                     int seed =-1,
                     bool sorted =true)
  {
    {
      if (0 < a.size()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2101) << "ASSERTION FAILED: \"" << "0 < a.size()" << "\" ";
      if (nnzpr <= ncols) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2102) << "ASSERTION FAILED: \"" << "nnzpr <= ncols" << "\" ";
    }

    a.resize(nrows * nnzpr);




    nta::Random rng(seed == -1 ? rand() : seed);


    std::vector<size_t> x(ncols);
    for (size_t i = 0; i != ncols; ++i)
      x[i] = i;
    for (size_t i = 0; i != nrows; ++i) {
      std::random_shuffle(x.begin(), x.end(), rng);
      if (sorted)
        std::sort(x.begin(), x.begin() + nnzpr);
      size_t offset = i*nnzpr;
      for (size_t j = 0; j != nnzpr; ++j)
        a[offset + j] = std::make_pair<T1,T2>(x[j], init_nz_val);
    }
  }
# 2143 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename T1, typename T2>
  inline void
  gaussian_2d_pair_sample(size_t nrows, size_t ncols, size_t nnzpr, size_t rf_x,
                          T2 sigma,
                          std::vector<std::pair<T1, T2> >& a,
                          const T2& init_nz_val,
                          int seed =-1,
                          bool sorted =true)
  {
    {
      if (ncols % rf_x == 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2153) << "ASSERTION FAILED: \"" << "ncols % rf_x == 0" << "\" ";
      if (nnzpr <= ncols) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2154) << "ASSERTION FAILED: \"" << "nnzpr <= ncols" << "\" ";
      if (0 < sigma) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2155) << "ASSERTION FAILED: \"" << "0 < sigma" << "\" ";
    }

    a.resize(nrows * nnzpr);




    nta::Random rng(seed == -1 ? rand() : seed);


    size_t rf_y = ncols / rf_x;
    T2 c_x = float(rf_x - 1.0) / 2.0, c_y = float(rf_y - 1.0) / 2.0;
    Gaussian2D<float> sg2d(c_x, c_y, sigma*sigma, 0, 0, sigma*sigma);
    std::vector<float> z(ncols);



    float s = 0;
    for (size_t j = 0; j != ncols; ++j)
      s += z[j] = sg2d(j / rf_y, j % rf_y);

    for (size_t j = 0; j != ncols; ++j)
      z[j] /= s;






    for (size_t i = 0; i != nrows; ++i) {

      std::set<size_t> b;

      while (b.size() < nnzpr) {
        T2 s = z[0], p = T2(rng.getReal64());
        size_t k = 0;
        while (s < p && k < ncols-1)
          s += z[++k];

        b.insert(k);
      }

      size_t offset = i*nnzpr;
      std::set<size_t>::const_iterator it = b.begin();
      for (size_t j = 0; j != nnzpr; ++j, ++it)
        a[offset + j] = std::make_pair<T1,T2>(*it, init_nz_val);
    }






  }


  template <typename T>
  inline void random_shuffle(std::vector<T>& x)
  {
    std::random_shuffle(x.begin(), x.end());
  }
# 2227 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename Container, typename Generator>
  inline void generate(Container& c, Generator gen)
  {
    typename Container::iterator i = c.begin(), e = c.end();

    for (; i != e; ++i)
      *i = gen();
  }
# 2249 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename InIt1, typename InIt2, typename OutIt>
  inline void
  concatenate(InIt1 x_begin, InIt2 seg_begin, InIt2 seg_end, OutIt y_begin)
  {
    {
      if (seg_begin <= seg_end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2254) << "ASSERTION FAILED: \"" << "seg_begin <= seg_end" << "\" "
        << "concatenate: Invalid segment range";
    }

    for (; seg_begin != seg_end; ++seg_begin) {
      InIt1 begin = x_begin + seg_begin->first;
      InIt1 end = begin + seg_begin->second;
      std::copy(begin, end, y_begin);
      y_begin += seg_begin->second;
    }
  }
# 2279 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It>
  inline void clip(It begin, It end,
                   const typename std::iterator_traits<It>::value_type& _min,
                   const typename std::iterator_traits<It>::value_type& _max)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2285) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "clip: Invalid range";
    }

    while (begin != end) {
      typename std::iterator_traits<It>::value_type val = *begin;
      if (val > _max)
        *begin = _max;
      else if (val < _min)
        *begin = _min;
      ++begin;
    }
  }
# 2309 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename T>
  inline void clip(T& a,
                   const typename T::value_type& _min,
                   const typename T::value_type& _max)
  {
    clip(a.begin(), a.end(), _min, _max);
  }
# 2328 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename InIter, typename OutIter1, typename OutIter2>
  inline size_t threshold(InIter begin, InIter end,
                          OutIter1 ind, OutIter2 nz,
                          const typename std::iterator_traits<InIter>::value_type& th,
                          bool above =true)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2335) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "threshold: Invalid range";
    }

    typedef typename std::iterator_traits<InIter>::value_type value_type;
    typedef size_t size_type;

    size_type n = 0;

    if (above) {

      for (InIter it = begin; it != end; ++it) {
        value_type val = (value_type) *it;
        if (val >= th) {
          *ind = (size_type) (it - begin);
          *nz = val;
          ++ind; ++nz; ++n;
        }
      }

    } else {

      for (InIter it = begin; it != end; ++it) {
        value_type val = (value_type) *it;
        if (val < th) {
          *ind = (size_type) (it - begin);
          *nz = val;
          ++ind; ++nz; ++n;
        }
      }
    }

    return n;
  }







  template <typename InputIterator, typename OutputIterator>
  inline nta::UInt32
  binarize_with_threshold(nta::Real32 threshold,
                          InputIterator x, InputIterator x_end,
                          OutputIterator y, OutputIterator y_end)
  {
    {
      if (x_end - x == y_end - y) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2383) << "ASSERTION FAILED: \"" << "x_end - x == y_end - y" << "\" ";
    }

    nta::UInt32 count = 0;

    for (; x != x_end; ++x, ++y)
      if (*x > threshold) {
        *y = 1;
        ++count;
      } else
        *y = 0;

    return count;
  }
# 2409 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename InputIterator, typename OutputIterator>
  inline void
  nonZeroRowsIndicator_01(nta::UInt32 nrows, nta::UInt32 ncols,
                          InputIterator x, InputIterator x_end,
                          OutputIterator y, OutputIterator y_end)
  {
    {
      if (0 < nrows) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2416) << "ASSERTION FAILED: \"" << "0 < nrows" << "\" ";
      if (0 < ncols) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2417) << "ASSERTION FAILED: \"" << "0 < ncols" << "\" ";
      if ((nta::UInt32)(x_end - x) == nrows * ncols) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2418) << "ASSERTION FAILED: \"" << "(nta::UInt32)(x_end - x) == nrows * ncols" << "\" ";
      if ((nta::UInt32)(y_end - y) == nrows) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2419) << "ASSERTION FAILED: \"" << "(nta::UInt32)(y_end - y) == nrows" << "\" ";




    }

    for (nta::UInt32 r = 0; r != nrows; ++r, ++y) {

      InputIterator it = x + r * ncols, it_end = it + ncols;
      nta::UInt32 found = 0;

      while (it != it_end && found == 0)
        found = nta::UInt32(*it++);

      *y = found;
    }
  }







  template <typename InputIterator>
  inline nta::UInt32
  nNonZeroRows_01(nta::UInt32 nrows, nta::UInt32 ncols,
                  InputIterator x, InputIterator x_end)
  {
    {
      if (0 < nrows) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2450) << "ASSERTION FAILED: \"" << "0 < nrows" << "\" ";
      if (0 < ncols) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2451) << "ASSERTION FAILED: \"" << "0 < ncols" << "\" ";
      if ((nta::UInt32)(x_end - x) == nrows * ncols) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2452) << "ASSERTION FAILED: \"" << "(nta::UInt32)(x_end - x) == nrows * ncols" << "\" ";




    }

    nta::UInt32 count = 0;

    for (nta::UInt32 r = 0; r != nrows; ++r) {

      InputIterator it = x + r * ncols, it_end = it + ncols;
      nta::UInt32 found = 0;

      while (it != it_end && found == 0)
        found = nta::UInt32(*it++);

      count += found;
    }

    return count;
  }
# 2482 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename InputIterator, typename OutputIterator>
  inline void
  nonZeroColsIndicator_01(nta::UInt32 nrows, nta::UInt32 ncols,
                          InputIterator x, InputIterator x_end,
                          OutputIterator y, OutputIterator y_end)
  {
    {
      if (0 < nrows) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2489) << "ASSERTION FAILED: \"" << "0 < nrows" << "\" ";
      if (0 < ncols) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2490) << "ASSERTION FAILED: \"" << "0 < ncols" << "\" ";
      if ((nta::UInt32)(x_end - x) == nrows * ncols) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2491) << "ASSERTION FAILED: \"" << "(nta::UInt32)(x_end - x) == nrows * ncols" << "\" ";
      if ((nta::UInt32)(y_end - y) == ncols) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2492) << "ASSERTION FAILED: \"" << "(nta::UInt32)(y_end - y) == ncols" << "\" ";




    }

    nta::UInt32 N = nrows*ncols;

    for (nta::UInt32 c = 0; c != ncols; ++c, ++y) {

      InputIterator it = x + c, it_end = it + N;
      nta::UInt32 found = 0;

      while (it != it_end && found == 0) {
        found = nta::UInt32(*it);
        it += ncols;
      }

      *y = found;
    }
  }
# 2522 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename InputIterator>
  inline nta::UInt32
  nNonZeroCols_01(nta::UInt32 nrows, nta::UInt32 ncols,
                  InputIterator x, InputIterator x_end)
  {
    {
      if (0 < nrows) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2528) << "ASSERTION FAILED: \"" << "0 < nrows" << "\" ";
      if (0 < ncols) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2529) << "ASSERTION FAILED: \"" << "0 < ncols" << "\" ";
      if ((nta::UInt32)(x_end - x) == nrows * ncols) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2530) << "ASSERTION FAILED: \"" << "(nta::UInt32)(x_end - x) == nrows * ncols" << "\" ";




    }

    nta::UInt32 count = 0;
    nta::UInt32 N = nrows*ncols;

    for (nta::UInt32 c = 0; c != ncols; ++c) {

      InputIterator it = x + c, it_end = it + N;
      nta::UInt32 found = 0;

      while (it != it_end && found == 0) {
        found = nta::UInt32(*it);
        it += ncols;
      }

      count += found;
    }

    return count;
  }







  template <typename InIter>
  inline void mask(InIter begin, InIter end, InIter zone_begin, InIter zone_end,
                   const typename std::iterator_traits<InIter>::value_type& v =0,
                   bool maskOutside =true)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2568) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "mask 1: Invalid range for vector";
      if (zone_begin <= zone_end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2570) << "ASSERTION FAILED: \"" << "zone_begin <= zone_end" << "\" "
        << "mask 1: Invalid range for mask";
      if (begin <= zone_begin && zone_end <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2572) << "ASSERTION FAILED: \"" << "begin <= zone_begin && zone_end <= end" << "\" "
        << "mask 1: Mask incompatible with vector";
    }

    typedef typename std::iterator_traits<InIter>::value_type value_type;

    if (maskOutside) {
      std::fill(begin, zone_begin, v);
      std::fill(zone_end, end, v);
    } else {
      std::fill(zone_begin, zone_end, v);
    }
  }


  template <typename value_type>
  inline void mask(std::vector<value_type>& x,
                   typename std::vector<value_type>::size_type zone_begin,
                   typename std::vector<value_type>::size_type zone_end,
                   const value_type& v =0,
                   bool maskOutside =true)
  {
    {
      if (0 <= zone_begin && zone_begin <= zone_end && zone_end <= x.size()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2595) << "ASSERTION FAILED: \"" << "0 <= zone_begin && zone_begin <= zone_end && zone_end <= x.size()" << "\" "
        << "mask 2: Mask incompatible with vector";
    }

    mask(x.begin(), x.end(), x.begin() + zone_begin, x.begin() + zone_end,
         v, maskOutside);
  }


  template <typename value_type1, typename value_type2>
  inline void mask(std::vector<value_type1>& x, const std::vector<value_type2>& mask,
                   bool multiplyYesNo =false, value_type2 eps =(value_type2)nta::Epsilon)
  {
    {
      if (x.size() == mask.size()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2609) << "ASSERTION FAILED: \"" << "x.size() == mask.size()" << "\" "
        << "mask 3: Need mask and vector to have same size";
    }

    typedef typename std::vector<value_type1>::size_type size_type;

    if (multiplyYesNo) {
      for (size_type i = 0; i != x.size(); ++i)
        if (!nearlyZero(mask[i]), eps)
          x[i] *= (value_type1) mask[i];
        else
          x[i] = (value_type1) 0;

    } else {
      for (size_type i = 0; i != x.size(); ++i)
        if (nearlyZero(mask[i], eps))
          x[i] = (value_type1) 0;
    }
  }
# 2636 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename T>
  struct Lp0
  {
    typedef T value_type;

    inline value_type operator()(value_type& a, value_type b) const
    {
      value_type inc = value_type(b < -nta::Epsilon || b > nta::Epsilon);
      a += inc;
      return inc;
    }

    inline value_type root(value_type x) const { return x; }
  };






  template <typename T>
  struct Lp1
  {
    typedef T value_type;

    inline value_type operator()(value_type& a, value_type b) const
    {
      value_type inc = fabs(b);
      a += inc;
      return inc;
    }

    inline value_type root(value_type x) const { return x; }
  };






  template <typename T>
  struct Lp2
  {
    typedef T value_type;

    nta::Sqrt<value_type> s;

    inline value_type operator()(value_type& a, value_type b) const
    {
      value_type inc = b * b;
      a += inc;
      return inc;
    }

    inline value_type root(value_type x) const
    {
      return s(x);
    }
  };






  template <typename T>
  struct Lp
  {
    typedef T value_type;

    nta::Pow<value_type> pf;

    Lp(value_type p_)
      : p(p_), inv_p((value_type)1.0)
    {



      if (p_ > (value_type)0.0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2714) << "ASSERTION FAILED: \"" << "p_ > (value_type)0.0" << "\" "
        << "NearestNeighbor::PP(): "
        << "Invalid value for p: " << p_
        << " - p needs to be > 0";

      inv_p = (value_type)1.0/p;
    }

    value_type p, inv_p;

    inline value_type operator()(value_type& a, value_type b) const
    {
      value_type inc = pf(b > 0.0 ? b : -b, p);
      a += inc;
      return inc;
    }

    inline value_type root(value_type x) const
    {


      return pf(x, inv_p);
    }
  };






  template <typename T>
  struct LpMax
  {
    typedef T value_type;

    nta::Max<value_type> m;

    inline value_type operator()(value_type& a, value_type b) const
    {
      value_type inc = m(a, b > 0 ? b : -b);
      a = inc;
      return inc;
    }

    inline value_type root(value_type x) const { return x; }
  };





  template <typename It>
  inline typename std::iterator_traits<It>::value_type
  l0_norm(It begin, It end, bool =true)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2770) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "l0_norm: Invalid range";
    }

    typedef typename std::iterator_traits<It>::value_type value_type;

    value_type n = (value_type) 0;
    Lp0<value_type> lp0;

    for (; begin != end; ++begin)
      lp0(n, *begin);

    return n;
  }





  template <typename T>
  inline typename T::value_type l0_norm(const T& a, bool =true)
  {
    return l0_norm(a.begin(), a.end());
  }





  template <typename It>
  inline typename std::iterator_traits<It>::value_type
  l1_norm(It begin, It end, bool =true)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2804) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "l1_norm: Invalid range";
    }

    typedef typename std::iterator_traits<It>::value_type value_type;

    value_type n = (value_type) 0;
    Lp1<value_type> lp1;

    for (; begin != end; ++begin)
      lp1(n, *begin);

    return n;
  }





  template <typename T>
  inline typename T::value_type l1_norm(const T& a, bool =true)
  {
    return l1_norm(a.begin(), a.end());
  }
# 2849 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It>
  inline typename std::iterator_traits<It>::value_type
  l2_norm(It begin, It end, bool take_root =true)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2854) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "l2_norm: Invalid range";
    }

    typedef typename std::iterator_traits<It>::value_type value_type;
    value_type n = (value_type) 0;

    Lp2<value_type> lp2;
# 2871 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
    for (; begin != end; ++begin)
      lp2(n, *begin);



    if (take_root)
      n = lp2.root(n);

    return n;
  }





  template <typename T>
  inline typename T::value_type l2_norm(const T& a, bool take_root =true)
  {
    return l2_norm(a.begin(), a.end(), take_root);
  }





  template <typename It>
  inline typename std::iterator_traits<It>::value_type
  lp_norm(typename std::iterator_traits<It>::value_type p,
          It begin, It end, bool take_root =true)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2902) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "lp_norm: Invalid range";
    }

    typedef typename std::iterator_traits<It>::value_type value_type;

    value_type n = (value_type) 0;
    Lp<value_type> lp(p);

    for (; begin != end; ++begin)
      lp(n, *begin);

    if (take_root)
      n = lp.root(n);

    return n;
  }





  template <typename T>
  inline typename T::value_type
  lp_norm(typename T::value_type p, const T& a, bool take_root =true)
  {
    return lp_norm(p, a.begin(), a.end(), take_root);
  }





  template <typename It>
  inline typename std::iterator_traits<It>::value_type
  lmax_norm(It begin, It end, bool =true)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2940) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "lmax_norm: Invalid range";
    }

    typedef typename std::iterator_traits<It>::value_type value_type;

    value_type n = (value_type) 0;
    LpMax<value_type> lmax;

    for (; begin != end; ++begin)
      lmax(n, *begin);

    return n;
  }





  template <typename T>
  inline typename T::value_type lmax_norm(const T& a, bool =true)
  {
    return lmax_norm(a.begin(), a.end());
  }
# 2974 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It>
  inline typename std::iterator_traits<It>::value_type
  norm(typename std::iterator_traits<It>::value_type p,
       It begin, It end, bool take_root =true)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 2980) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "norm: Invalid range";
    }

    typedef typename std::iterator_traits<It>::value_type value_type;

    if (p == (value_type) 0)
      return l0_norm(begin, end);
    else if (p == (value_type) 1)
      return l1_norm(begin, end);
    else if (p == (value_type) 2)
      return l2_norm(begin, end, take_root);
    else if (p == std::numeric_limits<value_type>::max())
      return lmax_norm(begin, end);
    else
      return lp_norm(p, begin, end, take_root);
  }




  template <typename It>
  inline void
  multiply_val(It begin, It end,
               const typename std::iterator_traits<It>::value_type& val)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3007) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "multiply_val: Invalid range";
    }

    if (val == 1.0f)
      return;

    for (; begin != end; ++begin)
      *begin *= val;
  }




  template <typename T>
  inline void multiply_val(T& x, const typename T::value_type& val)
  {
    multiply_val(x.begin(), x.end(), val);
  }





  template <typename T>
  inline typename T::value_type
  norm(typename T::value_type p, const T& a, bool take_root =true)
  {
    return norm(p, a.begin(), a.end(), take_root);
  }
# 3047 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It>
  inline void
  normalize(It begin, It end,
            const typename std::iterator_traits<It>::value_type& p =1.0,
            const typename std::iterator_traits<It>::value_type& n =1.0)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3054) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "normalize: Invalid input range";
    }

    typedef typename std::iterator_traits<It>::value_type value_type;

    value_type s = (value_type) 0;

    if (p == (value_type) 0)
      s = l0_norm(begin, end);
    else if (p == (value_type) 1)
      s = l1_norm(begin, end);
    else if (p == (value_type) 2)
      s = l2_norm(begin, end);
    else if (p == std::numeric_limits<value_type>::max())
      s = lmax_norm(begin, end);

    if (s != (value_type) 0)
      multiply_val(begin, end, n/s);
  }





  template <typename T>
  inline void normalize(T& a,
                        const typename T::value_type& p =1.0,
                        const typename T::value_type& n =1.0)
  {
    normalize(a.begin(), a.end(), p, n);
  }







  template <typename It>
  inline void
  normalize_max(It begin, It end,
                const typename std::iterator_traits<It>::value_type& n = 1.0)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3099) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "normalize_max: Invalid range";
    }

    typedef typename std::iterator_traits<It>::value_type value_type;

    normalize(begin, end, std::numeric_limits<value_type>::max(), n);
  }





  template <typename value_type>
  inline void normalize_max(std::vector<value_type>& x, const value_type& n = 1.0)
  {
    normalize_max(x.begin(), x.end(), n);
  }





  template <typename T>
  inline void generate_range(T& t,
                             typename T::value_type start,
                             typename T::value_type end,
                             typename T::value_type increment =1)
  {
    std::insert_iterator<T> it(t, t.begin());

    for (typename T::value_type i = start; i < end; i += increment, ++it)
      *it = i;
  }
# 3142 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It>
  inline void
  uniform_range(It begin, It end,
                typename std::iterator_traits<It>::value_type val =1)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3148) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "uniform_range: Invalid input range";
    }

    typedef typename std::iterator_traits<It>::value_type value_type;

    std::fill(begin, end, (value_type) 1);
    normalize(begin, end, val);
  }
# 3165 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename C>
  inline void uniform_range(C& a, typename C::value_type val =1)
  {
    uniform_range(a.begin(), a.end(), val);
  }
# 3181 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It1, typename It2>
  inline typename std::iterator_traits<It1>::value_type
  max_abs_diff(It1 begin1, It1 end1, It2 begin2, It2 end2)
  {
    {
      if (begin1 <= end1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3186) << "ASSERTION FAILED: \"" << "begin1 <= end1" << "\" "
        << "max_abs_diff: Invalid range 1";
      if (begin2 <= end2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3188) << "ASSERTION FAILED: \"" << "begin2 <= end2" << "\" "
        << "max_abs_diff: Invalid range 2";
      if (end1 - begin1 == end2 - begin2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3190) << "ASSERTION FAILED: \"" << "end1 - begin1 == end2 - begin2" << "\" "
        << "max_abs_diff: Ranges of different sizes";
    }

    typename std::iterator_traits<It1>::value_type d(0), val(0);

    while (begin1 != end1) {
      val = *begin1 - *begin2;
      val = val > 0 ? val : -val;
      if (val > d)
        d = val;
      ++begin1; ++begin2;
    }

    return d;
  }
# 3214 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename T1, typename T2>
  inline typename T1::value_type max_abs_diff(const T1& a, const T2& b)
  {
    return max_abs_diff(a.begin(), a.end(), b.begin(), b.end());
  }
# 3228 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It1, typename It2>
  inline typename std::iterator_traits<It1>::value_type
  hamming_distance(It1 begin1, It1 end1, It2 begin2, It2 end2)
  {
    {
      if (begin1 <= end1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3233) << "ASSERTION FAILED: \"" << "begin1 <= end1" << "\" "
        << "hamming_distance: Invalid range 1";
      if (begin2 <= end2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3235) << "ASSERTION FAILED: \"" << "begin2 <= end2" << "\" "
        << "hamming_distance: Invalid range 2";
      if (end1 - begin1 == end2 - begin2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3237) << "ASSERTION FAILED: \"" << "end1 - begin1 == end2 - begin2" << "\" "
        << "hamming_distance: Ranges of different sizes";
    }

    typename std::iterator_traits<It1>::value_type d(0);

    while (begin1 != end1) {
      d += *begin1 != *begin2;
      ++begin1; ++begin2;
    }

    return d;
  }
# 3258 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename T1, typename T2>
  inline typename T1::value_type
  hamming_distance(const T1& a, const T2& b)
  {
    return hamming_distance(a.begin(), a.end(), b.begin(), b.end());
  }





  template <typename It1, typename It2>
  inline size_t
  sparse_hamming_distance(It1 begin1, It1 end1, It2 begin2, It2 end2)
  {
    {


      if (begin1 <= end1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3276) << "ASSERTION FAILED: \"" << "begin1 <= end1" << "\" "
        << "sparse_hamming_distance: Invalid range 1";
      if (begin2 <= end2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3278) << "ASSERTION FAILED: \"" << "begin2 <= end2" << "\" "
        << "sparse_hamming_distance: Invalid range 2";
    }

    typedef size_t size_type;

    size_type d = 0;

    while (begin1 != end1 && begin2 != end2) {
      if (*begin1 < *begin2) {
        ++d;
        ++begin1;
      } else if (*begin2 < *begin1) {
        ++d;
        ++begin2;
      } else {
        ++begin1;
        ++begin2;
      }
    }

    d += (size_type)(end1 - begin1);
    d += (size_type)(end2 - begin2);

    return d;
  }


  template <typename T1, typename T2>
  inline typename T1::size_type
  sparse_hamming_distance(const T1& a, const T2& b)
  {
    return sparse_hamming_distance(a.begin(), a.end(), b.begin(), b.end());
  }
# 3321 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It1, typename It2>
  inline typename std::iterator_traits<It1>::value_type
  manhattan_distance(It1 begin1, It1 end1, It2 begin2, It2 end2)
  {
    {
      if (begin1 <= end1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3326) << "ASSERTION FAILED: \"" << "begin1 <= end1" << "\" "
        << "manhattan_distance: Invalid range 1";
      if (begin2 <= end2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3328) << "ASSERTION FAILED: \"" << "begin2 <= end2" << "\" "
        << "manhattan_distance: Invalid range 2";
      if (end1 - begin1 == end2 - begin2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3330) << "ASSERTION FAILED: \"" << "end1 - begin1 == end2 - begin2" << "\" "
        << "manhattan_distance: Ranges of different sizes";
    }

    typedef typename std::iterator_traits<It1>::value_type value_type;

    value_type d = (value_type) 0;
    Lp1<value_type> lp1;

    for (; begin1 != end1; ++begin1, ++begin2)
      lp1(d, *begin1 - *begin2);

    return d;
  }
# 3352 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename T1, typename T2>
  inline typename T1::value_type
  manhattan_distance(const T1& a, const T2& b)
  {
    return manhattan_distance(a.begin(), a.end(), b.begin(), b.end());
  }
# 3367 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It1, typename It2>
  inline typename std::iterator_traits<It1>::value_type
  euclidean_distance(It1 begin1, It1 end1, It2 begin2, It2 end2, bool take_root =true)
  {
    {
      if (begin1 <= end1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3372) << "ASSERTION FAILED: \"" << "begin1 <= end1" << "\" "
        << "euclidean_distance: Invalid range 1";
      if (begin2 <= end2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3374) << "ASSERTION FAILED: \"" << "begin2 <= end2" << "\" "
        << "euclidean_distance: Invalid range 2";
      if (end1 - begin1 == end2 - begin2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3376) << "ASSERTION FAILED: \"" << "end1 - begin1 == end2 - begin2" << "\" "
        << "euclidean_distance: Ranges of different sizes";
    }

    typedef typename std::iterator_traits<It1>::value_type value_type;

    value_type d = (value_type) 0;
    Lp2<value_type> lp2;

    for (; begin1 != end1; ++begin1, ++begin2)
      lp2(d, *begin1 - *begin2);

    if (take_root)
      d = lp2.root(d);

    return d;
  }
# 3401 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename T1, typename T2>
  inline typename T1::value_type
  euclidean_distance(const T1& a, const T2& b, bool take_root =true)
  {
    return euclidean_distance(a.begin(), a.end(), b.begin(), b.end(), take_root);
  }
# 3416 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It1, typename It2>
  inline typename std::iterator_traits<It1>::value_type
  lp_distance(typename std::iterator_traits<It1>::value_type p,
              It1 begin1, It1 end1, It2 begin2, It2 end2, bool take_root =true)
  {
    {
      if (begin1 <= end1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3422) << "ASSERTION FAILED: \"" << "begin1 <= end1" << "\" "
        << "lp_distance: Invalid range 1";
      if (begin2 <= end2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3424) << "ASSERTION FAILED: \"" << "begin2 <= end2" << "\" "
        << "lp_distance: Invalid range 2";
      if (end1 - begin1 == end2 - begin2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3426) << "ASSERTION FAILED: \"" << "end1 - begin1 == end2 - begin2" << "\" "
        << "lp_distance: Ranges of different sizes";
    }

    typedef typename std::iterator_traits<It1>::value_type value_type;

    value_type d = (value_type) 0;
    Lp<value_type> lp(p);

    for (; begin1 != end1; ++begin1, ++begin2)
      lp(d, *begin1 - *begin2);

    if (take_root)
      d = lp.root(d);

    return d;
  }
# 3451 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename T1, typename T2>
  inline typename T1::value_type
  lp_distance(typename T1::value_type p,
              const T1& a, const T2& b, bool take_root =true)
  {
    return lp_distance(p, a.begin(), a.end(), b.begin(), b.end(), take_root);
  }
# 3467 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It1, typename It2>
  inline typename std::iterator_traits<It1>::value_type
  lmax_distance(It1 begin1, It1 end1, It2 begin2, It2 end2, bool =true)
  {
    {
      if (begin1 <= end1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3472) << "ASSERTION FAILED: \"" << "begin1 <= end1" << "\" "
        << "lmax_distance: Invalid range 1";
      if (begin2 <= end2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3474) << "ASSERTION FAILED: \"" << "begin2 <= end2" << "\" "
        << "lmax_distance: Invalid range 2";
      if (end1 - begin1 == end2 - begin2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3476) << "ASSERTION FAILED: \"" << "end1 - begin1 == end2 - begin2" << "\" "
        << "lmax_distance: Ranges of different sizes";
    }

    typedef typename std::iterator_traits<It1>::value_type value_type;

    value_type d = (value_type) 0;
    LpMax<value_type> lmax;

    for (; begin1 != end1; ++begin1, ++begin2)
      lmax(d, *begin1 - *begin2);

    return d;
  }
# 3498 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename T1, typename T2>
  inline typename T1::value_type
  lmax_distance(const T1& a, const T2& b, bool =true)
  {
    return lmax_distance(a.begin(), a.end(), b.begin(), b.end());
  }
# 3513 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It1, typename It2>
  inline typename std::iterator_traits<It1>::value_type
  distance(typename std::iterator_traits<It1>::value_type p,
           It1 begin1, It1 end1, It2 begin2, It2 end2, bool take_root =true)
  {
    {
      if (begin1 <= end1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3519) << "ASSERTION FAILED: \"" << "begin1 <= end1" << "\" "
        << "distance: Invalid range 1";
      if (begin2 <= end2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3521) << "ASSERTION FAILED: \"" << "begin2 <= end2" << "\" "
        << "distance: Invalid range 2";
      if (end1 - begin1 == end2 - begin2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3523) << "ASSERTION FAILED: \"" << "end1 - begin1 == end2 - begin2" << "\" "
        << "distance: Ranges of different sizes";
    }

    typedef typename std::iterator_traits<It1>::value_type value_type;

    if (p == (value_type) 0)
      return hamming_distance(begin1, end1, begin2);
    else if (p == (value_type) 1)
      return manhattan_distance(begin1, end1, begin2);
    else if (p == (value_type) 2)
      return euclidean_distance(begin1, end1, begin2, take_root);
    else if (p == std::numeric_limits<value_type>::max())
      return lmax_distance(begin1, end1, begin2);
    else
      return lp_distance(p, begin1, end1, begin2, take_root);
  }
# 3548 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename T1, typename T2>
  inline typename T1::value_type
  distance(typename T1::value_type p, const T1& a, const T2& b, bool take_root =true)
  {
    return distance(p, a.begin(), a.end(), b.begin(), b.end(), take_root);
  }







  template <typename C, typename Predicate>
  inline size_t count_if(const C& c, Predicate pred)
  {
    return std::count_if(c.begin(), c.end(), pred);
  }





  template <typename It>
  inline size_t
  count_zeros(It begin, It end,
              const typename std::iterator_traits<It>::value_type& eps =nta::Epsilon)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3577) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "count_zeros: Invalid range";
    }

    typedef typename std::iterator_traits<It>::value_type value_type;
    return std::count_if(begin, end, IsNearlyZero<DistanceToZero<value_type> >(eps));
  }





  template <typename C>
  inline size_t count_zeros(const C& c, const typename C::value_type& eps =nta::Epsilon)
  {
    return count_zeros(c.begin, c.end(), eps);
  }





  template <typename It>
  inline size_t
  count_ones(It begin, It end,
             const typename std::iterator_traits<It>::value_type& eps =nta::Epsilon)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3605) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "count_ones: Invalid range";
    }

    typedef typename std::iterator_traits<It>::value_type value_type;
    return std::count_if(begin, end, IsNearlyZero<DistanceToOne<value_type> >(eps));
  }





  template <typename C>
  inline size_t count_ones(const C& c, const typename C::value_type& eps =nta::Epsilon)
  {
    return count_ones(c.begin(), c.end(), eps);
  }
# 3637 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  inline nta::UInt32
  count_gt(nta::Real32* begin, nta::Real32* end, nta::Real32 threshold)
  {
    if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3640) << "ASSERTION FAILED: \"" << "begin <= end" << "\" ";
# 3766 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
    return std::count_if(begin, end, std::bind2nd(std::greater<nta::Real32>(), threshold));

  }
# 3780 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  inline nta::UInt32
  count_gte(nta::Real32* begin, nta::Real32* end, nta::Real32 threshold)
  {
    if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3783) << "ASSERTION FAILED: \"" << "begin <= end" << "\" ";

    return std::count_if(begin, end,
                         std::bind2nd(std::greater_equal<nta::Real32>(),
                         threshold));
  }






  inline size_t count_non_zeros(nta::Real32* begin, nta::Real32* end)
  {
    if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3797) << "ASSERTION FAILED: \"" << "begin <= end" << "\" ";
    return count_gt(begin, end, 0);
  }






  template <typename T>
  inline size_t count_non_zeros(const std::vector<T>& x)
  {
    if (sizeof(T) == 4) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3809) << "ASSERTION FAILED: \"" << "sizeof(T) == 4" << "\" ";
    nta::Real32* begin = (nta::Real32*) &x[0];
    nta::Real32* end = begin + x.size();
    return count_gt(begin, end, 0);
  }






  template <>
  inline size_t count_non_zeros(const std::vector<bool>& x)
  {
    size_t count = 0;
    for (size_t i = 0; i != x.size(); ++i)
      count += x[i];
    return count;
  }


  template <typename T1, typename T2>
  inline size_t count_non_zeros(const std::vector<std::pair<T1,T2> >& x)
  {
    size_t count = 0;
    for (size_t i = 0; i != x.size(); ++i)
      if (! is_zero(x[i]))
        ++count;
    return count;
  }





  template <typename It>
  inline size_t
  count_lt(It begin, It end, const typename std::iterator_traits<It>::value_type& thres)
  {
    typedef typename std::iterator_traits<It>::value_type value_type;
    return std::count_if(begin, end, std::bind2nd(std::less<value_type>(), thres));
  }






  template <typename It>
  inline void
  round_01(It begin, It end,
           const typename std::iterator_traits<It>::value_type& threshold =.5)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3863) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "round_01: Invalid range";
    }

    typename std::iterator_traits<It>::value_type val;

    while (begin != end) {
      val = *begin;
      if (val >= threshold)
        val = 1;
      else
        val = 0;
      *begin = val;
      ++begin;
    }
  }




  template <typename T>
  inline void round_01(T& a, const typename T::value_type& threshold =.5)
  {
    round_01(a.begin(), a.end(), threshold);
  }
# 3900 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  inline nta::Real32 sum(nta::Real32* begin, nta::Real32* end)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3903) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "sum: Invalid range";
    }
# 3915 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
    nta::Real32 result = 0;
    for (; begin != end; ++begin)
      result += *begin;
    return result;


  }
# 3930 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename T>
  inline typename T::value_type sum(const T& x)
  {
    typename T::value_type result = 0;
    typename T::const_iterator it;
    for (it = x.begin(); it != x.end(); ++it)
      result += *it;
    return result;
  }


  template <typename T1, typename T2, typename T3>
  inline void sum(const std::vector<T1>& a, const std::vector<T2>& b,
                  size_t begin, size_t end, std::vector<T3>& c)
  {
    for (size_t i = begin; i != end; ++i)
      c[i] = a[i] + b[i];
  }





  template <typename It>
  inline typename std::iterator_traits<It>::value_type product(It begin, It end)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3957) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "product: Invalid range";
    }

    typename std::iterator_traits<It>::value_type p(1);

    for (; begin != end; ++begin)
      p *= *begin;

    return p;
  }





  template <typename T>
  inline typename T::value_type product(const T& x)
  {
    return product(x.begin(), x.end());
  }




  template <typename It>
  inline void add_val(It begin, It end,
                      const typename std::iterator_traits<It>::value_type& val)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 3987) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "add_val: Invalid range";
    }

    if (val == 0.0f)
      return;

    for (; begin != end; ++begin)
      *begin += val;
  }




  template <typename T>
  inline void add_val(T& x, const typename T::value_type& val)
  {
    add_val(x.begin(), x.end(), val);
  }




  template <typename It>
  inline void subtract_val(It begin, It end,
                           const typename std::iterator_traits<It>::value_type& val)
  {
    add_val(begin, end, -val);
  }




  template <typename T>
  inline void subtract_val(T& x, const typename T::value_type& val)
  {
    subtract_val(x.begin(), x.end(), val);
  }




  template <typename It>
  inline void negate(It begin, It end)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4033) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "negate: Invalid range";
    }

    for (; begin != end; ++begin)
      *begin = -*begin;
  }




  template <typename T>
  inline void negate(T& x)
  {
    negate(x.begin(), x.end());
  }




  template <typename It>
  inline void
  divide_val(It begin, It end,
             const typename std::iterator_traits<It>::value_type& val)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4059) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "divide_val: Invalid range";
      if (val != 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4061) << "ASSERTION FAILED: \"" << "val != 0" << "\" "
        << "divide_val: Division by zero";
    }

    multiply_val(begin, end, 1.0f/val);
  }





  template <typename T>
  inline void divide_val(T& x, const typename T::value_type& val)
  {
    divide_val(x.begin(), x.end(), val);
  }




  template <typename It1, typename It2>
  inline void add(It1 begin1, It1 end1, It2 begin2, It2 end2)
  {
    {
      if (begin1 <= end1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4085) << "ASSERTION FAILED: \"" << "begin1 <= end1" << "\" "
        << "add: Invalid range";
      if (end1 - begin1 <= end2 - begin2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4087) << "ASSERTION FAILED: \"" << "end1 - begin1 <= end2 - begin2" << "\" "
        << "add: Incompatible ranges";
    }

    for (; begin1 != end1; ++begin1, ++begin2)
      *begin1 += *begin2;
  }




  template <typename T1, typename T2>
  inline void add(T1& x, const T2& y)
  {
    add(x.begin(), x.end(), y.begin(), y.end());
  }




  template <typename It1, typename It2>
  inline void subtract(It1 begin1, It1 end1, It2 begin2, It2 end2)
  {
    {
      if (begin1 <= end1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4111) << "ASSERTION FAILED: \"" << "begin1 <= end1" << "\" "
        << "subtract: Invalid range";
      if (end1 - begin1 <= end2 - begin2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4113) << "ASSERTION FAILED: \"" << "end1 - begin1 <= end2 - begin2" << "\" "
        << "subtract: Incompatible ranges";
    }

    for (; begin1 != end1; ++begin1, ++begin2)
      *begin1 -= *begin2;
  }





  template <typename T1, typename T2>
  inline void subtract(T1& x, const T2& y)
  {
    subtract(x.begin(), x.end(), y.begin(), y.end());
  }




  template <typename It1, typename It2>
  inline void multiply(It1 begin1, It1 end1, It2 begin2, It2 end2)
  {
    {
      if (begin1 <= end1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4138) << "ASSERTION FAILED: \"" << "begin1 <= end1" << "\" "
        << "Binary multiply: Invalid range";
      if (end1 - begin1 <= end2 - begin2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4140) << "ASSERTION FAILED: \"" << "end1 - begin1 <= end2 - begin2" << "\" "
        << "Binary multiply: Incompatible ranges";
    }

    for (; begin1 != end1; ++begin1, ++begin2)
      *begin1 *= *begin2;
  }




  template <typename T1, typename T2>
  inline void multiply(T1& x, const T2& y)
  {
    multiply(x.begin(), x.end(), y.begin(), y.end());
  }


  template <typename It1, typename It2, typename It3>
  inline void multiply(It1 begin1, It1 end1, It2 begin2, It2 end2,
                       It3 begin3, It3 end3)
  {
    {
      if (begin1 <= end1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4163) << "ASSERTION FAILED: \"" << "begin1 <= end1" << "\" "
        << "Ternary multiply: Invalid range";
      if (end1 - begin1 <= end2 - begin2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4165) << "ASSERTION FAILED: \"" << "end1 - begin1 <= end2 - begin2" << "\" "
        << "Ternary multiply: Incompatible input ranges";
      if (end1 - begin1 <= end3 - begin3) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4167) << "ASSERTION FAILED: \"" << "end1 - begin1 <= end3 - begin3" << "\" "
        << "Ternary multiply: Not enough memory for result";
    }

    typedef typename std::iterator_traits<It3>::value_type value_type;

    for (; begin1 != end1; ++begin1, ++begin2, ++begin3)
      *begin3 = (value_type) *begin1 * *begin2;
  }


  template <typename T1, typename T2, typename T3>
  inline void multiply(const T1& x, const T2& y, T3& z)
  {
    multiply(x.begin(), x.end(), y.begin(), y.end(), z.begin(), z.end());
  }







  template <typename I, typename T>
  inline void
  multiply_val(T val, const Buffer<I>& indices, SparseVector<I,T>& x)
  {
    I n1 = indices.nnz, n2 = x.nnz, i1 = 0, i2 =0;

    while (i1 != n1 && i2 != n2)
      if (x[i2].first < indices[i1]) {
        ++i2;
      } else if (indices[i1] < x[i2].first) {
        ++i1;
      } else {
        x[i2].second *= val;
        ++i1; ++i2;
      }
  }




  template <typename It1, typename It2>
  inline void divide(It1 begin1, It1 end1, It2 begin2, It2 end2,
                     typename std::iterator_traits<It1>::value_type fuzz =0)
  {
    {
      if (begin1 <= end1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4215) << "ASSERTION FAILED: \"" << "begin1 <= end1" << "\" "
        << "divide: Invalid range";
      if (end1 - begin1 <= end2 - begin2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4217) << "ASSERTION FAILED: \"" << "end1 - begin1 <= end2 - begin2" << "\" "
        << "divide: Incompatible ranges";
    }

    if (fuzz == 0)
      for (; begin1 != end1; ++begin1, ++begin2)
        *begin1 /= *begin2;
    else
      for (; begin1 != end1; ++begin1, ++begin2)
        *begin1 /= (*begin2 + fuzz);
  }





  template <typename T1, typename T2>
  inline void divide(T1& x, const T2& y, typename T1::value_type fuzz =0)
  {
    divide(x.begin(), x.end(), y.begin(), y.end(), fuzz);
  }


  template <typename It1>
  inline void divide_by_max(It1 begin, It1 end)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4244) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "divide_by_max: Invalid range";
    }

    typename std::iterator_traits<It1>::value_type max_val =
      *(std::max_element(begin, end));

    if (!nta::nearlyZero(max_val))
      for (It1 it = begin; it != end; ++it)
        *it /= max_val;
  }


  template <typename T1>
  inline void divide_by_max(T1& v)
  {
    divide_by_max(v.begin(), v.end());
  }




  template <typename It1, typename It2, typename TFuncIsNearlyZero, typename TFuncHandleZero>
  inline void inverseNZ(It1 begin1, It1 end1, It2 out, It2 out_end,
                        TFuncIsNearlyZero fIsZero, TFuncHandleZero fHandleZero)
  {
    {
      if (begin1 <= end1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4271) << "ASSERTION FAILED: \"" << "begin1 <= end1" << "\" "
        << "inverseNZ: Invalid input range";
      if (out <= out_end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4273) << "ASSERTION FAILED: \"" << "out <= out_end" << "\" "
        << "inverseNZ: Invalid output range";
      if (end1 - begin1 == out_end - out) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4275) << "ASSERTION FAILED: \"" << "end1 - begin1 == out_end - out" << "\" "
        << "inverseNZ: Incompatible ranges";
    }

    const typename std::iterator_traits<It2>::value_type one(1.0);

    for (; begin1 != end1; ++begin1, ++out) {
      if(fIsZero(*begin1))
        *out = fHandleZero(*begin1);
      else
        *out = one / *begin1;
    }
  }
# 4308 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename T1, typename T2, typename TFuncIsNearlyZero, typename TFuncHandleZero>
  inline void inverseNZ(const T1& x, T2 &out,
                        TFuncIsNearlyZero fIsNearlyZero, TFuncHandleZero fHandleZero)
  {
    inverseNZ(x.begin(), x.end(), out.begin(), out.end(), fIsNearlyZero, fHandleZero);
  }


  template <typename It1, typename It2>
  inline void inverse(It1 begin1, It1 end1, It2 out, It2 out_end,
                      const typename std::iterator_traits<It2>::value_type one =1.0)
  {
    {
      if (begin1 <= end1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4321) << "ASSERTION FAILED: \"" << "begin1 <= end1" << "\" "
        << "inverse: Invalid input range";
      if (out <= out_end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4323) << "ASSERTION FAILED: \"" << "out <= out_end" << "\" "
        << "inverse: Invalid output range";
      if (end1 - begin1 == out_end - out) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4325) << "ASSERTION FAILED: \"" << "end1 - begin1 == out_end - out" << "\" "
        << "inverse: Incompatible ranges";
    }

    for (; begin1 != end1; ++begin1, ++out)
      *out = one / *begin1;
  }


  template <typename T1, typename T2>
  inline void inverse(const T1& x, T2 &out, const typename T2::value_type one=1.0)
  {
    inverse(x.begin(), x.end(), out.begin(), out.end(), one);
  }





  template <typename It1, typename It2>
  inline void add_ky(const typename std::iterator_traits<It1>::value_type& k,
                     It1 y, It1 y_end, It2 x, It2 x_end)
  {
    {
      if (y <= y_end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4349) << "ASSERTION FAILED: \"" << "y <= y_end" << "\" "
        << "add_ky: Invalid y range";
      if (x <= x_end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4351) << "ASSERTION FAILED: \"" << "x <= x_end" << "\" "
        << "add_ky: Invalid x range";
      if (y_end - y <= x - x_end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4353) << "ASSERTION FAILED: \"" << "y_end - y <= x - x_end" << "\" "
        << "add_ky: Result range too small";
    }

    while (y != y_end) {
      *x += k * *y;
      ++x; ++y;
    }
  }




  template <typename T1, typename T2>
  inline void add_ky(const typename T1::value_type& k, const T2& y, T1& x)
  {
    add_ky(k, y.begin(), y.end(), x.begin(), x.end());
  }





  template <typename It1, typename It2, typename It3>
  inline void add_ky(It1 x1, It1 x1_end,
                     const typename std::iterator_traits<It1>::value_type& k,
                     It2 y, It3 x2)
  {
    while (x1 != x1_end) {
      *x2 = *x1 + k * *y;
      ++x2; ++x1; ++y;
    }
  }




  template <typename T1, typename T2, typename T3>
  inline void add_ky(const T1& x1,
                     const typename T1::value_type& k, const T2& y,
                     T3& x2)
  {


    add_ky(x1.begin(), x1.end(), k, y.begin(), x2.begin());
  }
# 4408 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename T1, typename T2>
  inline void axpy(T1& x, const typename T1::value_type& a, const T2& y)
  {


    typename T1::iterator it_x = x.begin(), it_x_end = x.end();
    typename T2::const_iterator it_y = y.begin();

    while (it_x != it_x_end) {
      *it_x = a * *it_x + *it_y;
      ++it_x; ++it_y;
    }
  }





  template <typename X, typename Y>
  inline void axby(const typename std::iterator_traits<X>::value_type& a,
                   X x, X x_end,
                   const typename std::iterator_traits<X>::value_type& b,
                   Y y)
  {
    while (x != x_end) {
      *x = a * *x + b * *y;
      ++x; ++y;
    }
  }




  template <typename T1, typename T2>
  inline void axby(const typename T1::value_type& a, T1& x,
                   const typename T1::value_type& b, const T2& y)
  {


    axby(a, x.begin(), x.end(), b, y.begin());
  }





  template <typename It>
  inline void range_exp(typename std::iterator_traits<It>::value_type k,
                        It begin, It end)
  {
    typedef typename std::iterator_traits<It>::value_type value_type;

    Exp<value_type> e_f;

    for (; begin != end; ++begin)
      *begin = e_f(k * *begin);
  }




  template <typename C>
  inline void range_exp(typename C::value_type k, C& c)
  {
    range_exp(k, c.begin(), c.end());
  }





  template <typename It>
  inline void range_exp(typename std::iterator_traits<It>::value_type k1,
                        typename std::iterator_traits<It>::value_type k2,
                        It begin, It end)
  {
    typedef typename std::iterator_traits<It>::value_type value_type;

    Exp<value_type> e_f;

    for (; begin != end; ++begin)
      *begin = k1 * e_f(k2 * *begin);
  }




  template <typename C>
  inline void range_exp(typename C::value_type k1, typename C::value_type k2, C& c)
  {
    range_exp(k1, k2, c.begin(), c.end());
  }
# 4508 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename It1, typename It2>
  inline typename std::iterator_traits<It1>::value_type
  inner_product(It1 it_x, It1 it_x_end, It2 it_y)
  {
    typename std::iterator_traits<It1>::value_type n(0);

    while (it_x != it_x_end) {
      n += *it_x * *it_y;
      ++it_x; ++it_y;
    }

    return n;
  }





  template <typename F1, typename It>
  inline void transform(It begin, It end, F1 f)
  {
    {
      if (begin <= end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4530) << "ASSERTION FAILED: \"" << "begin <= end" << "\" "
        << "transform: Invalid range";
    }

    for (; begin != end; ++begin)
      *begin = f(*begin);
  }




  template <typename F1, typename T1>
  inline void transform(T1& a, F1 f)
  {
    typename T1::iterator ia = a.begin(), iae = a.end();

    for (; ia != iae; ++ia)
      *ia = f(*ia);
  }




  template <typename F1, typename T1, typename T2>
  inline void transform(const T1& a, T2& b, F1 f)
  {


    typename T1::const_iterator ia = a.begin(), iae = a.end();
    typename T2::iterator ib = b.begin();

    for (; ia != iae; ++ia, ++ib)
      *ib = f(*ia);
  }




  template <typename F2, typename T1, typename T2, typename T3>
  inline void transform(const T1& a, const T2& b, T3& c, F2 f)
  {




    typename T1::const_iterator ia = a.begin(), iae = a.end();
    typename T2::const_iterator ib = b.begin();
    typename T3::iterator ic = c.begin();

    for (; ia != iae; ++ia, ++ib, ++ic)
      *ic = f(*ia, *ib);
  }




  template <typename F3, typename T1, typename T2, typename T3, typename T4>
  inline void transform(const T1& a, const T2& b, const T3& c, T4& d, F3 f)
  {






    typename T1::const_iterator ia = a.begin(), iae = a.end();
    typename T2::const_iterator ib = b.begin();
    typename T3::const_iterator ic = c.begin();
    typename T4::iterator id = d.begin();

    for (; ia != iae; ++ia, ++ib, ++ic, ++id)
      *id = f(*ia, *ib, *ic);
  }







  template <typename ForwardIterator, typename F>
  inline ForwardIterator
  min_element(ForwardIterator first, ForwardIterator last, F f)
  {
    {
      if (first <= last) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4615) << "ASSERTION FAILED: \"" << "first <= last" << "\" "
        << "min_element: Invalid range";
    }

    typedef typename ForwardIterator::value_type value_type;

    ForwardIterator min_it = first;
    value_type min_val = f(*first);

    while (first != last) {
      value_type val = f(*first);
      if (val < min_val) {
        min_it = first;
        min_val = val;
      }
      ++first;
    }

    return min_it;
  }





  template <typename ForwardIterator, typename F>
  inline ForwardIterator
  max_element(ForwardIterator first, ForwardIterator last, F f)
  {
    {
      if (first <= last) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4645) << "ASSERTION FAILED: \"" << "first <= last" << "\" "
        << "max_element: Invalid range";
    }

    typedef typename ForwardIterator::value_type value_type;

    ForwardIterator max_it = first;
    value_type max_val = f(*first);

    while (first != last) {
      value_type val = f(*first);
      if (val > max_val) {
        max_it = first;
        max_val = val;
      }
      ++first;
    }

    return max_it;
  }





  template <typename C>
  inline size_t min_element(const C& c)
  {
    if (c.empty())
      return (size_t) 0;
    else
      return (size_t) (std::min_element(c.begin(), c.end()) - c.begin());
  }





  template <typename C>
  inline size_t max_element(const C& c)
  {
    if (c.empty())
      return (size_t) 0;
    else
      return (size_t) (std::max_element(c.begin(), c.end()) - c.begin());
  }





  template <typename It1, typename It2, typename It3>
  inline void minimum(It1 begin1, It1 end1, It2 begin2, It3 out)
  {
    {
      if (begin1 <= end1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4700) << "ASSERTION FAILED: \"" << "begin1 <= end1" << "\" "
        << "minimum: Invalid range";
    }

    typedef typename std::iterator_traits<It3>::value_type T;
    for(; begin1!=end1; ++begin1, ++begin2, ++out) {
      *out = std::min<T>(*begin1, *begin2);
    }
  }





  template <typename T1, typename T2, typename T3>
  inline void minimum(const T1 &x, const T2 &y, T3 &out)
  {
    minimum(x.begin(), x.end(), y.begin(), out.begin());
  }




  template <typename C>
  inline bool contains(const C& c, typename C::value_type& v)
  {
    return std::find(c.begin(), c.end(), v) != c.end();
  }


  template <typename C1, typename C2>
  inline bool is_subsequence(const C1& seq, const C2& sub)
  {
    return std::search(seq.begin(), seq.end(), sub.begin(), sub.end()) != seq.end();
  }


  template <typename C1, typename C2>
  inline bool is_subsequence_of(const C1& c, const C2& sub)
  {
    bool found = false;
    typename C1::const_iterator it, end = c.end();
    for (it = c.begin(); it != end; ++it)
      if (is_subsequence(*it, sub))
        found = true;
    return found;
  }







  template <typename It1, typename It2, typename RNG>
  inline void sample(size_t n, It1 pdf_begin, It1 pdf_end, It2 output, RNG& rng)
  {
    {
      if (pdf_begin <= pdf_end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4758) << "ASSERTION FAILED: \"" << "pdf_begin <= pdf_end" << "\" "
        << "sample: Invalid range for pdf";
    }

    typedef typename std::iterator_traits<It1>::value_type value_type;
    typedef typename std::iterator_traits<It2>::value_type size_type2;

    size_t size = (size_t) (pdf_end - pdf_begin);
    std::vector<double> cdf(size, 0);
    std::vector<double>::const_iterator it = cdf.begin();
    cumulative(pdf_begin, pdf_end, cdf.begin(), cdf.end());
    double m = cdf[size-1];

    for (size_t i = 0; i != n; ++i, ++output) {
      double p = m * double(rng()) / double(rng.max() - rng.min());
      it = std::lower_bound(cdf.begin(), cdf.end(), p);
      *output = (size_type2) (it - cdf.begin());
    }
  }





  template <typename It1, typename It2>
  inline void sample(size_t n, It1 pdf_begin, It1 pdf_end, It2 output)
  {
    {
      if (pdf_begin <= pdf_end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4786) << "ASSERTION FAILED: \"" << "pdf_begin <= pdf_end" << "\" "
        << "sample: Invalid range for pdf";
    }

    nta::Random rng;
    sample(n, pdf_begin, pdf_end, output, rng);
  }





  template <typename C1>
  inline size_t sample_one(const C1& pdf)
  {
    size_t c = 0;
    sample(1, pdf.begin(), pdf.end(), &c);
    return c;
  }


  template <typename C1, typename RNG>
  inline size_t sample_one(const C1& pdf, RNG& rng)
  {
    size_t c = 0;
    sample(1, pdf.begin(), pdf.end(), &c, rng);
    return c;
  }
# 4834 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename InputIterator, typename OutputIterator>
  inline void logical_and(InputIterator x, InputIterator x_end,
                          InputIterator y, InputIterator y_end,
                          OutputIterator z, OutputIterator z_end)
  {
    {
      if (x_end - x == y_end - y) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4840) << "ASSERTION FAILED: \"" << "x_end - x == y_end - y" << "\" ";
      if (x_end - x == z_end - z) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4841) << "ASSERTION FAILED: \"" << "x_end - x == z_end - z" << "\" ";
    }
# 4907 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
    for (; x != x_end; ++x, ++y, ++z)
      *z = (*x) && (*y);

  }






  template <typename Iterator>
  inline void in_place_logical_and(Iterator x, Iterator x_end,
                                   Iterator y, Iterator y_end)
  {
    {
      if (x_end - x == y_end - y) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 4922) << "ASSERTION FAILED: \"" << "x_end - x == y_end - y" << "\" ";
    }
# 4979 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
    for (; x != x_end; ++x, ++y)
      *y = (*x) && *(y);

  }
# 4991 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  inline void in_place_logical_and(const ByteVector& x, ByteVector& y,
                                   int begin =-1, int end =-1)
  {
    if (begin == -1)
      begin = 0;

    if (end == -1)
      end = (int) x.size();

    for (int i = begin; i != end; ++i)
      y[i] &= x[i];
  }





  inline void in_place_logical_or(const ByteVector& x, ByteVector& y,
                                  int begin =-1, int end =-1)
  {
    if (begin == -1)
      begin = 0;

    if (end == -1)
      end = (int) x.size();

    for (int i = begin; i != end; ++i)
      y[i] |= x[i];
  }


  inline void
  logical_or(size_t n, const ByteVector& x, const ByteVector& y, ByteVector& z)
  {
    for (size_t i = 0; i != n; ++i)
      z[i] = x[i] || y[i];
  }


  inline void in_place_logical_or(size_t n, const ByteVector& x, ByteVector& y)
  {
    for (size_t i = 0; i != n; ++i)
      y[i] |= x[i];
  }




  template <typename InputIterator1, typename InputIterator2, typename OutputIterator>
  inline size_t sparseOr(size_t n,
                         InputIterator1 begin1, InputIterator1 end1,
                         InputIterator2 begin2, InputIterator2 end2,
                         OutputIterator out, OutputIterator out_end)
  {
    {
      if (0 <= end1 - begin1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5046) << "ASSERTION FAILED: \"" << "0 <= end1 - begin1" << "\" "
        << "sparseOr: Mismatched iterators for first vector";
      if (0 <= end2 - begin2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5048) << "ASSERTION FAILED: \"" << "0 <= end2 - begin2" << "\" "
        << "sparseOr: Mismatched iterators for second vector";
      if (0 <= out_end - out) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5050) << "ASSERTION FAILED: \"" << "0 <= out_end - out" << "\" "
        << "sparseOr: Mismatched iterators for output vector";
      if (0 <= n) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5052) << "ASSERTION FAILED: \"" << "0 <= n" << "\" "
        << "sparseOr: Invalid max size: " << n;
      if ((size_t)(end1 - begin1) <= n) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5054) << "ASSERTION FAILED: \"" << "(size_t)(end1 - begin1) <= n" << "\" "
        << "sparseOr: Invalid first vector size";
      if ((size_t)(end2 - begin2) <= n) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5056) << "ASSERTION FAILED: \"" << "(size_t)(end2 - begin2) <= n" << "\" "
        << "sparseOr: Invalid second vector size";
      if (n <= (size_t)(out_end - out)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5058) << "ASSERTION FAILED: \"" << "n <= (size_t)(out_end - out)" << "\" "
        << "sparseOr: Insufficient memory for result";
      for (int i = 0; i < (int)(end1 - begin1); ++i)
        if (*(begin1 + i) < n) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5061) << "ASSERTION FAILED: \"" << "*(begin1 + i) < n" << "\" "
          << "sparseOr: Invalid index in first vector: " << *(begin1 + i);
      for (int i = 1; i < (int)(end1 - begin1); ++i)
        if (*(begin1 + i - 1) < *(begin1 + i)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5064) << "ASSERTION FAILED: \"" << "*(begin1 + i - 1) < *(begin1 + i)" << "\" "
          << "sparseOr: Indices need to be in strictly increasing order"
          << " (first vector)";
      for (int i = 0; i < (int)(end2 - begin2); ++i)
        if (*(begin2 + i) < n) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5068) << "ASSERTION FAILED: \"" << "*(begin2 + i) < n" << "\" "
          << "sparseOr: Invalid index in second vector: " << *(begin2 + i);
      for (int i = 1; i < (int)(end2 - begin2); ++i)
        if (*(begin2 + i - 1) < *(begin2 + i)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5071) << "ASSERTION FAILED: \"" << "*(begin2 + i - 1) < *(begin2 + i)" << "\" "
          << "sparseOr: Indices need to be in strictly increasing order"
          << " (second vector)";
    }

    typedef typename std::iterator_traits<OutputIterator>::value_type value_type;

    OutputIterator out_begin = out;

    while (begin1 != end1 && begin2 != end2) {

      if (*begin1 < *begin2) {
        *out++ = (value_type) *begin1++;
      } else if (*begin2 < *begin1) {
        *out++ = (value_type) *begin2++;
      } else {
        *out++ = (value_type) *begin1++;
        ++begin2;
      }
    }

    for (; begin1 != end1; ++begin1)
      *out++ = (value_type) *begin1;

    for (; begin2 != end2; ++begin2)
      *out++ = (value_type) *begin2;

    return (size_t)(out - out_begin);
  }


  template <typename U>
  inline size_t sparseOr(size_t n,
                         const std::vector<U>& x1, const std::vector<U>& x2,
                         std::vector<U>& out)
  {
    return sparseOr(n, x1.begin(), x1.end(), x2.begin(), x2.end(),
                    out.begin(), out.end());
  }


  template <typename InputIterator1, typename InputIterator2, typename OutputIterator>
  inline size_t sparseAnd(size_t n,
                          InputIterator1 begin1, InputIterator1 end1,
                          InputIterator2 begin2, InputIterator2 end2,
                          OutputIterator out, OutputIterator out_end)
  {
    {
      if (0 <= end1 - begin1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5119) << "ASSERTION FAILED: \"" << "0 <= end1 - begin1" << "\" "
        << "sparseAnd: Mismatched iterators for first vector";
      if (0 <= end2 - begin2) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5121) << "ASSERTION FAILED: \"" << "0 <= end2 - begin2" << "\" "
        << "sparseAnd: Mismatched iterators for second vector";
      if (0 <= out_end - out) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5123) << "ASSERTION FAILED: \"" << "0 <= out_end - out" << "\" "
        << "sparseAnd: Mismatched iterators for output vector";
      if (0 <= n) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5125) << "ASSERTION FAILED: \"" << "0 <= n" << "\" "
        << "sparseAnd: Invalid max size: " << n;
      if ((size_t)(end1 - begin1) <= n) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5127) << "ASSERTION FAILED: \"" << "(size_t)(end1 - begin1) <= n" << "\" "
        << "sparseAnd: Invalid first vector size";
      if ((size_t)(end2 - begin2) <= n) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5129) << "ASSERTION FAILED: \"" << "(size_t)(end2 - begin2) <= n" << "\" "
        << "sparseAnd: Invalid second vector size";


      for (int i = 0; i < (int)(end1 - begin1); ++i)
        if (*(begin1 + i) < n) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5134) << "ASSERTION FAILED: \"" << "*(begin1 + i) < n" << "\" "
          << "sparseAnd: Invalid index in first vector: " << *(begin1 + i);
      for (int i = 1; i < (int)(end1 - begin1); ++i)
        if (*(begin1 + i - 1) < *(begin1 + i)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5137) << "ASSERTION FAILED: \"" << "*(begin1 + i - 1) < *(begin1 + i)" << "\" "
          << "sparseAnd: Indices need to be in strictly increasing order"
          << " (first vector)";
      for (int i = 0; i < (int)(end2 - begin2); ++i)
        if (*(begin2 + i) < n) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5141) << "ASSERTION FAILED: \"" << "*(begin2 + i) < n" << "\" "
          << "sparseAnd: Invalid index in second vector: " << *(begin2 + i);
      for (int i = 1; i < (int)(end2 - begin2); ++i)
        if (*(begin2 + i - 1) < *(begin2 + i)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5144) << "ASSERTION FAILED: \"" << "*(begin2 + i - 1) < *(begin2 + i)" << "\" "
          << "sparseAnd: Indices need to be in strictly increasing order"
          << " (second vector)";
    }

    typedef typename std::iterator_traits<OutputIterator>::value_type value_type;

    OutputIterator out_begin = out;

    while (begin1 != end1 && begin2 != end2) {

      if (*begin1 < *begin2) {
        ++begin1;
      } else if (*begin2 < *begin1) {
        ++begin2;
      } else {
        *out++ = (value_type) *begin1++;
        ++begin2;
      }
    }

    return (size_t)(out - out_begin);
  }


  template <typename U>
  inline size_t sparseAnd(size_t n,
                          const std::vector<U>& x1, const std::vector<U>& x2,
                          std::vector<U>& out)
  {
    return sparseAnd(n, x1.begin(), x1.end(), x2.begin(), x2.end(),
                     out.begin(), out.end());
  }






  template <typename C>
  inline void sort(C& c)
  {
    std::sort(c.begin(), c.end());
  }


  template <typename C, typename F>
  inline void sort(C& c, F f)
  {
    std::sort(c.begin(), c.end(), f);
  }


  template <typename It>
  inline void sort_on_first(It x_begin, It x_end, int direction =1)
  {
    typedef typename std::iterator_traits<It>::value_type P;
    typedef typename P::first_type I;
    typedef typename P::second_type F;

    typedef select1st<std::pair<I,F> > sel1st;

    if (direction == -1) {
      std::sort(x_begin, x_end, predicate_compose<std::greater<I>, sel1st>());
    } else {
      std::sort(x_begin, x_end, predicate_compose<std::less<I>, sel1st>());
    }
  }


  template <typename I, typename F>
  inline void sort_on_first(size_t n, std::vector<std::pair<I,F> >& x,
                            int direction =1)
  {
    sort_on_first(x.begin(), x.begin() + n, direction);
  }


  template <typename I, typename F>
  inline void sort_on_first(std::vector<std::pair<I,F> >& x, int direction =1)
  {
    sort_on_first(x.begin(), x.end(), direction);
  }


  template <typename I, typename F>
  inline void sort_on_first(SparseVector<I,F>& x, int direction =1)
  {
    sort_on_first(x.begin(), x.begin() + x.nnz, direction);
  }





  template <typename I, typename C, typename F>
  inline void partial_sort(I k, C& elts, F f)
  {
    std::partial_sort(elts.begin(), elts.begin() + k, elts.end(), f);
  }





  template <typename size_type,
            typename InputIterator,
            typename OutputIterator,
            typename Order>
  inline void
  partial_sort_2nd(size_type k,
                   InputIterator in_begin, InputIterator in_end,
                   OutputIterator out_begin, Order)
  {
    typedef typename std::iterator_traits<InputIterator>::value_type value_type;
    typedef select2nd<std::pair<size_type, value_type> > sel2nd;

    std::vector<std::pair<size_type, value_type> > v(in_end - in_begin);

    for (size_type i = 0; in_begin != in_end; ++in_begin, ++i)
      v[i] = std::make_pair(i, *in_begin);

    std::partial_sort(v.begin(), v.begin() + k, v.end(),
                      predicate_compose<Order, sel2nd>());

    for (size_type i = 0; i != k; ++i, ++out_begin)
      *out_begin = v[i];
  }





  template <typename C1, typename OutputIterator, typename Order>
  inline void
  partial_sort_2nd(size_t k, const C1& c1, OutputIterator out_begin, Order order)
  {
    partial_sort_2nd(k, c1.begin(), c1.end(), out_begin, order);
  }
# 5296 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename size_type,
            typename InIter,
            typename OutputIterator1,
            typename OutputIterator2,
            typename Order>
  inline void
  partial_sort(size_type k, InIter in_begin, InIter in_end,
               OutputIterator1 ind, OutputIterator2 nz,
               Order order, size_type start_offset =0,
               bool resort_on_first =false)
  {
    typedef typename std::iterator_traits<InIter>::value_type value_type;
    typedef select1st<std::pair<size_type, value_type> > sel1st;

    std::vector<std::pair<size_type, value_type> > v(in_end - in_begin);

    for (size_type i = start_offset; in_begin != in_end; ++in_begin, ++i)
      v[i - start_offset] = std::make_pair(i, *in_begin);

    std::partial_sort(v.begin(), v.begin() + k, v.end(), order);

    if (resort_on_first) {
      std::sort(v.begin(), v.begin() + k,
                predicate_compose<std::less<size_type>, sel1st>());
    }

    for (size_type i = 0; i != k; ++i, ++ind, ++nz) {
      *ind = v[i].first;
      *nz = v[i].second;
    }
  }





  template <typename I0, typename I, typename T>
  inline void
  partial_argsort(I0 k, SparseVector<I,T>& x, int direction =-1)
  {
    {
      if (0 < k) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5337) << "ASSERTION FAILED: \"" << "0 < k" << "\" ";
      if (k <= x.size()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5338) << "ASSERTION FAILED: \"" << "k <= x.size()" << "\" ";
      if (direction == -1 || direction == 1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5339) << "ASSERTION FAILED: \"" << "direction == -1 || direction == 1" << "\" ";
    }

    typedef I size_type;
    typedef T value_type;

    if (direction == -1) {

      greater_2nd_no_ties<size_type, value_type> order;
      std::partial_sort(x.begin(), x.begin() + k, x.begin() + x.nnz, order);

    } else if (direction == 1) {

      less_2nd<size_type, value_type> order;
      std::partial_sort(x.begin(), x.begin() + k, x.begin() + x.nnz, order);
    }
  }





  static SparseVector<size_t, float> partial_argsort_buffer;
# 5378 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename InIter, typename OutIter>
  inline void partial_argsort(size_t k, InIter begin, InIter end,
                              OutIter sorted, OutIter sorted_end,
                              int direction =-1)
  {
    {
      if (0 < k) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5384) << "ASSERTION FAILED: \"" << "0 < k" << "\" ";
      if (0 < end - begin) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5385) << "ASSERTION FAILED: \"" << "0 < end - begin" << "\" ";
      if (k <= (size_t)(end - begin)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5386) << "ASSERTION FAILED: \"" << "k <= (size_t)(end - begin)" << "\" ";
      if (k <= (size_t)(sorted_end - sorted)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5387) << "ASSERTION FAILED: \"" << "k <= (size_t)(sorted_end - sorted)" << "\" ";
      if (direction == -1 || direction == 1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5388) << "ASSERTION FAILED: \"" << "direction == -1 || direction == 1" << "\" ";
    }

    typedef size_t size_type;
    typedef float value_type;

    SparseVector<size_type, value_type>& buff = partial_argsort_buffer;

    size_type n = (size_type)(end - begin);



    buff.resize(n);
    buff.nnz = n;

    InIter it = begin;

    for (size_type i = 0; i != n; ++i, ++it) {
      buff[i].first = i;
      buff[i].second = *it;
    }

    partial_argsort(k, buff, direction);

    for (size_type i = 0; i != k; ++i)
      sorted[i] = buff[i].first;
  }






  template <typename InIter, typename OutIter>
  inline void
  partial_argsort_rnd_tie_break(size_t k,
                                InIter begin, InIter end,
                                OutIter sorted, OutIter sorted_end,
                                Random& rng,
                                bool real_random =false)
  {
    {
      if (0 < k) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5430) << "ASSERTION FAILED: \"" << "0 < k" << "\" ";
      if (0 < end - begin) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5431) << "ASSERTION FAILED: \"" << "0 < end - begin" << "\" ";
      if (k <= (size_t)(end - begin)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5432) << "ASSERTION FAILED: \"" << "k <= (size_t)(end - begin)" << "\" ";
      if (k <= (size_t)(sorted_end - sorted)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5433) << "ASSERTION FAILED: \"" << "k <= (size_t)(sorted_end - sorted)" << "\" ";
    }

    typedef size_t size_type;
    typedef float value_type;

    SparseVector<size_type, value_type>& buff = partial_argsort_buffer;

    size_type n = (size_type)(end - begin);



    buff.resize(n);
    buff.nnz = n;

    InIter it = begin;

    for (size_type i = 0; i != n; ++i, ++it) {
      buff[i].first = i;
      buff[i].second = *it;
    }

    if (!real_random) {
      greater_2nd<size_type, value_type> order;
      std::partial_sort(buff.begin(), buff.begin() + k, buff.begin() + buff.nnz, order);
    } else {
      greater_2nd_rnd_ties<size_type, value_type, Random> order(rng);
      std::partial_sort(buff.begin(), buff.begin() + k, buff.begin() + buff.nnz, order);
    }

    for (size_type i = 0; i != k; ++i)
      sorted[i] = buff[i].first;
  }




  template <typename It1>
  inline void
  update_with_indices_of_non_zeros(nta::UInt32 segment_size,
                                   It1 input_begin, It1 input_end,
                                   It1 prev_begin, It1 prev_end,
                                   It1 curr_begin, It1 curr_end)
  {
    typedef nta::UInt32 size_type;
    typedef nta::Real32 value_type;

    size_type input_size = (size_type)(input_end - input_begin);

    std::fill(curr_begin, curr_end, 0);

    for (size_type i = 0; i != input_size; ++i) {

      if (*(input_begin + i) == 0)
        continue;

      size_type begin = i*segment_size;
      size_type end = begin + segment_size;
      bool all_zero = true;

      for (size_type j = begin; j != end; ++j) {

        if (*(prev_begin + j) > 0) {
          all_zero = false;
          *(curr_begin + j) = 1;
        }
      }

      if (all_zero)
        std::fill(curr_begin + begin, curr_begin + end, 1);
    }
  }
# 5514 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename I, typename InIter, typename OutIter>
  inline void
  winnerTakesAll(const std::vector<I>& boundaries, InIter begin1, OutIter begin2)
  {
    typedef typename std::iterator_traits<InIter>::value_type value_type;

    I max_i = 0, size = (I) boundaries.size();
    value_type max_v = 0;

    for (I i = 0, k = 0; i < size; ++i) {
      max_v = 0;
      max_i = i == 0 ? 0 : boundaries[i-1];
      while (k < boundaries[i]) {
        if (*begin1 > max_v) {
          max_i = k;
          max_v = *begin1;
        }
        ++k;
        ++begin1;
      }
      *begin2 = (value_type) max_i;
      ++begin2;
    }
  }





  template <typename I, typename InIter, typename OutIter>
  std::pair<I, typename std::iterator_traits<InIter>::value_type>
  winnerTakesAll2(const std::vector<I>& boundaries, InIter begin1, OutIter begin2)
  {
    I max_i = 0;
    typedef typename std::iterator_traits<InIter>::value_type value_type;
    value_type max_v = 0;

    for (I i = 0, k = 0; i < boundaries.size(); ++i) {
      max_v = 0;
      max_i = i == 0 ? 0 : boundaries[i-1];
      while (k < boundaries[i]) {
        if (begin1[k] > max_v) {
          begin2[max_i] = 0;
          max_i = k;
          max_v = (value_type) (begin1[k]);
        } else {
          begin2[k] = 0;
        }
        ++k;
      }
      begin2[max_i] = 1;
    }
    return std::make_pair(max_i, max_v);
  }
# 5578 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
  template <typename I, typename InIter, typename OutIter1, typename OutIter2,
            typename RNG>
  inline void
  winnerTakesAll3(I k, I seg_size, InIter begin, InIter end,
                  OutIter1 ind, OutIter2 nz, RNG& rng)
  {
    typedef I size_type;
    typedef typename std::iterator_traits<InIter>::value_type value_type;

    {
      if (k > 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5588) << "ASSERTION FAILED: \"" << "k > 0" << "\" "
        << "winnerTakesAll3: Invalid k: " << k
        << " - Needs to be > 0";

      if (seg_size > 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5592) << "ASSERTION FAILED: \"" << "seg_size > 0" << "\" "
        << "winnerTakesAll3: Invalid segment size: " << seg_size
        << " - Needs to be  > 0";

      if (k <= seg_size) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5596) << "ASSERTION FAILED: \"" << "k <= seg_size" << "\" "
        << "winnerTakesAll3: Invalid k (" << k << ") or "
        << "segment size (" << seg_size << ")"
        << " - k needs to be <= seg_size";

      if ((size_type) (end - begin) % seg_size == 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/array_algo.hpp", 5601) << "ASSERTION FAILED: \"" << "(size_type) (end - begin) % seg_size == 0" << "\" "
        << "winnerTakesAll3: Invalid input range of size: "
        << (size_type) (end - begin)
        << " - Needs to be integer multiple of segment size: "
        << seg_size;
    }

    typedef select2nd<std::pair<size_type, value_type> > sel2nd;

    InIter seg_begin = begin;
    size_type offset = (size_type) 0;

    for (; seg_begin != end; seg_begin += seg_size, offset += seg_size) {

      InIter seg_end = seg_begin + seg_size;
      size_type offset = (size_type) (seg_begin - begin);

      if (nearlyZeroRange(seg_begin, seg_end)) {

        std::vector<size_type> indices(seg_size);
        random_perm_interval(indices, offset, 1, rng);

        sort(indices.begin(), indices.begin() + k, std::less<size_type>());

        for (size_type i = 0; i != k ; ++i, ++ind, ++nz) {
          *ind = indices[i];
          *nz = (value_type) 0;
        }

      } else {

        partial_sort(k, seg_begin, seg_end, ind, nz,
                     predicate_compose<std::greater<value_type>, sel2nd>(),
                     offset, true);
      }
    }
  }


  template <typename I, typename InIter, typename OutIter1, typename OutIter2>
  inline void
  winnerTakesAll3(I k, I seg_size, InIter begin, InIter end,
                  OutIter1 ind, OutIter2 nz)
  {
    nta::Random rng;
    winnerTakesAll3(k, seg_size, begin, end, ind, nz, rng);
  }
# 5798 "/home/marek/devel/nupic/nta/math/array_algo.hpp"
}
# 43 "/home/marek/devel/nupic/nta/math/stl_io.hpp" 2

namespace nta {




  typedef enum { CSR =0, CSR_01, BINARY, AS_DENSE } SPARSE_IO_TYPE;

  struct IOControl
  {
    int abbr;
    bool output_n_elts;

    bool pair_paren;
    const char* pair_sep;

    int convert_to_sparse;
    int convert_from_sparse;

    SPARSE_IO_TYPE sparse_io;

    bool bit_vector;

    inline IOControl(int a =-1, bool s =true, bool pp =false, const char* psep =" ",
                     SPARSE_IO_TYPE smio =CSR,
                     bool cts =false,
                     bool cfs =false,
                     bool bv =false)
      : abbr(a),
        output_n_elts(s),
        pair_paren(pp),
        pair_sep(psep),
        convert_to_sparse(cts),
        convert_from_sparse(cfs),
        sparse_io(smio),
        bit_vector(bv)
    {}

    inline void reset()
    {
      abbr = -1;
      output_n_elts = true;
      pair_paren = false;
      pair_sep = " ";
      convert_to_sparse = false;
      convert_from_sparse = false;
      sparse_io = CSR;
      bit_vector = false;
    }
  };

  extern IOControl io_control;

  template <typename CharT, typename Traits, typename T>
  inline std::basic_ostream<CharT,Traits>&
  operator,(std::basic_ostream<CharT,Traits>& out_stream, const T& a)
  {
    return out_stream << ' ' << a;
  }

  template <typename CharT, typename Traits, typename T>
  inline std::basic_istream<CharT,Traits>&
  operator,(std::basic_istream<CharT,Traits>& in_stream, T& a)
  {
    return in_stream >> a;
  }

  template <typename CharT, typename Traits>
  inline std::basic_ostream<CharT,Traits>&
  operator,(std::basic_ostream<CharT,Traits>& out_stream,
            std::basic_ostream<CharT,Traits>& (*pf)(std::basic_ostream<CharT,Traits>&))
  {
    pf(out_stream);
    return out_stream;
  }

  template <typename CharT, typename Traits>
  inline std::basic_ostream<CharT,Traits>&
  p_paren(std::basic_ostream<CharT,Traits>& out_stream)
  {
    io_control.pair_paren = true;
    return out_stream;
  }

  template <typename CharT, typename Traits>
  inline std::basic_ostream<CharT,Traits>&
  psep_comma(std::basic_ostream<CharT,Traits>& out_stream)
  {
    io_control.pair_sep = ",";
    return out_stream;
  }

  template <typename CharT, typename Traits>
  inline std::basic_ostream<CharT,Traits>&
  psep_dot(std::basic_ostream<CharT,Traits>& out_stream)
  {
    io_control.pair_sep = ".";
    return out_stream;
  }

  struct abbr
  {
    int n;
    inline abbr(int _n) : n(_n) {}
  };

  template <typename CharT, typename Traits>
  inline std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& out_stream, abbr s)
  {
    io_control.abbr = s.n;
    return out_stream;
  }

  struct debug
  {
    int n;
    inline debug(int _n =-1) : n(_n) {}
  };

  template <typename CharT, typename Traits>
  inline std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& out_stream, debug d)
  {
    io_control.abbr = d.n;
    io_control.output_n_elts = false;
    io_control.pair_sep = ",";
    io_control.pair_paren = true;
    return out_stream;
  }

  template <typename CharT, typename Traits>
  inline std::basic_istream<CharT,Traits>&
  from_csr_01(std::basic_istream<CharT,Traits>& in_stream)
  {
    io_control.convert_from_sparse = CSR_01;
    return in_stream;
  }

  template <typename CharT, typename Traits>
  inline std::basic_ostream<CharT,Traits>&
  to_csr_01(std::basic_ostream<CharT,Traits>& out_stream)
  {
    io_control.convert_to_sparse = CSR_01;
    return out_stream;
  }

  template <typename CharT, typename Traits>
  inline std::basic_istream<CharT,Traits>&
  bit_vector(std::basic_istream<CharT,Traits>& in_stream)
  {
    io_control.bit_vector = true;
    return in_stream;
  }

  template <typename CharT, typename Traits>
  inline std::basic_ostream<CharT,Traits>&
  bit_vector(std::basic_ostream<CharT,Traits>& out_stream)
  {
    io_control.bit_vector = true;
    return out_stream;
  }

  template <typename CharT, typename Traits>
  inline std::basic_istream<CharT,Traits>&
  general_vector(std::basic_istream<CharT,Traits>& in_stream)
  {
    io_control.bit_vector = false;
    return in_stream;
  }

  template <typename CharT, typename Traits>
  inline std::basic_ostream<CharT,Traits>&
  general_vector(std::basic_ostream<CharT,Traits>& out_stream)
  {
    io_control.bit_vector = false;
    return out_stream;
  }




  struct sparse_format_class
  {
    SPARSE_IO_TYPE format;

    inline sparse_format_class(SPARSE_IO_TYPE f) : format(f) {}
  };

  inline sparse_format_class
  sparse_format(SPARSE_IO_TYPE f) { return sparse_format_class(f); }

  template <typename CharT, typename Traits>
  inline std::basic_ostream<CharT,Traits>&
  operator<<(std::basic_ostream<CharT,Traits>& out_stream, sparse_format_class s)
  {
    io_control.sparse_io = s.format;
    return out_stream;
  }

  template <typename CharT, typename Traits>
  inline std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& in_stream, sparse_format_class s)
  {
    io_control.sparse_io = s.format;
    return in_stream;
  }

  template <typename CharT, typename Traits>
  inline std::basic_ostream<CharT,Traits>&
  as_dense(std::basic_ostream<CharT,Traits>& out_stream)
  {
    io_control.sparse_io = AS_DENSE;
    return out_stream;
  }

  template <typename CharT, typename Traits>
  inline std::basic_ostream<CharT,Traits>&
  as_binary(std::basic_ostream<CharT,Traits>& out_stream)
  {
    io_control.sparse_io = BINARY;
    return out_stream;
  }




  template <typename T1>
  struct is_positive_checker
  {
    T1& var;

    inline is_positive_checker(T1& v) : var(v) {}

    template <typename CharT, typename Traits>
    inline void do_check(std::basic_istream<CharT,Traits>& in_stream)
    {
      double value = 0;
      in_stream >> value;
      if (value < 0) {
        std::cout << "Value out of range: " << value
                  << " - Expected positive or zero value"
                  << std::endl;
        exit(-1);
      }
      var = (T1) value;
    }
  };

  template <typename CharT, typename Traits, typename T1>
  inline std::basic_istream<CharT,Traits>&
  operator>>(std::basic_istream<CharT,Traits>& in_stream, is_positive_checker<T1> cp)
  {
    cp.do_check(in_stream);
    return in_stream;
  }

  template <typename T1>
  inline is_positive_checker<T1> assert_positive(T1& var)
  {
    return is_positive_checker<T1>(var);
  }




  template <typename It>
  inline void binary_save(std::ostream& out_stream, It begin, It end)
  {
    typedef typename std::iterator_traits<It>::value_type value_type;
    size_t size = (size_t) (end - begin);
    if (size > 0) {
      char* ptr = (char*) & *begin;
      out_stream.write(ptr, (std::streamsize) size*sizeof(value_type));
    }
  }


  template <typename It>
  inline void binary_load(std::istream& in_stream, It begin, It end)
  {
    typedef typename std::iterator_traits<It>::value_type value_type;
    size_t size = (size_t) (end - begin);
    if (size > 0) {
      char* ptr = (char*) & *begin;
      in_stream.read(ptr, (std::streamsize) size*sizeof(value_type));
    }
  }


  template <typename T>
  inline void binary_save(std::ostream& out_stream, const std::vector<T>& v)
  {
    nta::binary_save(out_stream, v.begin(), v.end());
  }


  template <typename T>
  inline void binary_load(std::istream& in_stream, std::vector<T>& v)
  {
    nta::binary_load(in_stream, v.begin(), v.end());
  }
# 353 "/home/marek/devel/nupic/nta/math/stl_io.hpp"
  template <typename T1, typename T2>
  inline std::ostream& operator<<(std::ostream& out_stream, const std::pair<T1, T2>& p)
  {
    if (io_control.pair_paren)
      out_stream << "(";
    out_stream << p.first;
    out_stream << io_control.pair_sep;
    out_stream << p.second;
    if (io_control.pair_paren)
      out_stream << ")";
    return out_stream;
  }


  template <typename T1, typename T2>
  inline std::istream& operator>>(std::istream& in_stream, std::pair<T1, T2>& p)
  {
    in_stream >> p.first >> p.second;
    return in_stream;
  }




  template <typename T, bool>
  struct vector_loader
  {
    inline void load(size_t, std::istream&, std::vector<T>&);
  };





  template <typename T>
  struct vector_loader<T, true>
  {
    inline void load(size_t n, std::istream& in_stream, std::vector<T>& v)
    {
      if (io_control.convert_from_sparse == CSR_01) {

        std::fill(v.begin(), v.end(), (T) 0);

        for (size_t i = 0; i != n; ++i) {
          int index = 0;
          in_stream >> index;
          v[index] = (T) 1;
        }

      } else if (io_control.bit_vector) {

        for (size_t i = 0; i != n; ++i) {
          float x = 0;
          in_stream >> x;
          if (x)
            v[i] = 1;
          else
            v[i] = 0;
        }

      } else {
        for (size_t i = 0; i != n; ++i)
          in_stream >> v[i];
      }
    }
  };


  template <typename T> inline std::istream& operator>>(std::istream& in_stream, std::vector<T>& v);




  template <typename T>
  struct vector_loader<T, false>
  {
    inline void load(size_t n, std::istream& in_stream, std::vector<T>& v)
    {
      for (size_t i = 0; i != n; ++i)
        in_stream >> v[i];
    }
  };






  template <typename T>
  inline void vector_load(size_t n, std::istream& in_stream, std::vector<T>& v)
  {
    vector_loader<T, boost::is_fundamental<T>::value > loader;
    loader.load(n, in_stream, v);
  }


  template <typename T, bool>
  struct vector_saver
  {
    inline void save(size_t n, std::ostream& out_stream, const std::vector<T>& v);
  };





  template <typename T>
  struct vector_saver<T, true>
  {
    inline void save(size_t n, std::ostream& out_stream, const std::vector<T>& v)
    {
      if (io_control.output_n_elts)
        out_stream << n << ' ';

      if (io_control.abbr > 0)
        n = std::min((size_t) io_control.abbr, n);

      if (io_control.convert_to_sparse == CSR_01) {

        for (size_t i = 0; i != n; ++i)
          if (!is_zero(v[i]))
            out_stream << i << ' ';

      } else if (io_control.bit_vector) {

        size_t k = 7;
        for (size_t i = 0; i != v.size(); ++i) {
          out_stream << (is_zero(v[i]) ? '0' : '1');
          if (i == k) {
            out_stream << ' ';
            k += 8;
          }
        }

      } else {

        for (size_t i = 0; i != n; ++i)
          out_stream << v[i] << ' ';
      }

      if (io_control.abbr > 0 && n < v.size()) {
        size_t rest = v.size() - n;
        out_stream << "[+" << rest << "/" << count_non_zeros(v) << "]";
      }
    }
  };


  template <typename T> inline std::ostream& operator<<(std::ostream& out_stream, const std::vector<T>& v);




  template <typename T>
  struct vector_saver<T, false>
  {
    inline void save(size_t n, std::ostream& out_stream, const std::vector<T>& v)
    {
      if (io_control.output_n_elts)
        out_stream << n << ' ';

      if (io_control.abbr > 0)
        n = std::min((size_t) io_control.abbr, n);

      for (size_t i = 0; i != n; ++i)
        out_stream << v[i] << ' ';

      if (io_control.abbr > 0 && n < v.size()) {
        size_t rest = v.size() - n;
        out_stream << "[+" << rest << "/" << count_non_zeros(v) << "]";
      }
    }
  };






  template <typename T>
  inline void vector_save(size_t n, std::ostream& out_stream, const std::vector<T>& v)
  {
    vector_saver<T, boost::is_fundamental<T>::value> saver;
    saver.save(n, out_stream, v);
  }





  template <typename T>
  inline std::ostream& operator<<(std::ostream& out_stream, const std::vector<T>& v)
  {
    vector_save(v.size(), out_stream, v);
    return out_stream;
  }






  template <typename T>
  inline std::istream&
  operator>>(std::istream& in_stream, std::vector<T>& v)
  {
    size_t n = 0;
    in_stream >> n;
    v.resize(n);
    vector_load(n, in_stream, v);
    return in_stream;
  }





  template <typename T>
  inline std::ostream& operator<<(std::ostream& out_stream, const Buffer<T>& b)
  {
    vector_save(b.nnz, out_stream, static_cast<const std::vector<T>&>(b));
    return out_stream;
  }





  template <typename T>
  inline std::istream& operator>>(std::istream& in_stream, Buffer<T>& b)
  {
    in_stream >> b.nnz;
    if (b.nnz <= b.size()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/stl_io.hpp", 585) << "ASSERTION FAILED: \"" << "b.nnz <= b.size()" << "\" ";
    vector_load(b.nnz, in_stream, static_cast<std::vector<T>&>(b));
    return in_stream;
  }




  template <typename T1>
  inline std::ostream& operator<<(std::ostream& out_stream, const std::set<T1>& m)
  {
    typename std::set<T1>::const_iterator
      it = m.begin(), end = m.end();

    while (it != end) {
      out_stream << *it << ' ';
      ++it;
    }

    return out_stream;
  }




  template <typename T1, typename T2>
  inline std::ostream& operator<<(std::ostream& out_stream, const std::map<T1, T2>& m)
  {
    out_stream << m.size() << " ";

    typename std::map<T1, T2>::const_iterator
      it = m.begin(), end = m.end();

    while (it != end) {
      out_stream << it->first << ' ' << it->second << ' ';
      ++it;
    }

    return out_stream;
  }


  template <typename T1, typename T2>
  inline std::istream& operator>>(std::istream& in_stream, std::map<T1, T2>& m)
  {
    int size = 0;
    in_stream >> size;

    for (int i = 0; i != size; ++i) {
      T1 k; T2 v;
      in_stream >> k >> v;
      m.insert(std::make_pair(k, v));
    }

    return in_stream;
  }




  template <typename T>
  inline void show_all_differences(const std::vector<T>& x, const std::vector<T>& y)
  {
    std::vector<size_t> diffs;
    find_all_differences(x, y, diffs);
    std::cout << diffs.size() << " differences: " << std::endl;
    for (size_t i = 0; i != diffs.size(); ++i)
      std::cout << "(at:" << diffs[i]
                << " y=" << x[diffs[i]]
                << ", ans=" << y[diffs[i]] << ")";
    std::cout << std::endl;
  }


}
# 37 "/home/marek/devel/nupic/nta/algorithms/SparsePooler.hpp" 2

# 1 "/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp" 1
# 31 "/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp"
# 1 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp" 1
# 34 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdio" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdio" 3


# 1 "/usr/include/stdio.h" 1 3 4
# 29 "/usr/include/stdio.h" 3 4
extern "C" {




# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4
# 74 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 31 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 21 "/usr/include/_G_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 32 "/usr/include/libio.h" 2 3 4
# 144 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 154 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 177 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 245 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 293 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 302 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 338 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 434 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
# 464 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
# 526 "/usr/include/libio.h" 3 4
}
# 75 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 110 "/usr/include/stdio.h" 3 4
typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;
# 164 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 165 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) throw ();

extern int rename (const char *__old, const char *__new) throw ();




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) throw ();
# 195 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void) ;
# 205 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;





extern char *tmpnam_r (char *__s) throw () ;
# 227 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;
# 237 "/usr/include/stdio.h" 3 4
extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 252 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 262 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 272 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 297 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();
# 356 "/usr/include/stdio.h" 3 4
extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) throw ();





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));
# 425 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) throw ();
# 471 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
# 531 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);
# 550 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 561 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 573 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 594 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);
# 622 "/usr/include/stdio.h" 3 4
extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
          ;
# 638 "/usr/include/stdio.h" 3 4
extern char *gets (char *__s) __attribute__ ((__deprecated__));
# 649 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 665 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;
# 689 "/usr/include/stdio.h" 3 4
extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 726 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 737 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);
# 749 "/usr/include/stdio.h" 3 4
extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 773 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 798 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 818 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);




extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;




extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;
# 846 "/usr/include/stdio.h" 3 4
extern void perror (const char *__s);







# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 854 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 873 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 943 "/usr/include/stdio.h" 3 4
}
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdio" 2 3
# 93 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 149 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdio" 3
namespace __gnu_cxx
{
# 167 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
# 35 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp" 2
# 1 "/home/marek/devel/nupic/external/common/include/boost/unordered_set.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/unordered_set.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/unordered/unordered_set.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/unordered/unordered_set.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/unordered/unordered_set_fwd.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/unordered/unordered_set_fwd.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/functional/hash_fwd.hpp" 1





# 1 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/hash_fwd.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/hash_fwd.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 2 3
# 18 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/hash_fwd.hpp" 2



namespace boost
{
    template <class T> struct hash;




    template <class T> void hash_combine(std::size_t& seed, T const& v);


    template <class It> std::size_t hash_range(It, It);
    template <class It> void hash_range(std::size_t&, It, It);





}
# 6 "/home/marek/devel/nupic/external/common/include/boost/functional/hash_fwd.hpp" 2
# 16 "/home/marek/devel/nupic/external/common/include/boost/unordered/unordered_set_fwd.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/fwd.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/fwd.hpp"
namespace boost
{
namespace unordered
{
    struct piecewise_construct_t {};
    const piecewise_construct_t piecewise_construct = piecewise_construct_t();
}
}
# 17 "/home/marek/devel/nupic/external/common/include/boost/unordered/unordered_set_fwd.hpp" 2


namespace boost
{
    namespace unordered
    {
        template <class T,
            class H = boost::hash<T>,
            class P = std::equal_to<T>,
            class A = std::allocator<T> >
        class unordered_set;

        template <class T, class H, class P, class A>
        inline bool operator==(unordered_set<T, H, P, A> const&,
            unordered_set<T, H, P, A> const&);
        template <class T, class H, class P, class A>
        inline bool operator!=(unordered_set<T, H, P, A> const&,
            unordered_set<T, H, P, A> const&);
        template <class T, class H, class P, class A>
        inline void swap(unordered_set<T, H, P, A> &m1,
                unordered_set<T, H, P, A> &m2);

        template <class T,
            class H = boost::hash<T>,
            class P = std::equal_to<T>,
            class A = std::allocator<T> >
        class unordered_multiset;

        template <class T, class H, class P, class A>
        inline bool operator==(unordered_multiset<T, H, P, A> const&,
            unordered_multiset<T, H, P, A> const&);
        template <class T, class H, class P, class A>
        inline bool operator!=(unordered_multiset<T, H, P, A> const&,
            unordered_multiset<T, H, P, A> const&);
        template <class T, class H, class P, class A>
        inline void swap(unordered_multiset<T, H, P, A> &m1,
                unordered_multiset<T, H, P, A> &m2);
    }

    using boost::unordered::unordered_set;
    using boost::unordered::unordered_multiset;
    using boost::unordered::swap;
    using boost::unordered::operator==;
    using boost::unordered::operator!=;
}
# 16 "/home/marek/devel/nupic/external/common/include/boost/unordered/unordered_set.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/equivalent.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/equivalent.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/table.hpp" 1
# 10 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/table.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/buckets.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/buckets.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/util.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/util.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/iterator/iterator_categories.hpp" 1
# 11 "/home/marek/devel/nupic/external/common/include/boost/iterator/iterator_categories.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/iterator/detail/config_def.hpp" 1
# 11 "/home/marek/devel/nupic/external/common/include/boost/iterator/iterator_categories.hpp" 2






# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/placeholders.hpp" 1
# 24 "/home/marek/devel/nupic/external/common/include/boost/mpl/placeholders.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/arg.hpp" 1
# 23 "/home/marek/devel/nupic/external/common/include/boost/mpl/arg.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/arg_fwd.hpp" 1
# 21 "/home/marek/devel/nupic/external/common/include/boost/mpl/arg_fwd.hpp"
namespace mpl_ {

template< int N > struct arg;

}
namespace boost { namespace mpl { using ::mpl_::arg; } }
# 23 "/home/marek/devel/nupic/external/common/include/boost/mpl/arg.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/na_assert.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/mpl/arg.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/arity_spec.hpp" 1
# 26 "/home/marek/devel/nupic/external/common/include/boost/mpl/arg.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/arg_typedef.hpp" 1
# 27 "/home/marek/devel/nupic/external/common/include/boost/mpl/arg.hpp" 2
# 37 "/home/marek/devel/nupic/external/common/include/boost/mpl/arg.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/include_preprocessed.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/stringize.hpp" 1
# 20 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessed/gcc/arg.hpp" 1
# 13 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessed/gcc/arg.hpp"
namespace mpl_ {
template<> struct arg< -1 >
{
    static const int value = -1;



    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U1 type;
        enum { mpl_assertion_in_line_27 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<1>
{
    static const int value = 1;
    typedef arg<2> next;



    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U1 type;
        enum { mpl_assertion_in_line_45 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<2>
{
    static const int value = 2;
    typedef arg<3> next;



    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U2 type;
        enum { mpl_assertion_in_line_63 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<3>
{
    static const int value = 3;
    typedef arg<4> next;



    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U3 type;
        enum { mpl_assertion_in_line_81 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<4>
{
    static const int value = 4;
    typedef arg<5> next;



    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U4 type;
        enum { mpl_assertion_in_line_99 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<5>
{
    static const int value = 5;
    typedef arg<6> next;



    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U5 type;
        enum { mpl_assertion_in_line_117 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};



}
# 37 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "/home/marek/devel/nupic/external/common/include/boost/mpl/arg.hpp" 2
# 24 "/home/marek/devel/nupic/external/common/include/boost/mpl/placeholders.hpp" 2
# 43 "/home/marek/devel/nupic/external/common/include/boost/mpl/placeholders.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/include_preprocessed.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/include_preprocessed.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/stringize.hpp" 1
# 20 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 37 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/include_preprocessed.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessed/gcc/placeholders.hpp" 1
# 13 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/preprocessed/gcc/placeholders.hpp"
namespace mpl_ {
typedef arg< -1 > _;
}
namespace boost { namespace mpl {

using ::mpl_::_;

namespace placeholders {
using mpl_::_;
}

}}



namespace mpl_ {
typedef arg<1> _1;

}
namespace boost { namespace mpl {

using ::mpl_::_1;

namespace placeholders {
using mpl_::_1;
}

}}
namespace mpl_ {
typedef arg<2> _2;

}
namespace boost { namespace mpl {

using ::mpl_::_2;

namespace placeholders {
using mpl_::_2;
}

}}
namespace mpl_ {
typedef arg<3> _3;

}
namespace boost { namespace mpl {

using ::mpl_::_3;

namespace placeholders {
using mpl_::_3;
}

}}
namespace mpl_ {
typedef arg<4> _4;

}
namespace boost { namespace mpl {

using ::mpl_::_4;

namespace placeholders {
using mpl_::_4;
}

}}
namespace mpl_ {
typedef arg<5> _5;

}
namespace boost { namespace mpl {

using ::mpl_::_5;

namespace placeholders {
using mpl_::_5;
}

}}
namespace mpl_ {
typedef arg<6> _6;

}
namespace boost { namespace mpl {

using ::mpl_::_6;

namespace placeholders {
using mpl_::_6;
}

}}
# 37 "/home/marek/devel/nupic/external/common/include/boost/mpl/aux_/include_preprocessed.hpp" 2
# 43 "/home/marek/devel/nupic/external/common/include/boost/mpl/placeholders.hpp" 2
# 17 "/home/marek/devel/nupic/external/common/include/boost/iterator/iterator_categories.hpp" 2







namespace boost {





struct no_traversal_tag {};

struct incrementable_traversal_tag
  : no_traversal_tag
{


};

struct single_pass_traversal_tag
  : incrementable_traversal_tag
{


};

struct forward_traversal_tag
  : single_pass_traversal_tag
{


};

struct bidirectional_traversal_tag
  : forward_traversal_tag
{


};

struct random_access_traversal_tag
  : bidirectional_traversal_tag
{


};

namespace detail
{






  template <class Cat>
  struct old_category_to_traversal
    : mpl::eval_if<
          is_convertible<Cat,std::random_access_iterator_tag>
        , mpl::identity<random_access_traversal_tag>
        , mpl::eval_if<
              is_convertible<Cat,std::bidirectional_iterator_tag>
            , mpl::identity<bidirectional_traversal_tag>
            , mpl::eval_if<
                  is_convertible<Cat,std::forward_iterator_tag>
                , mpl::identity<forward_traversal_tag>
                , mpl::eval_if<
                      is_convertible<Cat,std::input_iterator_tag>
                    , mpl::identity<single_pass_traversal_tag>
                    , mpl::eval_if<
                          is_convertible<Cat,std::output_iterator_tag>
                        , mpl::identity<incrementable_traversal_tag>
                        , void
                      >
                  >
              >
          >
      >
  {};
# 108 "/home/marek/devel/nupic/external/common/include/boost/iterator/iterator_categories.hpp"
  template <class Traversal>
  struct pure_traversal_tag
    : mpl::eval_if<
          is_convertible<Traversal,random_access_traversal_tag>
        , mpl::identity<random_access_traversal_tag>
        , mpl::eval_if<
              is_convertible<Traversal,bidirectional_traversal_tag>
            , mpl::identity<bidirectional_traversal_tag>
            , mpl::eval_if<
                  is_convertible<Traversal,forward_traversal_tag>
                , mpl::identity<forward_traversal_tag>
                , mpl::eval_if<
                      is_convertible<Traversal,single_pass_traversal_tag>
                    , mpl::identity<single_pass_traversal_tag>
                    , mpl::eval_if<
                          is_convertible<Traversal,incrementable_traversal_tag>
                        , mpl::identity<incrementable_traversal_tag>
                        , void
                      >
                  >
              >
          >
      >
  {
  };
# 142 "/home/marek/devel/nupic/external/common/include/boost/iterator/iterator_categories.hpp"
}





template <class Cat>
struct iterator_category_to_traversal
  : mpl::eval_if<
        is_convertible<Cat,incrementable_traversal_tag>
      , mpl::identity<Cat>
      , boost::detail::old_category_to_traversal<Cat>
    >
{};


template <class Iterator = mpl::_1>
struct iterator_traversal
  : iterator_category_to_traversal<
        typename boost::detail::iterator_traits<Iterator>::iterator_category
    >
{};
# 184 "/home/marek/devel/nupic/external/common/include/boost/iterator/iterator_categories.hpp"
}


# 1 "/home/marek/devel/nupic/external/common/include/boost/iterator/detail/config_undef.hpp" 1
# 186 "/home/marek/devel/nupic/external/common/include/boost/iterator/iterator_categories.hpp" 2
# 16 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/util.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/detail/select_type.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/detail/select_type.hpp"
namespace boost { namespace detail {






  template <bool b> struct if_true
  {
      template <class T, class F>
      struct then { typedef T type; };
  };

  template <>
  struct if_true<false>
  {
      template <class T, class F>
      struct then { typedef F type; };
  };
}}
# 18 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/util.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/move/move.hpp" 1
# 67 "/home/marek/devel/nupic/external/common/include/boost/move/move.hpp"
   namespace boost {
   namespace move_detail {


   template<bool C, typename T1, typename T2>
   struct if_c
   {
       typedef T1 type;
   };

   template<typename T1, typename T2>
   struct if_c<false,T1,T2>
   {
       typedef T2 type;
   };

   template<typename T1, typename T2, typename T3>
   struct if_
   {
      typedef typename if_c<0 != T1::value, T2, T3>::type type;
   };


   template <bool B, class T = void>
   struct enable_if_c
   {
      typedef T type;
   };

   template <class T>
   struct enable_if_c<false, T> {};

   template <class Cond, class T = void>
   struct enable_if : public enable_if_c<Cond::value, T> {};

   template <class Cond, class T = void>
   struct disable_if : public enable_if_c<!Cond::value, T> {};


   template<class T, T v>
   struct integral_constant
   {
      static const T value = v;
      typedef T value_type;
      typedef integral_constant<T, v> type;
   };


   template <class T>
   struct identity
   {
      typedef T type;
   };


   template <class T, class U>
   class is_convertible
   {
      typedef char true_t;
      class false_t { char dummy[2]; };
      static true_t dispatch(U);
      static false_t dispatch(...);
      static T &trigger();
      public:
      enum { value = sizeof(dispatch(trigger())) == sizeof(true_t) };
   };


   template <typename Condition1, typename Condition2, typename Condition3 = integral_constant<bool, true> >
     struct and_
       : public integral_constant<bool, Condition1::value && Condition2::value && Condition3::value>
   {};

   template <typename Boolean>
     struct not_
       : public integral_constant<bool, !Boolean::value>
   {};


   template<class T>
   struct is_lvalue_reference
      : public integral_constant<bool, false>
   {};

   template<class T>
   struct is_lvalue_reference<T&>
      : public integral_constant<bool, true>
   {};


   template<class T>
   struct has_trivial_destructor
      : public integral_constant<bool, false>
   {};


   template<class T> struct addr_impl_ref
   {
      T & v_;
      inline addr_impl_ref( T & v ): v_( v ) {}
      inline operator T& () const { return v_; }

      private:
      addr_impl_ref & operator=(const addr_impl_ref &);
   };

   template<class T> struct addressof_impl
   {
      static inline T * f( T & v, long )
      {
         return reinterpret_cast<T*>(
            &const_cast<char&>(reinterpret_cast<const volatile char &>(v)));
      }

      static inline T * f( T * v, int )
      { return v; }
   };

   template<class T>
   inline T * addressof( T & v )
   {
      return ::boost::move_detail::addressof_impl<T>::f
         ( ::boost::move_detail::addr_impl_ref<T>( v ), 0 );
   }

   }
   }
# 226 "/home/marek/devel/nupic/external/common/include/boost/move/move.hpp"
   namespace boost {

   namespace move_detail {
      template<class T>
      struct is_class_or_union
      {
         struct twochar { char _[2]; };
         template <class U>
         static char is_class_or_union_tester(void(U::*)(void));
         template <class U>
         static twochar is_class_or_union_tester(...);
         static const bool value = sizeof(is_class_or_union_tester<T>(0)) == sizeof(char);
      };
      struct empty{};
   }






   template <class T>
   class rv
      : public ::boost::move_detail::if_c
         < ::boost::move_detail::is_class_or_union<T>::value
         , T
         , ::boost::move_detail::empty
         >::type
   {
      rv();
      ~rv();
      rv(rv const&);
      void operator=(rv const&);
   } __attribute__((__may_alias__));
# 269 "/home/marek/devel/nupic/external/common/include/boost/move/move.hpp"
   namespace move_detail {

   template <class T>
   struct is_rv
      : ::boost::move_detail::integral_constant<bool, false>
   {};

   template <class T>
   struct is_rv< rv<T> >
      : ::boost::move_detail::integral_constant<bool, true>
   {};

   template <class T>
   struct is_rv< const rv<T> >
      : ::boost::move_detail::integral_constant<bool, true>
   {};

   }






   template<class T>
   struct has_move_emulation_enabled
      : ::boost::move_detail::is_convertible< T, ::boost::rv<T>& >
   {};

   template<class T>
   struct has_move_emulation_enabled<T&>
      : ::boost::move_detail::integral_constant<bool, false>
   {};

   template<class T>
   struct has_move_emulation_enabled< ::boost::rv<T> >
      : ::boost::move_detail::integral_constant<bool, false>
   {};

   template <class T>
   struct has_move_emulation_enabled_aux
     : has_move_emulation_enabled<T> {};

   template <class T>
   struct has_nothrow_move
      : public ::boost::move_detail::integral_constant<bool, false>
   {};







   template <class T>
   inline typename ::boost::move_detail::disable_if<has_move_emulation_enabled_aux<T>, T&>::type move(T& x)
   {
      return x;
   }

   template <class T>
   inline typename ::boost::move_detail::enable_if<has_move_emulation_enabled<T>, rv<T>&>::type move(T& x)
   {
      return *static_cast<rv<T>* >(::boost::move_detail::addressof(x));
   }

   template <class T>
   inline typename ::boost::move_detail::enable_if<has_move_emulation_enabled<T>, rv<T>&>::type move(rv<T>& x)
   {
      return x;
   }
# 397 "/home/marek/devel/nupic/external/common/include/boost/move/move.hpp"
   template <class T>
   inline typename ::boost::move_detail::enable_if< ::boost::move_detail::is_rv<T>, T &>::type
      forward(const typename ::boost::move_detail::identity<T>::type &x)
   {
      return const_cast<T&>(x);
   }

   template <class T>
   inline typename ::boost::move_detail::disable_if< ::boost::move_detail::is_rv<T>, const T &>::type
      forward(const typename ::boost::move_detail::identity<T>::type &x)
   {
      return x;
   }
# 455 "/home/marek/devel/nupic/external/common/include/boost/move/move.hpp"
   }
# 650 "/home/marek/devel/nupic/external/common/include/boost/move/move.hpp"
namespace boost {
# 663 "/home/marek/devel/nupic/external/common/include/boost/move/move.hpp"
template <class It>
class move_iterator
{
   public:
   typedef It iterator_type;
   typedef typename std::iterator_traits<iterator_type>::value_type value_type;



   typedef typename ::boost::move_detail::if_
      < ::boost::has_move_emulation_enabled<value_type>
      , ::boost::rv<value_type>&
      , value_type & >::type reference;

   typedef It pointer;
   typedef typename std::iterator_traits<iterator_type>::difference_type difference_type;
   typedef typename std::iterator_traits<iterator_type>::iterator_category iterator_category;

   move_iterator()
   {}

   explicit move_iterator(It i)
      : m_it(i)
   {}

   template <class U>
   move_iterator(const move_iterator<U>& u)
      : m_it(u.base())
   {}

   iterator_type base() const
   { return m_it; }

   reference operator*() const
   {

      return *m_it;



   }

   pointer operator->() const
   { return m_it; }

   move_iterator& operator++()
   { ++m_it; return *this; }

   move_iterator<iterator_type> operator++(int)
   { move_iterator<iterator_type> tmp(*this); ++(*this); return tmp; }

   move_iterator& operator--()
   { --m_it; return *this; }

   move_iterator<iterator_type> operator--(int)
   { move_iterator<iterator_type> tmp(*this); --(*this); return tmp; }

   move_iterator<iterator_type> operator+ (difference_type n) const
   { return move_iterator<iterator_type>(m_it + n); }

   move_iterator& operator+=(difference_type n)
   { m_it += n; return *this; }

   move_iterator<iterator_type> operator- (difference_type n) const
   { return move_iterator<iterator_type>(m_it - n); }

   move_iterator& operator-=(difference_type n)
   { m_it -= n; return *this; }

   reference operator[](difference_type n) const
   {

      return m_it[n];



   }

   friend bool operator==(const move_iterator& x, const move_iterator& y)
   { return x.base() == y.base(); }

   friend bool operator!=(const move_iterator& x, const move_iterator& y)
   { return x.base() != y.base(); }

   friend bool operator< (const move_iterator& x, const move_iterator& y)
   { return x.base() < y.base(); }

   friend bool operator<=(const move_iterator& x, const move_iterator& y)
   { return x.base() <= y.base(); }

   friend bool operator> (const move_iterator& x, const move_iterator& y)
   { return x.base() > y.base(); }

   friend bool operator>=(const move_iterator& x, const move_iterator& y)
   { return x.base() >= y.base(); }

   friend difference_type operator-(const move_iterator& x, const move_iterator& y)
   { return x.base() - y.base(); }

   friend move_iterator operator+(difference_type n, const move_iterator& x)
   { return move_iterator(x.base() + n); }

   private:
   It m_it;
};



namespace move_detail {

template <class I>
struct is_move_iterator
   : public ::boost::move_detail::integral_constant<bool, false>
{
};

template <class I>
struct is_move_iterator< ::boost::move_iterator<I> >
   : public ::boost::move_detail::integral_constant<bool, true>
{
};

}
# 795 "/home/marek/devel/nupic/external/common/include/boost/move/move.hpp"
template<class It>
inline move_iterator<It> make_move_iterator(const It &it)
{ return move_iterator<It>(it); }
# 808 "/home/marek/devel/nupic/external/common/include/boost/move/move.hpp"
template <typename C>
class back_move_insert_iterator
   : public std::iterator<std::output_iterator_tag, void, void, void, void>
{
   C* container_m;

   public:
   typedef C container_type;
   typedef typename C::value_type value_type;
   typedef typename C::reference reference;

   explicit back_move_insert_iterator(C& x) : container_m(&x) { }

   back_move_insert_iterator& operator=(reference x)
   { container_m->push_back(boost::move(x)); return *this; }

   back_move_insert_iterator& operator=(::boost::rv< value_type >& x)
   { reference rx = x; return this->operator=(rx); }

   back_move_insert_iterator& operator*() { return *this; }
   back_move_insert_iterator& operator++() { return *this; }
   back_move_insert_iterator& operator++(int) { return *this; }
};



template <typename C>
inline back_move_insert_iterator<C> back_move_inserter(C& x)
{
   return back_move_insert_iterator<C>(x);
}
# 848 "/home/marek/devel/nupic/external/common/include/boost/move/move.hpp"
template <typename C>
class front_move_insert_iterator
   : public std::iterator<std::output_iterator_tag, void, void, void, void>
{
   C* container_m;

public:
   typedef C container_type;
   typedef typename C::value_type value_type;
   typedef typename C::reference reference;

   explicit front_move_insert_iterator(C& x) : container_m(&x) { }

   front_move_insert_iterator& operator=(reference x)
   { container_m->push_front(boost::move(x)); return *this; }

   front_move_insert_iterator& operator=(::boost::rv< value_type >& x)
   { reference rx = x; return this->operator=(rx); }

   front_move_insert_iterator& operator*() { return *this; }
   front_move_insert_iterator& operator++() { return *this; }
   front_move_insert_iterator& operator++(int) { return *this; }
};



template <typename C>
inline front_move_insert_iterator<C> front_move_inserter(C& x)
{
   return front_move_insert_iterator<C>(x);
}






template <typename C>
class move_insert_iterator
   : public std::iterator<std::output_iterator_tag, void, void, void, void>
{
   C* container_m;
   typename C::iterator pos_;

   public:
   typedef C container_type;
   typedef typename C::value_type value_type;
   typedef typename C::reference reference;

   explicit move_insert_iterator(C& x, typename C::iterator pos)
      : container_m(&x), pos_(pos)
   {}

   move_insert_iterator& operator=(reference x)
   {
      pos_ = container_m->insert(pos_, ::boost::move(x));
      ++pos_;
      return *this;
   }

   move_insert_iterator& operator=(::boost::rv< value_type >& x)
   { reference rx = x; return this->operator=(rx); }

   move_insert_iterator& operator*() { return *this; }
   move_insert_iterator& operator++() { return *this; }
   move_insert_iterator& operator++(int) { return *this; }
};



template <typename C>
inline move_insert_iterator<C> move_inserter(C& x, typename C::iterator it)
{
   return move_insert_iterator<C>(x, it);
}
# 941 "/home/marek/devel/nupic/external/common/include/boost/move/move.hpp"
   template <typename I,
            typename O>
   O move(I f, I l, O result)
   {
      while (f != l) {
         *result = ::boost::move(*f);
         ++f; ++result;
      }
      return result;
   }
# 968 "/home/marek/devel/nupic/external/common/include/boost/move/move.hpp"
   template <typename I,
   typename O>
   O move_backward(I f, I l, O result)
   {
      while (f != l) {
         --l; --result;
         *result = ::boost::move(*l);
      }
      return result;
   }
# 995 "/home/marek/devel/nupic/external/common/include/boost/move/move.hpp"
template
   <typename I,
    typename F>
F uninitialized_move(I f, I l, F r



   )
{
   typedef typename std::iterator_traits<I>::value_type input_value_type;
   while (f != l) {
      ::new(static_cast<void*>(&*r)) input_value_type(boost::move(*f));
      ++f; ++r;
   }
   return r;
}
# 1030 "/home/marek/devel/nupic/external/common/include/boost/move/move.hpp"
namespace move_detail {

template
<typename I,
typename F>
inline F uninitialized_move_move_iterator(I f, I l, F r

)
{
   return ::boost::uninitialized_move(f, l, r);
}
# 1051 "/home/marek/devel/nupic/external/common/include/boost/move/move.hpp"
}

template
<typename I,
typename F>
inline F uninitialized_copy_or_move(I f, I l, F r,
                             typename ::boost::move_detail::enable_if< move_detail::is_move_iterator<I> >::type* = 0)
{
   return ::boost::move_detail::uninitialized_move_move_iterator(f, l, r);
}







namespace move_detail {

template
<typename I,
typename F>
inline F move_move_iterator(I f, I l, F r

)
{
   return ::boost::move(f, l, r);
}
# 1090 "/home/marek/devel/nupic/external/common/include/boost/move/move.hpp"
}

template
<typename I,
typename F>
inline F copy_or_move(I f, I l, F r,
                             typename ::boost::move_detail::enable_if< move_detail::is_move_iterator<I> >::type* = 0)
{
   return ::boost::move_detail::move_move_iterator(f, l, r);
}
# 1115 "/home/marek/devel/nupic/external/common/include/boost/move/move.hpp"
template
<typename I,
typename F>
inline F uninitialized_copy_or_move(I f, I l, F r

   ,typename ::boost::move_detail::disable_if< move_detail::is_move_iterator<I> >::type* = 0

   )
{
   return std::uninitialized_copy(f, l, r);
}
# 1138 "/home/marek/devel/nupic/external/common/include/boost/move/move.hpp"
template
<typename I,
typename F>
inline F copy_or_move(I f, I l, F r

   ,typename ::boost::move_detail::disable_if< move_detail::is_move_iterator<I> >::type* = 0

   )
{
   return std::copy(f, l, r);
}
# 1159 "/home/marek/devel/nupic/external/common/include/boost/move/move.hpp"
template <class T>
struct has_trivial_destructor_after_move
   : ::boost::move_detail::has_trivial_destructor<T>
{};



namespace move_detail {






   template< class T>
   struct forward_type
   { typedef const T &type; };

   template< class T>
   struct forward_type< boost::rv<T> >
   { typedef T type; };






template< class T > struct is_rvalue_reference : ::boost::move_detail::integral_constant<bool, false> { };



   template< class T > struct is_rvalue_reference< boost::rv<T>& >
      : ::boost::move_detail::integral_constant<bool, true>
   {};

   template< class T > struct is_rvalue_reference< const boost::rv<T>& >
      : ::boost::move_detail::integral_constant<bool, true>
   {};





   namespace detail_add_rvalue_reference
   {
      template< class T
              , bool emulation = ::boost::has_move_emulation_enabled<T>::value
              , bool rv = ::boost::move_detail::is_rv<T>::value >
      struct add_rvalue_reference_impl { typedef T type; };

      template< class T, bool emulation>
      struct add_rvalue_reference_impl< T, emulation, true > { typedef T & type; };

      template< class T, bool rv >
      struct add_rvalue_reference_impl< T, true, rv > { typedef ::boost::rv<T>& type; };
   }

   template< class T >
   struct add_rvalue_reference
      : detail_add_rvalue_reference::add_rvalue_reference_impl<T>
   { };

   template< class T >
   struct add_rvalue_reference<T &>
   { typedef T & type; };



template< class T > struct remove_rvalue_reference { typedef T type; };




   template< class T > struct remove_rvalue_reference< rv<T> > { typedef T type; };
   template< class T > struct remove_rvalue_reference< const rv<T> > { typedef T type; };
   template< class T > struct remove_rvalue_reference< volatile rv<T> > { typedef T type; };
   template< class T > struct remove_rvalue_reference< const volatile rv<T> > { typedef T type; };
   template< class T > struct remove_rvalue_reference< rv<T>& > { typedef T type; };
   template< class T > struct remove_rvalue_reference< const rv<T>& > { typedef T type; };
   template< class T > struct remove_rvalue_reference< volatile rv<T>& > { typedef T type; };
   template< class T > struct remove_rvalue_reference< const volatile rv<T>& >{ typedef T type; };


template <typename T>
typename boost::move_detail::add_rvalue_reference<T>::type declval();

}
# 1258 "/home/marek/devel/nupic/external/common/include/boost/move/move.hpp"
}
# 19 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/util.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/size.hpp" 1
# 20 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/util.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/seq/enum.hpp" 1
# 21 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/util.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/swap.hpp" 1
# 10 "/home/marek/devel/nupic/external/common/include/boost/swap.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/utility/swap.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/utility/swap.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 2 3
# 25 "/home/marek/devel/nupic/external/common/include/boost/utility/swap.hpp" 2


namespace boost_swap_impl
{
  template<class T>
  void swap_impl(T& left, T& right)
  {
    using namespace std;
    swap(left,right);
  }

  template<class T, std::size_t N>
  void swap_impl(T (& left)[N], T (& right)[N])
  {
    for (std::size_t i = 0; i < N; ++i)
    {
      ::boost_swap_impl::swap_impl(left[i], right[i]);
    }
  }
}

namespace boost
{
  template<class T1, class T2>
  void swap(T1& left, T2& right)
  {
    ::boost_swap_impl::swap_impl(left, right);
  }
}
# 10 "/home/marek/devel/nupic/external/common/include/boost/swap.hpp" 2
# 22 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/util.hpp" 2


namespace boost { namespace unordered { namespace detail {

    static const float minimum_max_load_factor = 1e-3f;
    static const std::size_t default_bucket_count = 11;
    struct move_tag {};
    struct empty_emplace {};




    template <typename I>
    struct is_forward :
        boost::is_convertible<
            typename boost::iterator_traversal<I>::type,
            boost::forward_traversal_tag>
    {};

    template <typename I, typename ReturnType>
    struct enable_if_forward :
        boost::enable_if_c<
            boost::unordered::detail::is_forward<I>::value,
            ReturnType>
    {};

    template <typename I, typename ReturnType>
    struct disable_if_forward :
        boost::disable_if_c<
            boost::unordered::detail::is_forward<I>::value,
            ReturnType>
    {};
# 67 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/util.hpp"
    template<class T> struct prime_list_template
    {
        static std::size_t const value[];


        static std::ptrdiff_t const length;




    };

    template<class T>
    std::size_t const prime_list_template<T>::value[] = {
        17ul, 29ul, 37ul, 53ul, 67ul, 79ul, 97ul, 131ul, 193ul, 257ul, 389ul, 521ul, 769ul, 1031ul, 1543ul, 2053ul, 3079ul, 6151ul, 12289ul, 24593ul, 49157ul, 98317ul, 196613ul, 393241ul, 786433ul, 1572869ul, 3145739ul, 6291469ul, 12582917ul, 25165843ul, 50331653ul, 100663319ul, 201326611ul, 402653189ul, 805306457ul, 1610612741ul, 3221225473ul, 4294967291ul
    };


    template<class T>
    std::ptrdiff_t const prime_list_template<T>::length
        = 38;




    typedef prime_list_template<std::size_t> prime_list;


    inline std::size_t next_prime(std::size_t num) {
        std::size_t const* const prime_list_begin = prime_list::value;
        std::size_t const* const prime_list_end = prime_list_begin +
            prime_list::length;
        std::size_t const* bound =
            std::lower_bound(prime_list_begin, prime_list_end, num);
        if(bound == prime_list_end)
            bound--;
        return *bound;
    }


    inline std::size_t prev_prime(std::size_t num) {
        std::size_t const* const prime_list_begin = prime_list::value;
        std::size_t const* const prime_list_end = prime_list_begin +
            prime_list::length;
        std::size_t const* bound =
            std::upper_bound(prime_list_begin,prime_list_end, num);
        if(bound != prime_list_begin)
            bound--;
        return *bound;
    }






    using ::std::distance;
# 136 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/util.hpp"
    template <class I>
    inline typename
        boost::unordered::detail::enable_if_forward<I, std::size_t>::type
        insert_size(I i, I j)
    {
        return std::distance(i, j);
    }

    template <class I>
    inline typename
        boost::unordered::detail::disable_if_forward<I, std::size_t>::type
        insert_size(I, I)
    {
        return 1;
    }

    template <class I>
    inline std::size_t initial_size(I i, I j,
        std::size_t num_buckets =
            boost::unordered::detail::default_bucket_count)
    {

        return (std::max)(
            boost::unordered::detail::insert_size(i, j) + 1,
            num_buckets);
    }




    template <typename T, int Index>
    struct compressed_base : private T
    {
        compressed_base(T const& x) : T(x) {}
        compressed_base(T& x, move_tag) : T(boost::move(x)) {}

        T& get() { return *this; }
        T const& get() const { return *this; }
    };

    template <typename T, int Index>
    struct uncompressed_base
    {
        uncompressed_base(T const& x) : value_(x) {}
        uncompressed_base(T& x, move_tag) : value_(boost::move(x)) {}

        T& get() { return value_; }
        T const& get() const { return value_; }
    private:
        T value_;
    };

    template <typename T, int Index>
    struct generate_base
      : boost::detail::if_true<
            boost::is_empty<T>::value
        >:: template then<
            boost::unordered::detail::compressed_base<T, Index>,
            boost::unordered::detail::uncompressed_base<T, Index>
        >
    {};

    template <typename T1, typename T2>
    struct compressed
      : private boost::unordered::detail::generate_base<T1, 1>::type,
        private boost::unordered::detail::generate_base<T2, 2>::type
    {
        typedef typename generate_base<T1, 1>::type base1;
        typedef typename generate_base<T2, 2>::type base2;

        typedef T1 first_type;
        typedef T2 second_type;

        first_type& first() {
            return static_cast<base1*>(this)->get();
        }

        first_type const& first() const {
            return static_cast<base1 const*>(this)->get();
        }

        second_type& second() {
            return static_cast<base2*>(this)->get();
        }

        second_type const& second() const {
            return static_cast<base2 const*>(this)->get();
        }

        template <typename First, typename Second>
        compressed(First const& x1, Second const& x2)
            : base1(x1), base2(x2) {}

        compressed(compressed const& x)
            : base1(x.first()), base2(x.second()) {}

        compressed(compressed& x, move_tag m)
            : base1(x.first(), m), base2(x.second(), m) {}

        void assign(compressed const& x)
        {
            first() = x.first();
            second() = x.second();
        }

        void move_assign(compressed& x)
        {
            first() = boost::move(x.first());
            second() = boost::move(x.second());
        }

        void swap(compressed& x)
        {
            boost::swap(first(), x.first());
            boost::swap(second(), x.second());
        }

    private:


        compressed& operator=(compressed const&);
    };
}}}
# 14 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/buckets.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/inc.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/dec.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/dec.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/arithmetic/dec.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/dec.hpp" 2
# 20 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/enum.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/enum.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/enum.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/enum.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/debug/error.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/enum.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/auto_rec.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/auto_rec.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/auto_rec.hpp" 2
# 20 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/enum.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/punctuation/comma_if.hpp" 1
# 21 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/enum.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/repeat.hpp" 1
# 22 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/enum.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/elem.hpp" 1
# 23 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/enum.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/rem.hpp" 1
# 24 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/enum.hpp" 2
# 21 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/enum_params.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/enum_params.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/enum_params.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/punctuation/comma_if.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/enum_params.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/repeat.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/enum_params.hpp" 2
# 22 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/enum_binary_params.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/enum_binary_params.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/enum_binary_params.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/enum_binary_params.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/punctuation/comma_if.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/enum_binary_params.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/repeat.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/enum_binary_params.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/elem.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/enum_binary_params.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/rem.hpp" 1
# 20 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/enum_binary_params.hpp" 2
# 23 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/repeat_from_to.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/repeat_from_to.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/arithmetic/add.hpp" 1
# 17 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/repeat_from_to.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/arithmetic/sub.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/repeat_from_to.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/cat.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/repeat_from_to.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 20 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/repeat_from_to.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/control/while.hpp" 1
# 21 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/repeat_from_to.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/debug/error.hpp" 1
# 22 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/repeat_from_to.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/auto_rec.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/auto_rec.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/config/config.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/detail/auto_rec.hpp" 2
# 23 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/repeat_from_to.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/repeat.hpp" 1
# 24 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/repeat_from_to.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/elem.hpp" 1
# 25 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/repeat_from_to.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/tuple/rem.hpp" 1
# 26 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/repeat_from_to.hpp" 2
# 24 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp" 2



# 1 "/home/marek/devel/nupic/external/common/include/boost/tuple/tuple.hpp" 1
# 32 "/home/marek/devel/nupic/external/common/include/boost/tuple/tuple.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/ref.hpp" 1
# 11 "/home/marek/devel/nupic/external/common/include/boost/ref.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/utility/addressof.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/utility/addressof.hpp"
namespace boost
{

namespace detail
{

template<class T> struct addr_impl_ref
{
    T & v_;

    inline addr_impl_ref( T & v ): v_( v ) {}
    inline operator T& () const { return v_; }

private:
    addr_impl_ref & operator=(const addr_impl_ref &);
};

template<class T> struct addressof_impl
{
    static inline T * f( T & v, long )
    {
        return reinterpret_cast<T*>(
            &const_cast<char&>(reinterpret_cast<const volatile char &>(v)));
    }

    static inline T * f( T * v, int )
    {
        return v;
    }
};

}

template<class T> T * addressof( T & v )
{






    return boost::detail::addressof_impl<T>::f( boost::detail::addr_impl_ref<T>( v ), 0 );


}
# 100 "/home/marek/devel/nupic/external/common/include/boost/utility/addressof.hpp"
}
# 11 "/home/marek/devel/nupic/external/common/include/boost/ref.hpp" 2
# 29 "/home/marek/devel/nupic/external/common/include/boost/ref.hpp"
namespace boost
{

template<class T> class reference_wrapper
{
public:
    typedef T type;







    explicit reference_wrapper(T& t): t_(boost::addressof(t)) {}



    operator T& () const { return *t_; }

    T& get() const { return *t_; }

    T* get_pointer() const { return t_; }

private:

    T* t_;
};







template<class T> inline reference_wrapper<T> const ref(T & t)
{
    return reference_wrapper<T>(t);
}

template<class T> inline reference_wrapper<T const> const cref(T const & t)
{
    return reference_wrapper<T const>(t);
}





template<typename T>
class is_reference_wrapper
    : public mpl::false_
{
};

template<typename T>
class unwrap_reference
{
 public:
    typedef T type;
};
# 106 "/home/marek/devel/nupic/external/common/include/boost/ref.hpp"
template<typename T> class is_reference_wrapper< reference_wrapper<T> > : public mpl::true_ { }; template<typename T> class unwrap_reference< reference_wrapper<T> > { public: typedef T type; };

template<typename T> class is_reference_wrapper< reference_wrapper<T> const > : public mpl::true_ { }; template<typename T> class unwrap_reference< reference_wrapper<T> const > { public: typedef T type; };
template<typename T> class is_reference_wrapper< reference_wrapper<T> volatile > : public mpl::true_ { }; template<typename T> class unwrap_reference< reference_wrapper<T> volatile > { public: typedef T type; };
template<typename T> class is_reference_wrapper< reference_wrapper<T> const volatile > : public mpl::true_ { }; template<typename T> class unwrap_reference< reference_wrapper<T> const volatile > { public: typedef T type; };
# 176 "/home/marek/devel/nupic/external/common/include/boost/ref.hpp"
template <class T> inline typename unwrap_reference<T>::type&
unwrap_ref(T& t)
{
    return t;
}

template<class T> inline T* get_pointer( reference_wrapper<T> const & r )
{
    return r.get_pointer();
}

}
# 32 "/home/marek/devel/nupic/external/common/include/boost/tuple/tuple.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/tuple/detail/tuple_basic.hpp" 1
# 38 "/home/marek/devel/nupic/external/common/include/boost/tuple/detail/tuple_basic.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/type_traits/cv_traits.hpp" 1
# 38 "/home/marek/devel/nupic/external/common/include/boost/tuple/detail/tuple_basic.hpp" 2






namespace boost {
namespace tuples {


struct null_type {};


namespace detail {
  inline const null_type cnull() { return null_type(); }





template <bool If, class Then, class Else> struct IF { typedef Then RET; };

template <class Then, class Else> struct IF<false, Then, Else> {
  typedef Else RET;
};

}


template <class HT, class TT> struct cons;



template <
  class T0 = null_type, class T1 = null_type, class T2 = null_type,
  class T3 = null_type, class T4 = null_type, class T5 = null_type,
  class T6 = null_type, class T7 = null_type, class T8 = null_type,
  class T9 = null_type>
class tuple;


template<class T> struct length;



namespace detail {



template<class T>
class generate_error;

template<int N>
struct drop_front {
    template<class Tuple>
    struct apply {
        typedef typename drop_front<N-1>::template
            apply<Tuple> next;
        typedef typename next::type::tail_type type;
        static const type& call(const Tuple& tup) {
            return next::call(tup).tail;
        }
    };
};

template<>
struct drop_front<0> {
    template<class Tuple>
    struct apply {
        typedef Tuple type;
        static const type& call(const Tuple& tup) {
            return tup;
        }
    };
};

}
# 124 "/home/marek/devel/nupic/external/common/include/boost/tuple/detail/tuple_basic.hpp"
template<int N, class T>
struct element
{
  typedef typename detail::drop_front<N>::template
      apply<T>::type::head_type type;
};

template<int N, class T>
struct element<N, const T>
{
private:
  typedef typename detail::drop_front<N>::template
      apply<T>::type::head_type unqualified_type;
public:



  typedef typename boost::add_const<unqualified_type>::type type;

};
# 184 "/home/marek/devel/nupic/external/common/include/boost/tuple/detail/tuple_basic.hpp"
template <class T> struct access_traits {
  typedef const T& const_type;
  typedef T& non_const_type;

  typedef const typename boost::remove_cv<T>::type& parameter_type;






};

template <class T> struct access_traits<T&> {

  typedef T& const_type;
  typedef T& non_const_type;

  typedef T& parameter_type;
};



template<int N, class HT, class TT>
inline typename access_traits<
                  typename element<N, cons<HT, TT> >::type
                >::non_const_type
get(cons<HT, TT>& c ) {
  typedef typename detail::drop_front<N>::template
      apply<cons<HT, TT> > impl;
  typedef typename impl::type cons_element;
  return const_cast<cons_element&>(impl::call(c)).head;
}




template<int N, class HT, class TT>
inline typename access_traits<
                  typename element<N, cons<HT, TT> >::type
                >::const_type
get(const cons<HT, TT>& c ) {
  typedef typename detail::drop_front<N>::template
      apply<cons<HT, TT> > impl;
  typedef typename impl::type cons_element;
  return impl::call(c).head;
}


namespace detail {







template <class T> class non_storeable_type {
  non_storeable_type();
};

template <class T> struct wrap_non_storeable_type {
  typedef typename IF<
    ::boost::is_function<T>::value, non_storeable_type<T>, T
  >::RET type;
};
template <> struct wrap_non_storeable_type<void> {
  typedef non_storeable_type<void> type;
};

}

template <class HT, class TT>
struct cons {

  typedef HT head_type;
  typedef TT tail_type;

  typedef typename
    detail::wrap_non_storeable_type<head_type>::type stored_head_type;

  stored_head_type head;
  tail_type tail;

  typename access_traits<stored_head_type>::non_const_type
  get_head() { return head; }

  typename access_traits<tail_type>::non_const_type
  get_tail() { return tail; }

  typename access_traits<stored_head_type>::const_type
  get_head() const { return head; }

  typename access_traits<tail_type>::const_type
  get_tail() const { return tail; }

  cons() : head(), tail() {}







  cons(typename access_traits<stored_head_type>::parameter_type h,
       const tail_type& t)
    : head (h), tail(t) {}

  template <class T1, class T2, class T3, class T4, class T5,
            class T6, class T7, class T8, class T9, class T10>
  cons( T1& t1, T2& t2, T3& t3, T4& t4, T5& t5,
        T6& t6, T7& t7, T8& t8, T9& t9, T10& t10 )
    : head (t1),
      tail (t2, t3, t4, t5, t6, t7, t8, t9, t10, detail::cnull())
      {}

  template <class T2, class T3, class T4, class T5,
            class T6, class T7, class T8, class T9, class T10>
  cons( const null_type& , T2& t2, T3& t3, T4& t4, T5& t5,
        T6& t6, T7& t7, T8& t8, T9& t9, T10& t10 )
    : head (),
      tail (t2, t3, t4, t5, t6, t7, t8, t9, t10, detail::cnull())
      {}


  template <class HT2, class TT2>
  cons( const cons<HT2, TT2>& u ) : head(u.head), tail(u.tail) {}

  template <class HT2, class TT2>
  cons& operator=( const cons<HT2, TT2>& u ) {
    head=u.head; tail=u.tail; return *this;
  }



  cons& operator=(const cons& u) {
    head = u.head; tail = u.tail; return *this;
  }

  template <class T1, class T2>
  cons& operator=( const std::pair<T1, T2>& u ) {
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((length<cons>::value == 2) == 0 ? false : true) >)> boost_static_assert_typedef_325;
    head = u.first; tail.head = u.second; return *this;
  }


  template <int N>
  typename access_traits<
             typename element<N, cons<HT, TT> >::type
           >::non_const_type
  get() {
    return boost::tuples::get<N>(*this);
  }

  template <int N>
  typename access_traits<
             typename element<N, cons<HT, TT> >::type
           >::const_type
  get() const {
    return boost::tuples::get<N>(*this);
  }
};

template <class HT>
struct cons<HT, null_type> {

  typedef HT head_type;
  typedef null_type tail_type;
  typedef cons<HT, null_type> self_type;

  typedef typename
    detail::wrap_non_storeable_type<head_type>::type stored_head_type;
  stored_head_type head;

  typename access_traits<stored_head_type>::non_const_type
  get_head() { return head; }

  null_type get_tail() { return null_type(); }

  typename access_traits<stored_head_type>::const_type
  get_head() const { return head; }

  const null_type get_tail() const { return null_type(); }


  cons() : head() {}

  cons(typename access_traits<stored_head_type>::parameter_type h,
       const null_type& = null_type())
    : head (h) {}

  template<class T1>
  cons(T1& t1, const null_type&, const null_type&, const null_type&,
       const null_type&, const null_type&, const null_type&,
       const null_type&, const null_type&, const null_type&)
  : head (t1) {}

  cons(const null_type&,
       const null_type&, const null_type&, const null_type&,
       const null_type&, const null_type&, const null_type&,
       const null_type&, const null_type&, const null_type&)
  : head () {}

  template <class HT2>
  cons( const cons<HT2, null_type>& u ) : head(u.head) {}

  template <class HT2>
  cons& operator=(const cons<HT2, null_type>& u )
  { head = u.head; return *this; }



  cons& operator=(const cons& u) { head = u.head; return *this; }

  template <int N>
  typename access_traits<
             typename element<N, self_type>::type
            >::non_const_type
  get() {
    return boost::tuples::get<N>(*this);
  }

  template <int N>
  typename access_traits<
             typename element<N, self_type>::type
           >::const_type
  get() const {
    return boost::tuples::get<N>(*this);
  }

};



template<class T>
struct length {
  static const int value = 1 + length<typename T::tail_type>::value;
};

template<>
struct length<tuple<> > {
  static const int value = 0;
};

template<>
struct length<tuple<> const> {
  static const int value = 0;
};

template<>
struct length<null_type> {
  static const int value = 0;
};

template<>
struct length<null_type const> {
  static const int value = 0;
};

namespace detail {


template <class T0, class T1, class T2, class T3, class T4,
          class T5, class T6, class T7, class T8, class T9>
struct map_tuple_to_cons
{
  typedef cons<T0,
               typename map_tuple_to_cons<T1, T2, T3, T4, T5,
                                          T6, T7, T8, T9, null_type>::type
              > type;
};


template <>
struct map_tuple_to_cons<null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>
{
  typedef null_type type;
};

}



template <class T0, class T1, class T2, class T3, class T4,
          class T5, class T6, class T7, class T8, class T9>

class tuple :
  public detail::map_tuple_to_cons<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type
{
public:
  typedef typename
    detail::map_tuple_to_cons<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type inherited;
  typedef typename inherited::head_type head_type;
  typedef typename inherited::tail_type tail_type;



  tuple() {}

  tuple(typename access_traits<T0>::parameter_type t0)
    : inherited(t0, detail::cnull(), detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1)
    : inherited(t0, t1, detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2)
    : inherited(t0, t1, t2, detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3)
    : inherited(t0, t1, t2, t3, detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull(),
                detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4)
    : inherited(t0, t1, t2, t3, t4, detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5)
    : inherited(t0, t1, t2, t3, t4, t5, detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5,
        typename access_traits<T6>::parameter_type t6)
    : inherited(t0, t1, t2, t3, t4, t5, t6, detail::cnull(),
                detail::cnull(), detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5,
        typename access_traits<T6>::parameter_type t6,
        typename access_traits<T7>::parameter_type t7)
    : inherited(t0, t1, t2, t3, t4, t5, t6, t7, detail::cnull(),
                detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5,
        typename access_traits<T6>::parameter_type t6,
        typename access_traits<T7>::parameter_type t7,
        typename access_traits<T8>::parameter_type t8)
    : inherited(t0, t1, t2, t3, t4, t5, t6, t7, t8, detail::cnull()) {}

  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5,
        typename access_traits<T6>::parameter_type t6,
        typename access_traits<T7>::parameter_type t7,
        typename access_traits<T8>::parameter_type t8,
        typename access_traits<T9>::parameter_type t9)
    : inherited(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {}


  template<class U1, class U2>
  tuple(const cons<U1, U2>& p) : inherited(p) {}

  template <class U1, class U2>
  tuple& operator=(const cons<U1, U2>& k) {
    inherited::operator=(k);
    return *this;
  }

  template <class U1, class U2>
  tuple& operator=(const std::pair<U1, U2>& k) {
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((length<tuple>::value == 2) == 0 ? false : true) >)> boost_static_assert_typedef_582;
    this->head = k.first;
    this->tail.head = k.second;
    return *this;
  }

};


template <>
class tuple<null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> :
  public null_type
{
public:
  typedef null_type inherited;
};



namespace detail {

struct swallow_assign;
typedef void (detail::swallow_assign::*ignore_t)();
struct swallow_assign {
  swallow_assign(ignore_t(*)(ignore_t)) {}
  template<typename T>
  swallow_assign const& operator=(const T&) const {
    return *this;
  }
};


}


inline detail::ignore_t ignore(detail::ignore_t) { return 0; }
# 636 "/home/marek/devel/nupic/external/common/include/boost/tuple/detail/tuple_basic.hpp"
template<class T>
struct make_tuple_traits {
  typedef T type;







};
# 660 "/home/marek/devel/nupic/external/common/include/boost/tuple/detail/tuple_basic.hpp"
template<class T>
struct make_tuple_traits<T&> {
  typedef typename
     detail::generate_error<T&>::
       do_not_use_with_reference_type error;
};





template<class T, int n> struct make_tuple_traits <T[n]> {
  typedef const T (&type)[n];
};

template<class T, int n>
struct make_tuple_traits<const T[n]> {
  typedef const T (&type)[n];
};

template<class T, int n> struct make_tuple_traits<volatile T[n]> {
  typedef const volatile T (&type)[n];
};

template<class T, int n>
struct make_tuple_traits<const volatile T[n]> {
  typedef const volatile T (&type)[n];
};

template<class T>
struct make_tuple_traits<reference_wrapper<T> >{
  typedef T& type;
};

template<class T>
struct make_tuple_traits<const reference_wrapper<T> >{
  typedef T& type;
};

template<>
struct make_tuple_traits<detail::ignore_t(detail::ignore_t)> {
  typedef detail::swallow_assign type;
};



namespace detail {



template <
  class T0 = null_type, class T1 = null_type, class T2 = null_type,
  class T3 = null_type, class T4 = null_type, class T5 = null_type,
  class T6 = null_type, class T7 = null_type, class T8 = null_type,
  class T9 = null_type
>
struct make_tuple_mapper {
  typedef
    tuple<typename make_tuple_traits<T0>::type,
          typename make_tuple_traits<T1>::type,
          typename make_tuple_traits<T2>::type,
          typename make_tuple_traits<T3>::type,
          typename make_tuple_traits<T4>::type,
          typename make_tuple_traits<T5>::type,
          typename make_tuple_traits<T6>::type,
          typename make_tuple_traits<T7>::type,
          typename make_tuple_traits<T8>::type,
          typename make_tuple_traits<T9>::type> type;
};

}


inline tuple<> make_tuple() {
  return tuple<>();
}

template<class T0>
inline typename detail::make_tuple_mapper<T0>::type
make_tuple(const T0& t0) {
  typedef typename detail::make_tuple_mapper<T0>::type t;
  return t(t0);
}

template<class T0, class T1>
inline typename detail::make_tuple_mapper<T0, T1>::type
make_tuple(const T0& t0, const T1& t1) {
  typedef typename detail::make_tuple_mapper<T0, T1>::type t;
  return t(t0, t1);
}

template<class T0, class T1, class T2>
inline typename detail::make_tuple_mapper<T0, T1, T2>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2) {
  typedef typename detail::make_tuple_mapper<T0, T1, T2>::type t;
  return t(t0, t1, t2);
}

template<class T0, class T1, class T2, class T3>
inline typename detail::make_tuple_mapper<T0, T1, T2, T3>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3) {
  typedef typename detail::make_tuple_mapper<T0, T1, T2, T3>::type t;
  return t(t0, t1, t2, t3);
}

template<class T0, class T1, class T2, class T3, class T4>
inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4) {
  typedef typename detail::make_tuple_mapper<T0, T1, T2, T3, T4>::type t;
  return t(t0, t1, t2, t3, t4);
}

template<class T0, class T1, class T2, class T3, class T4, class T5>
inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4, const T5& t5) {
  typedef typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5>::type t;
  return t(t0, t1, t2, t3, t4, t5);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6>
inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4, const T5& t5, const T6& t6) {
  typedef typename detail::make_tuple_mapper
           <T0, T1, T2, T3, T4, T5, T6>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
         class T7>
inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6, T7>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4, const T5& t5, const T6& t6, const T7& t7) {
  typedef typename detail::make_tuple_mapper
           <T0, T1, T2, T3, T4, T5, T6, T7>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6, t7);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
         class T7, class T8>
inline typename detail::make_tuple_mapper
  <T0, T1, T2, T3, T4, T5, T6, T7, T8>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4, const T5& t5, const T6& t6, const T7& t7,
                  const T8& t8) {
  typedef typename detail::make_tuple_mapper
           <T0, T1, T2, T3, T4, T5, T6, T7, T8>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6, t7, t8);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
         class T7, class T8, class T9>
inline typename detail::make_tuple_mapper
  <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4, const T5& t5, const T6& t6, const T7& t7,
                  const T8& t8, const T9& t9) {
  typedef typename detail::make_tuple_mapper
           <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9);
}

namespace detail {

template<class T>
struct tie_traits {
  typedef T& type;
};

template<>
struct tie_traits<ignore_t(ignore_t)> {
  typedef swallow_assign type;
};

template<>
struct tie_traits<void> {
  typedef null_type type;
};

template <
  class T0 = void, class T1 = void, class T2 = void,
  class T3 = void, class T4 = void, class T5 = void,
  class T6 = void, class T7 = void, class T8 = void,
  class T9 = void
>
struct tie_mapper {
  typedef
    tuple<typename tie_traits<T0>::type,
          typename tie_traits<T1>::type,
          typename tie_traits<T2>::type,
          typename tie_traits<T3>::type,
          typename tie_traits<T4>::type,
          typename tie_traits<T5>::type,
          typename tie_traits<T6>::type,
          typename tie_traits<T7>::type,
          typename tie_traits<T8>::type,
          typename tie_traits<T9>::type> type;
};

}


template<class T0>
inline typename detail::tie_mapper<T0>::type
tie(T0& t0) {
  typedef typename detail::tie_mapper<T0>::type t;
  return t(t0);
}

template<class T0, class T1>
inline typename detail::tie_mapper<T0, T1>::type
tie(T0& t0, T1& t1) {
  typedef typename detail::tie_mapper<T0, T1>::type t;
  return t(t0, t1);
}

template<class T0, class T1, class T2>
inline typename detail::tie_mapper<T0, T1, T2>::type
tie(T0& t0, T1& t1, T2& t2) {
  typedef typename detail::tie_mapper<T0, T1, T2>::type t;
  return t(t0, t1, t2);
}

template<class T0, class T1, class T2, class T3>
inline typename detail::tie_mapper<T0, T1, T2, T3>::type
tie(T0& t0, T1& t1, T2& t2, T3& t3) {
  typedef typename detail::tie_mapper<T0, T1, T2, T3>::type t;
  return t(t0, t1, t2, t3);
}

template<class T0, class T1, class T2, class T3, class T4>
inline typename detail::tie_mapper<T0, T1, T2, T3, T4>::type
tie(T0& t0, T1& t1, T2& t2, T3& t3,
                  T4& t4) {
  typedef typename detail::tie_mapper<T0, T1, T2, T3, T4>::type t;
  return t(t0, t1, t2, t3, t4);
}

template<class T0, class T1, class T2, class T3, class T4, class T5>
inline typename detail::tie_mapper<T0, T1, T2, T3, T4, T5>::type
tie(T0& t0, T1& t1, T2& t2, T3& t3,
                  T4& t4, T5& t5) {
  typedef typename detail::tie_mapper<T0, T1, T2, T3, T4, T5>::type t;
  return t(t0, t1, t2, t3, t4, t5);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6>
inline typename detail::tie_mapper<T0, T1, T2, T3, T4, T5, T6>::type
tie(T0& t0, T1& t1, T2& t2, T3& t3,
                  T4& t4, T5& t5, T6& t6) {
  typedef typename detail::tie_mapper
           <T0, T1, T2, T3, T4, T5, T6>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
         class T7>
inline typename detail::tie_mapper<T0, T1, T2, T3, T4, T5, T6, T7>::type
tie(T0& t0, T1& t1, T2& t2, T3& t3,
                  T4& t4, T5& t5, T6& t6, T7& t7) {
  typedef typename detail::tie_mapper
           <T0, T1, T2, T3, T4, T5, T6, T7>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6, t7);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
         class T7, class T8>
inline typename detail::tie_mapper
  <T0, T1, T2, T3, T4, T5, T6, T7, T8>::type
tie(T0& t0, T1& t1, T2& t2, T3& t3,
                  T4& t4, T5& t5, T6& t6, T7& t7,
                  T8& t8) {
  typedef typename detail::tie_mapper
           <T0, T1, T2, T3, T4, T5, T6, T7, T8>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6, t7, t8);
}

template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
         class T7, class T8, class T9>
inline typename detail::tie_mapper
  <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type
tie(T0& t0, T1& t1, T2& t2, T3& t3,
                  T4& t4, T5& t5, T6& t6, T7& t7,
                  T8& t8, T9& t9) {
  typedef typename detail::tie_mapper
           <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9);
}

template <class T0, class T1, class T2, class T3, class T4,
          class T5, class T6, class T7, class T8, class T9>
void swap(tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>& lhs,
          tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>& rhs);
inline void swap(null_type&, null_type&) {}
template<class HH>
inline void swap(cons<HH, null_type>& lhs, cons<HH, null_type>& rhs) {
  ::boost::swap(lhs.head, rhs.head);
}
template<class HH, class TT>
inline void swap(cons<HH, TT>& lhs, cons<HH, TT>& rhs) {
  ::boost::swap(lhs.head, rhs.head);
  ::boost::tuples::swap(lhs.tail, rhs.tail);
}
template <class T0, class T1, class T2, class T3, class T4,
          class T5, class T6, class T7, class T8, class T9>
inline void swap(tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>& lhs,
          tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>& rhs) {
  typedef tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> tuple_type;
  typedef typename tuple_type::inherited base;
  ::boost::tuples::swap(static_cast<base&>(lhs), static_cast<base&>(rhs));
}

}
}
# 33 "/home/marek/devel/nupic/external/common/include/boost/tuple/tuple.hpp" 2




namespace boost {

using tuples::tuple;
using tuples::make_tuple;
using tuples::tie;

using tuples::get;
# 87 "/home/marek/devel/nupic/external/common/include/boost/tuple/tuple.hpp"
}
# 27 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp" 2




# 1 "/home/marek/devel/nupic/external/common/include/boost/assert.hpp" 1
# 50 "/home/marek/devel/nupic/external/common/include/boost/assert.hpp"
# 1 "/usr/include/assert.h" 1 3 4
# 64 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 50 "/home/marek/devel/nupic/external/common/include/boost/assert.hpp" 2
# 31 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp" 2
# 48 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp"
namespace boost { namespace unordered { namespace detail {




    template <typename T> typename boost::add_lvalue_reference<T>::type make();
    struct choice9 { typedef char (&type)[9]; };
    struct choice8 : choice9 { typedef char (&type)[8]; };
    struct choice7 : choice8 { typedef char (&type)[7]; };
    struct choice6 : choice7 { typedef char (&type)[6]; };
    struct choice5 : choice6 { typedef char (&type)[5]; };
    struct choice4 : choice5 { typedef char (&type)[4]; };
    struct choice3 : choice4 { typedef char (&type)[3]; };
    struct choice2 : choice3 { typedef char (&type)[2]; };
    struct choice1 : choice2 { typedef char (&type)[1]; };
    choice1 choose();

    typedef choice1::type yes_type;
    typedef choice2::type no_type;

    struct private_type
    {
       private_type const &operator,(int) const;
    };

    template <typename T>
    no_type is_private_type(T const&);
    yes_type is_private_type(private_type const&);

    struct convert_from_anything {
        template <typename T>
        convert_from_anything(T const&);
    };
# 161 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp"
template < typename A0> struct emplace_args1 { typedef const A0 & Arg0; Arg0 a0; emplace_args1 ( Arg0 b0 ) : a0( boost::forward<A0>(b0)) {} }; template < typename A0> inline emplace_args1 < A0 > create_emplace_args( const A0 & b0 ) { emplace_args1 < A0 > e( b0); return e; } template < typename A0 , typename A1> struct emplace_args2 { typedef const A0 & Arg0; Arg0 a0; typedef const A1 & Arg1; Arg1 a1; emplace_args2 ( Arg0 b0 , Arg1 b1 ) : a0( boost::forward<A0>(b0)) , a1( boost::forward<A1>(b1)) {} }; template < typename A0 , typename A1> inline emplace_args2 < A0 , A1 > create_emplace_args( const A0 & b0 , const A1 & b1 ) { emplace_args2 < A0 , A1 > e( b0 , b1); return e; } template < typename A0 , typename A1 , typename A2> struct emplace_args3 { typedef const A0 & Arg0; Arg0 a0; typedef const A1 & Arg1; Arg1 a1; typedef const A2 & Arg2; Arg2 a2; emplace_args3 ( Arg0 b0 , Arg1 b1 , Arg2 b2 ) : a0( boost::forward<A0>(b0)) , a1( boost::forward<A1>(b1)) , a2( boost::forward<A2>(b2)) {} }; template < typename A0 , typename A1 , typename A2> inline emplace_args3 < A0 , A1 , A2 > create_emplace_args( const A0 & b0 , const A1 & b1 , const A2 & b2 ) { emplace_args3 < A0 , A1 , A2 > e( b0 , b1 , b2); return e; } template < typename A0 , typename A1 , typename A2 , typename A3> struct emplace_args4 { typedef const A0 & Arg0; Arg0 a0; typedef const A1 & Arg1; Arg1 a1; typedef const A2 & Arg2; Arg2 a2; typedef const A3 & Arg3; Arg3 a3; emplace_args4 ( Arg0 b0 , Arg1 b1 , Arg2 b2 , Arg3 b3 ) : a0( boost::forward<A0>(b0)) , a1( boost::forward<A1>(b1)) , a2( boost::forward<A2>(b2)) , a3( boost::forward<A3>(b3)) {} }; template < typename A0 , typename A1 , typename A2 , typename A3> inline emplace_args4 < A0 , A1 , A2 , A3 > create_emplace_args( const A0 & b0 , const A1 & b1 , const A2 & b2 , const A3 & b3 ) { emplace_args4 < A0 , A1 , A2 , A3 > e( b0 , b1 , b2 , b3); return e; } template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4> struct emplace_args5 { typedef const A0 & Arg0; Arg0 a0; typedef const A1 & Arg1; Arg1 a1; typedef const A2 & Arg2; Arg2 a2; typedef const A3 & Arg3; Arg3 a3; typedef const A4 & Arg4; Arg4 a4; emplace_args5 ( Arg0 b0 , Arg1 b1 , Arg2 b2 , Arg3 b3 , Arg4 b4 ) : a0( boost::forward<A0>(b0)) , a1( boost::forward<A1>(b1)) , a2( boost::forward<A2>(b2)) , a3( boost::forward<A3>(b3)) , a4( boost::forward<A4>(b4)) {} }; template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4> inline emplace_args5 < A0 , A1 , A2 , A3 , A4 > create_emplace_args( const A0 & b0 , const A1 & b1 , const A2 & b2 , const A3 & b3 , const A4 & b4 ) { emplace_args5 < A0 , A1 , A2 , A3 , A4 > e( b0 , b1 , b2 , b3 , b4); return e; } template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5> struct emplace_args6 { typedef const A0 & Arg0; Arg0 a0; typedef const A1 & Arg1; Arg1 a1; typedef const A2 & Arg2; Arg2 a2; typedef const A3 & Arg3; Arg3 a3; typedef const A4 & Arg4; Arg4 a4; typedef const A5 & Arg5; Arg5 a5; emplace_args6 ( Arg0 b0 , Arg1 b1 , Arg2 b2 , Arg3 b3 , Arg4 b4 , Arg5 b5 ) : a0( boost::forward<A0>(b0)) , a1( boost::forward<A1>(b1)) , a2( boost::forward<A2>(b2)) , a3( boost::forward<A3>(b3)) , a4( boost::forward<A4>(b4)) , a5( boost::forward<A5>(b5)) {} }; template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5> inline emplace_args6 < A0 , A1 , A2 , A3 , A4 , A5 > create_emplace_args( const A0 & b0 , const A1 & b1 , const A2 & b2 , const A3 & b3 , const A4 & b4 , const A5 & b5 ) { emplace_args6 < A0 , A1 , A2 , A3 , A4 , A5 > e( b0 , b1 , b2 , b3 , b4 , b5); return e; } template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6> struct emplace_args7 { typedef const A0 & Arg0; Arg0 a0; typedef const A1 & Arg1; Arg1 a1; typedef const A2 & Arg2; Arg2 a2; typedef const A3 & Arg3; Arg3 a3; typedef const A4 & Arg4; Arg4 a4; typedef const A5 & Arg5; Arg5 a5; typedef const A6 & Arg6; Arg6 a6; emplace_args7 ( Arg0 b0 , Arg1 b1 , Arg2 b2 , Arg3 b3 , Arg4 b4 , Arg5 b5 , Arg6 b6 ) : a0( boost::forward<A0>(b0)) , a1( boost::forward<A1>(b1)) , a2( boost::forward<A2>(b2)) , a3( boost::forward<A3>(b3)) , a4( boost::forward<A4>(b4)) , a5( boost::forward<A5>(b5)) , a6( boost::forward<A6>(b6)) {} }; template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6> inline emplace_args7 < A0 , A1 , A2 , A3 , A4 , A5 , A6 > create_emplace_args( const A0 & b0 , const A1 & b1 , const A2 & b2 , const A3 & b3 , const A4 & b4 , const A5 & b5 , const A6 & b6 ) { emplace_args7 < A0 , A1 , A2 , A3 , A4 , A5 , A6 > e( b0 , b1 , b2 , b3 , b4 , b5 , b6); return e; } template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 , typename A7> struct emplace_args8 { typedef const A0 & Arg0; Arg0 a0; typedef const A1 & Arg1; Arg1 a1; typedef const A2 & Arg2; Arg2 a2; typedef const A3 & Arg3; Arg3 a3; typedef const A4 & Arg4; Arg4 a4; typedef const A5 & Arg5; Arg5 a5; typedef const A6 & Arg6; Arg6 a6; typedef const A7 & Arg7; Arg7 a7; emplace_args8 ( Arg0 b0 , Arg1 b1 , Arg2 b2 , Arg3 b3 , Arg4 b4 , Arg5 b5 , Arg6 b6 , Arg7 b7 ) : a0( boost::forward<A0>(b0)) , a1( boost::forward<A1>(b1)) , a2( boost::forward<A2>(b2)) , a3( boost::forward<A3>(b3)) , a4( boost::forward<A4>(b4)) , a5( boost::forward<A5>(b5)) , a6( boost::forward<A6>(b6)) , a7( boost::forward<A7>(b7)) {} }; template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 , typename A7> inline emplace_args8 < A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 > create_emplace_args( const A0 & b0 , const A1 & b1 , const A2 & b2 , const A3 & b3 , const A4 & b4 , const A5 & b5 , const A6 & b6 , const A7 & b7 ) { emplace_args8 < A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 > e( b0 , b1 , b2 , b3 , b4 , b5 , b6 , b7); return e; } template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 , typename A7 , typename A8> struct emplace_args9 { typedef const A0 & Arg0; Arg0 a0; typedef const A1 & Arg1; Arg1 a1; typedef const A2 & Arg2; Arg2 a2; typedef const A3 & Arg3; Arg3 a3; typedef const A4 & Arg4; Arg4 a4; typedef const A5 & Arg5; Arg5 a5; typedef const A6 & Arg6; Arg6 a6; typedef const A7 & Arg7; Arg7 a7; typedef const A8 & Arg8; Arg8 a8; emplace_args9 ( Arg0 b0 , Arg1 b1 , Arg2 b2 , Arg3 b3 , Arg4 b4 , Arg5 b5 , Arg6 b6 , Arg7 b7 , Arg8 b8 ) : a0( boost::forward<A0>(b0)) , a1( boost::forward<A1>(b1)) , a2( boost::forward<A2>(b2)) , a3( boost::forward<A3>(b3)) , a4( boost::forward<A4>(b4)) , a5( boost::forward<A5>(b5)) , a6( boost::forward<A6>(b6)) , a7( boost::forward<A7>(b7)) , a8( boost::forward<A8>(b8)) {} }; template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 , typename A7 , typename A8> inline emplace_args9 < A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 > create_emplace_args( const A0 & b0 , const A1 & b1 , const A2 & b2 , const A3 & b3 , const A4 & b4 , const A5 & b5 , const A6 & b6 , const A7 & b7 , const A8 & b8 ) { emplace_args9 < A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 > e( b0 , b1 , b2 , b3 , b4 , b5 , b6 , b7 , b8); return e; }
# 170 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp"
}}}
# 206 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp"
namespace boost { namespace unordered { namespace detail {
# 221 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp"
    template <typename T, T Value>
    struct integral_constant { enum { value = Value }; };

    typedef boost::unordered::detail::integral_constant<bool, true> true_type;
    typedef boost::unordered::detail::integral_constant<bool, false> false_type;
# 237 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp"
    template <class T>
    inline void destroy(T* x) {
        x->~T();
    }
# 258 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp"
    template <typename T, unsigned int> struct expr_test;
    template <typename T> struct expr_test<T, sizeof(char)> : T {};
    template <typename U> static char for_expr_test(U const&);
# 328 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp"
}}}
# 338 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/limits.hpp" 1
# 338 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/pointer_to_other.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/pointer_to_other.hpp"
namespace boost
{



template<class T, class U>
struct pointer_to_other;

template<class T, class U,
         template<class> class Sp>
struct pointer_to_other< Sp<T>, U >
{
   typedef Sp<U> type;
};

template<class T, class T2, class U,
         template<class, class> class Sp>
struct pointer_to_other< Sp<T, T2>, U >
{
   typedef Sp<U, T2> type;
};

template<class T, class T2, class T3, class U,
         template<class, class, class> class Sp>
struct pointer_to_other< Sp<T, T2, T3>, U >
{
   typedef Sp<U, T2, T3> type;
};

template<class T, class U>
struct pointer_to_other< T*, U >
{
   typedef U* type;
};

}
# 340 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp" 2
# 352 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp"
namespace boost { namespace unordered { namespace detail {


    template <typename Alloc, typename T>
    struct rebind_wrap
    {
        typedef typename Alloc::template rebind<T>::other type;
    };
# 384 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp"
    template <typename T, typename T2>
    struct sfinae : T2 {};
# 413 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp"
    template <typename Tp, typename Default> struct default_type_pointer { template <typename X> static typename boost::unordered::detail::sfinae< typename X::pointer, choice1>::type test(choice1); template <typename X> static choice2::type test(choice2); struct DefaultWrap { typedef Default pointer; }; enum { value = (1 == sizeof(test<Tp>(choose()))) }; typedef typename boost::detail::if_true<value>:: template then<Tp, DefaultWrap> ::type::pointer type; };
    template <typename Tp, typename Default> struct default_type_const_pointer { template <typename X> static typename boost::unordered::detail::sfinae< typename X::const_pointer, choice1>::type test(choice1); template <typename X> static choice2::type test(choice2); struct DefaultWrap { typedef Default const_pointer; }; enum { value = (1 == sizeof(test<Tp>(choose()))) }; typedef typename boost::detail::if_true<value>:: template then<Tp, DefaultWrap> ::type::const_pointer type; };
    template <typename Tp, typename Default> struct default_type_void_pointer { template <typename X> static typename boost::unordered::detail::sfinae< typename X::void_pointer, choice1>::type test(choice1); template <typename X> static choice2::type test(choice2); struct DefaultWrap { typedef Default void_pointer; }; enum { value = (1 == sizeof(test<Tp>(choose()))) }; typedef typename boost::detail::if_true<value>:: template then<Tp, DefaultWrap> ::type::void_pointer type; };
    template <typename Tp, typename Default> struct default_type_const_void_pointer { template <typename X> static typename boost::unordered::detail::sfinae< typename X::const_void_pointer, choice1>::type test(choice1); template <typename X> static choice2::type test(choice2); struct DefaultWrap { typedef Default const_void_pointer; }; enum { value = (1 == sizeof(test<Tp>(choose()))) }; typedef typename boost::detail::if_true<value>:: template then<Tp, DefaultWrap> ::type::const_void_pointer type; };
    template <typename Tp, typename Default> struct default_type_difference_type { template <typename X> static typename boost::unordered::detail::sfinae< typename X::difference_type, choice1>::type test(choice1); template <typename X> static choice2::type test(choice2); struct DefaultWrap { typedef Default difference_type; }; enum { value = (1 == sizeof(test<Tp>(choose()))) }; typedef typename boost::detail::if_true<value>:: template then<Tp, DefaultWrap> ::type::difference_type type; };
    template <typename Tp, typename Default> struct default_type_size_type { template <typename X> static typename boost::unordered::detail::sfinae< typename X::size_type, choice1>::type test(choice1); template <typename X> static choice2::type test(choice2); struct DefaultWrap { typedef Default size_type; }; enum { value = (1 == sizeof(test<Tp>(choose()))) }; typedef typename boost::detail::if_true<value>:: template then<Tp, DefaultWrap> ::type::size_type type; };
    template <typename Tp, typename Default> struct default_type_propagate_on_container_copy_assignment { template <typename X> static typename boost::unordered::detail::sfinae< typename X::propagate_on_container_copy_assignment, choice1>::type test(choice1); template <typename X> static choice2::type test(choice2); struct DefaultWrap { typedef Default propagate_on_container_copy_assignment; }; enum { value = (1 == sizeof(test<Tp>(choose()))) }; typedef typename boost::detail::if_true<value>:: template then<Tp, DefaultWrap> ::type::propagate_on_container_copy_assignment type; };
    template <typename Tp, typename Default> struct default_type_propagate_on_container_move_assignment { template <typename X> static typename boost::unordered::detail::sfinae< typename X::propagate_on_container_move_assignment, choice1>::type test(choice1); template <typename X> static choice2::type test(choice2); struct DefaultWrap { typedef Default propagate_on_container_move_assignment; }; enum { value = (1 == sizeof(test<Tp>(choose()))) }; typedef typename boost::detail::if_true<value>:: template then<Tp, DefaultWrap> ::type::propagate_on_container_move_assignment type; };
    template <typename Tp, typename Default> struct default_type_propagate_on_container_swap { template <typename X> static typename boost::unordered::detail::sfinae< typename X::propagate_on_container_swap, choice1>::type test(choice1); template <typename X> static choice2::type test(choice2); struct DefaultWrap { typedef Default propagate_on_container_swap; }; enum { value = (1 == sizeof(test<Tp>(choose()))) }; typedef typename boost::detail::if_true<value>:: template then<Tp, DefaultWrap> ::type::propagate_on_container_swap type; };



    template <typename T>
    struct has_select_on_container_copy_construction { template <typename U> static typename boost::unordered::detail::expr_test< choice1, sizeof(boost::unordered::detail::for_expr_test(( (boost::unordered::detail::make< U const >().select_on_container_copy_construction ()), 0)))>::type test( choice1); template <typename U> static choice2::type test( choice2); enum { value = sizeof(test<T>(choose())) == sizeof(choice1::type) }; };



    template <typename T>
    struct has_max_size { template <typename U> static typename boost::unordered::detail::expr_test< choice1, sizeof(boost::unordered::detail::for_expr_test(( (boost::unordered::detail::make< U const >().max_size ()), 0)))>::type test( choice1); template <typename U> static choice2::type test( choice2); enum { value = sizeof(test<T>(choose())) == sizeof(choice1::type) }; };
# 446 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp"
    template <typename T, typename ValueType>
    struct has_construct { template <typename U> static typename boost::unordered::detail::expr_test< choice1, sizeof(boost::unordered::detail::for_expr_test(( (boost::unordered::detail::make< U >().construct ( boost::unordered::detail::make<ValueType*>(), boost::unordered::detail::make<ValueType const>())), 0)))>::type test( choice1); template <typename U> static choice2::type test( choice2); enum { value = sizeof(test<T>(choose())) == sizeof(choice1::type) }; };







    template <typename T, typename ValueType>
    struct has_destroy { template <typename U> static typename boost::unordered::detail::expr_test< choice1, sizeof(boost::unordered::detail::for_expr_test(( (boost::unordered::detail::make< U >().destroy (boost::unordered::detail::make<ValueType*>())), 0)))>::type test( choice1); template <typename U> static choice2::type test( choice2); enum { value = sizeof(test<T>(choose())) == sizeof(choice1::type) }; };
# 476 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp"
    template <typename Alloc>
    inline Alloc call_select_on_container_copy_construction(const Alloc& rhs,
        typename boost::enable_if_c<
            boost::unordered::detail::
            has_select_on_container_copy_construction<Alloc>::value, void*
        >::type = 0)
    {
        return rhs.select_on_container_copy_construction();
    }

    template <typename Alloc>
    inline Alloc call_select_on_container_copy_construction(const Alloc& rhs,
        typename boost::disable_if_c<
            boost::unordered::detail::
            has_select_on_container_copy_construction<Alloc>::value, void*
        >::type = 0)
    {
        return rhs;
    }

    template <typename SizeType, typename Alloc>
    inline SizeType call_max_size(const Alloc& a,
        typename boost::enable_if_c<
            boost::unordered::detail::has_max_size<Alloc>::value, void*
        >::type = 0)
    {
        return a.max_size();
    }

    template <typename SizeType, typename Alloc>
    inline SizeType call_max_size(const Alloc&, typename boost::disable_if_c<
            boost::unordered::detail::has_max_size<Alloc>::value, void*
        >::type = 0)
    {
        return (std::numeric_limits<SizeType>::max)();
    }

    template <typename Alloc>
    struct allocator_traits
    {
        typedef Alloc allocator_type;
        typedef typename Alloc::value_type value_type;

        typedef typename default_type_pointer<Alloc, value_type*>::type
            pointer;

        template <typename T>
        struct pointer_to_other : boost::pointer_to_other<pointer, T> {};

        typedef typename default_type_const_pointer<Alloc, typename pointer_to_other<const value_type>::type>::type

            const_pointer;
# 537 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp"
        typedef typename default_type_difference_type<Alloc, std::ptrdiff_t>::type difference_type;


        typedef typename default_type_size_type<Alloc, std::size_t>::type
            size_type;



        static pointer allocate(Alloc& a, size_type n)
            { return a.allocate(n); }







        static void deallocate(Alloc& a, pointer p, size_type n)
            { a.deallocate(p, n); }

    public:
# 597 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp"
        template <typename T>
        static typename boost::enable_if_c<
                boost::unordered::detail::has_construct<Alloc, T>::value>::type
            construct(Alloc& a, T* p, T const& x)
        {
            a.construct(p, x);
        }

        template <typename T>
        static typename boost::disable_if_c<
                boost::unordered::detail::has_construct<Alloc, T>::value>::type
            construct(Alloc&, T* p, T const& x)
        {
            new ((void*) p) T(x);
        }

        template <typename T>
        static typename boost::enable_if_c<
                boost::unordered::detail::has_destroy<Alloc, T>::value>::type
            destroy(Alloc& a, T* p)
        {
            a.destroy(p);
        }

        template <typename T>
        static typename boost::disable_if_c<
                boost::unordered::detail::has_destroy<Alloc, T>::value>::type
            destroy(Alloc&, T* p)
        {
            boost::unordered::detail::destroy(p);
        }
# 677 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp"
        static size_type max_size(const Alloc& a)
        {
            return boost::unordered::detail::call_max_size<size_type>(a);
        }



        static Alloc select_on_container_copy_construction(Alloc const& rhs)
        {
            return boost::unordered::detail::
                call_select_on_container_copy_construction(rhs);
        }



        typedef typename default_type_propagate_on_container_copy_assignment<Alloc, false_type>::type

            propagate_on_container_copy_assignment;
        typedef typename default_type_propagate_on_container_move_assignment<Alloc, false_type>::type

            propagate_on_container_move_assignment;
        typedef typename default_type_propagate_on_container_swap<Alloc, false_type>::type

            propagate_on_container_swap;
    };
}}}
# 761 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp"
namespace boost { namespace unordered { namespace detail {
# 803 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp"
    template <typename Alloc, typename T>
    inline void destroy_value_impl(Alloc&, T* x) {
        boost::unordered::detail::destroy(x);
    }
# 900 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp"
template<typename Alloc, typename T> void construct_from_tuple(Alloc&, T* ptr, boost:: tuple<>) { new ((void*) ptr) T(); } template<typename Alloc, typename T, typename A0> void construct_from_tuple(Alloc&, T* ptr, boost:: tuple< A0> const& x) { new ((void*) ptr) T( boost:: get<0>(x) ); } template<typename Alloc, typename T, typename A0 , typename A1> void construct_from_tuple(Alloc&, T* ptr, boost:: tuple< A0 , A1> const& x) { new ((void*) ptr) T( boost:: get<0>(x) , boost:: get<1>(x) ); } template<typename Alloc, typename T, typename A0 , typename A1 , typename A2> void construct_from_tuple(Alloc&, T* ptr, boost:: tuple< A0 , A1 , A2> const& x) { new ((void*) ptr) T( boost:: get<0>(x) , boost:: get<1>(x) , boost:: get<2>(x) ); } template<typename Alloc, typename T, typename A0 , typename A1 , typename A2 , typename A3> void construct_from_tuple(Alloc&, T* ptr, boost:: tuple< A0 , A1 , A2 , A3> const& x) { new ((void*) ptr) T( boost:: get<0>(x) , boost:: get<1>(x) , boost:: get<2>(x) , boost:: get<3>(x) ); } template<typename Alloc, typename T, typename A0 , typename A1 , typename A2 , typename A3 , typename A4> void construct_from_tuple(Alloc&, T* ptr, boost:: tuple< A0 , A1 , A2 , A3 , A4> const& x) { new ((void*) ptr) T( boost:: get<0>(x) , boost:: get<1>(x) , boost:: get<2>(x) , boost:: get<3>(x) , boost:: get<4>(x) ); } template<typename Alloc, typename T, typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5> void construct_from_tuple(Alloc&, T* ptr, boost:: tuple< A0 , A1 , A2 , A3 , A4 , A5> const& x) { new ((void*) ptr) T( boost:: get<0>(x) , boost:: get<1>(x) , boost:: get<2>(x) , boost:: get<3>(x) , boost:: get<4>(x) , boost:: get<5>(x) ); } template<typename Alloc, typename T, typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6> void construct_from_tuple(Alloc&, T* ptr, boost:: tuple< A0 , A1 , A2 , A3 , A4 , A5 , A6> const& x) { new ((void*) ptr) T( boost:: get<0>(x) , boost:: get<1>(x) , boost:: get<2>(x) , boost:: get<3>(x) , boost:: get<4>(x) , boost:: get<5>(x) , boost:: get<6>(x) ); } template<typename Alloc, typename T, typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 , typename A7> void construct_from_tuple(Alloc&, T* ptr, boost:: tuple< A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7> const& x) { new ((void*) ptr) T( boost:: get<0>(x) , boost:: get<1>(x) , boost:: get<2>(x) , boost:: get<3>(x) , boost:: get<4>(x) , boost:: get<5>(x) , boost:: get<6>(x) , boost:: get<7>(x) ); } template<typename Alloc, typename T, typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 , typename A7 , typename A8> void construct_from_tuple(Alloc&, T* ptr, boost:: tuple< A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8> const& x) { new ((void*) ptr) T( boost:: get<0>(x) , boost:: get<1>(x) , boost:: get<2>(x) , boost:: get<3>(x) , boost:: get<4>(x) , boost:: get<5>(x) , boost:: get<6>(x) , boost:: get<7>(x) , boost:: get<8>(x) ); }
# 946 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp"
    template <typename A, typename B, typename A0>
    struct check3_base {
        static choice1::type test(choice1,
            boost::unordered::piecewise_construct_t);





        static choice3::type test(choice3, ...);

        enum { value =
            sizeof(test(choose(), boost::unordered::detail::make<A0>())) };
    };

    template <typename A, typename B, typename A0>
    struct piecewise3 {
        enum { value = check3_base<A,B,A0>::value == sizeof(choice1::type) };
    };
# 1065 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp"
    template <typename Alloc, typename T, typename A0>
    inline void construct_value_impl(Alloc&, T* address,
            emplace_args1<A0> const& args)
    {
        new((void*) address) T(boost::forward<A0>(args.a0));
    }

    template <typename Alloc, typename T, typename A0, typename A1>
    inline void construct_value_impl(Alloc&, T* address,
            emplace_args2<A0, A1> const& args)
    {
        new((void*) address) T(
            boost::forward<A0>(args.a0),
            boost::forward<A1>(args.a1)
        );
    }

    template <typename Alloc, typename T, typename A0, typename A1, typename A2>
    inline void construct_value_impl(Alloc&, T* address,
            emplace_args3<A0, A1, A2> const& args)
    {
        new((void*) address) T(
            boost::forward<A0>(args.a0),
            boost::forward<A1>(args.a1),
            boost::forward<A2>(args.a2)
        );
    }

    template < typename Alloc, typename T, typename A0 , typename A1 , typename A2 , typename A3 > inline void construct_value_impl(Alloc&, T* address, boost::unordered::detail::emplace_args4 < A0 , A1 , A2 , A3 > const& args) { new((void*) address) T( boost::forward<A0>(args.a0) , boost::forward<A1>(args.a1) , boost::forward<A2>(args.a2) , boost::forward<A3>(args.a3)); } template < typename Alloc, typename T, typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > inline void construct_value_impl(Alloc&, T* address, boost::unordered::detail::emplace_args5 < A0 , A1 , A2 , A3 , A4 > const& args) { new((void*) address) T( boost::forward<A0>(args.a0) , boost::forward<A1>(args.a1) , boost::forward<A2>(args.a2) , boost::forward<A3>(args.a3) , boost::forward<A4>(args.a4)); } template < typename Alloc, typename T, typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > inline void construct_value_impl(Alloc&, T* address, boost::unordered::detail::emplace_args6 < A0 , A1 , A2 , A3 , A4 , A5 > const& args) { new((void*) address) T( boost::forward<A0>(args.a0) , boost::forward<A1>(args.a1) , boost::forward<A2>(args.a2) , boost::forward<A3>(args.a3) , boost::forward<A4>(args.a4) , boost::forward<A5>(args.a5)); } template < typename Alloc, typename T, typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > inline void construct_value_impl(Alloc&, T* address, boost::unordered::detail::emplace_args7 < A0 , A1 , A2 , A3 , A4 , A5 , A6 > const& args) { new((void*) address) T( boost::forward<A0>(args.a0) , boost::forward<A1>(args.a1) , boost::forward<A2>(args.a2) , boost::forward<A3>(args.a3) , boost::forward<A4>(args.a4) , boost::forward<A5>(args.a5) , boost::forward<A6>(args.a6)); } template < typename Alloc, typename T, typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 , typename A7 > inline void construct_value_impl(Alloc&, T* address, boost::unordered::detail::emplace_args8 < A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 > const& args) { new((void*) address) T( boost::forward<A0>(args.a0) , boost::forward<A1>(args.a1) , boost::forward<A2>(args.a2) , boost::forward<A3>(args.a3) , boost::forward<A4>(args.a4) , boost::forward<A5>(args.a5) , boost::forward<A6>(args.a6) , boost::forward<A7>(args.a7)); } template < typename Alloc, typename T, typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 , typename A7 , typename A8 > inline void construct_value_impl(Alloc&, T* address, boost::unordered::detail::emplace_args9 < A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 > const& args) { new((void*) address) T( boost::forward<A0>(args.a0) , boost::forward<A1>(args.a1) , boost::forward<A2>(args.a2) , boost::forward<A3>(args.a3) , boost::forward<A4>(args.a4) , boost::forward<A5>(args.a5) , boost::forward<A6>(args.a6) , boost::forward<A7>(args.a7) , boost::forward<A8>(args.a8)); }




    template <typename Alloc, typename A, typename B,
        typename A0, typename A1, typename A2>
    inline void construct_value_impl(Alloc& alloc, std::pair<A, B>* address,
            boost::unordered::detail::emplace_args3<A0, A1, A2> const& args,
            typename enable_if<piecewise3<A, B, A0>, void*>::type = 0)
    {
        boost::unordered::detail::construct_from_tuple(alloc,
            boost::addressof(address->first), args.a1);
        boost::unordered::detail::construct_from_tuple(alloc,
            boost::addressof(address->second), args.a2);
    }
# 1164 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp"
}}}





namespace boost { namespace unordered { namespace detail {
# 1180 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp"
    template <typename Allocator>
    struct array_constructor
    {
        typedef boost::unordered::detail::allocator_traits<Allocator> traits;
        typedef typename traits::pointer pointer;

        Allocator& alloc_;
        pointer ptr_;
        pointer constructed_;
        std::size_t length_;

        array_constructor(Allocator& a)
            : alloc_(a), ptr_(), constructed_(), length_(0)
        {
            constructed_ = pointer();
            ptr_ = pointer();
        }

        ~array_constructor() {
            if (ptr_) {
                for(pointer p = ptr_; p != constructed_; ++p)
                    traits::destroy(alloc_, boost::addressof(*p));

                traits::deallocate(alloc_, ptr_, length_);
            }
        }

        template <typename V>
        void construct(V const& v, std::size_t l)
        {
            ((!ptr_) ? static_cast<void> (0) : __assert_fail ("!ptr_", "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/allocate.hpp", 1210, __PRETTY_FUNCTION__));
            length_ = l;
            ptr_ = traits::allocate(alloc_, length_);
            pointer end = ptr_ + static_cast<std::ptrdiff_t>(length_);
            for(constructed_ = ptr_; constructed_ != end; ++constructed_)
                traits::construct(alloc_, boost::addressof(*constructed_), v);
        }

        pointer get() const
        {
            return ptr_;
        }

        pointer release()
        {
            pointer p(ptr_);
            ptr_ = pointer();
            return p;
        }

    private:

        array_constructor(array_constructor const&);
        array_constructor& operator=(array_constructor const&);
    };
}}}
# 15 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/buckets.hpp" 2




# 1 "/home/marek/devel/nupic/external/common/include/boost/assert.hpp" 1
# 50 "/home/marek/devel/nupic/external/common/include/boost/assert.hpp"
# 1 "/usr/include/assert.h" 1 3 4
# 64 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 50 "/home/marek/devel/nupic/external/common/include/boost/assert.hpp" 2
# 19 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/buckets.hpp" 2




namespace boost { namespace unordered { namespace detail {

    template <typename Types> struct table;
    template <typename NodePointer> struct bucket;
    struct ptr_bucket;
    template <typename Types> struct table_impl;
    template <typename Types> struct grouped_table_impl;

}}}

namespace boost { namespace unordered { namespace iterator_detail {






    template <typename NodePointer, typename Value> struct iterator;
    template <typename ConstNodePointer, typename NodePointer,
        typename Value> struct c_iterator;
    template <typename NodePointer, typename Value, typename Policy>
        struct l_iterator;
    template <typename ConstNodePointer, typename NodePointer,
        typename Value, typename Policy> struct cl_iterator;





    template <typename NodePointer, typename Value, typename Policy>
    struct l_iterator
        : public boost::iterator<
            std::forward_iterator_tag, Value, std::ptrdiff_t,
            NodePointer, Value&>
    {

        template <typename ConstNodePointer, typename NodePointer2,
                typename Value2, typename Policy2>
        friend struct boost::unordered::iterator_detail::cl_iterator;
    private:

        typedef NodePointer node_pointer;
        typedef boost::unordered::iterator_detail::iterator<NodePointer, Value>
            iterator;
        node_pointer ptr_;
        std::size_t bucket_;
        std::size_t bucket_count_;

    public:

        l_iterator() : ptr_() {}

        l_iterator(iterator x, std::size_t b, std::size_t c)
            : ptr_(x.node_), bucket_(b), bucket_count_(c) {}

        Value& operator*() const {
            return ptr_->value();
        }

        Value* operator->() const {
            return ptr_->value_ptr();
        }

        l_iterator& operator++() {
            ptr_ = static_cast<node_pointer>(ptr_->next_);
            if (ptr_ && Policy::to_bucket(bucket_count_, ptr_->hash_)
                    != bucket_)
                ptr_ = node_pointer();
            return *this;
        }

        l_iterator operator++(int) {
            l_iterator tmp(*this);
            ++(*this);
            return tmp;
        }

        bool operator==(l_iterator x) const {
            return ptr_ == x.ptr_;
        }

        bool operator!=(l_iterator x) const {
            return ptr_ != x.ptr_;
        }
    };

    template <typename ConstNodePointer, typename NodePointer, typename Value,
             typename Policy>
    struct cl_iterator
        : public boost::iterator<
            std::forward_iterator_tag, Value, std::ptrdiff_t,
            ConstNodePointer, Value const&>
    {
        friend struct boost::unordered::iterator_detail::l_iterator
            <NodePointer, Value, Policy>;
    private:

        typedef NodePointer node_pointer;
        typedef boost::unordered::iterator_detail::iterator<NodePointer, Value>
            iterator;
        node_pointer ptr_;
        std::size_t bucket_;
        std::size_t bucket_count_;

    public:

        cl_iterator() : ptr_() {}

        cl_iterator(iterator x, std::size_t b, std::size_t c) :
            ptr_(x.node_), bucket_(b), bucket_count_(c) {}

        cl_iterator(boost::unordered::iterator_detail::l_iterator<
                NodePointer, Value, Policy> const& x) :
            ptr_(x.ptr_), bucket_(x.bucket_), bucket_count_(x.bucket_count_)
        {}

        Value const&
            operator*() const {
            return ptr_->value();
        }

        Value const* operator->() const {
            return ptr_->value_ptr();
        }

        cl_iterator& operator++() {
            ptr_ = static_cast<node_pointer>(ptr_->next_);
            if (ptr_ && Policy::to_bucket(bucket_count_, ptr_->hash_)
                    != bucket_)
                ptr_ = node_pointer();
            return *this;
        }

        cl_iterator operator++(int) {
            cl_iterator tmp(*this);
            ++(*this);
            return tmp;
        }

        friend bool operator==(cl_iterator const& x, cl_iterator const& y) {
            return x.ptr_ == y.ptr_;
        }

        friend bool operator!=(cl_iterator const& x, cl_iterator const& y) {
            return x.ptr_ != y.ptr_;
        }
    };

    template <typename NodePointer, typename Value>
    struct iterator
        : public boost::iterator<
            std::forward_iterator_tag, Value, std::ptrdiff_t,
            NodePointer, Value&>
    {

        template <typename, typename, typename>
        friend struct boost::unordered::iterator_detail::c_iterator;
        template <typename, typename, typename>
        friend struct boost::unordered::iterator_detail::l_iterator;
        template <typename, typename, typename, typename>
        friend struct boost::unordered::iterator_detail::cl_iterator;
        template <typename>
        friend struct boost::unordered::detail::table;
        template <typename>
        friend struct boost::unordered::detail::table_impl;
        template <typename>
        friend struct boost::unordered::detail::grouped_table_impl;
    private:

        typedef NodePointer node_pointer;
        node_pointer node_;

    public:

        iterator() : node_() {}

        explicit iterator(node_pointer const& x) : node_(x) {}

        Value& operator*() const {
            return node_->value();
        }

        Value* operator->() const {
            return &node_->value();
        }

        iterator& operator++() {
            node_ = static_cast<node_pointer>(node_->next_);
            return *this;
        }

        iterator operator++(int) {
            iterator tmp(node_);
            node_ = static_cast<node_pointer>(node_->next_);
            return tmp;
        }

        bool operator==(iterator const& x) const {
            return node_ == x.node_;
        }

        bool operator!=(iterator const& x) const {
            return node_ != x.node_;
        }
    };

    template <typename ConstNodePointer, typename NodePointer, typename Value>
    struct c_iterator
        : public boost::iterator<
            std::forward_iterator_tag, Value, std::ptrdiff_t,
            ConstNodePointer, Value const&>
    {
        friend struct boost::unordered::iterator_detail::iterator<
                NodePointer, Value>;


        template <typename>
        friend struct boost::unordered::detail::table;
        template <typename>
        friend struct boost::unordered::detail::table_impl;
        template <typename>
        friend struct boost::unordered::detail::grouped_table_impl;

    private:


        typedef NodePointer node_pointer;
        typedef boost::unordered::iterator_detail::iterator<NodePointer, Value>
            iterator;
        node_pointer node_;

    public:

        c_iterator() : node_() {}

        explicit c_iterator(node_pointer const& x) : node_(x) {}

        c_iterator(boost::unordered::iterator_detail::iterator<
                NodePointer, Value> const& x) : node_(x.node_) {}

        Value const& operator*() const {
            return node_->value();
        }

        Value const* operator->() const {
            return &node_->value();
        }

        c_iterator& operator++() {
            node_ = static_cast<node_pointer>(node_->next_);
            return *this;
        }

        c_iterator operator++(int) {
            c_iterator tmp(node_);
            node_ = static_cast<node_pointer>(node_->next_);
            return tmp;
        }

        friend bool operator==(c_iterator const& x, c_iterator const& y) {
            return x.node_ == y.node_;
        }

        friend bool operator!=(c_iterator const& x, c_iterator const& y) {
            return x.node_ != y.node_;
        }
    };
}}}

namespace boost { namespace unordered { namespace detail {





    template <typename NodeAlloc>
    struct node_constructor
    {
    private:

        typedef NodeAlloc node_allocator;
        typedef boost::unordered::detail::allocator_traits<NodeAlloc>
            node_allocator_traits;
        typedef typename node_allocator_traits::value_type node;
        typedef typename node_allocator_traits::pointer node_pointer;
        typedef typename node::value_type value_type;

    protected:

        node_allocator& alloc_;

    private:

        node_pointer node_;
        bool node_constructed_;
        bool value_constructed_;

    public:

        node_constructor(node_allocator& n) :
            alloc_(n),
            node_(),
            node_constructed_(false),
            value_constructed_(false)
        {
        }

        ~node_constructor();

        void construct();

        template <typename Args>
        void construct_with_value(Args const& args)
        {
            construct();
            boost::unordered::detail::construct_value_impl(
                alloc_, node_->value_ptr(), args);
            value_constructed_ = true;
        }

        template <typename A0>
        void construct_with_value2(const A0 & a0)
        {
            construct();
            boost::unordered::detail::construct_value_impl(
                alloc_, node_->value_ptr(),
                create_emplace_args(boost::forward<A0>(a0)));
            value_constructed_ = true;
        }

        value_type const& value() const {
            ((node_ && node_constructed_ && value_constructed_) ? static_cast<void> (0) : __assert_fail ("node_ && node_constructed_ && value_constructed_", "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/buckets.hpp", 354, __PRETTY_FUNCTION__));
            return node_->value();
        }


        node_pointer release()
        {
            ((node_ && node_constructed_) ? static_cast<void> (0) : __assert_fail ("node_ && node_constructed_", "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/buckets.hpp", 361, __PRETTY_FUNCTION__));
            node_pointer p = node_;
            node_ = node_pointer();
            return p;
        }

    private:
        node_constructor(node_constructor const&);
        node_constructor& operator=(node_constructor const&);
    };

    template <typename Alloc>
    node_constructor<Alloc>::~node_constructor()
    {
        if (node_) {
            if (value_constructed_) {
                boost::unordered::detail::destroy_value_impl(alloc_,
                    node_->value_ptr());
            }

            if (node_constructed_) {
                node_allocator_traits::destroy(alloc_,
                    boost::addressof(*node_));
            }

            node_allocator_traits::deallocate(alloc_, node_, 1);
        }
    }

    template <typename Alloc>
    void node_constructor<Alloc>::construct()
    {
        if(!node_) {
            node_constructed_ = false;
            value_constructed_ = false;

            node_ = node_allocator_traits::allocate(alloc_, 1);

            node_allocator_traits::construct(alloc_,
                boost::addressof(*node_), node());
            node_->init(static_cast<typename node::link_pointer>(node_));
            node_constructed_ = true;
        }
        else {
            ((node_constructed_) ? static_cast<void> (0) : __assert_fail ("node_constructed_", "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/buckets.hpp", 405, __PRETTY_FUNCTION__));

            if (value_constructed_)
            {
                boost::unordered::detail::destroy_value_impl(alloc_,
                    node_->value_ptr());
                value_constructed_ = false;
            }
        }
    }







    template <typename NodeAlloc>
    struct node_holder : private node_constructor<NodeAlloc>
    {
    private:
        typedef node_constructor<NodeAlloc> base;

        typedef NodeAlloc node_allocator;
        typedef boost::unordered::detail::allocator_traits<NodeAlloc>
            node_allocator_traits;
        typedef typename node_allocator_traits::value_type node;
        typedef typename node_allocator_traits::pointer node_pointer;
        typedef typename node::value_type value_type;
        typedef typename node::link_pointer link_pointer;
        typedef boost::unordered::iterator_detail::
            iterator<node_pointer, value_type> iterator;

        node_pointer nodes_;

    public:

        template <typename Table>
        explicit node_holder(Table& b) :
            base(b.node_alloc()),
            nodes_()
        {
            if (b.size_) {
                typename Table::previous_pointer prev = b.get_previous_start();
                nodes_ = static_cast<node_pointer>(prev->next_);
                prev->next_ = link_pointer();
                b.size_ = 0;
            }
        }

        ~node_holder();

        template <typename T>
        inline void assign_impl(T const& v) {
            nodes_->value() = v;
        }

        template <typename T1, typename T2>
        inline void assign_impl(std::pair<T1 const, T2> const& v) {
            const_cast<T1&>(nodes_->value().first) = v.first;
            nodes_->value().second = v.second;
        }

        template <typename T>
        inline void move_assign_impl(T& v) {
            nodes_->value() = boost::move(v);
        }

        template <typename T1, typename T2>
        inline void move_assign_impl(std::pair<T1 const, T2>& v) {

            const_cast<T1&>(nodes_->value().first) =
                boost::move(const_cast<T1&>(v.first));
            nodes_->value().second = boost::move(v.second);
        }

        node_pointer copy_of(value_type const& v)
        {
            if (nodes_) {
                assign_impl(v);
                node_pointer p = nodes_;
                nodes_ = static_cast<node_pointer>(p->next_);
                p->init(static_cast<typename node::link_pointer>(p));
                p->next_ = link_pointer();
                return p;
            }
            else {
                this->construct_with_value2(v);
                return base::release();
            }
        }

        node_pointer move_copy_of(value_type& v)
        {
            if (nodes_) {
                move_assign_impl(v);
                node_pointer p = nodes_;
                nodes_ = static_cast<node_pointer>(p->next_);
                p->init(static_cast<typename node::link_pointer>(p));
                p->next_ = link_pointer();
                return p;
            }
            else {
                this->construct_with_value2(boost::move(v));
                return base::release();
            }
        }

        iterator begin() const
        {
            return iterator(nodes_);
        }
    };

    template <typename Alloc>
    node_holder<Alloc>::~node_holder()
    {
        while (nodes_) {
            node_pointer p = nodes_;
            nodes_ = static_cast<node_pointer>(p->next_);

            boost::unordered::detail::destroy_value_impl(this->alloc_,
                p->value_ptr());
            node_allocator_traits::destroy(this->alloc_, boost::addressof(*p));
            node_allocator_traits::deallocate(this->alloc_, p, 1);
        }
    }





    template <typename NodePointer>
    struct bucket
    {
        typedef NodePointer previous_pointer;
        previous_pointer next_;

        bucket() : next_() {}

        previous_pointer first_from_start()
        {
            return next_;
        }

        enum { extra_node = true };
    };

    struct ptr_bucket
    {
        typedef ptr_bucket* previous_pointer;
        previous_pointer next_;

        ptr_bucket() : next_(0) {}

        previous_pointer first_from_start()
        {
            return this;
        }

        enum { extra_node = false };
    };







    template <typename SizeT>
    struct prime_policy
    {
        template <typename Hash, typename T>
        static inline SizeT apply_hash(Hash const& hf, T const& x) {
            return hf(x);
        }

        static inline SizeT to_bucket(SizeT bucket_count, SizeT hash) {
            return hash % bucket_count;
        }

        static inline SizeT new_bucket_count(SizeT min) {
            return boost::unordered::detail::next_prime(min);
        }

        static inline SizeT prev_bucket_count(SizeT max) {
            return boost::unordered::detail::prev_prime(max);
        }
    };

    template <typename SizeT>
    struct mix64_policy
    {
        template <typename Hash, typename T>
        static inline SizeT apply_hash(Hash const& hf, T const& x) {
            SizeT key = hf(x);
            key = (~key) + (key << 21);
            key = key ^ (key >> 24);
            key = (key + (key << 3)) + (key << 8);
            key = key ^ (key >> 14);
            key = (key + (key << 2)) + (key << 4);
            key = key ^ (key >> 28);
            key = key + (key << 31);
            return key;
        }

        static inline SizeT to_bucket(SizeT bucket_count, SizeT hash) {
            return hash & (bucket_count - 1);
        }

        static inline SizeT new_bucket_count(SizeT min) {
            if (min <= 4) return 4;
            --min;
            min |= min >> 1;
            min |= min >> 2;
            min |= min >> 4;
            min |= min >> 8;
            min |= min >> 16;
            min |= min >> 32;
            return min + 1;
        }

        static inline SizeT prev_bucket_count(SizeT max) {
            max |= max >> 1;
            max |= max >> 2;
            max |= max >> 4;
            max |= max >> 8;
            max |= max >> 16;
            max |= max >> 32;
            return (max >> 1) + 1;
        }
    };

    template <int digits, int radix>
    struct pick_policy_impl {
        typedef prime_policy<std::size_t> type;
    };

    template <>
    struct pick_policy_impl<64, 2> {
        typedef mix64_policy<std::size_t> type;
    };

    struct pick_policy :
        pick_policy_impl<
            std::numeric_limits<std::size_t>::digits,
            std::numeric_limits<std::size_t>::radix> {};
# 667 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/buckets.hpp"
    template <class H, class P> class set_hash_functions;

    template <class H, class P>
    class functions
    {
        friend class boost::unordered::detail::set_hash_functions<H, P>;
        functions& operator=(functions const&);

        typedef compressed<H, P> function_pair;

        typedef typename boost::aligned_storage<
            sizeof(function_pair),
            boost::alignment_of<function_pair>::value>::type aligned_function;

        bool current_;
        aligned_function funcs_[2];

        function_pair const& current() const {
            return *static_cast<function_pair const*>(
                static_cast<void const*>(&funcs_[current_]));
        }

        void construct(bool which, H const& hf, P const& eq)
        {
            new((void*) &funcs_[which]) function_pair(hf, eq);
        }

        void construct(bool which, function_pair const& f)
        {
            new((void*) &funcs_[which]) function_pair(f);
        }

        void destroy(bool which)
        {
            boost::unordered::detail::destroy((function_pair*)(&funcs_[which]));
        }

    public:

        functions(H const& hf, P const& eq)
            : current_(false)
        {
            construct(current_, hf, eq);
        }

        functions(functions const& bf)
            : current_(false)
        {
            construct(current_, bf.current());
        }

        ~functions() {
            this->destroy(current_);
        }

        H const& hash_function() const {
            return current().first();
        }

        P const& key_eq() const {
            return current().second();
        }
    };

    template <class H, class P>
    class set_hash_functions
    {
        set_hash_functions(set_hash_functions const&);
        set_hash_functions& operator=(set_hash_functions const&);

        functions<H,P>& functions_;
        bool tmp_functions_;

    public:

        set_hash_functions(functions<H,P>& f, H const& h, P const& p)
          : functions_(f),
            tmp_functions_(!f.current_)
        {
            f.construct(tmp_functions_, h, p);
        }

        set_hash_functions(functions<H,P>& f, functions<H,P> const& other)
          : functions_(f),
            tmp_functions_(!f.current_)
        {
            f.construct(tmp_functions_, other.current());
        }

        ~set_hash_functions()
        {
            functions_.destroy(tmp_functions_);
        }

        void commit()
        {
            functions_.current_ = tmp_functions_;
            tmp_functions_ = !tmp_functions_;
        }
    };
# 775 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/buckets.hpp"
    struct please_ignore_this_overload {
        typedef please_ignore_this_overload type;
    };

    template <typename T>
    struct rv_ref_impl {
        typedef ::boost::rv< T >& type;
    };

    template <typename T>
    struct rv_ref :
        boost::detail::if_true<
            boost::is_class<T>::value
        >::template then <
            boost::unordered::detail::rv_ref_impl<T>,
            please_ignore_this_overload
        >::type
    {};




}}}
# 10 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/table.hpp" 2




# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cmath" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cmath" 3
# 14 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/table.hpp" 2







namespace boost { namespace unordered { namespace detail {




    inline std::size_t double_to_size(double f)
    {
        return f >= static_cast<double>(
            (std::numeric_limits<std::size_t>::max)()) ?
            (std::numeric_limits<std::size_t>::max)() :
            static_cast<std::size_t>(f);
    }



    template <typename ValueType>
    struct value_base
    {
        typedef ValueType value_type;

        typename boost::aligned_storage<
            sizeof(value_type),
            boost::alignment_of<value_type>::value>::type data_;

        void* address() {
            return this;
        }

        value_type& value() {
            return *(ValueType*) this;
        }

        value_type* value_ptr() {
            return (ValueType*) this;
        }

    private:

        value_base& operator=(value_base const&);
    };

    template <typename NodeAlloc>
    struct copy_nodes
    {
        typedef boost::unordered::detail::allocator_traits<NodeAlloc>
            node_allocator_traits;

        node_constructor<NodeAlloc> constructor;

        explicit copy_nodes(NodeAlloc& a) : constructor(a) {}

        typename node_allocator_traits::pointer create(
                typename node_allocator_traits::value_type::value_type const& v)
        {
            constructor.construct_with_value2(v);
            return constructor.release();
        }
    };

    template <typename NodeAlloc>
    struct move_nodes
    {
        typedef boost::unordered::detail::allocator_traits<NodeAlloc>
            node_allocator_traits;

        node_constructor<NodeAlloc> constructor;

        explicit move_nodes(NodeAlloc& a) : constructor(a) {}

        typename node_allocator_traits::pointer create(
                typename node_allocator_traits::value_type::value_type& v)
        {
            constructor.construct_with_value2(boost::move(v));
            return constructor.release();
        }
    };

    template <typename Buckets>
    struct assign_nodes
    {
        node_holder<typename Buckets::node_allocator> holder;

        explicit assign_nodes(Buckets& b) : holder(b) {}

        typename Buckets::node_pointer create(
                typename Buckets::value_type const& v)
        {
            return holder.copy_of(v);
        }
    };

    template <typename Buckets>
    struct move_assign_nodes
    {
        node_holder<typename Buckets::node_allocator> holder;

        explicit move_assign_nodes(Buckets& b) : holder(b) {}

        typename Buckets::node_pointer create(
                typename Buckets::value_type& v)
        {
            return holder.move_copy_of(v);
        }
    };

    template <typename Types>
    struct table :
        Types::policy,
        boost::unordered::detail::functions<
            typename Types::hasher,
            typename Types::key_equal>
    {
    private:
        table(table const&);
        table& operator=(table const&);
    public:
        typedef typename Types::node node;
        typedef typename Types::bucket bucket;
        typedef typename Types::hasher hasher;
        typedef typename Types::key_equal key_equal;
        typedef typename Types::key_type key_type;
        typedef typename Types::extractor extractor;
        typedef typename Types::value_type value_type;
        typedef typename Types::table table_impl;
        typedef typename Types::link_pointer link_pointer;
        typedef typename Types::policy policy;

        typedef boost::unordered::detail::functions<
            typename Types::hasher,
            typename Types::key_equal> functions;

        typedef typename Types::allocator allocator;
        typedef typename boost::unordered::detail::
            rebind_wrap<allocator, node>::type node_allocator;
        typedef typename boost::unordered::detail::
            rebind_wrap<allocator, bucket>::type bucket_allocator;
        typedef boost::unordered::detail::allocator_traits<node_allocator>
            node_allocator_traits;
        typedef boost::unordered::detail::allocator_traits<bucket_allocator>
            bucket_allocator_traits;
        typedef typename node_allocator_traits::pointer
            node_pointer;
        typedef typename node_allocator_traits::const_pointer
            const_node_pointer;
        typedef typename bucket_allocator_traits::pointer
            bucket_pointer;
        typedef typename bucket::previous_pointer
            previous_pointer;
        typedef boost::unordered::detail::node_constructor<node_allocator>
            node_constructor;

        typedef boost::unordered::iterator_detail::
            iterator<node_pointer, value_type> iterator;
        typedef boost::unordered::iterator_detail::
            c_iterator<const_node_pointer, node_pointer, value_type> c_iterator;
        typedef boost::unordered::iterator_detail::
            l_iterator<node_pointer, value_type, policy> l_iterator;
        typedef boost::unordered::iterator_detail::
            cl_iterator<const_node_pointer, node_pointer, value_type, policy>
            cl_iterator;




        boost::unordered::detail::compressed<bucket_allocator, node_allocator>
            allocators_;
        std::size_t bucket_count_;
        std::size_t size_;
        float mlf_;
        std::size_t max_load_;
        bucket_pointer buckets_;




        bucket_allocator const& bucket_alloc() const
        {
            return allocators_.first();
        }

        node_allocator const& node_alloc() const
        {
            return allocators_.second();
        }

        bucket_allocator& bucket_alloc()
        {
            return allocators_.first();
        }

        node_allocator& node_alloc()
        {
            return allocators_.second();
        }

        std::size_t max_bucket_count() const
        {

            return policy::prev_bucket_count(
                bucket_allocator_traits::max_size(bucket_alloc()) - 1);
        }

        bucket_pointer get_bucket(std::size_t bucket_index) const
        {
            ((buckets_) ? static_cast<void> (0) : __assert_fail ("buckets_", "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/table.hpp", 225, __PRETTY_FUNCTION__));
            return buckets_ + static_cast<std::ptrdiff_t>(bucket_index);
        }

        previous_pointer get_previous_start() const
        {
            return get_bucket(bucket_count_)->first_from_start();
        }

        previous_pointer get_previous_start(std::size_t bucket_index) const
        {
            return get_bucket(bucket_index)->next_;
        }

        iterator begin() const
        {
            return size_ ? iterator(static_cast<node_pointer>(
                        get_previous_start()->next_)) : iterator();
        }

        iterator begin(std::size_t bucket_index) const
        {
            if (!size_) return iterator();
            previous_pointer prev = get_previous_start(bucket_index);
            return prev ? iterator(static_cast<node_pointer>(prev->next_)) :
                iterator();
        }

        float load_factor() const
        {
            ((bucket_count_ != 0) ? static_cast<void> (0) : __assert_fail ("bucket_count_ != 0", "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/table.hpp", 255, __PRETTY_FUNCTION__));
            return static_cast<float>(size_)
                / static_cast<float>(bucket_count_);
        }

        std::size_t bucket_size(std::size_t index) const
        {
            iterator it = begin(index);
            if (!it.node_) return 0;

            std::size_t count = 0;
            while(it.node_ && policy::to_bucket(
                        bucket_count_, it.node_->hash_) == index)
            {
                ++count;
                ++it;
            }

            return count;
        }




        std::size_t max_size() const
        {
            using namespace std;


            return boost::unordered::detail::double_to_size(ceil(
                    static_cast<double>(mlf_) *
                    static_cast<double>(max_bucket_count())
                )) - 1;
        }

        void recalculate_max_load()
        {
            using namespace std;



            max_load_ = buckets_ ? boost::unordered::detail::double_to_size(ceil(
                    static_cast<double>(mlf_) *
                    static_cast<double>(bucket_count_)
                )) : 0;

        }

        void max_load_factor(float z)
        {
            ((z > 0) ? static_cast<void> (0) : __assert_fail ("z > 0", "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/table.hpp", 305, __PRETTY_FUNCTION__));
            mlf_ = (std::max)(z, minimum_max_load_factor);
            recalculate_max_load();
        }

        std::size_t min_buckets_for_size(std::size_t size) const
        {
            ((mlf_ >= minimum_max_load_factor) ? static_cast<void> (0) : __assert_fail ("mlf_ >= minimum_max_load_factor", "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/table.hpp", 312, __PRETTY_FUNCTION__));

            using namespace std;
# 323 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/table.hpp"
            return policy::new_bucket_count(
                boost::unordered::detail::double_to_size(floor(
                    static_cast<double>(size) /
                    static_cast<double>(mlf_))) + 1);
        }




        table(std::size_t num_buckets,
                hasher const& hf,
                key_equal const& eq,
                node_allocator const& a) :
            functions(hf, eq),
            allocators_(a,a),
            bucket_count_(policy::new_bucket_count(num_buckets)),
            size_(0),
            mlf_(1.0f),
            max_load_(0),
            buckets_()
        {}

        table(table const& x, node_allocator const& a) :
            functions(x),
            allocators_(a,a),
            bucket_count_(x.min_buckets_for_size(x.size_)),
            size_(0),
            mlf_(x.mlf_),
            max_load_(0),
            buckets_()
        {}

        table(table& x, boost::unordered::detail::move_tag m) :
            functions(x),
            allocators_(x.allocators_, m),
            bucket_count_(x.bucket_count_),
            size_(x.size_),
            mlf_(x.mlf_),
            max_load_(x.max_load_),
            buckets_(x.buckets_)
        {
            x.buckets_ = bucket_pointer();
            x.size_ = 0;
            x.max_load_ = 0;
        }

        table(table& x, node_allocator const& a,
                boost::unordered::detail::move_tag) :
            functions(x),
            allocators_(a, a),
            bucket_count_(x.bucket_count_),
            size_(0),
            mlf_(x.mlf_),
            max_load_(x.max_load_),
            buckets_()
        {}




        void init(table const& x)
        {
            if (x.size_) {
                create_buckets(bucket_count_);
                copy_nodes<node_allocator> copy(node_alloc());
                table_impl::fill_buckets(x.begin(), *this, copy);
            }
        }

        void move_init(table& x)
        {
            if(node_alloc() == x.node_alloc()) {
                move_buckets_from(x);
            }
            else if(x.size_) {

                create_buckets(bucket_count_);

                move_nodes<node_allocator> move(node_alloc());
                node_holder<node_allocator> nodes(x);
                table_impl::fill_buckets(nodes.begin(), *this, move);
            }
        }




        void create_buckets(std::size_t new_count)
        {
            boost::unordered::detail::array_constructor<bucket_allocator>
                constructor(bucket_alloc());


            constructor.construct(bucket(), new_count + 1);

            if (buckets_)
            {


                (constructor.get() +
                    static_cast<std::ptrdiff_t>(new_count))->next_ =
                        (buckets_ + static_cast<std::ptrdiff_t>(
                            bucket_count_))->next_;
                destroy_buckets();
            }
            else if (bucket::extra_node)
            {
                node_constructor a(node_alloc());
                a.construct();

                (constructor.get() +
                    static_cast<std::ptrdiff_t>(new_count))->next_ =
                        a.release();
            }

            bucket_count_ = new_count;
            buckets_ = constructor.release();
            recalculate_max_load();
        }




        void swap_allocators(table& other, false_type)
        {



            ((node_alloc() == other.node_alloc()) ? static_cast<void> (0) : __assert_fail ("node_alloc() == other.node_alloc()", "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/table.hpp", 451, __PRETTY_FUNCTION__));
        }

        void swap_allocators(table& other, true_type)
        {
            allocators_.swap(other.allocators_);
        }


        void swap(table& x)
        {
            boost::unordered::detail::set_hash_functions<hasher, key_equal>
                op1(*this, x);
            boost::unordered::detail::set_hash_functions<hasher, key_equal>
                op2(x, *this);



            swap_allocators(x,
                boost::unordered::detail::integral_constant<bool,
                    allocator_traits<node_allocator>::
                    propagate_on_container_swap::value>());

            boost::swap(buckets_, x.buckets_);
            boost::swap(bucket_count_, x.bucket_count_);
            boost::swap(size_, x.size_);
            std::swap(mlf_, x.mlf_);
            std::swap(max_load_, x.max_load_);
            op1.commit();
            op2.commit();
        }

        void move_buckets_from(table& other)
        {
            ((node_alloc() == other.node_alloc()) ? static_cast<void> (0) : __assert_fail ("node_alloc() == other.node_alloc()", "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/table.hpp", 485, __PRETTY_FUNCTION__));
            ((!buckets_) ? static_cast<void> (0) : __assert_fail ("!buckets_", "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/table.hpp", 486, __PRETTY_FUNCTION__));
            buckets_ = other.buckets_;
            bucket_count_ = other.bucket_count_;
            size_ = other.size_;
            other.buckets_ = bucket_pointer();
            other.size_ = 0;
            other.max_load_ = 0;
        }




        ~table()
        {
            delete_buckets();
        }

        void delete_node(c_iterator n)
        {
            boost::unordered::detail::destroy_value_impl(node_alloc(),
                n.node_->value_ptr());
            node_allocator_traits::destroy(node_alloc(),
                    boost::addressof(*n.node_));
            node_allocator_traits::deallocate(node_alloc(), n.node_, 1);
            --size_;
        }

        std::size_t delete_nodes(c_iterator begin, c_iterator end)
        {
            std::size_t count = 0;

            while(begin != end) {
                c_iterator n = begin;
                ++begin;
                delete_node(n);
                ++count;
            }

            return count;
        }

        void delete_buckets()
        {
            if(buckets_) {
                delete_nodes(begin(), iterator());

                if (bucket::extra_node) {
                    node_pointer n = static_cast<node_pointer>(
                            get_bucket(bucket_count_)->next_);
                    node_allocator_traits::destroy(node_alloc(),
                            boost::addressof(*n));
                    node_allocator_traits::deallocate(node_alloc(), n, 1);
                }

                destroy_buckets();
                buckets_ = bucket_pointer();
                max_load_ = 0;
            }

            ((!size_) ? static_cast<void> (0) : __assert_fail ("!size_", "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/table.hpp", 545, __PRETTY_FUNCTION__));
        }

        void clear()
        {
            if(!size_) return;

            delete_nodes(begin(), iterator());
            get_previous_start()->next_ = link_pointer();
            clear_buckets();

            ((!size_) ? static_cast<void> (0) : __assert_fail ("!size_", "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/table.hpp", 556, __PRETTY_FUNCTION__));
        }

        void clear_buckets()
        {
            bucket_pointer end = get_bucket(bucket_count_);
            for(bucket_pointer it = buckets_; it != end; ++it)
            {
                it->next_ = node_pointer();
            }
        }

        void destroy_buckets()
        {
            bucket_pointer end = get_bucket(bucket_count_ + 1);
            for(bucket_pointer it = buckets_; it != end; ++it)
            {
                bucket_allocator_traits::destroy(bucket_alloc(),
                    boost::addressof(*it));
            }

            bucket_allocator_traits::deallocate(bucket_alloc(),
                buckets_, bucket_count_ + 1);
        }






        void fix_buckets(bucket_pointer this_bucket,
                previous_pointer prev, node_pointer next)
        {
            if (!next)
            {
                if (this_bucket->next_ == prev)
                    this_bucket->next_ = node_pointer();
            }
            else
            {
                bucket_pointer next_bucket = get_bucket(
                    policy::to_bucket(bucket_count_, next->hash_));

                if (next_bucket != this_bucket)
                {
                    next_bucket->next_ = prev;
                    if (this_bucket->next_ == prev)
                        this_bucket->next_ = node_pointer();
                }
            }
        }



        void fix_buckets_range(std::size_t bucket_index,
                previous_pointer prev, node_pointer begin, node_pointer end)
        {
            node_pointer n = begin;



            if (get_bucket(bucket_index)->next_ != prev)
            {
                for(;;) {
                    n = static_cast<node_pointer>(n->next_);
                    if (n == end) {
                        if (n) {
                            std::size_t new_bucket_index =
                                policy::to_bucket(bucket_count_, n->hash_);
                            if (bucket_index != new_bucket_index) {
                                get_bucket(new_bucket_index)->next_ = prev;
                            }
                        }
                        return;
                    }

                    std::size_t new_bucket_index =
                        policy::to_bucket(bucket_count_, n->hash_);
                    if (bucket_index != new_bucket_index) {
                        bucket_index = new_bucket_index;
                        break;
                    }
                }
            }



            get_bucket(bucket_index)->next_ = previous_pointer();
            for(;;) {
                n = static_cast<node_pointer>(n->next_);
                if (n == end) break;

                std::size_t new_bucket_index =
                    policy::to_bucket(bucket_count_, n->hash_);
                if (bucket_index != new_bucket_index) {
                    bucket_index = new_bucket_index;
                    get_bucket(bucket_index)->next_ = previous_pointer();
                }
            };


            if (n) {
                get_bucket(
                    policy::to_bucket(bucket_count_, n->hash_))->next_
                    = prev;
            }
        }




        void assign(table const& x)
        {
            if (this != boost::addressof(x))
            {
                assign(x,
                    boost::unordered::detail::integral_constant<bool,
                        allocator_traits<node_allocator>::
                        propagate_on_container_copy_assignment::value>());
            }
        }

        void assign(table const& x, false_type)
        {

            boost::unordered::detail::set_hash_functions<hasher, key_equal>
                new_func_this(*this, x);
            new_func_this.commit();
            mlf_ = x.mlf_;
            recalculate_max_load();

            if (!size_ && !x.size_) return;

            if (x.size_ >= max_load_) {
                create_buckets(min_buckets_for_size(x.size_));
            }
            else {
                clear_buckets();
            }




            assign_nodes<table> assign(*this);
            table_impl::fill_buckets(x.begin(), *this, assign);
        }

        void assign(table const& x, true_type)
        {
            if (node_alloc() == x.node_alloc()) {
                allocators_.assign(x.allocators_);
                assign(x, false_type());
            }
            else {
                boost::unordered::detail::set_hash_functions<hasher, key_equal>
                    new_func_this(*this, x);



                delete_buckets();
                allocators_.assign(x.allocators_);


                new_func_this.commit();
                mlf_ = x.mlf_;
                bucket_count_ = min_buckets_for_size(x.size_);
                max_load_ = 0;


                if (x.size_) {
                    create_buckets(bucket_count_);
                    copy_nodes<node_allocator> copy(node_alloc());
                    table_impl::fill_buckets(x.begin(), *this, copy);
                }
            }
        }

        void move_assign(table& x)
        {
            if (this != boost::addressof(x))
            {
                move_assign(x,
                    boost::unordered::detail::integral_constant<bool,
                        allocator_traits<node_allocator>::
                        propagate_on_container_move_assignment::value>());
            }
        }

        void move_assign(table& x, true_type)
        {
            delete_buckets();
            allocators_.move_assign(x.allocators_);
            move_assign_no_alloc(x);
        }

        void move_assign(table& x, false_type)
        {
            if (node_alloc() == x.node_alloc()) {
                delete_buckets();
                move_assign_no_alloc(x);
            }
            else {
                boost::unordered::detail::set_hash_functions<hasher, key_equal>
                    new_func_this(*this, x);
                new_func_this.commit();
                mlf_ = x.mlf_;
                recalculate_max_load();

                if (!size_ && !x.size_) return;

                if (x.size_ >= max_load_) {
                    create_buckets(min_buckets_for_size(x.size_));
                }
                else {
                    clear_buckets();
                }




                move_assign_nodes<table> assign(*this);
                node_holder<node_allocator> nodes(x);
                table_impl::fill_buckets(nodes.begin(), *this, assign);
            }
        }

        void move_assign_no_alloc(table& x)
        {
            boost::unordered::detail::set_hash_functions<hasher, key_equal>
                new_func_this(*this, x);

            mlf_ = x.mlf_;
            max_load_ = x.max_load_;
            move_buckets_from(x);
            new_func_this.commit();
        }



        key_type const& get_key(value_type const& x) const
        {
            return extractor::extract(x);
        }

        std::size_t hash(key_type const& k) const
        {
            return policy::apply_hash(this->hash_function(), k);
        }



        template <typename Key, typename Hash, typename Pred>
        iterator generic_find_node(
                Key const& k,
                Hash const& hf,
                Pred const& eq) const
        {
            return static_cast<table_impl const*>(this)->
                find_node_impl(policy::apply_hash(hf, k), k, eq);
        }

        iterator find_node(
                std::size_t key_hash,
                key_type const& k) const
        {
            return static_cast<table_impl const*>(this)->
                find_node_impl(key_hash, k, this->key_eq());
        }

        iterator find_node(key_type const& k) const
        {
            return static_cast<table_impl const*>(this)->
                find_node_impl(hash(k), k, this->key_eq());
        }

        iterator find_matching_node(iterator n) const
        {






            return find_node(get_key(*n));
        }



        void reserve_for_insert(std::size_t);
        void rehash(std::size_t);
        void reserve(std::size_t);
    };





    template <typename Types>
    inline void table<Types>::reserve_for_insert(std::size_t size)
    {
        if (!buckets_) {
            create_buckets((std::max)(bucket_count_,
                min_buckets_for_size(size)));
        }


        else if(size > max_load_) {
            std::size_t num_buckets
                = min_buckets_for_size((std::max)(size,
                    size_ + (size_ >> 1)));

            if (num_buckets != bucket_count_)
                static_cast<table_impl*>(this)->rehash_impl(num_buckets);
        }
    }




    template <typename Types>
    inline void table<Types>::rehash(std::size_t min_buckets)
    {
        using namespace std;

        if(!size_) {
            delete_buckets();
            bucket_count_ = policy::new_bucket_count(min_buckets);
        }
        else {
            min_buckets = policy::new_bucket_count((std::max)(min_buckets,
                boost::unordered::detail::double_to_size(floor(
                    static_cast<double>(size_) /
                    static_cast<double>(mlf_))) + 1));

            if(min_buckets != bucket_count_)
                static_cast<table_impl*>(this)->rehash_impl(min_buckets);
        }
    }

    template <typename Types>
    inline void table<Types>::reserve(std::size_t num_elements)
    {
        rehash(static_cast<std::size_t>(
            std::ceil(static_cast<double>(num_elements) / mlf_)));
    }
}}}
# 14 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/equivalent.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/extract_key.hpp" 1
# 11 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/extract_key.hpp"
namespace boost {
namespace unordered {
namespace detail {
# 25 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/extract_key.hpp"
    struct no_key {
        no_key() {}
        template <class T> no_key(T const&) {}
    };

    template <typename Key, typename T>
    struct is_key {
        template <typename T2>
        static choice1::type test(T2 const&);
        static choice2::type test(Key const&);

        enum { value = sizeof(test(boost::unordered::detail::make<T>())) ==
            sizeof(choice2::type) };

        typedef typename boost::detail::if_true<value>::
            template then<Key const&, no_key>::type type;
    };

    template <class ValueType>
    struct set_extractor
    {
        typedef ValueType value_type;
        typedef ValueType key_type;

        static key_type const& extract(key_type const& v)
        {
            return v;
        }

        static no_key extract()
        {
            return no_key();
        }
# 66 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/extract_key.hpp"
        template <class Arg>
        static no_key extract(Arg const&)
        {
            return no_key();
        }

        template <class Arg1, class Arg2>
        static no_key extract(Arg1 const&, Arg2 const&)
        {
            return no_key();
        }


        static bool compare_mapped(value_type const&, value_type const&)
        {
            return true;
        }
    };

    template <class Key, class ValueType>
    struct map_extractor
    {
        typedef ValueType value_type;
        typedef typename boost::remove_const<Key>::type key_type;

        static key_type const& extract(value_type const& v)
        {
            return v.first;
        }

        static key_type const& extract(key_type const& v)
        {
            return v;
        }

        template <class Second>
        static key_type const& extract(std::pair<key_type, Second> const& v)
        {
            return v.first;
        }

        template <class Second>
        static key_type const& extract(
            std::pair<key_type const, Second> const& v)
        {
            return v.first;
        }
# 129 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/extract_key.hpp"
        template <class Arg1>
        static key_type const& extract(key_type const& k, Arg1 const&)
        {
            return k;
        }

        static no_key extract()
        {
            return no_key();
        }

        template <class Arg>
        static no_key extract(Arg const&)
        {
            return no_key();
        }

        template <class Arg, class Arg1>
        static no_key extract(Arg const&, Arg1 const&)
        {
            return no_key();
        }
# 192 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/extract_key.hpp"
static no_key extract(boost::unordered::piecewise_construct_t, boost::tuple<> const&) { return no_key(); } template <typename T> static typename is_key<key_type, T>::type extract(boost::unordered::piecewise_construct_t, boost::tuple<T> const& k) { return typename is_key<key_type, T>::type( boost::get<0>(k)); }






        static bool compare_mapped(value_type const& x, value_type const& y)
        {
            return x.second == y.second;
        }
    };
}}}
# 15 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/equivalent.hpp" 2


namespace boost { namespace unordered { namespace detail {

    template <typename A, typename T> struct grouped_node;
    template <typename T> struct grouped_ptr_node;
    template <typename Types> struct grouped_table_impl;

    template <typename A, typename T>
    struct grouped_node :
        boost::unordered::detail::value_base<T>
    {
        typedef typename ::boost::unordered::detail::rebind_wrap<
            A, grouped_node<A, T> >::type::pointer link_pointer;

        link_pointer next_;
        link_pointer group_prev_;
        std::size_t hash_;

        grouped_node() :
            next_(),
            group_prev_(),
            hash_(0)
        {}

        void init(link_pointer self)
        {
            group_prev_ = self;
        }

    private:
        grouped_node& operator=(grouped_node const&);
    };

    template <typename T>
    struct grouped_ptr_node :
        boost::unordered::detail::value_base<T>,
        boost::unordered::detail::ptr_bucket
    {
        typedef boost::unordered::detail::ptr_bucket bucket_base;
        typedef ptr_bucket* link_pointer;

        link_pointer group_prev_;
        std::size_t hash_;

        grouped_ptr_node() :
            bucket_base(),
            group_prev_(0),
            hash_(0)
        {}

        void init(link_pointer self)
        {
            group_prev_ = self;
        }

    private:
        grouped_ptr_node& operator=(grouped_ptr_node const&);
    };




    template <typename A, typename T, typename NodePtr, typename BucketPtr>
    struct pick_grouped_node2
    {
        typedef boost::unordered::detail::grouped_node<A, T> node;

        typedef typename boost::unordered::detail::allocator_traits<
            typename boost::unordered::detail::rebind_wrap<A, node>::type
        >::pointer node_pointer;

        typedef boost::unordered::detail::bucket<node_pointer> bucket;
        typedef node_pointer link_pointer;
    };

    template <typename A, typename T>
    struct pick_grouped_node2<A, T,
        boost::unordered::detail::grouped_ptr_node<T>*,
        boost::unordered::detail::ptr_bucket*>
    {
        typedef boost::unordered::detail::grouped_ptr_node<T> node;
        typedef boost::unordered::detail::ptr_bucket bucket;
        typedef bucket* link_pointer;
    };

    template <typename A, typename T>
    struct pick_grouped_node
    {
        typedef boost::unordered::detail::allocator_traits<
            typename boost::unordered::detail::rebind_wrap<A,
                boost::unordered::detail::grouped_ptr_node<T> >::type
        > tentative_node_traits;

        typedef boost::unordered::detail::allocator_traits<
            typename boost::unordered::detail::rebind_wrap<A,
                boost::unordered::detail::ptr_bucket >::type
        > tentative_bucket_traits;

        typedef pick_grouped_node2<A, T,
            typename tentative_node_traits::pointer,
            typename tentative_bucket_traits::pointer> pick;

        typedef typename pick::node node;
        typedef typename pick::bucket bucket;
        typedef typename pick::link_pointer link_pointer;
    };

    template <typename A, typename T, typename H, typename P>
    struct multiset
    {
        typedef boost::unordered::detail::multiset<A, T, H, P> types;

        typedef A allocator;
        typedef T value_type;
        typedef H hasher;
        typedef P key_equal;
        typedef T key_type;

        typedef boost::unordered::detail::allocator_traits<allocator> traits;
        typedef boost::unordered::detail::pick_grouped_node<allocator,
            value_type> pick;
        typedef typename pick::node node;
        typedef typename pick::bucket bucket;
        typedef typename pick::link_pointer link_pointer;

        typedef boost::unordered::detail::grouped_table_impl<types> table;
        typedef boost::unordered::detail::set_extractor<value_type> extractor;

        typedef boost::unordered::detail::pick_policy::type policy;
    };

    template <typename A, typename K, typename M, typename H, typename P>
    struct multimap
    {
        typedef boost::unordered::detail::multimap<A, K, M, H, P> types;

        typedef A allocator;
        typedef std::pair<K const, M> value_type;
        typedef H hasher;
        typedef P key_equal;
        typedef K key_type;

        typedef boost::unordered::detail::allocator_traits<allocator> traits;
        typedef boost::unordered::detail::pick_grouped_node<allocator,
                value_type> pick;
        typedef typename pick::node node;
        typedef typename pick::bucket bucket;
        typedef typename pick::link_pointer link_pointer;

        typedef boost::unordered::detail::grouped_table_impl<types> table;
        typedef boost::unordered::detail::map_extractor<key_type, value_type>
            extractor;

        typedef boost::unordered::detail::pick_policy::type policy;
    };

    template <typename Types>
    struct grouped_table_impl : boost::unordered::detail::table<Types>
    {
        typedef boost::unordered::detail::table<Types> table;
        typedef typename table::value_type value_type;
        typedef typename table::bucket bucket;
        typedef typename table::policy policy;
        typedef typename table::node_pointer node_pointer;
        typedef typename table::node_allocator node_allocator;
        typedef typename table::node_allocator_traits node_allocator_traits;
        typedef typename table::bucket_pointer bucket_pointer;
        typedef typename table::link_pointer link_pointer;
        typedef typename table::previous_pointer previous_pointer;
        typedef typename table::hasher hasher;
        typedef typename table::key_equal key_equal;
        typedef typename table::key_type key_type;
        typedef typename table::node_constructor node_constructor;
        typedef typename table::extractor extractor;
        typedef typename table::iterator iterator;
        typedef typename table::c_iterator c_iterator;



        grouped_table_impl(std::size_t n,
                hasher const& hf,
                key_equal const& eq,
                node_allocator const& a)
          : table(n, hf, eq, a)
        {}

        grouped_table_impl(grouped_table_impl const& x)
          : table(x, node_allocator_traits::
                select_on_container_copy_construction(x.node_alloc()))
        {
            this->init(x);
        }

        grouped_table_impl(grouped_table_impl const& x,
                node_allocator const& a)
          : table(x, a)
        {
            this->init(x);
        }

        grouped_table_impl(grouped_table_impl& x,
                boost::unordered::detail::move_tag m)
          : table(x, m)
        {}

        grouped_table_impl(grouped_table_impl& x,
                node_allocator const& a,
                boost::unordered::detail::move_tag m)
          : table(x, a, m)
        {
            this->move_init(x);
        }



        template <class Key, class Pred>
        iterator find_node_impl(
                std::size_t key_hash,
                Key const& k,
                Pred const& eq) const
        {
            std::size_t bucket_index =
                policy::to_bucket(this->bucket_count_, key_hash);
            iterator n = this->begin(bucket_index);

            for (;;)
            {
                if (!n.node_) return n;

                std::size_t node_hash = n.node_->hash_;
                if (key_hash == node_hash)
                {
                    if (eq(k, this->get_key(*n)))
                        return n;
                }
                else
                {
                    if (policy::to_bucket(this->bucket_count_, node_hash)
                            != bucket_index)
                        return iterator();
                }

                n = iterator(static_cast<node_pointer>(
                    static_cast<node_pointer>(n.node_->group_prev_)->next_));
            }
        }

        std::size_t count(key_type const& k) const
        {
            iterator n = this->find_node(k);
            if (!n.node_) return 0;

            std::size_t x = 0;
            node_pointer it = n.node_;
            do {
                it = static_cast<node_pointer>(it->group_prev_);
                ++x;
            } while(it != n.node_);

            return x;
        }

        std::pair<iterator, iterator>
            equal_range(key_type const& k) const
        {
            iterator n = this->find_node(k);
            return std::make_pair(
                n, n.node_ ? iterator(
                    static_cast<node_pointer>(
                        static_cast<node_pointer>(n.node_->group_prev_)->next_
                    )) : n);
        }



        bool equals(grouped_table_impl const& other) const
        {
            if(this->size_ != other.size_) return false;

            for(iterator n1 = this->begin(); n1.node_;)
            {
                iterator n2 = other.find_matching_node(n1);
                if (!n2.node_) return false;
                iterator end1(static_cast<node_pointer>(
                    static_cast<node_pointer>(n1.node_->group_prev_)->next_));
                iterator end2(static_cast<node_pointer>(
                    static_cast<node_pointer>(n2.node_->group_prev_)->next_));
                if (!group_equals(n1, end1, n2, end2)) return false;
                n1 = end1;
            }

            return true;
        }



        static bool group_equals(iterator n1, iterator end1,
                iterator n2, iterator end2)
        {
            for(;;)
            {
                if (*n1 != *n2) break;

                ++n1;
                ++n2;

                if (n1 == end1) return n2 == end2;
                if (n2 == end2) return false;
            }

            for(iterator n1a = n1, n2a = n2;;)
            {
                ++n1a;
                ++n2a;

                if (n1a == end1)
                {
                    if (n2a == end2) break;
                    else return false;
                }

                if (n2a == end2) return false;
            }

            iterator start = n1;
            for(;n1 != end1; ++n1)
            {
                value_type const& v = *n1;
                if (find(start, n1, v)) continue;
                std::size_t matches = count_equal(n2, end2, v);
                if (!matches) return false;
                iterator next = n1;
                ++next;
                if (matches != 1 + count_equal(next, end1, v)) return false;
            }

            return true;
        }

        static bool find(iterator n, iterator end, value_type const& v)
        {
            for(;n != end; ++n)
                if (*n == v)
                    return true;
            return false;
        }

        static std::size_t count_equal(iterator n, iterator end,
            value_type const& v)
        {
            std::size_t count = 0;
            for(;n != end; ++n)
                if (*n == v) ++count;
            return count;
        }
# 394 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/equivalent.hpp"
        static inline void add_after_node(
                node_pointer n,
                node_pointer pos)
        {
            n->next_ = static_cast<node_pointer>(pos->group_prev_)->next_;
            n->group_prev_ = pos->group_prev_;
            static_cast<node_pointer>(pos->group_prev_)->next_ =
                static_cast<link_pointer>(n);
            pos->group_prev_ = static_cast<link_pointer>(n);
        }

        inline iterator add_node(
                node_constructor& a,
                std::size_t key_hash,
                iterator pos)
        {
            node_pointer n = a.release();
            n->hash_ = key_hash;
            if (pos.node_) {
                this->add_after_node(n, pos.node_);
                if (n->next_) {
                    std::size_t next_bucket = policy::to_bucket(
                        this->bucket_count_,
                        static_cast<node_pointer>(n->next_)->hash_);
                    if (next_bucket !=
                            policy::to_bucket(this->bucket_count_, key_hash)) {
                        this->get_bucket(next_bucket)->next_ = n;
                    }
                }
            }
            else {
                bucket_pointer b = this->get_bucket(
                    policy::to_bucket(this->bucket_count_, key_hash));

                if (!b->next_)
                {
                    previous_pointer start_node = this->get_previous_start();

                    if (start_node->next_) {
                        this->get_bucket(policy::to_bucket(this->bucket_count_,
                            static_cast<node_pointer>(start_node->next_)->hash_
                        ))->next_ = n;
                    }

                    b->next_ = start_node;
                    n->next_ = start_node->next_;
                    start_node->next_ = static_cast<link_pointer>(n);
                }
                else
                {
                    n->next_ = b->next_->next_;
                    b->next_->next_ = static_cast<link_pointer>(n);
                }
            }
            ++this->size_;
            return iterator(n);
        }

        iterator emplace_impl(node_constructor& a)
        {
            key_type const& k = this->get_key(a.value());
            std::size_t key_hash = this->hash(k);
            iterator position = this->find_node(key_hash, k);



            this->reserve_for_insert(this->size_ + 1);
            return this->add_node(a, key_hash, position);
        }

        void emplace_impl_no_rehash(node_constructor& a)
        {
            key_type const& k = this->get_key(a.value());
            std::size_t key_hash = this->hash(k);
            this->add_node(a, key_hash, this->find_node(key_hash, k));
        }



        iterator emplace(boost::unordered::detail::emplace_args1<
                boost::unordered::detail::please_ignore_this_overload> const&)
        {
            ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/equivalent.hpp", 476, __PRETTY_FUNCTION__));
            return iterator();
        }
# 489 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/equivalent.hpp"
        template <typename Args>
        iterator emplace(Args const& args)
        {
            node_constructor a(this->node_alloc());
            a.construct_with_value(args);

            return iterator(emplace_impl(a));
        }






        template <class I>
        typename boost::unordered::detail::enable_if_forward<I, void>::type
            insert_range(I i, I j)
        {
            if(i == j) return;

            std::size_t distance = boost::unordered::detail::distance(i, j);
            if(distance == 1) {
                node_constructor a(this->node_alloc());
                a.construct_with_value2(*i);
                emplace_impl(a);
            }
            else {

                this->reserve_for_insert(this->size_ + distance);

                node_constructor a(this->node_alloc());
                for (; i != j; ++i) {
                    a.construct_with_value2(*i);
                    emplace_impl_no_rehash(a);
                }
            }
        }

        template <class I>
        typename boost::unordered::detail::disable_if_forward<I, void>::type
            insert_range(I i, I j)
        {
            node_constructor a(this->node_alloc());
            for (; i != j; ++i) {
                a.construct_with_value2(*i);
                emplace_impl(a);
            }
        }






        std::size_t erase_key(key_type const& k)
        {
            if(!this->size_) return 0;

            std::size_t key_hash = this->hash(k);
            std::size_t bucket_index =
                policy::to_bucket(this->bucket_count_, key_hash);
            bucket_pointer this_bucket = this->get_bucket(bucket_index);

            previous_pointer prev = this_bucket->next_;
            if (!prev) return 0;

            for (;;)
            {
                if (!prev->next_) return 0;
                std::size_t node_hash =
                    static_cast<node_pointer>(prev->next_)->hash_;
                if (policy::to_bucket(this->bucket_count_, node_hash)
                        != bucket_index)
                    return 0;
                if (node_hash == key_hash &&
                    this->key_eq()(k, this->get_key(
                        static_cast<node_pointer>(prev->next_)->value())))
                    break;
                prev = static_cast<previous_pointer>(
                    static_cast<node_pointer>(prev->next_)->group_prev_);
            }

            node_pointer pos = static_cast<node_pointer>(prev->next_);
            link_pointer end1 =
                static_cast<node_pointer>(pos->group_prev_)->next_;
            node_pointer end = static_cast<node_pointer>(end1);
            prev->next_ = end1;
            this->fix_buckets(this_bucket, prev, end);
            return this->delete_nodes(c_iterator(pos), c_iterator(end));
        }

        iterator erase(c_iterator r)
        {
            ((r.node_) ? static_cast<void> (0) : __assert_fail ("r.node_", "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/equivalent.hpp", 582, __PRETTY_FUNCTION__));
            iterator next(r.node_);
            ++next;

            bucket_pointer this_bucket = this->get_bucket(
                policy::to_bucket(this->bucket_count_, r.node_->hash_));
            previous_pointer prev = unlink_node(*this_bucket, r.node_);

            this->fix_buckets(this_bucket, prev, next.node_);

            this->delete_node(r);

            return next;
        }

        iterator erase_range(c_iterator r1, c_iterator r2)
        {
            if (r1 == r2) return iterator(r2.node_);

            std::size_t bucket_index =
                policy::to_bucket(this->bucket_count_, r1.node_->hash_);
            previous_pointer prev = unlink_nodes(
                *this->get_bucket(bucket_index), r1.node_, r2.node_);
            this->fix_buckets_range(bucket_index, prev, r1.node_, r2.node_);
            this->delete_nodes(r1, r2);

            return iterator(r2.node_);
        }

        static previous_pointer unlink_node(bucket& b, node_pointer n)
        {
            node_pointer next = static_cast<node_pointer>(n->next_);
            previous_pointer prev =
                static_cast<previous_pointer>(n->group_prev_);

            if(prev->next_ != n) {



                prev = b.next_;
                while(prev->next_ != n) {
                    prev = static_cast<previous_pointer>(
                        static_cast<node_pointer>(prev->next_)->group_prev_);
                }


                if (next && next->group_prev_ == static_cast<link_pointer>(n))
                {
                    next->group_prev_ = n->group_prev_;
                }
            }
            else if (next && next->group_prev_ == static_cast<link_pointer>(n))
            {


                next->group_prev_ = n->group_prev_;
            }
            else {



                node_pointer x = static_cast<node_pointer>(n->group_prev_);
                while(x->group_prev_ != static_cast<link_pointer>(n)) {
                    x = static_cast<node_pointer>(x->group_prev_);
                }
                x->group_prev_ = n->group_prev_;
            }

            prev->next_ = static_cast<link_pointer>(next);
            return prev;
        }

        static previous_pointer unlink_nodes(bucket& b,
                node_pointer begin, node_pointer end)
        {
            previous_pointer prev = static_cast<previous_pointer>(
                begin->group_prev_);

            if(prev->next_ != static_cast<link_pointer>(begin)) {



                prev = b.next_;
                while(prev->next_ != static_cast<link_pointer>(begin))
                    prev = static_cast<previous_pointer>(
                        static_cast<node_pointer>(prev->next_)->group_prev_);

                if (end) split_group(end);
            }
            else {
                node_pointer group1 = split_group(begin);

                if (end) {
                    node_pointer group2 = split_group(end);

                    if(begin == group2) {
                        link_pointer end1 = group1->group_prev_;
                        link_pointer end2 = end->group_prev_;
                        group1->group_prev_ = end2;
                        end->group_prev_ = end1;
                    }
                }
            }

            prev->next_ = static_cast<link_pointer>(end);

            return prev;
        }




        static node_pointer split_group(node_pointer split)
        {

            node_pointer first = split;
            while (static_cast<node_pointer>(first->group_prev_)->next_ ==
                    static_cast<link_pointer>(first))
                first = static_cast<node_pointer>(first->group_prev_);

            if(first == split) return split;

            link_pointer last = first->group_prev_;
            first->group_prev_ = split->group_prev_;
            split->group_prev_ = last;

            return first;
        }




        template <class NodeCreator>
        static void fill_buckets(iterator n, table& dst,
            NodeCreator& creator)
        {
            previous_pointer prev = dst.get_previous_start();

            while (n.node_) {
                std::size_t key_hash = n.node_->hash_;
                iterator group_end(
                    static_cast<node_pointer>(
                        static_cast<node_pointer>(n.node_->group_prev_)->next_
                    ));

                node_pointer first_node = creator.create(*n);
                node_pointer end = first_node;
                first_node->hash_ = key_hash;
                prev->next_ = static_cast<link_pointer>(first_node);
                ++dst.size_;

                for (++n; n != group_end; ++n)
                {
                    end = creator.create(*n);
                    end->hash_ = key_hash;
                    add_after_node(end, first_node);
                    ++dst.size_;
                }

                prev = place_in_bucket(dst, prev, end);
            }
        }


        void rehash_impl(std::size_t num_buckets)
        {
            ((this->buckets_) ? static_cast<void> (0) : __assert_fail ("this->buckets_", "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/equivalent.hpp", 748, __PRETTY_FUNCTION__));

            this->create_buckets(num_buckets);
            previous_pointer prev = this->get_previous_start();
            while (prev->next_)
                prev = place_in_bucket(*this, prev,
                    static_cast<node_pointer>(
                        static_cast<node_pointer>(prev->next_)->group_prev_));
        }



        static previous_pointer place_in_bucket(table& dst,
                previous_pointer prev, node_pointer end)
        {
            bucket_pointer b = dst.get_bucket(policy::to_bucket(
                        dst.bucket_count_, end->hash_));

            if (!b->next_) {
                b->next_ = static_cast<node_pointer>(prev);
                return static_cast<previous_pointer>(end);
            }
            else {
                link_pointer next = end->next_;
                end->next_ = b->next_->next_;
                b->next_->next_ = prev->next_;
                prev->next_ = next;
                return prev;
            }
        }
    };
}}}
# 17 "/home/marek/devel/nupic/external/common/include/boost/unordered/unordered_set.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/unique.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/unique.hpp"
namespace boost { namespace unordered { namespace detail {

    template <typename A, typename T> struct unique_node;
    template <typename T> struct ptr_node;
    template <typename Types> struct table_impl;

    template <typename A, typename T>
    struct unique_node :
        boost::unordered::detail::value_base<T>
    {
        typedef typename ::boost::unordered::detail::rebind_wrap<
            A, unique_node<A, T> >::type::pointer link_pointer;

        link_pointer next_;
        std::size_t hash_;

        unique_node() :
            next_(),
            hash_(0)
        {}

        void init(link_pointer)
        {
        }

    private:
        unique_node& operator=(unique_node const&);
    };

    template <typename T>
    struct ptr_node :
        boost::unordered::detail::value_base<T>,
        boost::unordered::detail::ptr_bucket
    {
        typedef boost::unordered::detail::ptr_bucket bucket_base;
        typedef ptr_bucket* link_pointer;

        std::size_t hash_;

        ptr_node() :
            bucket_base(),
            hash_(0)
        {}

        void init(link_pointer)
        {
        }

    private:
        ptr_node& operator=(ptr_node const&);
    };




    template <typename A, typename T, typename NodePtr, typename BucketPtr>
    struct pick_node2
    {
        typedef boost::unordered::detail::unique_node<A, T> node;

        typedef typename boost::unordered::detail::allocator_traits<
            typename boost::unordered::detail::rebind_wrap<A, node>::type
        >::pointer node_pointer;

        typedef boost::unordered::detail::bucket<node_pointer> bucket;
        typedef node_pointer link_pointer;
    };

    template <typename A, typename T>
    struct pick_node2<A, T,
        boost::unordered::detail::ptr_node<T>*,
        boost::unordered::detail::ptr_bucket*>
    {
        typedef boost::unordered::detail::ptr_node<T> node;
        typedef boost::unordered::detail::ptr_bucket bucket;
        typedef bucket* link_pointer;
    };

    template <typename A, typename T>
    struct pick_node
    {
        typedef boost::unordered::detail::allocator_traits<
            typename boost::unordered::detail::rebind_wrap<A,
                boost::unordered::detail::ptr_node<T> >::type
        > tentative_node_traits;

        typedef boost::unordered::detail::allocator_traits<
            typename boost::unordered::detail::rebind_wrap<A,
                boost::unordered::detail::ptr_bucket >::type
        > tentative_bucket_traits;

        typedef pick_node2<A, T,
            typename tentative_node_traits::pointer,
            typename tentative_bucket_traits::pointer> pick;

        typedef typename pick::node node;
        typedef typename pick::bucket bucket;
        typedef typename pick::link_pointer link_pointer;
    };

    template <typename A, typename T, typename H, typename P>
    struct set
    {
        typedef boost::unordered::detail::set<A, T, H, P> types;

        typedef A allocator;
        typedef T value_type;
        typedef H hasher;
        typedef P key_equal;
        typedef T key_type;

        typedef boost::unordered::detail::allocator_traits<allocator> traits;
        typedef boost::unordered::detail::pick_node<allocator, value_type> pick;
        typedef typename pick::node node;
        typedef typename pick::bucket bucket;
        typedef typename pick::link_pointer link_pointer;

        typedef boost::unordered::detail::table_impl<types> table;
        typedef boost::unordered::detail::set_extractor<value_type> extractor;

        typedef boost::unordered::detail::pick_policy::type policy;
    };

    template <typename A, typename K, typename M, typename H, typename P>
    struct map
    {
        typedef boost::unordered::detail::map<A, K, M, H, P> types;

        typedef A allocator;
        typedef std::pair<K const, M> value_type;
        typedef H hasher;
        typedef P key_equal;
        typedef K key_type;

        typedef boost::unordered::detail::allocator_traits<allocator>
            traits;
        typedef boost::unordered::detail::pick_node<allocator, value_type> pick;
        typedef typename pick::node node;
        typedef typename pick::bucket bucket;
        typedef typename pick::link_pointer link_pointer;

        typedef boost::unordered::detail::table_impl<types> table;
        typedef boost::unordered::detail::map_extractor<key_type, value_type>
            extractor;

        typedef boost::unordered::detail::pick_policy::type policy;
    };

    template <typename Types>
    struct table_impl : boost::unordered::detail::table<Types>
    {
        typedef boost::unordered::detail::table<Types> table;
        typedef typename table::value_type value_type;
        typedef typename table::bucket bucket;
        typedef typename table::policy policy;
        typedef typename table::node_pointer node_pointer;
        typedef typename table::node_allocator node_allocator;
        typedef typename table::node_allocator_traits node_allocator_traits;
        typedef typename table::bucket_pointer bucket_pointer;
        typedef typename table::link_pointer link_pointer;
        typedef typename table::previous_pointer previous_pointer;
        typedef typename table::hasher hasher;
        typedef typename table::key_equal key_equal;
        typedef typename table::key_type key_type;
        typedef typename table::node_constructor node_constructor;
        typedef typename table::extractor extractor;
        typedef typename table::iterator iterator;
        typedef typename table::c_iterator c_iterator;

        typedef std::pair<iterator, bool> emplace_return;



        table_impl(std::size_t n,
                hasher const& hf,
                key_equal const& eq,
                node_allocator const& a)
          : table(n, hf, eq, a)
        {}

        table_impl(table_impl const& x)
          : table(x, node_allocator_traits::
                select_on_container_copy_construction(x.node_alloc()))
        {
            this->init(x);
        }

        table_impl(table_impl const& x,
                node_allocator const& a)
          : table(x, a)
        {
            this->init(x);
        }

        table_impl(table_impl& x,
                boost::unordered::detail::move_tag m)
          : table(x, m)
        {}

        table_impl(table_impl& x,
                node_allocator const& a,
                boost::unordered::detail::move_tag m)
          : table(x, a, m)
        {
            this->move_init(x);
        }



        template <class Key, class Pred>
        iterator find_node_impl(
                std::size_t key_hash,
                Key const& k,
                Pred const& eq) const
        {
            std::size_t bucket_index =
                policy::to_bucket(this->bucket_count_, key_hash);
            iterator n = this->begin(bucket_index);

            for (;;)
            {
                if (!n.node_) return n;

                std::size_t node_hash = n.node_->hash_;
                if (key_hash == node_hash)
                {
                    if (eq(k, this->get_key(*n)))
                        return n;
                }
                else
                {
                    if (policy::to_bucket(this->bucket_count_, node_hash)
                            != bucket_index)
                        return iterator();
                }

                ++n;
            }
        }

        std::size_t count(key_type const& k) const
        {
            return this->find_node(k).node_ ? 1 : 0;
        }

        value_type& at(key_type const& k) const
        {
            if (this->size_) {
                iterator it = this->find_node(k);
                if (it.node_) return *it;
            }

            boost::throw_exception(
                std::out_of_range("Unable to find key in unordered_map."));
        }

        std::pair<iterator, iterator>
            equal_range(key_type const& k) const
        {
            iterator n = this->find_node(k);
            iterator n2 = n;
            if (n2.node_) ++n2;
            return std::make_pair(n, n2);
        }



        bool equals(table_impl const& other) const
        {
            if(this->size_ != other.size_) return false;

            for(iterator n1 = this->begin(); n1.node_; ++n1)
            {
                iterator n2 = other.find_matching_node(n1);


                if (!n2.node_ || *n1 != *n2)
                    return false;




            }

            return true;
        }



        inline iterator add_node(
                node_constructor& a,
                std::size_t key_hash)
        {
            node_pointer n = a.release();
            n->hash_ = key_hash;

            bucket_pointer b = this->get_bucket(
                policy::to_bucket(this->bucket_count_, key_hash));

            if (!b->next_)
            {
                previous_pointer start_node = this->get_previous_start();

                if (start_node->next_) {
                    this->get_bucket(policy::to_bucket(this->bucket_count_,
                        static_cast<node_pointer>(start_node->next_)->hash_)
                    )->next_ = n;
                }

                b->next_ = start_node;
                n->next_ = start_node->next_;
                start_node->next_ = static_cast<link_pointer>(n);
            }
            else
            {
                n->next_ = b->next_->next_;
                b->next_->next_ = static_cast<link_pointer>(n);
            }

            ++this->size_;
            return iterator(n);
        }

        value_type& operator[](key_type const& k)
        {
            typedef typename value_type::second_type mapped_type;

            std::size_t key_hash = this->hash(k);
            iterator pos = this->find_node(key_hash, k);

            if (pos.node_) return *pos;



            node_constructor a(this->node_alloc());
            a.construct_with_value(create_emplace_args(
                boost::unordered::piecewise_construct,
                boost::make_tuple(k),
                boost::make_tuple()));

            this->reserve_for_insert(this->size_ + 1);
            return *add_node(a, key_hash);
        }



        emplace_return emplace(boost::unordered::detail::emplace_args1<
                boost::unordered::detail::please_ignore_this_overload> const&)
        {
            ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/unique.hpp", 368, __PRETTY_FUNCTION__));
            return emplace_return(this->begin(), false);
        }
# 381 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/unique.hpp"
        template <typename Args>
        emplace_return emplace(Args const& args)
        {





            return emplace_impl(
                extractor::extract(args.a0, args.a1),
                args);

        }


        template <typename A0>
        emplace_return emplace(
                boost::unordered::detail::emplace_args1<A0> const& args)
        {
            return emplace_impl(extractor::extract(args.a0), args);
        }


        template <typename Args>
        emplace_return emplace_impl(key_type const& k,
            Args const& args)
        {
            std::size_t key_hash = this->hash(k);
            iterator pos = this->find_node(key_hash, k);

            if (pos.node_) return emplace_return(pos, false);



            node_constructor a(this->node_alloc());
            a.construct_with_value(args);



            this->reserve_for_insert(this->size_ + 1);
            return emplace_return(this->add_node(a, key_hash), true);
        }

        emplace_return emplace_impl_with_node(node_constructor& a)
        {
            key_type const& k = this->get_key(a.value());
            std::size_t key_hash = this->hash(k);
            iterator pos = this->find_node(key_hash, k);

            if (pos.node_) return emplace_return(pos, false);



            this->reserve_for_insert(this->size_ + 1);
            return emplace_return(this->add_node(a, key_hash), true);
        }

        template <typename Args>
        emplace_return emplace_impl(no_key, Args const& args)
        {


            node_constructor a(this->node_alloc());
            a.construct_with_value(args);
            return emplace_impl_with_node(a);
        }







        template <class InputIt>
        void insert_range(InputIt i, InputIt j)
        {
            if(i != j)
                return insert_range_impl(extractor::extract(*i), i, j);
        }

        template <class InputIt>
        void insert_range_impl(key_type const& k, InputIt i, InputIt j)
        {
            node_constructor a(this->node_alloc());

            insert_range_impl2(a, k, i, j);

            while(++i != j) {
# 477 "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/unique.hpp"
                insert_range_impl2(a, extractor::extract(*i), i, j);
            }
        }

        template <class InputIt>
        void insert_range_impl2(node_constructor& a, key_type const& k,
            InputIt i, InputIt j)
        {

            std::size_t key_hash = this->hash(k);
            iterator pos = this->find_node(key_hash, k);

            if (!pos.node_) {
                a.construct_with_value2(*i);
                if(this->size_ + 1 > this->max_load_)
                    this->reserve_for_insert(this->size_ +
                        boost::unordered::detail::insert_size(i, j));


                this->add_node(a, key_hash);
            }
        }

        template <class InputIt>
        void insert_range_impl(no_key, InputIt i, InputIt j)
        {
            node_constructor a(this->node_alloc());

            do {
                a.construct_with_value2(*i);
                emplace_impl_with_node(a);
            } while(++i != j);
        }






        std::size_t erase_key(key_type const& k)
        {
            if(!this->size_) return 0;

            std::size_t key_hash = this->hash(k);
            std::size_t bucket_index =
                policy::to_bucket(this->bucket_count_, key_hash);
            bucket_pointer this_bucket = this->get_bucket(bucket_index);

            previous_pointer prev = this_bucket->next_;
            if (!prev) return 0;

            for (;;)
            {
                if (!prev->next_) return 0;
                std::size_t node_hash =
                    static_cast<node_pointer>(prev->next_)->hash_;
                if (policy::to_bucket(this->bucket_count_, node_hash)
                        != bucket_index)
                    return 0;
                if (node_hash == key_hash &&
                        this->key_eq()(k, this->get_key(
                        static_cast<node_pointer>(prev->next_)->value())))
                    break;
                prev = static_cast<previous_pointer>(prev->next_);
            }

            node_pointer pos = static_cast<node_pointer>(prev->next_);
            node_pointer end = static_cast<node_pointer>(pos->next_);
            prev->next_ = pos->next_;
            this->fix_buckets(this_bucket, prev, end);
            return this->delete_nodes(c_iterator(pos), c_iterator(end));
        }

        iterator erase(c_iterator r)
        {
            ((r.node_) ? static_cast<void> (0) : __assert_fail ("r.node_", "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/unique.hpp", 552, __PRETTY_FUNCTION__));
            iterator next(r.node_);
            ++next;

            bucket_pointer this_bucket = this->get_bucket(
                policy::to_bucket(this->bucket_count_, r.node_->hash_));
            previous_pointer prev = unlink_node(*this_bucket, r.node_);

            this->fix_buckets(this_bucket, prev, next.node_);

            this->delete_node(r);

            return next;
        }

        iterator erase_range(c_iterator r1, c_iterator r2)
        {
            if (r1 == r2) return iterator(r2.node_);

            std::size_t bucket_index =
                policy::to_bucket(this->bucket_count_, r1.node_->hash_);
            previous_pointer prev = unlink_nodes(
                *this->get_bucket(bucket_index), r1.node_, r2.node_);
            this->fix_buckets_range(bucket_index, prev, r1.node_, r2.node_);
            this->delete_nodes(r1, r2);

            return iterator(r2.node_);
        }

        static previous_pointer unlink_node(bucket& b, node_pointer n)
        {
            return unlink_nodes(b, n, static_cast<node_pointer>(n->next_));
        }

        static previous_pointer unlink_nodes(bucket& b,
                node_pointer begin, node_pointer end)
        {
            previous_pointer prev = b.next_;
            link_pointer begin_void = static_cast<link_pointer>(begin);
            while(prev->next_ != begin_void)
                prev = static_cast<previous_pointer>(prev->next_);
            prev->next_ = static_cast<link_pointer>(end);
            return prev;
        }




        template <class NodeCreator>
        static void fill_buckets(iterator n, table& dst,
            NodeCreator& creator)
        {
            previous_pointer prev = dst.get_previous_start();

            while (n.node_) {
                node_pointer node = creator.create(*n);
                node->hash_ = n.node_->hash_;
                prev->next_ = static_cast<link_pointer>(node);
                ++dst.size_;
                ++n;

                prev = place_in_bucket(dst, prev);
            }
        }


        void rehash_impl(std::size_t num_buckets)
        {
            ((this->buckets_) ? static_cast<void> (0) : __assert_fail ("this->buckets_", "/home/marek/devel/nupic/external/common/include/boost/unordered/detail/unique.hpp", 620, __PRETTY_FUNCTION__));

            this->create_buckets(num_buckets);
            previous_pointer prev = this->get_previous_start();
            while (prev->next_)
                prev = place_in_bucket(*this, prev);
        }



        static previous_pointer place_in_bucket(table& dst,
                previous_pointer prev)
        {
            node_pointer n = static_cast<node_pointer>(prev->next_);
            bucket_pointer b = dst.get_bucket(
                table::to_bucket(dst.bucket_count_, n->hash_));

            if (!b->next_) {
                b->next_ = prev;
                return static_cast<previous_pointer>(n);
            }
            else {
                prev->next_ = n->next_;
                n->next_ = b->next_->next_;
                b->next_->next_ = static_cast<link_pointer>(n);
                return prev;
            }
        }
    };
}}}
# 18 "/home/marek/devel/nupic/external/common/include/boost/unordered/unordered_set.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/functional/hash.hpp" 1





# 1 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/hash.hpp" 1
# 15 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/hash.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/detail/hash_float.hpp" 1
# 14 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/detail/hash_float.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/detail/float_functions.hpp" 1
# 10 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/detail/float_functions.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/config/no_tr1/cmath.hpp" 1
# 21 "/home/marek/devel/nupic/external/common/include/boost/config/no_tr1/cmath.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cmath" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cmath" 3
# 21 "/home/marek/devel/nupic/external/common/include/boost/config/no_tr1/cmath.hpp" 2
# 10 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/detail/float_functions.hpp" 2
# 23 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/detail/float_functions.hpp"
namespace boost {
    namespace hash_detail {



        struct not_found {



            inline operator float() const { return 0; }
            inline operator long double() const { return 0; }
        };



        template <typename T> struct is;
        template <> struct is<float> { char x[10]; };
        template <> struct is<double> { char x[20]; };
        template <> struct is<long double> { char x[30]; };
        template <> struct is<boost::hash_detail::not_found> { char x[40]; };



        template <typename T> is<T> float_type(T);





        template <typename Float> struct call_ldexp
        {
            typedef double float_type;

            inline double operator()(double a, int b) const
            {
                using namespace std;
                return ldexp(a, b);
            }
        };





        template <typename Float> struct call_frexp
        {
            typedef double float_type;

            inline double operator()(double a, int* b) const
            {
                using namespace std;
                return frexp(a, b);
            }
        };
    }
}
# 87 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/detail/float_functions.hpp"
namespace boost_hash_detect_float_functions {
    template <class Float> boost::hash_detail::not_found ldexp(Float, int);
    template <class Float> boost::hash_detail::not_found frexp(Float, int*);
}
# 188 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/detail/float_functions.hpp"
namespace boost_hash_detect_float_functions { template <class Float> boost::hash_detail::not_found ldexpf(Float, int); } namespace boost { namespace hash_detail { namespace ldexpf_detect { using namespace std; using namespace boost_hash_detect_float_functions; struct check { static float x; static int y; static const bool cpp = sizeof(float_type(ldexp(x,y))) == sizeof(is<float>); static const bool c99 = sizeof(float_type(ldexpf(x,y))) == sizeof(is<float>); }; } template <bool x> struct call_c99_ldexpf : boost::hash_detail::call_ldexp<double> {}; template <> struct call_c99_ldexpf<true> { typedef float float_type; template <typename T> inline float operator()(float a, T b) const { using namespace std; return ldexpf(a, b); } }; template <bool x> struct call_cpp_ldexpf : call_c99_ldexpf< ::boost::hash_detail:: ldexpf_detect::check::c99 > {}; template <> struct call_cpp_ldexpf<true> { typedef float float_type; template <typename T> inline float operator()(float a, T b) const { using namespace std; return ldexp(a, b); } }; template <> struct call_ldexp<float> : call_cpp_ldexpf< ::boost::hash_detail:: ldexpf_detect::check::cpp > {}; } }





namespace boost_hash_detect_float_functions { template <class Float> boost::hash_detail::not_found ldexpl(Float, int); } namespace boost { namespace hash_detail { namespace ldexpl_detect { using namespace std; using namespace boost_hash_detect_float_functions; struct check { static long double x; static int y; static const bool cpp = sizeof(float_type(ldexp(x,y))) == sizeof(is<long double>); static const bool c99 = sizeof(float_type(ldexpl(x,y))) == sizeof(is<long double>); }; } template <bool x> struct call_c99_ldexpl : boost::hash_detail::call_ldexp<double> {}; template <> struct call_c99_ldexpl<true> { typedef long double float_type; template <typename T> inline long double operator()(long double a, T b) const { using namespace std; return ldexpl(a, b); } }; template <bool x> struct call_cpp_ldexpl : call_c99_ldexpl< ::boost::hash_detail:: ldexpl_detect::check::c99 > {}; template <> struct call_cpp_ldexpl<true> { typedef long double float_type; template <typename T> inline long double operator()(long double a, T b) const { using namespace std; return ldexp(a, b); } }; template <> struct call_ldexp<long double> : call_cpp_ldexpl< ::boost::hash_detail:: ldexpl_detect::check::cpp > {}; } }





namespace boost_hash_detect_float_functions { template <class Float> boost::hash_detail::not_found frexpf(Float, int*); } namespace boost { namespace hash_detail { namespace frexpf_detect { using namespace std; using namespace boost_hash_detect_float_functions; struct check { static float x; static int* y; static const bool cpp = sizeof(float_type(frexp(x,y))) == sizeof(is<float>); static const bool c99 = sizeof(float_type(frexpf(x,y))) == sizeof(is<float>); }; } template <bool x> struct call_c99_frexpf : boost::hash_detail::call_frexp<double> {}; template <> struct call_c99_frexpf<true> { typedef float float_type; template <typename T> inline float operator()(float a, T b) const { using namespace std; return frexpf(a, b); } }; template <bool x> struct call_cpp_frexpf : call_c99_frexpf< ::boost::hash_detail:: frexpf_detect::check::c99 > {}; template <> struct call_cpp_frexpf<true> { typedef float float_type; template <typename T> inline float operator()(float a, T b) const { using namespace std; return frexp(a, b); } }; template <> struct call_frexp<float> : call_cpp_frexpf< ::boost::hash_detail:: frexpf_detect::check::cpp > {}; } }





namespace boost_hash_detect_float_functions { template <class Float> boost::hash_detail::not_found frexpl(Float, int*); } namespace boost { namespace hash_detail { namespace frexpl_detect { using namespace std; using namespace boost_hash_detect_float_functions; struct check { static long double x; static int* y; static const bool cpp = sizeof(float_type(frexp(x,y))) == sizeof(is<long double>); static const bool c99 = sizeof(float_type(frexpl(x,y))) == sizeof(is<long double>); }; } template <bool x> struct call_c99_frexpl : boost::hash_detail::call_frexp<double> {}; template <> struct call_c99_frexpl<true> { typedef long double float_type; template <typename T> inline long double operator()(long double a, T b) const { using namespace std; return frexpl(a, b); } }; template <bool x> struct call_cpp_frexpl : call_c99_frexpl< ::boost::hash_detail:: frexpl_detect::check::c99 > {}; template <> struct call_cpp_frexpl<true> { typedef long double float_type; template <typename T> inline long double operator()(long double a, T b) const { using namespace std; return frexp(a, b); } }; template <> struct call_frexp<long double> : call_cpp_frexpl< ::boost::hash_detail:: frexpl_detect::check::cpp > {}; } }






namespace boost
{
    namespace hash_detail
    {
        template <typename Float1, typename Float2>
        struct select_hash_type_impl {
            typedef double type;
        };

        template <>
        struct select_hash_type_impl<float, float> {
            typedef float type;
        };

        template <>
        struct select_hash_type_impl<long double, long double> {
            typedef long double type;
        };







        template <typename Float>
        struct select_hash_type : select_hash_type_impl<
                typename call_ldexp<Float>::float_type,
                typename call_frexp<Float>::float_type
            > {};
    }
}
# 14 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/detail/hash_float.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/detail/limits.hpp" 1
# 26 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/detail/limits.hpp"
namespace boost
{
    namespace hash_detail
    {
        template <class T>
        struct limits : std::numeric_limits<T> {};
# 58 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/detail/limits.hpp"
    }
}
# 15 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/detail/hash_float.hpp" 2


# 1 "/home/marek/devel/nupic/external/common/include/boost/integer/static_log2.hpp" 1
# 19 "/home/marek/devel/nupic/external/common/include/boost/integer/static_log2.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/integer_fwd.hpp" 1
# 12 "/home/marek/devel/nupic/external/common/include/boost/integer_fwd.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/climits" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/climits" 3

# 1 "/usr/bin/../lib/clang/3.3/include/limits.h" 1 3
# 38 "/usr/bin/../lib/clang/3.3/include/limits.h" 3
# 1 "/usr/include/limits.h" 1 3 4
# 143 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
# 160 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/local_lim.h" 1 3 4
# 38 "/usr/include/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/bits/local_lim.h" 2 3 4
# 161 "/usr/include/bits/posix1_lim.h" 2 3 4
# 144 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
# 148 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/xopen_lim.h" 1 3 4
# 33 "/usr/include/bits/xopen_lim.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 34 "/usr/include/bits/xopen_lim.h" 2 3 4
# 152 "/usr/include/limits.h" 2 3 4
# 39 "/usr/bin/../lib/clang/3.3/include/limits.h" 2 3
# 42 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/climits" 2 3
# 12 "/home/marek/devel/nupic/external/common/include/boost/integer_fwd.hpp" 2

# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstddef" 2 3
# 13 "/home/marek/devel/nupic/external/common/include/boost/integer_fwd.hpp" 2




# 1 "/home/marek/devel/nupic/external/common/include/boost/cstdint.hpp" 1
# 194 "/home/marek/devel/nupic/external/common/include/boost/cstdint.hpp"
namespace boost
{
# 208 "/home/marek/devel/nupic/external/common/include/boost/cstdint.hpp"
     typedef signed char int8_t;
     typedef signed char int_least8_t;
     typedef signed char int_fast8_t;
     typedef unsigned char uint8_t;
     typedef unsigned char uint_least8_t;
     typedef unsigned char uint_fast8_t;
# 231 "/home/marek/devel/nupic/external/common/include/boost/cstdint.hpp"
     typedef short int16_t;
     typedef short int_least16_t;
     typedef short int_fast16_t;
     typedef unsigned short uint16_t;
     typedef unsigned short uint_least16_t;
     typedef unsigned short uint_fast16_t;
# 260 "/home/marek/devel/nupic/external/common/include/boost/cstdint.hpp"
     typedef int int32_t;
     typedef int int_least32_t;
     typedef int int_fast32_t;
     typedef unsigned int uint32_t;
     typedef unsigned int uint_least32_t;
     typedef unsigned int uint_fast32_t;
# 306 "/home/marek/devel/nupic/external/common/include/boost/cstdint.hpp"
     typedef ::boost::long_long_type intmax_t;
     typedef ::boost::ulong_long_type uintmax_t;
     typedef ::boost::long_long_type int64_t;
     typedef ::boost::long_long_type int_least64_t;
     typedef ::boost::long_long_type int_fast64_t;
     typedef ::boost::ulong_long_type uint64_t;
     typedef ::boost::ulong_long_type uint_least64_t;
     typedef ::boost::ulong_long_type uint_fast64_t;
# 356 "/home/marek/devel/nupic/external/common/include/boost/cstdint.hpp"
}
# 387 "/home/marek/devel/nupic/external/common/include/boost/cstdint.hpp" 3
# 17 "/home/marek/devel/nupic/external/common/include/boost/integer_fwd.hpp" 2



namespace boost
{







     typedef boost::uintmax_t static_min_max_unsigned_type;
     typedef boost::intmax_t static_min_max_signed_type;
     typedef boost::uintmax_t static_log2_argument_type;
     typedef int static_log2_result_type;
# 42 "/home/marek/devel/nupic/external/common/include/boost/integer_fwd.hpp"
template < class T >
    class integer_traits;

template < >
    class integer_traits< bool >;

template < >
    class integer_traits< char >;

template < >
    class integer_traits< signed char >;

template < >
    class integer_traits< unsigned char >;


template < >
    class integer_traits< wchar_t >;


template < >
    class integer_traits< short >;

template < >
    class integer_traits< unsigned short >;

template < >
    class integer_traits< int >;

template < >
    class integer_traits< unsigned int >;

template < >
    class integer_traits< long >;

template < >
    class integer_traits< unsigned long >;


template < >
class integer_traits< ::boost::long_long_type>;

template < >
class integer_traits< ::boost::ulong_long_type >;
# 97 "/home/marek/devel/nupic/external/common/include/boost/integer_fwd.hpp"
template < typename LeastInt >
    struct int_fast_t;

template< int Bits >
    struct int_t;

template< int Bits >
    struct uint_t;


    template< boost::long_long_type MaxValue >



    struct int_max_value_t;


  template< boost::long_long_type MinValue >



    struct int_min_value_t;


  template< boost::ulong_long_type MaxValue >



    struct uint_value_t;




template < std::size_t Bit >
    struct high_bit_mask_t;

template < std::size_t Bits >
    struct low_bits_mask_t;

template < >
    struct low_bits_mask_t< ::std::numeric_limits<unsigned char>::digits >;



template <static_log2_argument_type Value >
    struct static_log2;

template <> struct static_log2<0u>;




template <static_min_max_signed_type Value1, static_min_max_signed_type Value2>
    struct static_signed_min;

template <static_min_max_signed_type Value1, static_min_max_signed_type Value2>
    struct static_signed_max;

template <static_min_max_unsigned_type Value1, static_min_max_unsigned_type Value2>
    struct static_unsigned_min;

template <static_min_max_unsigned_type Value1, static_min_max_unsigned_type Value2>
    struct static_unsigned_max;

}
# 19 "/home/marek/devel/nupic/external/common/include/boost/integer/static_log2.hpp" 2


namespace boost {

 namespace detail {

     namespace static_log2_impl {
# 44 "/home/marek/devel/nupic/external/common/include/boost/integer/static_log2.hpp"
     typedef boost::static_log2_argument_type argument_type;
     typedef boost::static_log2_result_type result_type;

     template <result_type n>
     struct choose_initial_n {

         static const bool c = (argument_type(1) << n << n) != 0;
         static const result_type value = !c*n + choose_initial_n<2*c*n>::value;




     };

     template <>
     struct choose_initial_n<0> {
         static const result_type value = 0;
     };




     const result_type n_zero = 16;
     const result_type initial_n = choose_initial_n<n_zero>::value;
# 84 "/home/marek/devel/nupic/external/common/include/boost/integer/static_log2.hpp"
     template <argument_type x, result_type n = initial_n>
     struct static_log2_impl {

         static const bool c = (x >> n) > 0;
         static const result_type value = c*n + (static_log2_impl< (x>>c*n), n/2 >::value);




     };

     template <>
     struct static_log2_impl<1, 0> {
        static const result_type value = 0;
     };

     }
 }







 template <static_log2_argument_type x>
 struct static_log2 {

     static const static_log2_result_type value = detail::static_log2_impl::static_log2_impl<x>::value;




 };


 template <>
 struct static_log2<0> { };

}
# 17 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/detail/hash_float.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/cstdint.hpp" 1
# 18 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/detail/hash_float.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/assert.hpp" 1
# 50 "/home/marek/devel/nupic/external/common/include/boost/assert.hpp"
# 1 "/usr/include/assert.h" 1 3 4
# 64 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 50 "/home/marek/devel/nupic/external/common/include/boost/assert.hpp" 2
# 19 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/detail/hash_float.hpp" 2


# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstring" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstring" 3


# 1 "/usr/include/string.h" 1 3 4
# 27 "/usr/include/string.h" 3 4
extern "C" {





# 1 "/usr/bin/../lib/clang/3.3/include/stddef.h" 1 3 4
# 33 "/usr/include/string.h" 2 3 4
# 42 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 92 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 106 "/usr/include/string.h" 3 4
extern void *rawmemchr (const void *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 117 "/usr/include/string.h" 3 4
extern void *memrchr (const void *__s, int __c, size_t __n)
      throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));
# 162 "/usr/include/string.h" 3 4
extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 232 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 259 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 273 "/usr/include/string.h" 3 4
extern char *strchrnul (const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern size_t strcspn (const char *__s, const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 311 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 338 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));
# 369 "/usr/include/string.h" 3 4
extern char *strcasestr (const char *__haystack, const char *__needle)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) throw ();
# 434 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, __locale_t __l) throw ();





extern void __bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 485 "/usr/include/string.h" 3 4
extern char *index (const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 513 "/usr/include/string.h" 3 4
extern char *rindex (const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern int ffs (int __i) throw () __attribute__ ((__const__));




extern int ffsl (long int __l) throw () __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (const char *__s1, const char *__s2,
    __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));
# 600 "/usr/include/string.h" 3 4
extern char *basename (const char *__filename) throw () __attribute__ ((__nonnull__ (1)));
# 640 "/usr/include/string.h" 3 4
}
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstring" 2 3
# 71 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstring" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;


  inline void*
  memchr(void* __s, int __c, size_t __n)
  { return __builtin_memchr(__s, __c, __n); }

  inline char*
  strchr(char* __s, int __n)
  { return __builtin_strchr(__s, __n); }

  inline char*
  strpbrk(char* __s1, const char* __s2)
  { return __builtin_strpbrk(__s1, __s2); }

  inline char*
  strrchr(char* __s, int __n)
  { return __builtin_strrchr(__s, __n); }

  inline char*
  strstr(char* __s1, const char* __s2)
  { return __builtin_strstr(__s1, __s2); }



}
# 21 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/detail/hash_float.hpp" 2
# 51 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/detail/hash_float.hpp"
namespace boost
{
    namespace hash_detail
    {
        inline void hash_float_combine(std::size_t& seed, std::size_t value)
        {
            seed ^= value + (seed<<6) + (seed>>2);
        }







        inline std::size_t hash_binary(char* ptr, std::size_t length)
        {
            std::size_t seed = 0;

            if (length >= sizeof(std::size_t)) {
                seed = *(std::size_t*) ptr;
                length -= sizeof(std::size_t);
                ptr += sizeof(std::size_t);

                while(length >= sizeof(std::size_t)) {
                    hash_float_combine(seed, *(std::size_t*) ptr);
                    length -= sizeof(std::size_t);
                    ptr += sizeof(std::size_t);
                }
            }

            if (length > 0) {
                std::size_t buffer = 0;
                std::memcpy(&buffer, ptr, length);
                hash_float_combine(seed, buffer);
            }

            return seed;
        }

        template <typename Float>
        inline std::size_t float_hash_impl(Float v,
            typename boost::enable_if_c<
                std::numeric_limits<Float>::is_iec559 &&
                std::numeric_limits<Float>::digits == 24 &&
                std::numeric_limits<Float>::radix == 2 &&
                std::numeric_limits<Float>::max_exponent == 128,
                int>::type
            )
        {
            return hash_binary((char*) &v, 4);
        }


        template <typename Float>
        inline std::size_t float_hash_impl(Float v,
            typename boost::enable_if_c<
                std::numeric_limits<Float>::is_iec559 &&
                std::numeric_limits<Float>::digits == 53 &&
                std::numeric_limits<Float>::radix == 2 &&
                std::numeric_limits<Float>::max_exponent == 1024,
                int>::type
            )
        {
            return hash_binary((char*) &v, 8);
        }

        template <typename Float>
        inline std::size_t float_hash_impl(Float v,
            typename boost::enable_if_c<
                std::numeric_limits<Float>::is_iec559 &&
                std::numeric_limits<Float>::digits == 64 &&
                std::numeric_limits<Float>::radix == 2 &&
                std::numeric_limits<Float>::max_exponent == 16384,
                int>::type
            )
        {
            return hash_binary((char*) &v, 10);
        }

        template <typename Float>
        inline std::size_t float_hash_impl(Float v,
            typename boost::enable_if_c<
                std::numeric_limits<Float>::is_iec559 &&
                std::numeric_limits<Float>::digits == 113 &&
                std::numeric_limits<Float>::radix == 2 &&
                std::numeric_limits<Float>::max_exponent == 16384,
                int>::type
            )
        {
            return hash_binary((char*) &v, 16);
        }






        template <class T>
        inline std::size_t float_hash_impl2(T v)
        {
            boost::hash_detail::call_frexp<T> frexp;
            boost::hash_detail::call_ldexp<T> ldexp;

            int exp = 0;

            v = frexp(v, &exp);



            if(v < 0) {
                v = -v;
                exp += limits<T>::max_exponent -
                    limits<T>::min_exponent;
            }

            v = ldexp(v, limits<std::size_t>::digits);
            std::size_t seed = static_cast<std::size_t>(v);
            v -= static_cast<T>(seed);


            std::size_t const length
                = (limits<T>::digits *
                        boost::static_log2<limits<T>::radix>::value
                        + limits<std::size_t>::digits - 1)
                / limits<std::size_t>::digits;

            for(std::size_t i = 0; i != length; ++i)
            {
                v = ldexp(v, limits<std::size_t>::digits);
                std::size_t part = static_cast<std::size_t>(v);
                v -= static_cast<T>(part);
                hash_float_combine(seed, part);
            }

            hash_float_combine(seed, exp);

            return seed;
        }


        template <class T>
        inline std::size_t float_hash_impl(T v, ...)
        {
            typedef typename select_hash_type<T>::type type;
            return float_hash_impl2(static_cast<type>(v));
        }

    }
}





namespace boost
{
    namespace hash_detail
    {
        template <class T>
        inline std::size_t float_hash_value(T v)
        {
            using namespace std;
            switch (fpclassify(v)) {
            case 2:
                return 0;
            case 1:
                return (std::size_t)(v > 0 ? -1 : -2);
            case 0:
                return (std::size_t)(-3);
            case 4:
            case 3:
                return float_hash_impl(v, 0);
            default:
                ((0) ? static_cast<void> (0) : __assert_fail ("0", "/home/marek/devel/nupic/external/common/include/boost/functional/hash/detail/hash_float.hpp", 225, __PRETTY_FUNCTION__));
                return 0;
            }
        }
    }
}
# 15 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/hash.hpp" 2
# 36 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/hash.hpp"
namespace boost
{
    namespace hash_detail
    {
        struct enable_hash_value { typedef std::size_t type; };

        template <typename T> struct basic_numbers {};
        template <typename T> struct long_numbers {};
        template <typename T> struct ulong_numbers {};
        template <typename T> struct float_numbers {};

        template <> struct basic_numbers<bool> :
            boost::hash_detail::enable_hash_value {};
        template <> struct basic_numbers<char> :
            boost::hash_detail::enable_hash_value {};
        template <> struct basic_numbers<unsigned char> :
            boost::hash_detail::enable_hash_value {};
        template <> struct basic_numbers<signed char> :
            boost::hash_detail::enable_hash_value {};
        template <> struct basic_numbers<short> :
            boost::hash_detail::enable_hash_value {};
        template <> struct basic_numbers<unsigned short> :
            boost::hash_detail::enable_hash_value {};
        template <> struct basic_numbers<int> :
            boost::hash_detail::enable_hash_value {};
        template <> struct basic_numbers<unsigned int> :
            boost::hash_detail::enable_hash_value {};
        template <> struct basic_numbers<long> :
            boost::hash_detail::enable_hash_value {};
        template <> struct basic_numbers<unsigned long> :
            boost::hash_detail::enable_hash_value {};


        template <> struct basic_numbers<wchar_t> :
            boost::hash_detail::enable_hash_value {};



        template <> struct long_numbers<boost::long_long_type> :
            boost::hash_detail::enable_hash_value {};
        template <> struct ulong_numbers<boost::ulong_long_type> :
            boost::hash_detail::enable_hash_value {};


        template <> struct float_numbers<float> :
            boost::hash_detail::enable_hash_value {};
        template <> struct float_numbers<double> :
            boost::hash_detail::enable_hash_value {};
        template <> struct float_numbers<long double> :
            boost::hash_detail::enable_hash_value {};
    }

    template <typename T>
    typename boost::hash_detail::basic_numbers<T>::type hash_value(T);
    template <typename T>
    typename boost::hash_detail::long_numbers<T>::type hash_value(T);
    template <typename T>
    typename boost::hash_detail::ulong_numbers<T>::type hash_value(T);

    template <typename T>
    typename boost::enable_if<boost::is_enum<T>, std::size_t>::type
     hash_value(T);


    template <class T> std::size_t hash_value(T* const&);





    template< class T, unsigned N >
    std::size_t hash_value(const T (&x)[N]);

    template< class T, unsigned N >
    std::size_t hash_value(T (&x)[N]);


    template <class Ch, class A>
    std::size_t hash_value(
        std::basic_string<Ch, std::char_traits<Ch>, A> const&);

    template <typename T>
    typename boost::hash_detail::float_numbers<T>::type hash_value(T);







    namespace hash_detail
    {
        template <class T>
        inline std::size_t hash_value_signed(T val)
        {
             const int size_t_bits = std::numeric_limits<std::size_t>::digits;

             const int length = (std::numeric_limits<T>::digits - 1)
                 / size_t_bits;

             std::size_t seed = 0;
             T positive = val < 0 ? -1 - val : val;


             for(unsigned int i = length * size_t_bits; i > 0; i -= size_t_bits)
             {
                 seed ^= (std::size_t) (positive >> i) + (seed<<6) + (seed>>2);
             }
             seed ^= (std::size_t) val + (seed<<6) + (seed>>2);

             return seed;
        }

        template <class T>
        inline std::size_t hash_value_unsigned(T val)
        {
             const int size_t_bits = std::numeric_limits<std::size_t>::digits;

             const int length = (std::numeric_limits<T>::digits - 1)
                 / size_t_bits;

             std::size_t seed = 0;


             for(unsigned int i = length * size_t_bits; i > 0; i -= size_t_bits)
             {
                 seed ^= (std::size_t) (val >> i) + (seed<<6) + (seed>>2);
             }
             seed ^= (std::size_t) val + (seed<<6) + (seed>>2);

             return seed;
        }
    }

    template <typename T>
    typename boost::hash_detail::basic_numbers<T>::type hash_value(T v)
    {
        return static_cast<std::size_t>(v);
    }

    template <typename T>
    typename boost::hash_detail::long_numbers<T>::type hash_value(T v)
    {
        return hash_detail::hash_value_signed(v);
    }

    template <typename T>
    typename boost::hash_detail::ulong_numbers<T>::type hash_value(T v)
    {
        return hash_detail::hash_value_unsigned(v);
    }

    template <typename T>
    typename boost::enable_if<boost::is_enum<T>, std::size_t>::type
     hash_value(T v)
    {
     return static_cast<std::size_t>(v);
    }



    template <class T> std::size_t hash_value(T* const& v)



    {






        std::size_t x = static_cast<std::size_t>(
           reinterpret_cast<std::ptrdiff_t>(v));

        return x + (x >> 3);
    }
# 228 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/hash.hpp"
    template <class T>
    inline void hash_combine(std::size_t& seed, T const& v)

    {
        boost::hash<T> hasher;
        seed ^= hasher(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);
    }





    template <class It>
    inline std::size_t hash_range(It first, It last)
    {
        std::size_t seed = 0;

        for(; first != last; ++first)
        {
            hash_combine(seed, *first);
        }

        return seed;
    }

    template <class It>
    inline void hash_range(std::size_t& seed, It first, It last)
    {
        for(; first != last; ++first)
        {
            hash_combine(seed, *first);
        }
    }
# 289 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/hash.hpp"
    template< class T, unsigned N >
    inline std::size_t hash_value(const T (&x)[N])
    {
        return hash_range(x, x + N);
    }

    template< class T, unsigned N >
    inline std::size_t hash_value(T (&x)[N])
    {
        return hash_range(x, x + N);
    }


    template <class Ch, class A>
    inline std::size_t hash_value(
        std::basic_string<Ch, std::char_traits<Ch>, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }

    template <typename T>
    typename boost::hash_detail::float_numbers<T>::type hash_value(T v)
    {
        return boost::hash_detail::float_hash_value(v);
    }
# 398 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/hash.hpp"
    template <> struct hash<bool> : public std::unary_function<bool, std::size_t> { std::size_t operator()(bool v) const { return boost::hash_value(v); } };
    template <> struct hash<char> : public std::unary_function<char, std::size_t> { std::size_t operator()(char v) const { return boost::hash_value(v); } };
    template <> struct hash<signed char> : public std::unary_function<signed char, std::size_t> { std::size_t operator()(signed char v) const { return boost::hash_value(v); } };
    template <> struct hash<unsigned char> : public std::unary_function<unsigned char, std::size_t> { std::size_t operator()(unsigned char v) const { return boost::hash_value(v); } };

    template <> struct hash<wchar_t> : public std::unary_function<wchar_t, std::size_t> { std::size_t operator()(wchar_t v) const { return boost::hash_value(v); } };

    template <> struct hash<short> : public std::unary_function<short, std::size_t> { std::size_t operator()(short v) const { return boost::hash_value(v); } };
    template <> struct hash<unsigned short> : public std::unary_function<unsigned short, std::size_t> { std::size_t operator()(unsigned short v) const { return boost::hash_value(v); } };
    template <> struct hash<int> : public std::unary_function<int, std::size_t> { std::size_t operator()(int v) const { return boost::hash_value(v); } };
    template <> struct hash<unsigned int> : public std::unary_function<unsigned int, std::size_t> { std::size_t operator()(unsigned int v) const { return boost::hash_value(v); } };
    template <> struct hash<long> : public std::unary_function<long, std::size_t> { std::size_t operator()(long v) const { return boost::hash_value(v); } };
    template <> struct hash<unsigned long> : public std::unary_function<unsigned long, std::size_t> { std::size_t operator()(unsigned long v) const { return boost::hash_value(v); } };

    template <> struct hash<float> : public std::unary_function<float, std::size_t> { std::size_t operator()(float v) const { return boost::hash_value(v); } };
    template <> struct hash<double> : public std::unary_function<double, std::size_t> { std::size_t operator()(double v) const { return boost::hash_value(v); } };
    template <> struct hash<long double> : public std::unary_function<long double, std::size_t> { std::size_t operator()(long double v) const { return boost::hash_value(v); } };

    template <> struct hash<std::string> : public std::unary_function<std::string, std::size_t> { std::size_t operator()(std::string const& v) const { return boost::hash_value(v); } };

    template <> struct hash<std::wstring> : public std::unary_function<std::wstring, std::size_t> { std::size_t operator()(std::wstring const& v) const { return boost::hash_value(v); } };



    template <> struct hash<boost::long_long_type> : public std::unary_function<boost::long_long_type, std::size_t> { std::size_t operator()(boost::long_long_type v) const { return boost::hash_value(v); } };
    template <> struct hash<boost::ulong_long_type> : public std::unary_function<boost::ulong_long_type, std::size_t> { std::size_t operator()(boost::ulong_long_type v) const { return boost::hash_value(v); } };
# 437 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/hash.hpp"
    template <class T>
    struct hash<T*>
        : public std::unary_function<T*, std::size_t>
    {
        std::size_t operator()(T* v) const
        {

            return boost::hash_value(v);






        }
    };
# 496 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/hash.hpp"
}
# 508 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/hash.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/extensions.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/extensions.hpp"
# 1 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/hash.hpp" 1
# 16 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/extensions.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/detail/container_fwd_0x.hpp" 1








# 1 "/home/marek/devel/nupic/external/common/include/boost/detail/container_fwd.hpp" 1
# 91 "/home/marek/devel/nupic/external/common/include/boost/detail/container_fwd.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/deque" 1 3
# 59 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/deque" 3





# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 1 3
# 66 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 88 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
  inline size_t
  __deque_buf_size(size_t __size)
  { return (__size < 512
     ? size_t(512 / __size) : size_t(1)); }
# 105 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator
    {
      typedef _Deque_iterator<_Tp, _Tp&, _Tp*> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;

      static size_t _S_buffer_size()
      { return __deque_buf_size(sizeof(_Tp)); }

      typedef std::random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Ptr pointer;
      typedef _Ref reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp** _Map_pointer;
      typedef _Deque_iterator _Self;

      _Tp* _M_cur;
      _Tp* _M_first;
      _Tp* _M_last;
      _Map_pointer _M_node;

      _Deque_iterator(_Tp* __x, _Map_pointer __y)
      : _M_cur(__x), _M_first(*__y),
        _M_last(*__y + _S_buffer_size()), _M_node(__y) { }

      _Deque_iterator()
      : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) { }

      _Deque_iterator(const iterator& __x)
      : _M_cur(__x._M_cur), _M_first(__x._M_first),
        _M_last(__x._M_last), _M_node(__x._M_node) { }

      reference
      operator*() const
      { return *_M_cur; }

      pointer
      operator->() const
      { return _M_cur; }

      _Self&
      operator++()
      {
 ++_M_cur;
 if (_M_cur == _M_last)
   {
     _M_set_node(_M_node + 1);
     _M_cur = _M_first;
   }
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 ++*this;
 return __tmp;
      }

      _Self&
      operator--()
      {
 if (_M_cur == _M_first)
   {
     _M_set_node(_M_node - 1);
     _M_cur = _M_last;
   }
 --_M_cur;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 --*this;
 return __tmp;
      }

      _Self&
      operator+=(difference_type __n)
      {
 const difference_type __offset = __n + (_M_cur - _M_first);
 if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
   _M_cur += __n;
 else
   {
     const difference_type __node_offset =
       __offset > 0 ? __offset / difference_type(_S_buffer_size())
                    : -difference_type((-__offset - 1)
           / _S_buffer_size()) - 1;
     _M_set_node(_M_node + __node_offset);
     _M_cur = _M_first + (__offset - __node_offset
     * difference_type(_S_buffer_size()));
   }
 return *this;
      }

      _Self
      operator+(difference_type __n) const
      {
 _Self __tmp = *this;
 return __tmp += __n;
      }

      _Self&
      operator-=(difference_type __n)
      { return *this += -__n; }

      _Self
      operator-(difference_type __n) const
      {
 _Self __tmp = *this;
 return __tmp -= __n;
      }

      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }






      void
      _M_set_node(_Map_pointer __new_node)
      {
 _M_node = __new_node;
 _M_first = *__new_node;
 _M_last = _M_first + difference_type(_S_buffer_size());
      }
    };




  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__x == __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__x == __y); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                          : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                   : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return __y < __x; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return __y < __x; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__x < __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__x < __y); }





  template<typename _Tp, typename _Ref, typename _Ptr>
    inline typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
    operator-(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    {
      return typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
 (_Deque_iterator<_Tp, _Ref, _Ptr>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
    operator-(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    {
      return typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
 (_Deque_iterator<_Tp, _RefL, _PtrL>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline _Deque_iterator<_Tp, _Ref, _Ptr>
    operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)
    { return __x + __n; }

  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>&,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>&, const _Tp&);

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>(__first),
         _Deque_iterator<_Tp, const _Tp&, const _Tp*>(__last),
         __result); }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::copy_backward(_Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__first),
    _Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__last),
    __result); }
# 438 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    class _Deque_base
    {
    public:
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Tp_allocator()); }

      typedef _Deque_iterator<_Tp, _Tp&, _Tp*> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;

      _Deque_base()
      : _M_impl()
      { _M_initialize_map(0); }

      _Deque_base(size_t __num_elements)
      : _M_impl()
      { _M_initialize_map(__num_elements); }

      _Deque_base(const allocator_type& __a, size_t __num_elements)
      : _M_impl(__a)
      { _M_initialize_map(__num_elements); }

      _Deque_base(const allocator_type& __a)
      : _M_impl(__a)
      { }
# 482 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      ~_Deque_base();

    protected:



      typedef typename _Alloc::template rebind<_Tp*>::other _Map_alloc_type;

      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _Deque_impl
      : public _Tp_alloc_type
      {
 _Tp** _M_map;
 size_t _M_map_size;
 iterator _M_start;
 iterator _M_finish;

 _Deque_impl()
 : _Tp_alloc_type(), _M_map(0), _M_map_size(0),
   _M_start(), _M_finish()
 { }

 _Deque_impl(const _Tp_alloc_type& __a)
 : _Tp_alloc_type(__a), _M_map(0), _M_map_size(0),
   _M_start(), _M_finish()
 { }







      };

      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      _Map_alloc_type
      _M_get_map_allocator() const
      { return _Map_alloc_type(_M_get_Tp_allocator()); }

      _Tp*
      _M_allocate_node()
      {
 return _M_impl._Tp_alloc_type::allocate(__deque_buf_size(sizeof(_Tp)));
      }

      void
      _M_deallocate_node(_Tp* __p)
      {
 _M_impl._Tp_alloc_type::deallocate(__p, __deque_buf_size(sizeof(_Tp)));
      }

      _Tp**
      _M_allocate_map(size_t __n)
      { return _M_get_map_allocator().allocate(__n); }

      void
      _M_deallocate_map(_Tp** __p, size_t __n)
      { _M_get_map_allocator().deallocate(__p, __n); }

    protected:
      void _M_initialize_map(size_t);
      void _M_create_nodes(_Tp** __nstart, _Tp** __nfinish);
      void _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);
      enum { _S_initial_map_size = 8 };

      _Deque_impl _M_impl;
    };

  template<typename _Tp, typename _Alloc>
    _Deque_base<_Tp, _Alloc>::
    ~_Deque_base()
    {
      if (this->_M_impl._M_map)
 {
   _M_destroy_nodes(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
 }
    }
# 579 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_initialize_map(size_t __num_elements)
    {
      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
      + 1);

      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
        size_t(__num_nodes + 2));
      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);






      _Tp** __nstart = (this->_M_impl._M_map
   + (this->_M_impl._M_map_size - __num_nodes) / 2);
      _Tp** __nfinish = __nstart + __num_nodes;

      try
 { _M_create_nodes(__nstart, __nfinish); }
      catch(...)
 {
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
   this->_M_impl._M_map = 0;
   this->_M_impl._M_map_size = 0;
   throw;
 }

      this->_M_impl._M_start._M_set_node(__nstart);
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
     + __num_elements
     % __deque_buf_size(sizeof(_Tp)));
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_create_nodes(_Tp** __nstart, _Tp** __nfinish)
    {
      _Tp** __cur;
      try
 {
   for (__cur = __nstart; __cur < __nfinish; ++__cur)
     *__cur = this->_M_allocate_node();
 }
      catch(...)
 {
   _M_destroy_nodes(__nstart, __cur);
   throw;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)
    {
      for (_Tp** __n = __nstart; __n < __nfinish; ++__n)
 _M_deallocate_node(*__n);
    }
# 729 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class deque : protected _Deque_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;



      typedef _Deque_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef typename _Base::iterator iterator;
      typedef typename _Base::const_iterator const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      typedef pointer* _Map_pointer;

      static size_t _S_buffer_size()
      { return __deque_buf_size(sizeof(_Tp)); }


      using _Base::_M_initialize_map;
      using _Base::_M_create_nodes;
      using _Base::_M_destroy_nodes;
      using _Base::_M_allocate_node;
      using _Base::_M_deallocate_node;
      using _Base::_M_allocate_map;
      using _Base::_M_deallocate_map;
      using _Base::_M_get_Tp_allocator;





      using _Base::_M_impl;

    public:





      deque()
      : _Base() { }





      explicit
      deque(const allocator_type& __a)
      : _Base(__a, 0) { }
# 827 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      explicit
      deque(size_type __n, const value_type& __value = value_type(),
     const allocator_type& __a = allocator_type())
      : _Base(__a, __n)
      { _M_fill_initialize(__value); }
# 841 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      deque(const deque& __x)
      : _Base(__x._M_get_Tp_allocator(), __x.size())
      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
        this->_M_impl._M_start,
        _M_get_Tp_allocator()); }
# 901 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      template<typename _InputIterator>
        deque(_InputIterator __first, _InputIterator __last,
       const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }







      ~deque()
      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }
# 927 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      deque&
      operator=(const deque& __x);
# 977 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 1000 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
# 1027 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }






      iterator
      begin()
      { return this->_M_impl._M_start; }





      const_iterator
      begin() const
      { return this->_M_impl._M_start; }






      iterator
      end()
      { return this->_M_impl._M_finish; }






      const_iterator
      end() const
      { return this->_M_impl._M_finish; }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->_M_impl._M_start); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->_M_impl._M_start); }
# 1141 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      size_type
      size() const
      { return this->_M_impl._M_finish - this->_M_impl._M_start; }


      size_type
      max_size() const
      { return _M_get_Tp_allocator().max_size(); }
# 1204 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 const size_type __len = size();
 if (__new_size > __len)
   insert(this->_M_impl._M_finish, __new_size - __len, __x);
 else if (__new_size < __len)
   _M_erase_at_end(this->_M_impl._M_start
     + difference_type(__new_size));
      }
# 1227 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      bool
      empty() const
      { return this->_M_impl._M_finish == this->_M_impl._M_start; }
# 1243 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      reference
      operator[](size_type __n)
      { return this->_M_impl._M_start[difference_type(__n)]; }
# 1258 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      const_reference
      operator[](size_type __n) const
      { return this->_M_impl._M_start[difference_type(__n)]; }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("deque::_M_range_check"));
      }

    public:
# 1283 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 1301 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 1358 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      void
      push_front(const value_type& __x)
      {
 if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
   {
     this->_M_impl.construct(this->_M_impl._M_start._M_cur - 1, __x);
     --this->_M_impl._M_start._M_cur;
   }
 else
   _M_push_front_aux(__x);
      }
# 1389 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_last - 1)
   {
     this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __x);
     ++this->_M_impl._M_finish._M_cur;
   }
 else
   _M_push_back_aux(__x);
      }
# 1420 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      void
      pop_front()
      {
 if (this->_M_impl._M_start._M_cur
     != this->_M_impl._M_start._M_last - 1)
   {
     this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
     ++this->_M_impl._M_start._M_cur;
   }
 else
   _M_pop_front_aux();
      }
# 1441 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      void
      pop_back()
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_first)
   {
     --this->_M_impl._M_finish._M_cur;
     this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
   }
 else
   _M_pop_back_aux();
      }
# 1478 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 1518 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 1540 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 1564 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      iterator
      erase(iterator __position);
# 1583 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 1595 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      void
      swap(deque& __x)
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_map, __x._M_impl._M_map);
 std::swap(this->_M_impl._M_map_size, __x._M_impl._M_map_size);



 std::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
      }







      void
      clear()
      { _M_erase_at_end(begin()); }

    protected:






      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        {
   _M_initialize_map(static_cast<size_type>(__n));
   _M_fill_initialize(__x);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }
# 1657 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag);
# 1679 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      void
      _M_fill_initialize(const value_type& __value);
# 1695 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag)
        {
   const size_type __len = std::distance(__first, __last);
   if (__len > size())
     {
       _ForwardIterator __mid = __first;
       std::advance(__mid, size());
       std::copy(__first, __mid, begin());
       insert(end(), __mid, __last);
     }
   else
     _M_erase_at_end(std::copy(__first, __last, begin()));
 }



      void
      _M_fill_assign(size_type __n, const value_type& __val)
      {
 if (__n > size())
   {
     std::fill(begin(), end(), __val);
     insert(end(), __n - size(), __val);
   }
 else
   {
     _M_erase_at_end(begin() + difference_type(__n));
     std::fill(begin(), end(), __val);
   }
      }




      void _M_push_back_aux(const value_type&);

      void _M_push_front_aux(const value_type&);
# 1766 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      void _M_pop_back_aux();

      void _M_pop_front_aux();
# 1778 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos,
      _Integer __n, _Integer __x, __true_type)
        { _M_fill_insert(__pos, __n, __x); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos,
      _InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
          _M_range_insert_aux(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert_aux(iterator __pos, _InputIterator __first,
       _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert_aux(iterator __pos, _ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag);




      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      iterator
      _M_insert_aux(iterator __pos, const value_type& __x);







      void
      _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);


      template<typename _ForwardIterator>
        void
        _M_insert_aux(iterator __pos,
        _ForwardIterator __first, _ForwardIterator __last,
        size_type __n);




      void
      _M_destroy_data_aux(iterator __first, iterator __last);



      template<typename _Alloc1>
        void
        _M_destroy_data(iterator __first, iterator __last, const _Alloc1&)
        { _M_destroy_data_aux(__first, __last); }

      void
      _M_destroy_data(iterator __first, iterator __last,
        const std::allocator<_Tp>&)
      {
 if (!__has_trivial_destructor(value_type))
   _M_destroy_data_aux(__first, __last);
      }


      void
      _M_erase_at_begin(iterator __pos)
      {
 _M_destroy_data(begin(), __pos, _M_get_Tp_allocator());
 _M_destroy_nodes(this->_M_impl._M_start._M_node, __pos._M_node);
 this->_M_impl._M_start = __pos;
      }



      void
      _M_erase_at_end(iterator __pos)
      {
 _M_destroy_data(__pos, end(), _M_get_Tp_allocator());
 _M_destroy_nodes(__pos._M_node + 1,
    this->_M_impl._M_finish._M_node + 1);
 this->_M_impl._M_finish = __pos;
      }
# 1887 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      iterator
      _M_reserve_elements_at_front(size_type __n)
      {
 const size_type __vacancies = this->_M_impl._M_start._M_cur
                               - this->_M_impl._M_start._M_first;
 if (__n > __vacancies)
   _M_new_elements_at_front(__n - __vacancies);
 return this->_M_impl._M_start - difference_type(__n);
      }

      iterator
      _M_reserve_elements_at_back(size_type __n)
      {
 const size_type __vacancies = (this->_M_impl._M_finish._M_last
           - this->_M_impl._M_finish._M_cur) - 1;
 if (__n > __vacancies)
   _M_new_elements_at_back(__n - __vacancies);
 return this->_M_impl._M_finish + difference_type(__n);
      }

      void
      _M_new_elements_at_front(size_type __new_elements);

      void
      _M_new_elements_at_back(size_type __new_elements);
# 1923 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
      void
      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add + 1 > this->_M_impl._M_map_size
     - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, false);
      }

      void
      _M_reserve_map_at_front(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add > size_type(this->_M_impl._M_start._M_node
           - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, true);
      }

      void
      _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);

    };
# 1955 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const deque<_Tp, _Alloc>& __x,
                         const deque<_Tp, _Alloc>& __y)
    { return __x.size() == __y.size()
             && std::equal(__x.begin(), __x.end(), __y.begin()); }
# 1973 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)
    { __x.swap(__y); }




}
# 65 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/deque" 2 3

# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/deque.tcc" 1 3
# 59 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/deque.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 90 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/deque.tcc" 3
  template <typename _Tp, typename _Alloc>
    deque<_Tp, _Alloc>&
    deque<_Tp, _Alloc>::
    operator=(const deque& __x)
    {
      const size_type __len = size();
      if (&__x != this)
 {
   if (__len >= __x.size())
     _M_erase_at_end(std::copy(__x.begin(), __x.end(),
          this->_M_impl._M_start));
   else
     {
       const_iterator __mid = __x.begin() + difference_type(__len);
       std::copy(__x.begin(), __mid, this->_M_impl._M_start);
       insert(this->_M_impl._M_finish, __mid, __x.end());
     }
 }
      return *this;
    }
# 146 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/deque.tcc" 3
  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      if (__position._M_cur == this->_M_impl._M_start._M_cur)
 {
   push_front(__x);
   return this->_M_impl._M_start;
 }
      else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
 {
   push_back(__x);
   iterator __tmp = this->_M_impl._M_finish;
   --__tmp;
   return __tmp;
 }
      else
        return _M_insert_aux(__position, __x);
    }
# 191 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/deque.tcc" 3
  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    erase(iterator __position)
    {
      iterator __next = __position;
      ++__next;
      const difference_type __index = __position - begin();
      if (static_cast<size_type>(__index) < (size() >> 1))
 {
   if (__position != begin())
     std::copy_backward(begin(), __position, __next);
   pop_front();
 }
      else
 {
   if (__next != end())
     std::copy(__next, end(), __position);
   pop_back();
 }
      return begin() + __index;
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first == __last)
 return __first;
      else if (__first == begin() && __last == end())
 {
   clear();
   return end();
 }
      else
 {
   const difference_type __n = __last - __first;
   const difference_type __elems_before = __first - begin();
   if (static_cast<size_type>(__elems_before) <= (size() - __n) / 2)
     {
       if (__first != begin())
  std::copy_backward(begin(), __first, __last);
       _M_erase_at_begin(begin() + __n);
     }
   else
     {
       if (__last != end())
  std::copy(__last, end(), __first);
       _M_erase_at_end(end() - __n);
     }
   return begin() + __elems_before;
 }
    }

  template <typename _Tp, class _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
        iterator __cur = begin();
        for (; __first != __last && __cur != end(); ++__cur, ++__first)
          *__cur = *__first;
        if (__first == __last)
          _M_erase_at_end(__cur);
        else
          insert(end(), __first, __last);
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
    {
      if (__pos._M_cur == this->_M_impl._M_start._M_cur)
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   try
     {
       std::__uninitialized_fill_a(__new_start, this->_M_impl._M_start,
       __x, _M_get_Tp_allocator());
       this->_M_impl._M_start = __new_start;
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   try
     {
       std::__uninitialized_fill_a(this->_M_impl._M_finish,
       __new_finish, __x,
       _M_get_Tp_allocator());
       this->_M_impl._M_finish = __new_finish;
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
      else
        _M_insert_aux(__pos, __n, __x);
    }
# 348 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/deque.tcc" 3
  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_initialize(const value_type& __value)
    {
      _Map_pointer __cur;
      try
        {
          for (__cur = this->_M_impl._M_start._M_node;
        __cur < this->_M_impl._M_finish._M_node;
        ++__cur)
            std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(),
     __value, _M_get_Tp_allocator());
          std::__uninitialized_fill_a(this->_M_impl._M_finish._M_first,
          this->_M_impl._M_finish._M_cur,
          __value, _M_get_Tp_allocator());
        }
      catch(...)
        {
          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
   _M_get_Tp_allocator());
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      {
        this->_M_initialize_map(0);
        try
          {
            for (; __first != __last; ++__first)



              push_back(*__first);

          }
        catch(...)
          {
            clear();
            throw;
          }
      }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        this->_M_initialize_map(__n);

        _Map_pointer __cur_node;
        try
          {
            for (__cur_node = this->_M_impl._M_start._M_node;
                 __cur_node < this->_M_impl._M_finish._M_node;
                 ++__cur_node)
       {
  _ForwardIterator __mid = __first;
  std::advance(__mid, _S_buffer_size());
  std::__uninitialized_copy_a(__first, __mid, *__cur_node,
         _M_get_Tp_allocator());
  __first = __mid;
       }
            std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_finish._M_first,
     _M_get_Tp_allocator());
          }
        catch(...)
          {
            std::_Destroy(this->_M_impl._M_start,
     iterator(*__cur_node, __cur_node),
     _M_get_Tp_allocator());
            throw;
          }
      }


  template<typename _Tp, typename _Alloc>






      void
      deque<_Tp, _Alloc>::
      _M_push_back_aux(const value_type& __t)

      {
 _M_reserve_map_at_back();
 *(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
 try
   {




     this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __t);

     this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
      + 1);
     this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
   }
 catch(...)
   {
     _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
     throw;
   }
      }


  template<typename _Tp, typename _Alloc>






      void
      deque<_Tp, _Alloc>::
      _M_push_front_aux(const value_type& __t)

      {
 _M_reserve_map_at_front();
 *(this->_M_impl._M_start._M_node - 1) = this->_M_allocate_node();
 try
   {
     this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node
            - 1);
     this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_last - 1;




     this->_M_impl.construct(this->_M_impl._M_start._M_cur, __t);

   }
 catch(...)
   {
     ++this->_M_impl._M_start;
     _M_deallocate_node(*(this->_M_impl._M_start._M_node - 1));
     throw;
   }
      }


  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_back_aux()
    {
      _M_deallocate_node(this->_M_impl._M_finish._M_first);
      this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);
      this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;
      this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
    }






  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_front_aux()
    {
      this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
      _M_deallocate_node(this->_M_impl._M_start._M_first);
      this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);
      this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      { std::copy(__first, __last, std::inserter(*this, __pos)); }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        if (__pos._M_cur == this->_M_impl._M_start._M_cur)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last, __new_start,
         _M_get_Tp_allocator());
  this->_M_impl._M_start = __new_start;
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
   {
     iterator __new_finish = _M_reserve_elements_at_back(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last,
         this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  this->_M_impl._M_finish = __new_finish;
       }
     catch(...)
       {
  _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
     __new_finish._M_node + 1);
  throw;
       }
   }
        else
          _M_insert_aux(__pos, __first, __last, __n);
      }

  template<typename _Tp, typename _Alloc>
# 592 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/deque.tcc" 3
    typename deque<_Tp, _Alloc>::iterator
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos, const value_type& __x)
      {
 value_type __x_copy = __x;

 difference_type __index = __pos - this->_M_impl._M_start;
 if (static_cast<size_type>(__index) < size() / 2)
   {
     push_front((front()));
     iterator __front1 = this->_M_impl._M_start;
     ++__front1;
     iterator __front2 = __front1;
     ++__front2;
     __pos = this->_M_impl._M_start + __index;
     iterator __pos1 = __pos;
     ++__pos1;
     std::copy(__front2, __pos1, __front1);
   }
 else
   {
     push_back((back()));
     iterator __back1 = this->_M_impl._M_finish;
     --__back1;
     iterator __back2 = __back1;
     --__back2;
     __pos = this->_M_impl._M_start + __index;
     std::copy_backward(__pos, __back2, __back1);
   }
 *__pos = (__x_copy);
 return __pos;
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)
    {
      const difference_type __elems_before = __pos - this->_M_impl._M_start;
      const size_type __length = this->size();
      value_type __x_copy = __x;
      if (__elems_before < difference_type(__length / 2))
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   iterator __old_start = this->_M_impl._M_start;
   __pos = this->_M_impl._M_start + __elems_before;
   try
     {
       if (__elems_before >= difference_type(__n))
  {
    iterator __start_n = (this->_M_impl._M_start
     + difference_type(__n));
    std::__uninitialized_move_a(this->_M_impl._M_start,
           __start_n, __new_start,
           _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::copy(__start_n, __pos, __old_start);
    std::fill(__pos - difference_type(__n), __pos, __x_copy);
  }
       else
  {
    std::__uninitialized_move_fill(this->_M_impl._M_start,
       __pos, __new_start,
       this->_M_impl._M_start,
       __x_copy,
       _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::fill(__old_start, __pos, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   iterator __old_finish = this->_M_impl._M_finish;
   const difference_type __elems_after =
     difference_type(__length) - __elems_before;
   __pos = this->_M_impl._M_finish - __elems_after;
   try
     {
       if (__elems_after > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_move_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy_backward(__pos, __finish_n, __old_finish);
    std::fill(__pos, __pos + difference_type(__n), __x_copy);
  }
       else
  {
    std::__uninitialized_fill_move(this->_M_impl._M_finish,
       __pos + difference_type(__n),
       __x_copy, __pos,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::fill(__pos, __old_finish, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos,
                    _ForwardIterator __first, _ForwardIterator __last,
                    size_type __n)
      {
        const difference_type __elemsbefore = __pos - this->_M_impl._M_start;
        const size_type __length = size();
        if (static_cast<size_type>(__elemsbefore) < __length / 2)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     iterator __old_start = this->_M_impl._M_start;
     __pos = this->_M_impl._M_start + __elemsbefore;
     try
       {
  if (__elemsbefore >= difference_type(__n))
    {
      iterator __start_n = (this->_M_impl._M_start
       + difference_type(__n));
      std::__uninitialized_move_a(this->_M_impl._M_start,
      __start_n, __new_start,
      _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__start_n, __pos, __old_start);
      std::copy(__first, __last, __pos - difference_type(__n));
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, difference_type(__n) - __elemsbefore);
      std::__uninitialized_move_copy(this->_M_impl._M_start,
         __pos, __first, __mid,
         __new_start,
         _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__mid, __last, __old_start);
    }
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else
        {
          iterator __new_finish = _M_reserve_elements_at_back(__n);
          iterator __old_finish = this->_M_impl._M_finish;
          const difference_type __elemsafter =
            difference_type(__length) - __elemsbefore;
          __pos = this->_M_impl._M_finish - __elemsafter;
          try
            {
              if (__elemsafter > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_move_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy_backward(__pos, __finish_n, __old_finish);
    std::copy(__first, __last, __pos);
  }
              else
  {
    _ForwardIterator __mid = __first;
    std::advance(__mid, __elemsafter);
    std::__uninitialized_copy_move(__mid, __last, __pos,
       this->_M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy(__first, __mid, __pos);
  }
            }
          catch(...)
            {
              _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
              throw;
            }
        }
      }

   template<typename _Tp, typename _Alloc>
     void
     deque<_Tp, _Alloc>::
     _M_destroy_data_aux(iterator __first, iterator __last)
     {
       for (_Map_pointer __node = __first._M_node + 1;
     __node < __last._M_node; ++__node)
  std::_Destroy(*__node, *__node + _S_buffer_size(),
         _M_get_Tp_allocator());

       if (__first._M_node != __last._M_node)
  {
    std::_Destroy(__first._M_cur, __first._M_last,
    _M_get_Tp_allocator());
    std::_Destroy(__last._M_first, __last._M_cur,
    _M_get_Tp_allocator());
  }
       else
  std::_Destroy(__first._M_cur, __last._M_cur,
         _M_get_Tp_allocator());
     }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_front(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_front"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_front(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_start._M_node - __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_start._M_node - __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_back(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_back"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_back(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_finish._M_node + __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_finish._M_node + __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
    {
      const size_type __old_num_nodes
 = this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;

      _Map_pointer __new_nstart;
      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
 {
   __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
      - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   if (__new_nstart < this->_M_impl._M_start._M_node)
     std::copy(this->_M_impl._M_start._M_node,
        this->_M_impl._M_finish._M_node + 1,
        __new_nstart);
   else
     std::copy_backward(this->_M_impl._M_start._M_node,
          this->_M_impl._M_finish._M_node + 1,
          __new_nstart + __old_num_nodes);
 }
      else
 {
   size_type __new_map_size = this->_M_impl._M_map_size
                              + std::max(this->_M_impl._M_map_size,
      __nodes_to_add) + 2;

   _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
   __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   std::copy(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1,
      __new_nstart);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);

   this->_M_impl._M_map = __new_map;
   this->_M_impl._M_map_size = __new_map_size;
 }

      this->_M_impl._M_start._M_set_node(__new_nstart);
      this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
    }



  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>& __first,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>& __last, const _Tp& __value)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;

      for (typename _Self::_Map_pointer __node = __first._M_node + 1;
           __node < __last._M_node; ++__node)
 std::fill(*__node, *__node + _Self::_S_buffer_size(), __value);

      if (__first._M_node != __last._M_node)
 {
   std::fill(__first._M_cur, __first._M_last, __value);
   std::fill(__last._M_first, __last._M_cur, __value);
 }
      else
 std::fill(__first._M_cur, __last._M_cur, __value);
    }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   const difference_type __clen
     = std::min(__len, std::min(__first._M_last - __first._M_cur,
           __result._M_last - __result._M_cur));
   std::copy(__first._M_cur, __first._M_cur + __clen, __result._M_cur);
   __first += __clen;
   __result += __clen;
   __len -= __clen;
 }
      return __result;
    }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   difference_type __llen = __last._M_cur - __last._M_first;
   _Tp* __lend = __last._M_cur;

   difference_type __rlen = __result._M_cur - __result._M_first;
   _Tp* __rend = __result._M_cur;

   if (!__llen)
     {
       __llen = _Self::_S_buffer_size();
       __lend = *(__last._M_node - 1) + __llen;
     }
   if (!__rlen)
     {
       __rlen = _Self::_S_buffer_size();
       __rend = *(__result._M_node - 1) + __rlen;
     }

   const difference_type __clen = std::min(__len,
        std::min(__llen, __rlen));
   std::copy_backward(__lend - __clen, __lend, __rend);
   __last -= __clen;
   __result -= __clen;
   __len -= __clen;
 }
      return __result;
    }
# 1066 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/deque.tcc" 3
}
# 67 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/deque" 2 3
# 91 "/home/marek/devel/nupic/external/common/include/boost/detail/container_fwd.hpp" 2





# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bitset" 1 3
# 46 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bitset" 3
# 60 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bitset" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
# 70 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bitset" 3
  template<size_t _Nw>
    struct _Base_bitset
    {
      typedef unsigned long _WordT;


      _WordT _M_w[_Nw];

                         _Base_bitset()
      : _M_w() { }
# 89 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bitset" 3
      _Base_bitset(unsigned long __val)
      : _M_w()
      { _M_w[0] = __val; }


      static size_t
      _S_whichword(size_t __pos)
      { return __pos / (8 * 8); }

      static size_t
      _S_whichbyte(size_t __pos)
      { return (__pos % (8 * 8)) / 8; }

      static size_t
      _S_whichbit(size_t __pos)
      { return __pos % (8 * 8); }

      static _WordT
      _S_maskbit(size_t __pos)
      { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }

      _WordT&
      _M_getword(size_t __pos)
      { return _M_w[_S_whichword(__pos)]; }

                         _WordT
      _M_getword(size_t __pos) const
      { return _M_w[_S_whichword(__pos)]; }







      _WordT&
      _M_hiword()
      { return _M_w[_Nw - 1]; }

                         _WordT
      _M_hiword() const
      { return _M_w[_Nw - 1]; }

      void
      _M_do_and(const _Base_bitset<_Nw>& __x)
      {
 for (size_t __i = 0; __i < _Nw; __i++)
   _M_w[__i] &= __x._M_w[__i];
      }

      void
      _M_do_or(const _Base_bitset<_Nw>& __x)
      {
 for (size_t __i = 0; __i < _Nw; __i++)
   _M_w[__i] |= __x._M_w[__i];
      }

      void
      _M_do_xor(const _Base_bitset<_Nw>& __x)
      {
 for (size_t __i = 0; __i < _Nw; __i++)
   _M_w[__i] ^= __x._M_w[__i];
      }

      void
      _M_do_left_shift(size_t __shift) ;

      void
      _M_do_right_shift(size_t __shift) ;

      void
      _M_do_flip()
      {
 for (size_t __i = 0; __i < _Nw; __i++)
   _M_w[__i] = ~_M_w[__i];
      }

      void
      _M_do_set()
      {
 for (size_t __i = 0; __i < _Nw; __i++)
   _M_w[__i] = ~static_cast<_WordT>(0);
      }

      void
      _M_do_reset()
      { __builtin_memset(_M_w, 0, _Nw * sizeof(_WordT)); }

      bool
      _M_is_equal(const _Base_bitset<_Nw>& __x) const
      {
 for (size_t __i = 0; __i < _Nw; ++__i)
   if (_M_w[__i] != __x._M_w[__i])
     return false;
 return true;
      }

      template<size_t _Nb>
        bool
        _M_are_all() const
        {
   for (size_t __i = 0; __i < _Nw - 1; __i++)
     if (_M_w[__i] != ~static_cast<_WordT>(0))
       return false;
   return _M_hiword() == (~static_cast<_WordT>(0)
     >> (_Nw * (8 * 8)
         - _Nb));
 }

      bool
      _M_is_any() const
      {
 for (size_t __i = 0; __i < _Nw; __i++)
   if (_M_w[__i] != static_cast<_WordT>(0))
     return true;
 return false;
      }

      size_t
      _M_do_count() const
      {
 size_t __result = 0;
 for (size_t __i = 0; __i < _Nw; __i++)
   __result += __builtin_popcountl(_M_w[__i]);
 return __result;
      }

      unsigned long
      _M_do_to_ulong() const;







      size_t
      _M_do_find_first(size_t) const ;


      size_t
      _M_do_find_next(size_t, size_t) const ;
    };


  template<size_t _Nw>
    void
    _Base_bitset<_Nw>::_M_do_left_shift(size_t __shift)
    {
      if (__builtin_expect(__shift != 0, 1))
 {
   const size_t __wshift = __shift / (8 * 8);
   const size_t __offset = __shift % (8 * 8);

   if (__offset == 0)
     for (size_t __n = _Nw - 1; __n >= __wshift; --__n)
       _M_w[__n] = _M_w[__n - __wshift];
   else
     {
       const size_t __sub_offset = ((8 * 8)
        - __offset);
       for (size_t __n = _Nw - 1; __n > __wshift; --__n)
  _M_w[__n] = ((_M_w[__n - __wshift] << __offset)
        | (_M_w[__n - __wshift - 1] >> __sub_offset));
       _M_w[__wshift] = _M_w[0] << __offset;
     }

   std::fill(_M_w + 0, _M_w + __wshift, static_cast<_WordT>(0));
 }
    }

  template<size_t _Nw>
    void
    _Base_bitset<_Nw>::_M_do_right_shift(size_t __shift)
    {
      if (__builtin_expect(__shift != 0, 1))
 {
   const size_t __wshift = __shift / (8 * 8);
   const size_t __offset = __shift % (8 * 8);
   const size_t __limit = _Nw - __wshift - 1;

   if (__offset == 0)
     for (size_t __n = 0; __n <= __limit; ++__n)
       _M_w[__n] = _M_w[__n + __wshift];
   else
     {
       const size_t __sub_offset = ((8 * 8)
        - __offset);
       for (size_t __n = 0; __n < __limit; ++__n)
  _M_w[__n] = ((_M_w[__n + __wshift] >> __offset)
        | (_M_w[__n + __wshift + 1] << __sub_offset));
       _M_w[__limit] = _M_w[_Nw-1] >> __offset;
     }

   std::fill(_M_w + __limit + 1, _M_w + _Nw, static_cast<_WordT>(0));
 }
    }

  template<size_t _Nw>
    unsigned long
    _Base_bitset<_Nw>::_M_do_to_ulong() const
    {
      for (size_t __i = 1; __i < _Nw; ++__i)
 if (_M_w[__i])
   __throw_overflow_error(("_Base_bitset::_M_do_to_ulong"));
      return _M_w[0];
    }
# 314 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bitset" 3
  template<size_t _Nw>
    size_t
    _Base_bitset<_Nw>::
    _M_do_find_first(size_t __not_found) const
    {
      for (size_t __i = 0; __i < _Nw; __i++)
 {
   _WordT __thisword = _M_w[__i];
   if (__thisword != static_cast<_WordT>(0))
     return (__i * (8 * 8)
      + __builtin_ctzl(__thisword));
 }

      return __not_found;
    }

  template<size_t _Nw>
    size_t
    _Base_bitset<_Nw>::
    _M_do_find_next(size_t __prev, size_t __not_found) const
    {

      ++__prev;


      if (__prev >= _Nw * (8 * 8))
 return __not_found;


      size_t __i = _S_whichword(__prev);
      _WordT __thisword = _M_w[__i];


      __thisword &= (~static_cast<_WordT>(0)) << _S_whichbit(__prev);

      if (__thisword != static_cast<_WordT>(0))
 return (__i * (8 * 8)
  + __builtin_ctzl(__thisword));


      __i++;
      for (; __i < _Nw; __i++)
 {
   __thisword = _M_w[__i];
   if (__thisword != static_cast<_WordT>(0))
     return (__i * (8 * 8)
      + __builtin_ctzl(__thisword));
 }

      return __not_found;
    }






  template<>
    struct _Base_bitset<1>
    {
      typedef unsigned long _WordT;
      _WordT _M_w;

                         _Base_bitset()
      : _M_w(0)
      { }




      _Base_bitset(unsigned long __val)

      : _M_w(__val)
      { }

      static size_t
      _S_whichword(size_t __pos)
      { return __pos / (8 * 8); }

      static size_t
      _S_whichbyte(size_t __pos)
      { return (__pos % (8 * 8)) / 8; }

      static size_t
      _S_whichbit(size_t __pos)
      { return __pos % (8 * 8); }

      static _WordT
      _S_maskbit(size_t __pos)
      { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }

      _WordT&
      _M_getword(size_t)
      { return _M_w; }

                         _WordT
      _M_getword(size_t) const
      { return _M_w; }







      _WordT&
      _M_hiword()
      { return _M_w; }

                         _WordT
      _M_hiword() const
      { return _M_w; }

      void
      _M_do_and(const _Base_bitset<1>& __x)
      { _M_w &= __x._M_w; }

      void
      _M_do_or(const _Base_bitset<1>& __x)
      { _M_w |= __x._M_w; }

      void
      _M_do_xor(const _Base_bitset<1>& __x)
      { _M_w ^= __x._M_w; }

      void
      _M_do_left_shift(size_t __shift)
      { _M_w <<= __shift; }

      void
      _M_do_right_shift(size_t __shift)
      { _M_w >>= __shift; }

      void
      _M_do_flip()
      { _M_w = ~_M_w; }

      void
      _M_do_set()
      { _M_w = ~static_cast<_WordT>(0); }

      void
      _M_do_reset()
      { _M_w = 0; }

      bool
      _M_is_equal(const _Base_bitset<1>& __x) const
      { return _M_w == __x._M_w; }

      template<size_t _Nb>
        bool
        _M_are_all() const
        { return _M_w == (~static_cast<_WordT>(0)
     >> ((8 * 8) - _Nb)); }

      bool
      _M_is_any() const
      { return _M_w != 0; }

      size_t
      _M_do_count() const
      { return __builtin_popcountl(_M_w); }

      unsigned long
      _M_do_to_ulong() const
      { return _M_w; }







      size_t
      _M_do_find_first(size_t __not_found) const
      {
        if (_M_w != 0)
          return __builtin_ctzl(_M_w);
        else
          return __not_found;
      }


      size_t
      _M_do_find_next(size_t __prev, size_t __not_found) const

      {
 ++__prev;
 if (__prev >= ((size_t) (8 * 8)))
   return __not_found;

 _WordT __x = _M_w >> __prev;
 if (__x != 0)
   return __builtin_ctzl(__x) + __prev;
 else
   return __not_found;
      }
    };






  template<>
    struct _Base_bitset<0>
    {
      typedef unsigned long _WordT;

                         _Base_bitset()
      { }




      _Base_bitset(unsigned long)

      { }

      static size_t
      _S_whichword(size_t __pos)
      { return __pos / (8 * 8); }

      static size_t
      _S_whichbyte(size_t __pos)
      { return (__pos % (8 * 8)) / 8; }

      static size_t
      _S_whichbit(size_t __pos)
      { return __pos % (8 * 8); }

      static _WordT
      _S_maskbit(size_t __pos)
      { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }
# 556 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bitset" 3
      _WordT&
      _M_getword(size_t)
      {
 __throw_out_of_range(("_Base_bitset::_M_getword"));
 return *new _WordT;
      }

                         _WordT
      _M_getword(size_t __pos) const
      { return 0; }

                         _WordT
      _M_hiword() const
      { return 0; }

      void
      _M_do_and(const _Base_bitset<0>&)
      { }

      void
      _M_do_or(const _Base_bitset<0>&)
      { }

      void
      _M_do_xor(const _Base_bitset<0>&)
      { }

      void
      _M_do_left_shift(size_t)
      { }

      void
      _M_do_right_shift(size_t)
      { }

      void
      _M_do_flip()
      { }

      void
      _M_do_set()
      { }

      void
      _M_do_reset()
      { }




      bool
      _M_is_equal(const _Base_bitset<0>&) const
      { return true; }

      template<size_t _Nb>
        bool
        _M_are_all() const
        { return true; }

      bool
      _M_is_any() const
      { return false; }

      size_t
      _M_do_count() const
      { return 0; }

      unsigned long
      _M_do_to_ulong() const
      { return 0; }
# 635 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bitset" 3
      size_t
      _M_do_find_first(size_t) const
      { return 0; }

      size_t
      _M_do_find_next(size_t, size_t) const
      { return 0; }
    };



  template<size_t _Extrabits>
    struct _Sanitize
    {
      typedef unsigned long _WordT;

      static void
      _S_do_sanitize(_WordT& __val)
      { __val &= ~((~static_cast<_WordT>(0)) << _Extrabits); }
    };

  template<>
    struct _Sanitize<0>
    {
      typedef unsigned long _WordT;

      static void
      _S_do_sanitize(_WordT) { }
    };
# 747 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bitset" 3
  template<size_t _Nb>
    class bitset
    : private _Base_bitset<((_Nb) / (8 * 8) + ((_Nb) % (8 * 8) == 0 ? 0 : 1))>
    {
    private:
      typedef _Base_bitset<((_Nb) / (8 * 8) + ((_Nb) % (8 * 8) == 0 ? 0 : 1))> _Base;
      typedef unsigned long _WordT;

      void
      _M_do_sanitize()
      {
 typedef _Sanitize<_Nb % (8 * 8)> __sanitize_type;
 __sanitize_type::_S_do_sanitize(this->_M_hiword());
      }





    public:
# 779 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bitset" 3
      class reference
      {
 friend class bitset;

 _WordT* _M_wp;
 size_t _M_bpos;


 reference();

      public:
 reference(bitset& __b, size_t __pos)
 {
   _M_wp = &__b._M_getword(__pos);
   _M_bpos = _Base::_S_whichbit(__pos);
 }

 ~reference()
 { }


 reference&
 operator=(bool __x)
 {
   if (__x)
     *_M_wp |= _Base::_S_maskbit(_M_bpos);
   else
     *_M_wp &= ~_Base::_S_maskbit(_M_bpos);
   return *this;
 }


 reference&
 operator=(const reference& __j)
 {
   if ((*(__j._M_wp) & _Base::_S_maskbit(__j._M_bpos)))
     *_M_wp |= _Base::_S_maskbit(_M_bpos);
   else
     *_M_wp &= ~_Base::_S_maskbit(_M_bpos);
   return *this;
 }


 bool
 operator~() const
 { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) == 0; }


 operator bool() const
 { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) != 0; }


 reference&
 flip()
 {
   *_M_wp ^= _Base::_S_maskbit(_M_bpos);
   return *this;
 }
      };
      friend class reference;



                         bitset()
      { }






      bitset(unsigned long __val)
      : _Base(__val)
      { _M_do_sanitize(); }
# 864 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bitset" 3
      template<class _CharT, class _Traits, class _Alloc>
 explicit
 bitset(const std::basic_string<_CharT, _Traits, _Alloc>& __s,
        size_t __position = 0)
 : _Base()
 {
   if (__position > __s.size())
     __throw_out_of_range(("bitset::bitset initial position " "not valid"));

   _M_copy_from_string(__s, __position,
         std::basic_string<_CharT, _Traits, _Alloc>::npos,
         _CharT('0'), _CharT('1'));
 }
# 888 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bitset" 3
      template<class _CharT, class _Traits, class _Alloc>
 bitset(const std::basic_string<_CharT, _Traits, _Alloc>& __s,
        size_t __position, size_t __n)
 : _Base()
 {
   if (__position > __s.size())
     __throw_out_of_range(("bitset::bitset initial position " "not valid"));

   _M_copy_from_string(__s, __position, __n, _CharT('0'), _CharT('1'));
 }



      template<class _CharT, class _Traits, class _Alloc>
 bitset(const std::basic_string<_CharT, _Traits, _Alloc>& __s,
        size_t __position, size_t __n,
        _CharT __zero, _CharT __one = _CharT('1'))
 : _Base()
 {
   if (__position > __s.size())
     __throw_out_of_range(("bitset::bitset initial position " "not valid"));

   _M_copy_from_string(__s, __position, __n, __zero, __one);
 }
# 950 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bitset" 3
      bitset<_Nb>&
      operator&=(const bitset<_Nb>& __rhs)
      {
 this->_M_do_and(__rhs);
 return *this;
      }

      bitset<_Nb>&
      operator|=(const bitset<_Nb>& __rhs)
      {
 this->_M_do_or(__rhs);
 return *this;
      }

      bitset<_Nb>&
      operator^=(const bitset<_Nb>& __rhs)
      {
 this->_M_do_xor(__rhs);
 return *this;
      }
# 979 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bitset" 3
      bitset<_Nb>&
      operator<<=(size_t __position)
      {
 if (__builtin_expect(__position < _Nb, 1))
   {
     this->_M_do_left_shift(__position);
     this->_M_do_sanitize();
   }
 else
   this->_M_do_reset();
 return *this;
      }

      bitset<_Nb>&
      operator>>=(size_t __position)
      {
 if (__builtin_expect(__position < _Nb, 1))
   {
     this->_M_do_right_shift(__position);
     this->_M_do_sanitize();
   }
 else
   this->_M_do_reset();
 return *this;
      }
# 1012 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bitset" 3
      bitset<_Nb>&
      _Unchecked_set(size_t __pos)
      {
 this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);
 return *this;
      }

      bitset<_Nb>&
      _Unchecked_set(size_t __pos, int __val)
      {
 if (__val)
   this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);
 else
   this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);
 return *this;
      }

      bitset<_Nb>&
      _Unchecked_reset(size_t __pos)
      {
 this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);
 return *this;
      }

      bitset<_Nb>&
      _Unchecked_flip(size_t __pos)
      {
 this->_M_getword(__pos) ^= _Base::_S_maskbit(__pos);
 return *this;
      }

                         bool
      _Unchecked_test(size_t __pos) const
      { return ((this->_M_getword(__pos) & _Base::_S_maskbit(__pos))
  != static_cast<_WordT>(0)); }






      bitset<_Nb>&
      set()
      {
 this->_M_do_set();
 this->_M_do_sanitize();
 return *this;
      }







      bitset<_Nb>&
      set(size_t __position, bool __val = true)
      {
 if (__position >= _Nb)
   __throw_out_of_range(("bitset::set"));
 return _Unchecked_set(__position, __val);
      }




      bitset<_Nb>&
      reset()
      {
 this->_M_do_reset();
 return *this;
      }
# 1092 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bitset" 3
      bitset<_Nb>&
      reset(size_t __position)
      {
 if (__position >= _Nb)
   __throw_out_of_range(("bitset::reset"));
 return _Unchecked_reset(__position);
      }




      bitset<_Nb>&
      flip()
      {
 this->_M_do_flip();
 this->_M_do_sanitize();
 return *this;
      }






      bitset<_Nb>&
      flip(size_t __position)
      {
 if (__position >= _Nb)
   __throw_out_of_range(("bitset::flip"));
 return _Unchecked_flip(__position);
      }


      bitset<_Nb>
      operator~() const
      { return bitset<_Nb>(*this).flip(); }
# 1144 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bitset" 3
      reference
      operator[](size_t __position)
      { return reference(*this, __position); }

                         bool
      operator[](size_t __position) const
      { return _Unchecked_test(__position); }
# 1159 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bitset" 3
      unsigned long
      to_ulong() const
      { return this->_M_do_to_ulong(); }
# 1177 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bitset" 3
      template<class _CharT, class _Traits, class _Alloc>
 std::basic_string<_CharT, _Traits, _Alloc>
 to_string() const
 {
   std::basic_string<_CharT, _Traits, _Alloc> __result;
   _M_copy_to_string(__result, _CharT('0'), _CharT('1'));
   return __result;
 }



      template<class _CharT, class _Traits, class _Alloc>
 std::basic_string<_CharT, _Traits, _Alloc>
 to_string(_CharT __zero, _CharT __one = _CharT('1')) const
 {
   std::basic_string<_CharT, _Traits, _Alloc> __result;
   _M_copy_to_string(__result, __zero, __one);
   return __result;
 }



      template<class _CharT, class _Traits>
 std::basic_string<_CharT, _Traits, std::allocator<_CharT> >
 to_string() const
 { return to_string<_CharT, _Traits, std::allocator<_CharT> >(); }



      template<class _CharT, class _Traits>
 std::basic_string<_CharT, _Traits, std::allocator<_CharT> >
 to_string(_CharT __zero, _CharT __one = _CharT('1')) const
 { return to_string<_CharT, _Traits,
                    std::allocator<_CharT> >(__zero, __one); }

      template<class _CharT>
 std::basic_string<_CharT, std::char_traits<_CharT>,
                   std::allocator<_CharT> >
 to_string() const
 {
   return to_string<_CharT, std::char_traits<_CharT>,
                    std::allocator<_CharT> >();
 }

      template<class _CharT>
 std::basic_string<_CharT, std::char_traits<_CharT>,
                   std::allocator<_CharT> >
 to_string(_CharT __zero, _CharT __one = _CharT('1')) const
 {
   return to_string<_CharT, std::char_traits<_CharT>,
                    std::allocator<_CharT> >(__zero, __one);
 }

      std::basic_string<char, std::char_traits<char>, std::allocator<char> >
      to_string() const
      {
 return to_string<char, std::char_traits<char>,
                  std::allocator<char> >();
      }

      std::basic_string<char, std::char_traits<char>, std::allocator<char> >
      to_string(char __zero, char __one = '1') const
      {
 return to_string<char, std::char_traits<char>,
                  std::allocator<char> >(__zero, __one);
      }


      template<class _CharT, class _Traits>
        void
        _M_copy_from_ptr(const _CharT*, size_t, size_t, size_t,
    _CharT, _CharT);

      template<class _CharT, class _Traits, class _Alloc>
 void
 _M_copy_from_string(const std::basic_string<_CharT,
       _Traits, _Alloc>& __s, size_t __pos, size_t __n,
       _CharT __zero, _CharT __one)
 { _M_copy_from_ptr<_CharT, _Traits>(__s.data(), __s.size(), __pos, __n,
         __zero, __one); }

      template<class _CharT, class _Traits, class _Alloc>
 void
        _M_copy_to_string(std::basic_string<_CharT, _Traits, _Alloc>&,
     _CharT, _CharT) const;


      template<class _CharT, class _Traits, class _Alloc>
 void
 _M_copy_from_string(const std::basic_string<_CharT,
       _Traits, _Alloc>& __s, size_t __pos, size_t __n)
 { _M_copy_from_string(__s, __pos, __n, _CharT('0'), _CharT('1')); }

      template<class _CharT, class _Traits, class _Alloc>
 void
        _M_copy_to_string(std::basic_string<_CharT, _Traits,_Alloc>& __s) const
 { _M_copy_to_string(__s, _CharT('0'), _CharT('1')); }


      size_t
      count() const
      { return this->_M_do_count(); }


                         size_t
      size() const
      { return _Nb; }



      bool
      operator==(const bitset<_Nb>& __rhs) const
      { return this->_M_is_equal(__rhs); }

      bool
      operator!=(const bitset<_Nb>& __rhs) const
      { return !this->_M_is_equal(__rhs); }
# 1302 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bitset" 3
      bool
      test(size_t __position) const
      {
 if (__position >= _Nb)
   __throw_out_of_range(("bitset::test"));
 return _Unchecked_test(__position);
      }







      bool
      all() const
      { return this->template _M_are_all<_Nb>(); }





      bool
      any() const
      { return this->_M_is_any(); }





      bool
      none() const
      { return !this->_M_is_any(); }



      bitset<_Nb>
      operator<<(size_t __position) const
      { return bitset<_Nb>(*this) <<= __position; }

      bitset<_Nb>
      operator>>(size_t __position) const
      { return bitset<_Nb>(*this) >>= __position; }
# 1353 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bitset" 3
      size_t
      _Find_first() const
      { return this->_M_do_find_first(_Nb); }
# 1364 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bitset" 3
      size_t
      _Find_next(size_t __prev) const
      { return this->_M_do_find_next(__prev, _Nb); }
    };


  template<size_t _Nb>
    template<class _CharT, class _Traits>
      void
      bitset<_Nb>::
      _M_copy_from_ptr(const _CharT* __s, size_t __len,
         size_t __pos, size_t __n, _CharT __zero, _CharT __one)
      {
 reset();
 const size_t __nbits = std::min(_Nb, std::min(__n, size_t(__len - __pos)));
 for (size_t __i = __nbits; __i > 0; --__i)
   {
     const _CharT __c = __s[__pos + __nbits - __i];
     if (_Traits::eq(__c, __zero))
       ;
     else if (_Traits::eq(__c, __one))
       _Unchecked_set(__i - 1);
     else
       __throw_invalid_argument(("bitset::_M_copy_from_ptr"));
   }
      }

  template<size_t _Nb>
    template<class _CharT, class _Traits, class _Alloc>
      void
      bitset<_Nb>::
      _M_copy_to_string(std::basic_string<_CharT, _Traits, _Alloc>& __s,
   _CharT __zero, _CharT __one) const
      {
 __s.assign(_Nb, __zero);
 for (size_t __i = _Nb; __i > 0; --__i)
   if (_Unchecked_test(__i - 1))
     _Traits::assign(__s[_Nb - __i], __one);
      }
# 1414 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bitset" 3
  template<size_t _Nb>
    inline bitset<_Nb>
    operator&(const bitset<_Nb>& __x, const bitset<_Nb>& __y)
    {
      bitset<_Nb> __result(__x);
      __result &= __y;
      return __result;
    }

  template<size_t _Nb>
    inline bitset<_Nb>
    operator|(const bitset<_Nb>& __x, const bitset<_Nb>& __y)
    {
      bitset<_Nb> __result(__x);
      __result |= __y;
      return __result;
    }

  template <size_t _Nb>
    inline bitset<_Nb>
    operator^(const bitset<_Nb>& __x, const bitset<_Nb>& __y)
    {
      bitset<_Nb> __result(__x);
      __result ^= __y;
      return __result;
    }
# 1451 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bitset" 3
  template<class _CharT, class _Traits, size_t _Nb>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is, bitset<_Nb>& __x)
    {
      typedef typename _Traits::char_type char_type;
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      std::basic_string<_CharT, _Traits> __tmp;
      __tmp.reserve(_Nb);



      const char_type __zero = __is.widen('0');
      const char_type __one = __is.widen('1');

      typename __ios_base::iostate __state = __ios_base::goodbit;
      typename __istream_type::sentry __sentry(__is);
      if (__sentry)
 {
   try
     {
       for (size_t __i = _Nb; __i > 0; --__i)
  {
    static typename _Traits::int_type __eof = _Traits::eof();

    typename _Traits::int_type __c1 = __is.rdbuf()->sbumpc();
    if (_Traits::eq_int_type(__c1, __eof))
      {
        __state |= __ios_base::eofbit;
        break;
      }
    else
      {
        const char_type __c2 = _Traits::to_char_type(__c1);
        if (_Traits::eq(__c2, __zero))
   __tmp.push_back(__zero);
        else if (_Traits::eq(__c2, __one))
   __tmp.push_back(__one);
        else if (_Traits::
          eq_int_type(__is.rdbuf()->sputbackc(__c2),
        __eof))
   {
     __state |= __ios_base::failbit;
     break;
   }
      }
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __is._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __is._M_setstate(__ios_base::badbit); }
 }

      if (__tmp.empty() && _Nb)
 __state |= __ios_base::failbit;
      else
 __x._M_copy_from_string(__tmp, static_cast<size_t>(0), _Nb,
    __zero, __one);
      if (__state)
 __is.setstate(__state);
      return __is;
    }

  template <class _CharT, class _Traits, size_t _Nb>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const bitset<_Nb>& __x)
    {
      std::basic_string<_CharT, _Traits> __tmp;



      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__os.getloc());
      __x._M_copy_to_string(__tmp, __ct.widen('0'), __ct.widen('1'));
      return __os << __tmp;
    }



}
# 96 "/home/marek/devel/nupic/external/common/include/boost/detail/container_fwd.hpp" 2
# 9 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/detail/container_fwd_0x.hpp" 2
# 17 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/extensions.hpp" 2



# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/repeat_from_to.hpp" 1
# 20 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/extensions.hpp" 2

# 1 "/home/marek/devel/nupic/external/common/include/boost/preprocessor/repetition/enum_params.hpp" 1
# 21 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/extensions.hpp" 2
# 35 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/extensions.hpp"
namespace boost
{
    template <class A, class B>
    std::size_t hash_value(std::pair<A, B> const&);
    template <class T, class A>
    std::size_t hash_value(std::vector<T, A> const&);
    template <class T, class A>
    std::size_t hash_value(std::list<T, A> const& v);
    template <class T, class A>
    std::size_t hash_value(std::deque<T, A> const& v);
    template <class K, class C, class A>
    std::size_t hash_value(std::set<K, C, A> const& v);
    template <class K, class C, class A>
    std::size_t hash_value(std::multiset<K, C, A> const& v);
    template <class K, class T, class C, class A>
    std::size_t hash_value(std::map<K, T, C, A> const& v);
    template <class K, class T, class C, class A>
    std::size_t hash_value(std::multimap<K, T, C, A> const& v);

    template <class T>
    std::size_t hash_value(std::complex<T> const&);

    template <class A, class B>
    std::size_t hash_value(std::pair<A, B> const& v)
    {
        std::size_t seed = 0;
        boost::hash_combine(seed, v.first);
        boost::hash_combine(seed, v.second);
        return seed;
    }

    template <class T, class A>
    std::size_t hash_value(std::vector<T, A> const& v)
    {
        return boost::hash_range(v.begin(), v.end());
    }

    template <class T, class A>
    std::size_t hash_value(std::list<T, A> const& v)
    {
        return boost::hash_range(v.begin(), v.end());
    }

    template <class T, class A>
    std::size_t hash_value(std::deque<T, A> const& v)
    {
        return boost::hash_range(v.begin(), v.end());
    }

    template <class K, class C, class A>
    std::size_t hash_value(std::set<K, C, A> const& v)
    {
        return boost::hash_range(v.begin(), v.end());
    }

    template <class K, class C, class A>
    std::size_t hash_value(std::multiset<K, C, A> const& v)
    {
        return boost::hash_range(v.begin(), v.end());
    }

    template <class K, class T, class C, class A>
    std::size_t hash_value(std::map<K, T, C, A> const& v)
    {
        return boost::hash_range(v.begin(), v.end());
    }

    template <class K, class T, class C, class A>
    std::size_t hash_value(std::multimap<K, T, C, A> const& v)
    {
        return boost::hash_range(v.begin(), v.end());
    }

    template <class T>
    std::size_t hash_value(std::complex<T> const& v)
    {
        boost::hash<T> hasher;
        std::size_t seed = hasher(v.imag());
        seed ^= hasher(v.real()) + (seed<<6) + (seed>>2);
        return seed;
    }
# 251 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/extensions.hpp"
    template <class T> struct hash
        : std::unary_function<T, std::size_t>
    {

        std::size_t operator()(T const& val) const
        {
            return hash_value(val);
        }






    };
# 365 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/extensions.hpp"
}
# 508 "/home/marek/devel/nupic/external/common/include/boost/functional/hash/hash.hpp" 2
# 6 "/home/marek/devel/nupic/external/common/include/boost/functional/hash.hpp" 2
# 20 "/home/marek/devel/nupic/external/common/include/boost/unordered/unordered_set.hpp" 2
# 36 "/home/marek/devel/nupic/external/common/include/boost/unordered/unordered_set.hpp"
namespace boost
{
namespace unordered
{
    template <class T, class H, class P, class A>
    class unordered_set
    {



    public:

        typedef T key_type;
        typedef T value_type;
        typedef H hasher;
        typedef P key_equal;
        typedef A allocator_type;

    private:

        typedef boost::unordered::detail::set<A, T, H, P> types;
        typedef typename types::traits allocator_traits;
        typedef typename types::table table;

    public:

        typedef typename allocator_traits::pointer pointer;
        typedef typename allocator_traits::const_pointer const_pointer;

        typedef value_type& reference;
        typedef value_type const& const_reference;

        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;

        typedef typename table::cl_iterator const_local_iterator;
        typedef typename table::cl_iterator local_iterator;
        typedef typename table::c_iterator const_iterator;
        typedef typename table::c_iterator iterator;

    private:

        table table_;

    public:



        explicit unordered_set(
                size_type = boost::unordered::detail::default_bucket_count,
                const hasher& = hasher(),
                const key_equal& = key_equal(),
                const allocator_type& = allocator_type());

        explicit unordered_set(allocator_type const&);

        template <class InputIt>
        unordered_set(InputIt, InputIt);

        template <class InputIt>
        unordered_set(
                InputIt, InputIt,
                size_type,
                const hasher& = hasher(),
                const key_equal& = key_equal());

        template <class InputIt>
        unordered_set(
                InputIt, InputIt,
                size_type,
                const hasher&,
                const key_equal&,
                const allocator_type&);



        unordered_set(unordered_set const&);

        unordered_set(unordered_set const&, allocator_type const&);
# 143 "/home/marek/devel/nupic/external/common/include/boost/unordered/unordered_set.hpp"
        ~unordered_set();
# 160 "/home/marek/devel/nupic/external/common/include/boost/unordered/unordered_set.hpp"
        unordered_set& operator=(unordered_set const& x)
        {
            table_.assign(x.table_);
            return *this;
        }
# 179 "/home/marek/devel/nupic/external/common/include/boost/unordered/unordered_set.hpp"
        allocator_type get_allocator() const
        {
            return table_.node_alloc();
        }



        bool empty() const
        {
            return table_.size_ == 0;
        }

        size_type size() const
        {
            return table_.size_;
        }

        size_type max_size() const;



        iterator begin()
        {
            return table_.begin();
        }

        const_iterator begin() const
        {
            return table_.begin();
        }

        iterator end()
        {
            return iterator();
        }

        const_iterator end() const
        {
            return const_iterator();
        }

        const_iterator cbegin() const
        {
            return table_.begin();
        }

        const_iterator cend() const
        {
            return const_iterator();
        }
# 252 "/home/marek/devel/nupic/external/common/include/boost/unordered/unordered_set.hpp"
        std::pair<iterator, bool> emplace(
                boost::unordered::detail::empty_emplace
                    = boost::unordered::detail::empty_emplace(),
                value_type v = value_type())
        {
            return this->emplace(boost::move(v));
        }

        iterator emplace_hint(const_iterator hint,
                boost::unordered::detail::empty_emplace
                    = boost::unordered::detail::empty_emplace(),
                value_type v = value_type()
            )
        {
            return this->emplace_hint(hint, boost::move(v));
        }



        template <typename A0>
        std::pair<iterator, bool> emplace(const A0 & a0)
        {
            return table_.emplace(
                boost::unordered::detail::create_emplace_args(
                    boost::forward<A0>(a0))
            );
        }

        template <typename A0>
        iterator emplace_hint(const_iterator, const A0 & a0)
        {
            return table_.emplace(
                boost::unordered::detail::create_emplace_args(
                    boost::forward<A0>(a0))
            ).first;
        }

        template <typename A0, typename A1>
        std::pair<iterator, bool> emplace(
            const A0 & a0,
            const A1 & a1)
        {
            return table_.emplace(
                boost::unordered::detail::create_emplace_args(
                    boost::forward<A0>(a0),
                    boost::forward<A1>(a1))
            );
        }

        template <typename A0, typename A1>
        iterator emplace_hint(const_iterator,
            const A0 & a0,
            const A1 & a1)
        {
            return table_.emplace(
                boost::unordered::detail::create_emplace_args(
                    boost::forward<A0>(a0),
                    boost::forward<A1>(a1))
            ).first;
        }

        template <typename A0, typename A1, typename A2>
        std::pair<iterator, bool> emplace(
            const A0 & a0,
            const A1 & a1,
            const A2 & a2)
        {
            return table_.emplace(
                boost::unordered::detail::create_emplace_args(
                    boost::forward<A0>(a0),
                    boost::forward<A1>(a1),
                    boost::forward<A2>(a2))
            );
        }

        template <typename A0, typename A1, typename A2>
        iterator emplace_hint(const_iterator,
            const A0 & a0,
            const A1 & a1,
            const A2 & a2)
        {
            return table_.emplace(
                boost::unordered::detail::create_emplace_args(
                    boost::forward<A0>(a0),
                    boost::forward<A1>(a1),
                    boost::forward<A2>(a2))
            ).first;
        }
# 371 "/home/marek/devel/nupic/external/common/include/boost/unordered/unordered_set.hpp"
        template < typename A0 , typename A1 , typename A2 , typename A3 > std::pair<iterator, bool> emplace( const A0 & a0 , const A1 & a1 , const A2 & a2 , const A3 & a3 ) { return table_.emplace( boost::unordered::detail::create_emplace_args( boost::forward<A0>(a0) , boost::forward<A1>(a1) , boost::forward<A2>(a2) , boost::forward<A3>(a3) )); } template < typename A0 , typename A1 , typename A2 , typename A3 > iterator emplace_hint( const_iterator, const A0 & a0 , const A1 & a1 , const A2 & a2 , const A3 & a3 ) { return table_.emplace( boost::unordered::detail::create_emplace_args( boost::forward<A0>(a0) , boost::forward<A1>(a1) , boost::forward<A2>(a2) , boost::forward<A3>(a3) )).first; } template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > std::pair<iterator, bool> emplace( const A0 & a0 , const A1 & a1 , const A2 & a2 , const A3 & a3 , const A4 & a4 ) { return table_.emplace( boost::unordered::detail::create_emplace_args( boost::forward<A0>(a0) , boost::forward<A1>(a1) , boost::forward<A2>(a2) , boost::forward<A3>(a3) , boost::forward<A4>(a4) )); } template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > iterator emplace_hint( const_iterator, const A0 & a0 , const A1 & a1 , const A2 & a2 , const A3 & a3 , const A4 & a4 ) { return table_.emplace( boost::unordered::detail::create_emplace_args( boost::forward<A0>(a0) , boost::forward<A1>(a1) , boost::forward<A2>(a2) , boost::forward<A3>(a3) , boost::forward<A4>(a4) )).first; } template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > std::pair<iterator, bool> emplace( const A0 & a0 , const A1 & a1 , const A2 & a2 , const A3 & a3 , const A4 & a4 , const A5 & a5 ) { return table_.emplace( boost::unordered::detail::create_emplace_args( boost::forward<A0>(a0) , boost::forward<A1>(a1) , boost::forward<A2>(a2) , boost::forward<A3>(a3) , boost::forward<A4>(a4) , boost::forward<A5>(a5) )); } template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > iterator emplace_hint( const_iterator, const A0 & a0 , const A1 & a1 , const A2 & a2 , const A3 & a3 , const A4 & a4 , const A5 & a5 ) { return table_.emplace( boost::unordered::detail::create_emplace_args( boost::forward<A0>(a0) , boost::forward<A1>(a1) , boost::forward<A2>(a2) , boost::forward<A3>(a3) , boost::forward<A4>(a4) , boost::forward<A5>(a5) )).first; } template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > std::pair<iterator, bool> emplace( const A0 & a0 , const A1 & a1 , const A2 & a2 , const A3 & a3 , const A4 & a4 , const A5 & a5 , const A6 & a6 ) { return table_.emplace( boost::unordered::detail::create_emplace_args( boost::forward<A0>(a0) , boost::forward<A1>(a1) , boost::forward<A2>(a2) , boost::forward<A3>(a3) , boost::forward<A4>(a4) , boost::forward<A5>(a5) , boost::forward<A6>(a6) )); } template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > iterator emplace_hint( const_iterator, const A0 & a0 , const A1 & a1 , const A2 & a2 , const A3 & a3 , const A4 & a4 , const A5 & a5 , const A6 & a6 ) { return table_.emplace( boost::unordered::detail::create_emplace_args( boost::forward<A0>(a0) , boost::forward<A1>(a1) , boost::forward<A2>(a2) , boost::forward<A3>(a3) , boost::forward<A4>(a4) , boost::forward<A5>(a5) , boost::forward<A6>(a6) )).first; } template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 , typename A7 > std::pair<iterator, bool> emplace( const A0 & a0 , const A1 & a1 , const A2 & a2 , const A3 & a3 , const A4 & a4 , const A5 & a5 , const A6 & a6 , const A7 & a7 ) { return table_.emplace( boost::unordered::detail::create_emplace_args( boost::forward<A0>(a0) , boost::forward<A1>(a1) , boost::forward<A2>(a2) , boost::forward<A3>(a3) , boost::forward<A4>(a4) , boost::forward<A5>(a5) , boost::forward<A6>(a6) , boost::forward<A7>(a7) )); } template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 , typename A7 > iterator emplace_hint( const_iterator, const A0 & a0 , const A1 & a1 , const A2 & a2 , const A3 & a3 , const A4 & a4 , const A5 & a5 , const A6 & a6 , const A7 & a7 ) { return table_.emplace( boost::unordered::detail::create_emplace_args( boost::forward<A0>(a0) , boost::forward<A1>(a1) , boost::forward<A2>(a2) , boost::forward<A3>(a3) , boost::forward<A4>(a4) , boost::forward<A5>(a5) , boost::forward<A6>(a6) , boost::forward<A7>(a7) )).first; } template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 , typename A7 , typename A8 > std::pair<iterator, bool> emplace( const A0 & a0 , const A1 & a1 , const A2 & a2 , const A3 & a3 , const A4 & a4 , const A5 & a5 , const A6 & a6 , const A7 & a7 , const A8 & a8 ) { return table_.emplace( boost::unordered::detail::create_emplace_args( boost::forward<A0>(a0) , boost::forward<A1>(a1) , boost::forward<A2>(a2) , boost::forward<A3>(a3) , boost::forward<A4>(a4) , boost::forward<A5>(a5) , boost::forward<A6>(a6) , boost::forward<A7>(a7) , boost::forward<A8>(a8) )); } template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 , typename A7 , typename A8 > iterator emplace_hint( const_iterator, const A0 & a0 , const A1 & a1 , const A2 & a2 , const A3 & a3 , const A4 & a4 , const A5 & a5 , const A6 & a6 , const A7 & a7 , const A8 & a8 ) { return table_.emplace( boost::unordered::detail::create_emplace_args( boost::forward<A0>(a0) , boost::forward<A1>(a1) , boost::forward<A2>(a2) , boost::forward<A3>(a3) , boost::forward<A4>(a4) , boost::forward<A5>(a5) , boost::forward<A6>(a6) , boost::forward<A7>(a7) , boost::forward<A8>(a8) )).first; }






        std::pair<iterator, bool> insert(value_type const& x)
        {
            return this->emplace(x);
        }

        std::pair<iterator, bool> insert(typename boost::unordered::detail::rv_ref<value_type>::type x)
        {
            return this->emplace(boost::move(x));
        }

        iterator insert(const_iterator hint, value_type const& x)
        {
            return this->emplace_hint(hint, x);
        }

        iterator insert(const_iterator hint,
                typename boost::unordered::detail::rv_ref<value_type>::type x)
        {
            return this->emplace_hint(hint, boost::move(x));
        }

        template <class InputIt> void insert(InputIt, InputIt);





        iterator erase(const_iterator);
        size_type erase(const key_type&);
        iterator erase(const_iterator, const_iterator);
        void quick_erase(const_iterator it) { erase(it); }
        void erase_return_void(const_iterator it) { erase(it); }

        void clear();
        void swap(unordered_set&);



        hasher hash_function() const;
        key_equal key_eq() const;



        const_iterator find(const key_type&) const;

        template <class CompatibleKey, class CompatibleHash,
            class CompatiblePredicate>
        const_iterator find(
                CompatibleKey const&,
                CompatibleHash const&,
                CompatiblePredicate const&) const;

        size_type count(const key_type&) const;

        std::pair<const_iterator, const_iterator>
        equal_range(const key_type&) const;



        size_type bucket_count() const
        {
            return table_.bucket_count_;
        }

        size_type max_bucket_count() const
        {
            return table_.max_bucket_count();
        }

        size_type bucket_size(size_type) const;

        size_type bucket(const key_type& k) const
        {
            return table::to_bucket(table_.bucket_count_,
                table_.hash(k));
        }

        local_iterator begin(size_type n)
        {
            return local_iterator(
                table_.begin(n), n, table_.bucket_count_);
        }

        const_local_iterator begin(size_type n) const
        {
            return const_local_iterator(
                table_.begin(n), n, table_.bucket_count_);
        }

        local_iterator end(size_type)
        {
            return local_iterator();
        }

        const_local_iterator end(size_type) const
        {
            return const_local_iterator();
        }

        const_local_iterator cbegin(size_type n) const
        {
            return const_local_iterator(
                table_.begin(n), n, table_.bucket_count_);
        }

        const_local_iterator cend(size_type) const
        {
            return const_local_iterator();
        }



        float max_load_factor() const
        {
            return table_.mlf_;
        }

        float load_factor() const;
        void max_load_factor(float);
        void rehash(size_type);
        void reserve(size_type);


        friend bool operator==<T,H,P,A>(
                unordered_set const&, unordered_set const&);
        friend bool operator!=<T,H,P,A>(
                unordered_set const&, unordered_set const&);

    };

    template <class T, class H, class P, class A>
    class unordered_multiset
    {



    public:

        typedef T key_type;
        typedef T value_type;
        typedef H hasher;
        typedef P key_equal;
        typedef A allocator_type;

    private:

        typedef boost::unordered::detail::multiset<A, T, H, P> types;
        typedef typename types::traits allocator_traits;
        typedef typename types::table table;

    public:

        typedef typename allocator_traits::pointer pointer;
        typedef typename allocator_traits::const_pointer const_pointer;

        typedef value_type& reference;
        typedef value_type const& const_reference;

        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;

        typedef typename table::cl_iterator const_local_iterator;
        typedef typename table::cl_iterator local_iterator;
        typedef typename table::c_iterator const_iterator;
        typedef typename table::c_iterator iterator;

    private:

        table table_;

    public:



        explicit unordered_multiset(
                size_type = boost::unordered::detail::default_bucket_count,
                const hasher& = hasher(),
                const key_equal& = key_equal(),
                const allocator_type& = allocator_type());

        explicit unordered_multiset(allocator_type const&);

        template <class InputIt>
        unordered_multiset(InputIt, InputIt);

        template <class InputIt>
        unordered_multiset(
                InputIt, InputIt,
                size_type,
                const hasher& = hasher(),
                const key_equal& = key_equal());

        template <class InputIt>
        unordered_multiset(
                InputIt, InputIt,
                size_type,
                const hasher&,
                const key_equal&,
                const allocator_type&);



        unordered_multiset(unordered_multiset const&);

        unordered_multiset(unordered_multiset const&, allocator_type const&);
# 611 "/home/marek/devel/nupic/external/common/include/boost/unordered/unordered_set.hpp"
        ~unordered_multiset();
# 629 "/home/marek/devel/nupic/external/common/include/boost/unordered/unordered_set.hpp"
        unordered_multiset& operator=(unordered_multiset const& x)
        {
            table_.assign(x.table_);
            return *this;
        }
# 648 "/home/marek/devel/nupic/external/common/include/boost/unordered/unordered_set.hpp"
        allocator_type get_allocator() const
        {
            return table_.node_alloc();
        }



        bool empty() const
        {
            return table_.size_ == 0;
        }

        size_type size() const
        {
            return table_.size_;
        }

        size_type max_size() const;



        iterator begin()
        {
            return iterator(table_.begin());
        }

        const_iterator begin() const
        {
            return const_iterator(table_.begin());
        }

        iterator end()
        {
            return iterator();
        }

        const_iterator end() const
        {
            return const_iterator();
        }

        const_iterator cbegin() const
        {
            return const_iterator(table_.begin());
        }

        const_iterator cend() const
        {
            return const_iterator();
        }
# 721 "/home/marek/devel/nupic/external/common/include/boost/unordered/unordered_set.hpp"
        iterator emplace(
                boost::unordered::detail::empty_emplace
                    = boost::unordered::detail::empty_emplace(),
                value_type v = value_type())
        {
            return this->emplace(boost::move(v));
        }

        iterator emplace_hint(const_iterator hint,
                boost::unordered::detail::empty_emplace
                    = boost::unordered::detail::empty_emplace(),
                value_type v = value_type()
            )
        {
            return this->emplace_hint(hint, boost::move(v));
        }



        template <typename A0>
        iterator emplace(const A0 & a0)
        {
            return table_.emplace(
                boost::unordered::detail::create_emplace_args(
                    boost::forward<A0>(a0))
            );
        }

        template <typename A0>
        iterator emplace_hint(const_iterator, const A0 & a0)
        {
            return table_.emplace(
                boost::unordered::detail::create_emplace_args(
                    boost::forward<A0>(a0))
            );
        }

        template <typename A0, typename A1>
        iterator emplace(
            const A0 & a0,
            const A1 & a1)
        {
            return table_.emplace(
                boost::unordered::detail::create_emplace_args(
                    boost::forward<A0>(a0),
                    boost::forward<A1>(a1))
            );
        }

        template <typename A0, typename A1>
        iterator emplace_hint(const_iterator,
            const A0 & a0,
            const A1 & a1)
        {
            return table_.emplace(
                boost::unordered::detail::create_emplace_args(
                    boost::forward<A0>(a0),
                    boost::forward<A1>(a1))
            );
        }

        template <typename A0, typename A1, typename A2>
        iterator emplace(
            const A0 & a0,
            const A1 & a1,
            const A2 & a2)
        {
            return table_.emplace(
                boost::unordered::detail::create_emplace_args(
                    boost::forward<A0>(a0),
                    boost::forward<A1>(a1),
                    boost::forward<A2>(a2))
            );
        }

        template <typename A0, typename A1, typename A2>
        iterator emplace_hint(const_iterator,
            const A0 & a0,
            const A1 & a1,
            const A2 & a2)
        {
            return table_.emplace(
                boost::unordered::detail::create_emplace_args(
                    boost::forward<A0>(a0),
                    boost::forward<A1>(a1),
                    boost::forward<A2>(a2))
            );
        }
# 840 "/home/marek/devel/nupic/external/common/include/boost/unordered/unordered_set.hpp"
        template < typename A0 , typename A1 , typename A2 , typename A3 > iterator emplace( const A0 & a0 , const A1 & a1 , const A2 & a2 , const A3 & a3 ) { return table_.emplace( boost::unordered::detail::create_emplace_args( boost::forward<A0>(a0) , boost::forward<A1>(a1) , boost::forward<A2>(a2) , boost::forward<A3>(a3) )); } template < typename A0 , typename A1 , typename A2 , typename A3 > iterator emplace_hint( const_iterator, const A0 & a0 , const A1 & a1 , const A2 & a2 , const A3 & a3 ) { return table_.emplace( boost::unordered::detail::create_emplace_args( boost::forward<A0>(a0) , boost::forward<A1>(a1) , boost::forward<A2>(a2) , boost::forward<A3>(a3) )); } template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > iterator emplace( const A0 & a0 , const A1 & a1 , const A2 & a2 , const A3 & a3 , const A4 & a4 ) { return table_.emplace( boost::unordered::detail::create_emplace_args( boost::forward<A0>(a0) , boost::forward<A1>(a1) , boost::forward<A2>(a2) , boost::forward<A3>(a3) , boost::forward<A4>(a4) )); } template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 > iterator emplace_hint( const_iterator, const A0 & a0 , const A1 & a1 , const A2 & a2 , const A3 & a3 , const A4 & a4 ) { return table_.emplace( boost::unordered::detail::create_emplace_args( boost::forward<A0>(a0) , boost::forward<A1>(a1) , boost::forward<A2>(a2) , boost::forward<A3>(a3) , boost::forward<A4>(a4) )); } template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > iterator emplace( const A0 & a0 , const A1 & a1 , const A2 & a2 , const A3 & a3 , const A4 & a4 , const A5 & a5 ) { return table_.emplace( boost::unordered::detail::create_emplace_args( boost::forward<A0>(a0) , boost::forward<A1>(a1) , boost::forward<A2>(a2) , boost::forward<A3>(a3) , boost::forward<A4>(a4) , boost::forward<A5>(a5) )); } template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 > iterator emplace_hint( const_iterator, const A0 & a0 , const A1 & a1 , const A2 & a2 , const A3 & a3 , const A4 & a4 , const A5 & a5 ) { return table_.emplace( boost::unordered::detail::create_emplace_args( boost::forward<A0>(a0) , boost::forward<A1>(a1) , boost::forward<A2>(a2) , boost::forward<A3>(a3) , boost::forward<A4>(a4) , boost::forward<A5>(a5) )); } template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > iterator emplace( const A0 & a0 , const A1 & a1 , const A2 & a2 , const A3 & a3 , const A4 & a4 , const A5 & a5 , const A6 & a6 ) { return table_.emplace( boost::unordered::detail::create_emplace_args( boost::forward<A0>(a0) , boost::forward<A1>(a1) , boost::forward<A2>(a2) , boost::forward<A3>(a3) , boost::forward<A4>(a4) , boost::forward<A5>(a5) , boost::forward<A6>(a6) )); } template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 > iterator emplace_hint( const_iterator, const A0 & a0 , const A1 & a1 , const A2 & a2 , const A3 & a3 , const A4 & a4 , const A5 & a5 , const A6 & a6 ) { return table_.emplace( boost::unordered::detail::create_emplace_args( boost::forward<A0>(a0) , boost::forward<A1>(a1) , boost::forward<A2>(a2) , boost::forward<A3>(a3) , boost::forward<A4>(a4) , boost::forward<A5>(a5) , boost::forward<A6>(a6) )); } template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 , typename A7 > iterator emplace( const A0 & a0 , const A1 & a1 , const A2 & a2 , const A3 & a3 , const A4 & a4 , const A5 & a5 , const A6 & a6 , const A7 & a7 ) { return table_.emplace( boost::unordered::detail::create_emplace_args( boost::forward<A0>(a0) , boost::forward<A1>(a1) , boost::forward<A2>(a2) , boost::forward<A3>(a3) , boost::forward<A4>(a4) , boost::forward<A5>(a5) , boost::forward<A6>(a6) , boost::forward<A7>(a7) )); } template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 , typename A7 > iterator emplace_hint( const_iterator, const A0 & a0 , const A1 & a1 , const A2 & a2 , const A3 & a3 , const A4 & a4 , const A5 & a5 , const A6 & a6 , const A7 & a7 ) { return table_.emplace( boost::unordered::detail::create_emplace_args( boost::forward<A0>(a0) , boost::forward<A1>(a1) , boost::forward<A2>(a2) , boost::forward<A3>(a3) , boost::forward<A4>(a4) , boost::forward<A5>(a5) , boost::forward<A6>(a6) , boost::forward<A7>(a7) )); } template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 , typename A7 , typename A8 > iterator emplace( const A0 & a0 , const A1 & a1 , const A2 & a2 , const A3 & a3 , const A4 & a4 , const A5 & a5 , const A6 & a6 , const A7 & a7 , const A8 & a8 ) { return table_.emplace( boost::unordered::detail::create_emplace_args( boost::forward<A0>(a0) , boost::forward<A1>(a1) , boost::forward<A2>(a2) , boost::forward<A3>(a3) , boost::forward<A4>(a4) , boost::forward<A5>(a5) , boost::forward<A6>(a6) , boost::forward<A7>(a7) , boost::forward<A8>(a8) )); } template < typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 , typename A7 , typename A8 > iterator emplace_hint( const_iterator, const A0 & a0 , const A1 & a1 , const A2 & a2 , const A3 & a3 , const A4 & a4 , const A5 & a5 , const A6 & a6 , const A7 & a7 , const A8 & a8 ) { return table_.emplace( boost::unordered::detail::create_emplace_args( boost::forward<A0>(a0) , boost::forward<A1>(a1) , boost::forward<A2>(a2) , boost::forward<A3>(a3) , boost::forward<A4>(a4) , boost::forward<A5>(a5) , boost::forward<A6>(a6) , boost::forward<A7>(a7) , boost::forward<A8>(a8) )); }






        iterator insert(value_type const& x)
        {
            return this->emplace(x);
        }

        iterator insert(typename boost::unordered::detail::rv_ref<value_type>::type x)
        {
            return this->emplace(boost::move(x));
        }

        iterator insert(const_iterator hint, value_type const& x)
        {
            return this->emplace_hint(hint, x);
        }

        iterator insert(const_iterator hint,
                typename boost::unordered::detail::rv_ref<value_type>::type x)
        {
            return this->emplace_hint(hint, boost::move(x));
        }

        template <class InputIt> void insert(InputIt, InputIt);





        iterator erase(const_iterator);
        size_type erase(const key_type&);
        iterator erase(const_iterator, const_iterator);
        void quick_erase(const_iterator it) { erase(it); }
        void erase_return_void(const_iterator it) { erase(it); }

        void clear();
        void swap(unordered_multiset&);



        hasher hash_function() const;
        key_equal key_eq() const;



        const_iterator find(const key_type&) const;

        template <class CompatibleKey, class CompatibleHash,
            class CompatiblePredicate>
        const_iterator find(
                CompatibleKey const&,
                CompatibleHash const&,
                CompatiblePredicate const&) const;

        size_type count(const key_type&) const;

        std::pair<const_iterator, const_iterator>
        equal_range(const key_type&) const;



        size_type bucket_count() const
        {
            return table_.bucket_count_;
        }

        size_type max_bucket_count() const
        {
            return table_.max_bucket_count();
        }

        size_type bucket_size(size_type) const;

        size_type bucket(const key_type& k) const
        {
            return table::to_bucket(table_.bucket_count_,
                table_.hash(k));
        }

        local_iterator begin(size_type n)
        {
            return local_iterator(
                table_.begin(n), n, table_.bucket_count_);
        }

        const_local_iterator begin(size_type n) const
        {
            return const_local_iterator(
                table_.begin(n), n, table_.bucket_count_);
        }

        local_iterator end(size_type)
        {
            return local_iterator();
        }

        const_local_iterator end(size_type) const
        {
            return const_local_iterator();
        }

        const_local_iterator cbegin(size_type n) const
        {
            return const_local_iterator(
                table_.begin(n), n, table_.bucket_count_);
        }

        const_local_iterator cend(size_type) const
        {
            return const_local_iterator();
        }



        float max_load_factor() const
        {
            return table_.mlf_;
        }

        float load_factor() const;
        void max_load_factor(float);
        void rehash(size_type);
        void reserve(size_type);


        friend bool operator==<T,H,P,A>(
                unordered_multiset const&, unordered_multiset const&);
        friend bool operator!=<T,H,P,A>(
                unordered_multiset const&, unordered_multiset const&);

    };



    template <class T, class H, class P, class A>
    unordered_set<T,H,P,A>::unordered_set(
            size_type n, const hasher &hf, const key_equal &eql,
            const allocator_type &a)
      : table_(n, hf, eql, a)
    {
    }

    template <class T, class H, class P, class A>
    unordered_set<T,H,P,A>::unordered_set(allocator_type const& a)
      : table_(boost::unordered::detail::default_bucket_count,
            hasher(), key_equal(), a)
    {
    }

    template <class T, class H, class P, class A>
    unordered_set<T,H,P,A>::unordered_set(
            unordered_set const& other, allocator_type const& a)
      : table_(other.table_, a)
    {
    }

    template <class T, class H, class P, class A>
    template <class InputIt>
    unordered_set<T,H,P,A>::unordered_set(InputIt f, InputIt l)
      : table_(boost::unordered::detail::initial_size(f, l),
        hasher(), key_equal(), allocator_type())
    {
        table_.insert_range(f, l);
    }

    template <class T, class H, class P, class A>
    template <class InputIt>
    unordered_set<T,H,P,A>::unordered_set(
            InputIt f, InputIt l,
            size_type n,
            const hasher &hf,
            const key_equal &eql)
      : table_(boost::unordered::detail::initial_size(f, l, n),
            hf, eql, allocator_type())
    {
        table_.insert_range(f, l);
    }

    template <class T, class H, class P, class A>
    template <class InputIt>
    unordered_set<T,H,P,A>::unordered_set(
            InputIt f, InputIt l,
            size_type n,
            const hasher &hf,
            const key_equal &eql,
            const allocator_type &a)
      : table_(boost::unordered::detail::initial_size(f, l, n), hf, eql, a)
    {
        table_.insert_range(f, l);
    }

    template <class T, class H, class P, class A>
    unordered_set<T,H,P,A>::~unordered_set() {}

    template <class T, class H, class P, class A>
    unordered_set<T,H,P,A>::unordered_set(
            unordered_set const& other)
      : table_(other.table_)
    {
    }
# 1084 "/home/marek/devel/nupic/external/common/include/boost/unordered/unordered_set.hpp"
    template <class T, class H, class P, class A>
    std::size_t unordered_set<T,H,P,A>::max_size() const
    {
        return table_.max_size();
    }



    template <class T, class H, class P, class A>
    template <class InputIt>
    void unordered_set<T,H,P,A>::insert(InputIt first, InputIt last)
    {
        table_.insert_range(first, last);
    }
# 1108 "/home/marek/devel/nupic/external/common/include/boost/unordered/unordered_set.hpp"
    template <class T, class H, class P, class A>
    typename unordered_set<T,H,P,A>::iterator
        unordered_set<T,H,P,A>::erase(const_iterator position)
    {
        return table_.erase(position);
    }

    template <class T, class H, class P, class A>
    typename unordered_set<T,H,P,A>::size_type
        unordered_set<T,H,P,A>::erase(const key_type& k)
    {
        return table_.erase_key(k);
    }

    template <class T, class H, class P, class A>
    typename unordered_set<T,H,P,A>::iterator
        unordered_set<T,H,P,A>::erase(
            const_iterator first, const_iterator last)
    {
        return table_.erase_range(first, last);
    }

    template <class T, class H, class P, class A>
    void unordered_set<T,H,P,A>::clear()
    {
        table_.clear();
    }

    template <class T, class H, class P, class A>
    void unordered_set<T,H,P,A>::swap(unordered_set& other)
    {
        table_.swap(other.table_);
    }



    template <class T, class H, class P, class A>
    typename unordered_set<T,H,P,A>::hasher
        unordered_set<T,H,P,A>::hash_function() const
    {
        return table_.hash_function();
    }

    template <class T, class H, class P, class A>
    typename unordered_set<T,H,P,A>::key_equal
        unordered_set<T,H,P,A>::key_eq() const
    {
        return table_.key_eq();
    }



    template <class T, class H, class P, class A>
    typename unordered_set<T,H,P,A>::const_iterator
        unordered_set<T,H,P,A>::find(const key_type& k) const
    {
        return table_.find_node(k);
    }

    template <class T, class H, class P, class A>
    template <class CompatibleKey, class CompatibleHash,
        class CompatiblePredicate>
    typename unordered_set<T,H,P,A>::const_iterator
        unordered_set<T,H,P,A>::find(
            CompatibleKey const& k,
            CompatibleHash const& hash,
            CompatiblePredicate const& eq) const
    {
        return table_.generic_find_node(k, hash, eq);
    }

    template <class T, class H, class P, class A>
    typename unordered_set<T,H,P,A>::size_type
        unordered_set<T,H,P,A>::count(const key_type& k) const
    {
        return table_.count(k);
    }

    template <class T, class H, class P, class A>
    std::pair<
            typename unordered_set<T,H,P,A>::const_iterator,
            typename unordered_set<T,H,P,A>::const_iterator>
        unordered_set<T,H,P,A>::equal_range(const key_type& k) const
    {
        return table_.equal_range(k);
    }

    template <class T, class H, class P, class A>
    typename unordered_set<T,H,P,A>::size_type
        unordered_set<T,H,P,A>::bucket_size(size_type n) const
    {
        return table_.bucket_size(n);
    }



    template <class T, class H, class P, class A>
    float unordered_set<T,H,P,A>::load_factor() const
    {
        return table_.load_factor();
    }

    template <class T, class H, class P, class A>
    void unordered_set<T,H,P,A>::max_load_factor(float m)
    {
        table_.max_load_factor(m);
    }

    template <class T, class H, class P, class A>
    void unordered_set<T,H,P,A>::rehash(size_type n)
    {
        table_.rehash(n);
    }

    template <class T, class H, class P, class A>
    void unordered_set<T,H,P,A>::reserve(size_type n)
    {
        table_.reserve(n);
    }

    template <class T, class H, class P, class A>
    inline bool operator==(
            unordered_set<T,H,P,A> const& m1,
            unordered_set<T,H,P,A> const& m2)
    {



        return m1.table_.equals(m2.table_);
    }

    template <class T, class H, class P, class A>
    inline bool operator!=(
            unordered_set<T,H,P,A> const& m1,
            unordered_set<T,H,P,A> const& m2)
    {



        return !m1.table_.equals(m2.table_);
    }

    template <class T, class H, class P, class A>
    inline void swap(
            unordered_set<T,H,P,A> &m1,
            unordered_set<T,H,P,A> &m2)
    {



        m1.swap(m2);
    }



    template <class T, class H, class P, class A>
    unordered_multiset<T,H,P,A>::unordered_multiset(
            size_type n, const hasher &hf, const key_equal &eql,
            const allocator_type &a)
      : table_(n, hf, eql, a)
    {
    }

    template <class T, class H, class P, class A>
    unordered_multiset<T,H,P,A>::unordered_multiset(allocator_type const& a)
      : table_(boost::unordered::detail::default_bucket_count,
            hasher(), key_equal(), a)
    {
    }

    template <class T, class H, class P, class A>
    unordered_multiset<T,H,P,A>::unordered_multiset(
            unordered_multiset const& other, allocator_type const& a)
      : table_(other.table_, a)
    {
    }

    template <class T, class H, class P, class A>
    template <class InputIt>
    unordered_multiset<T,H,P,A>::unordered_multiset(InputIt f, InputIt l)
      : table_(boost::unordered::detail::initial_size(f, l),
        hasher(), key_equal(), allocator_type())
    {
        table_.insert_range(f, l);
    }

    template <class T, class H, class P, class A>
    template <class InputIt>
    unordered_multiset<T,H,P,A>::unordered_multiset(
            InputIt f, InputIt l,
            size_type n,
            const hasher &hf,
            const key_equal &eql)
      : table_(boost::unordered::detail::initial_size(f, l, n),
            hf, eql, allocator_type())
    {
        table_.insert_range(f, l);
    }

    template <class T, class H, class P, class A>
    template <class InputIt>
    unordered_multiset<T,H,P,A>::unordered_multiset(
            InputIt f, InputIt l,
            size_type n,
            const hasher &hf,
            const key_equal &eql,
            const allocator_type &a)
      : table_(boost::unordered::detail::initial_size(f, l, n), hf, eql, a)
    {
        table_.insert_range(f, l);
    }

    template <class T, class H, class P, class A>
    unordered_multiset<T,H,P,A>::~unordered_multiset() {}

    template <class T, class H, class P, class A>
    unordered_multiset<T,H,P,A>::unordered_multiset(
            unordered_multiset const& other)
      : table_(other.table_)
    {
    }
# 1368 "/home/marek/devel/nupic/external/common/include/boost/unordered/unordered_set.hpp"
    template <class T, class H, class P, class A>
    std::size_t unordered_multiset<T,H,P,A>::max_size() const
    {
        return table_.max_size();
    }



    template <class T, class H, class P, class A>
    template <class InputIt>
    void unordered_multiset<T,H,P,A>::insert(InputIt first, InputIt last)
    {
        table_.insert_range(first, last);
    }
# 1392 "/home/marek/devel/nupic/external/common/include/boost/unordered/unordered_set.hpp"
    template <class T, class H, class P, class A>
    typename unordered_multiset<T,H,P,A>::iterator
        unordered_multiset<T,H,P,A>::erase(const_iterator position)
    {
        return table_.erase(position);
    }

    template <class T, class H, class P, class A>
    typename unordered_multiset<T,H,P,A>::size_type
        unordered_multiset<T,H,P,A>::erase(const key_type& k)
    {
        return table_.erase_key(k);
    }

    template <class T, class H, class P, class A>
    typename unordered_multiset<T,H,P,A>::iterator
        unordered_multiset<T,H,P,A>::erase(
                const_iterator first, const_iterator last)
    {
        return table_.erase_range(first, last);
    }

    template <class T, class H, class P, class A>
    void unordered_multiset<T,H,P,A>::clear()
    {
        table_.clear();
    }

    template <class T, class H, class P, class A>
    void unordered_multiset<T,H,P,A>::swap(unordered_multiset& other)
    {
        table_.swap(other.table_);
    }



    template <class T, class H, class P, class A>
    typename unordered_multiset<T,H,P,A>::hasher
        unordered_multiset<T,H,P,A>::hash_function() const
    {
        return table_.hash_function();
    }

    template <class T, class H, class P, class A>
    typename unordered_multiset<T,H,P,A>::key_equal
        unordered_multiset<T,H,P,A>::key_eq() const
    {
        return table_.key_eq();
    }



    template <class T, class H, class P, class A>
    typename unordered_multiset<T,H,P,A>::const_iterator
        unordered_multiset<T,H,P,A>::find(const key_type& k) const
    {
        return table_.find_node(k);
    }

    template <class T, class H, class P, class A>
    template <class CompatibleKey, class CompatibleHash,
        class CompatiblePredicate>
    typename unordered_multiset<T,H,P,A>::const_iterator
        unordered_multiset<T,H,P,A>::find(
            CompatibleKey const& k,
            CompatibleHash const& hash,
            CompatiblePredicate const& eq) const
    {
        return table_.generic_find_node(k, hash, eq);
    }

    template <class T, class H, class P, class A>
    typename unordered_multiset<T,H,P,A>::size_type
        unordered_multiset<T,H,P,A>::count(const key_type& k) const
    {
        return table_.count(k);
    }

    template <class T, class H, class P, class A>
    std::pair<
            typename unordered_multiset<T,H,P,A>::const_iterator,
            typename unordered_multiset<T,H,P,A>::const_iterator>
        unordered_multiset<T,H,P,A>::equal_range(const key_type& k) const
    {
        return table_.equal_range(k);
    }

    template <class T, class H, class P, class A>
    typename unordered_multiset<T,H,P,A>::size_type
        unordered_multiset<T,H,P,A>::bucket_size(size_type n) const
    {
        return table_.bucket_size(n);
    }



    template <class T, class H, class P, class A>
    float unordered_multiset<T,H,P,A>::load_factor() const
    {
        return table_.load_factor();
    }

    template <class T, class H, class P, class A>
    void unordered_multiset<T,H,P,A>::max_load_factor(float m)
    {
        table_.max_load_factor(m);
    }

    template <class T, class H, class P, class A>
    void unordered_multiset<T,H,P,A>::rehash(size_type n)
    {
        table_.rehash(n);
    }

    template <class T, class H, class P, class A>
    void unordered_multiset<T,H,P,A>::reserve(size_type n)
    {
        table_.reserve(n);
    }

    template <class T, class H, class P, class A>
    inline bool operator==(
            unordered_multiset<T,H,P,A> const& m1,
            unordered_multiset<T,H,P,A> const& m2)
    {



        return m1.table_.equals(m2.table_);
    }

    template <class T, class H, class P, class A>
    inline bool operator!=(
            unordered_multiset<T,H,P,A> const& m1,
            unordered_multiset<T,H,P,A> const& m2)
    {



        return !m1.table_.equals(m2.table_);
    }

    template <class T, class H, class P, class A>
    inline void swap(
            unordered_multiset<T,H,P,A> &m1,
            unordered_multiset<T,H,P,A> &m2)
    {



        m1.swap(m2);
    }
}
}
# 16 "/home/marek/devel/nupic/external/common/include/boost/unordered_set.hpp" 2
# 36 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp" 2


# 1 "/home/marek/devel/nupic/nta/ntypes/MemParser.hpp" 1
# 35 "/home/marek/devel/nupic/nta/ntypes/MemParser.hpp"
namespace nta {
# 57 "/home/marek/devel/nupic/nta/ntypes/MemParser.hpp"
class MemParser
{
public:
# 68 "/home/marek/devel/nupic/nta/ntypes/MemParser.hpp"
  MemParser(std::istream& in, UInt32 bytes=0);






  virtual ~MemParser();





  void get(unsigned long& val);





  void get(unsigned long long& val);





  void get(long& val);





  void get(double& val);





  void get(float& val);
# 119 "/home/marek/devel/nupic/nta/ntypes/MemParser.hpp"
  void get(std::string& val);





  friend MemParser& operator>>(MemParser& in, unsigned long& val)
  {
    in.get(val);
    return in;
  }

  friend MemParser& operator>>(MemParser& in, unsigned long long& val)
  {
    in.get(val);
    return in;
  }

  friend MemParser& operator>>(MemParser& in, long& val)
  {
    in.get(val);
    return in;
  }

  friend MemParser& operator>>(MemParser& in, unsigned int& val)
  {
    unsigned long lval;
    in.get(lval);
    val = lval;
    return in;
  }

  friend MemParser& operator>>(MemParser& in, int& val)
  {
    long lval;
    in.get(lval);
    val = lval;
    return in;
  }

  friend MemParser& operator>>(MemParser& in, double& val)
  {
    in.get(val);
    return in;
  }

  friend MemParser& operator>>(MemParser& in, float& val)
  {
    in.get(val);
    return in;
  }
# 179 "/home/marek/devel/nupic/nta/ntypes/MemParser.hpp"
  friend MemParser& operator>>(MemParser& in, std::string& val)
  {
    in.get(val);
    return in;
  }


private:
  std::string str_;
  const char* bufP_;
  UInt32 bytes_;

  const char* startP_;
  const char* endP_;

};



}
# 39 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp" 2
# 1 "/home/marek/devel/nupic/nta/ntypes/MemStream.hpp" 1
# 42 "/home/marek/devel/nupic/nta/ntypes/MemStream.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdio" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdio" 3
# 43 "/home/marek/devel/nupic/nta/ntypes/MemStream.hpp" 2



namespace nta {

void dbgbreak();
# 67 "/home/marek/devel/nupic/nta/ntypes/MemStream.hpp"
template<typename charT, typename traitsT, typename allocT>
class BasicIMemStreamBuf : public std::basic_streambuf<charT, traitsT>
{

public:
  BasicIMemStreamBuf (const charT* bufP, size_t bufSize)
  {
    setg ((charT*)bufP, (charT*)bufP, (charT*)bufP+bufSize);
    bufP_ = bufP;
    size_ = bufSize;
  }




  void str(const charT* bufP, size_t bufSize)
  {
    setg ((charT*)bufP, (charT*)bufP, (charT*)bufP+bufSize);
    bufP_ = bufP;
    size_ = bufSize;
  }






  const charT* str() {return bufP_;}






  size_t pcount() {return size_;}






  void setg(charT * p1, charT * p2, charT * p3) {std::basic_streambuf<charT, traitsT>::setg(p1,p2,p3);}
private:
  const charT* bufP_;
  size_t size_;

};
# 135 "/home/marek/devel/nupic/nta/ntypes/MemStream.hpp"
template<typename charT, typename traitsT, typename allocT>
class BasicOMemStreamBuf : public std::basic_streambuf<charT, traitsT>
{
public:
  typedef std::basic_string<charT, traitsT, allocT> stringType_;
  typedef typename traitsT::int_type int_type;

private:
  stringType_ data_;
  static const size_t growByMin_ = 512;

public:
  BasicOMemStreamBuf ()
  {
    data_.reserve (growByMin_);
    char* bufP = (char*)(data_.data());
    this->setp (bufP, bufP + data_.capacity());
  }

  virtual int_type overflow (int_type c)
  {
    size_t growBy;

    if (c == (-1)) return c;


    size_t curSize = pcount();


    growBy = curSize >> 3;
    if (growBy < growByMin_)
      growBy = growByMin_;





    stringType_ tmp;
    try {
      tmp.reserve (data_.capacity() + growBy);
    } catch (...) {
      throw nta::LoggingException("/home/marek/devel/nupic/nta/ntypes/MemStream.hpp", 176) << "MemStream::write() - request of " << data_.capacity() + growBy
                << " bytes (" << data_.capacity() + growBy
                << ") exceeds the maximum allowable memory block size.";

    }
    tmp.assign (data_.data(), curSize);
    data_.swap (tmp);

    char* bufP = (char*)(data_.data());
    this->setp (bufP, bufP + data_.capacity());


    this->pbump ((int)curSize);


    return this->sputc (c);
  }
# 202 "/home/marek/devel/nupic/nta/ntypes/MemStream.hpp"
  inline const charT* str() {return data_.data();}






  inline size_t pcount() {return this->pptr() - this->pbase(); }

};
# 235 "/home/marek/devel/nupic/nta/ntypes/MemStream.hpp"
template<typename charT, typename traitsT, typename allocT>
class BasicIMemStream : public std::basic_istream<charT, traitsT>
{
public:
  typedef BasicIMemStreamBuf<charT, traitsT, allocT> memStreamBufType_;

private:
  memStreamBufType_ streamBuf_;

public:
  BasicIMemStream(const charT* bufP=0, size_t bufSize=0) : std::istream(&streamBuf_),
     streamBuf_(bufP, bufSize)
  {
    this->rdbuf (&streamBuf_);
  }




  void str(const charT* bufP, size_t bufSize)
  {
    streamBuf_.str (bufP, bufSize);
  }






  const charT* str() {return streamBuf_.str();}






  size_t pcount() {return streamBuf_.pcount();}

};
# 294 "/home/marek/devel/nupic/nta/ntypes/MemStream.hpp"
template<typename charT, typename traitsT, typename allocT>
class BasicOMemStream : public std::basic_ostream<charT, traitsT>
{
public:
  typedef BasicOMemStreamBuf<charT, traitsT, allocT> memStreamBufType_;

private:
  memStreamBufType_ streamBuf_;

public:
  BasicOMemStream() : std::ostream(&streamBuf_),
     streamBuf_()
  {
    this->rdbuf (&streamBuf_);
  }





  void freeze (bool f) {}
# 324 "/home/marek/devel/nupic/nta/ntypes/MemStream.hpp"
  const charT* str() {return streamBuf_.str();}






  size_t pcount() {return streamBuf_.pcount();}

};





typedef BasicIMemStream<char,std::char_traits<char>,std::allocator<char> >
        IMemStream;
typedef BasicIMemStream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
        WIMemStream;

typedef BasicOMemStream<char,std::char_traits<char>,std::allocator<char> >
        OMemStream;
typedef BasicOMemStream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
        WOMemStream;


}
# 40 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp" 2







namespace nta {

  struct SparseMatrixAlgorithms;
# 113 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
  template <typename UI =nta::UInt32,
            typename Real_stor =nta::Real32,
            typename I =nta::Int32,
            typename Real_prec =nta::Real64,
            typename DTZ =nta::DistanceToZero<Real_stor> >
  class SparseMatrix
  {


    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::SignedIntegerConcept<I>)>::failed> boost_concept_check122;

  public:
    typedef UI size_type;
    typedef I difference_type;
    typedef Real_stor value_type;
    typedef Real_prec prec_value_type;

    typedef SparseMatrix<UI, Real_stor, I, Real_prec, DTZ> self_type;

    typedef const size_type* const_row_nz_index_iterator;
    typedef const value_type* const_row_nz_value_iterator;

    typedef size_type* row_nz_index_iterator;
    typedef value_type* row_nz_value_iterator;

    typedef ijv<size_type, value_type> IJV;

  protected:
    size_type nrows_;
    size_type nrows_max_;
    size_type ncols_;
    size_type *nnzr_;
    size_type *ind_mem_;
    value_type *nz_mem_;
    size_type **ind_;
    value_type **nz_;

    size_type *indb_;
    value_type *nzb_;
    IsNearlyZero<DTZ> isZero_;

    friend struct SparseMatrixAlgorithms;
# 197 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void assert_not_zero_value_(const value_type& val, const char* where) const
    {

      if (!isZero_(val)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 200) << "ASSERTION FAILED: \"" << "!isZero_(val)" << "\" "
        << "SparseMatrix " << where << ": Zero value should be != 0";

    }

    inline void assert_valid_row_(size_type row, const char* where) const
    {

      if (row >= 0 && row < nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 208) << "ASSERTION FAILED: \"" << "row >= 0 && row < nRows()" << "\" "
        << "SparseMatrix " << where
        << ": Invalid row index: " << row
        << " - Should be >= 0 and < " << nRows();

    }

    inline void assert_valid_col_(size_type col, const char* where) const
    {

      if (col >= 0 && col < nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 218) << "ASSERTION FAILED: \"" << "col >= 0 && col < nCols()" << "\" "
        << "SparseMatrix " << where
        << ": Invalid col index: " << col
        << " - Should be >= 0 and < " << nCols();

    }

    inline void assert_valid_row_col_(size_type row, size_type col,
                                      const char* where) const
    {

      assert_valid_row_(row, where);
      assert_valid_col_(col, where);

    }

    inline void assert_valid_row_ptr_(size_type row, size_type* ptr,
                                      const char* where) const
    {

      if (ind_begin_(row) <= ptr && ptr <= ind_end_(row)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 238) << "ASSERTION FAILED: \"" << "ind_begin_(row) <= ptr && ptr <= ind_end_(row)" << "\" "
        << "SparseMatrix " << where
        << ": Invalid row pointer";

    }

    inline void assert_valid_row_range_(size_type row_begin, size_type row_end,
                                        const char* where) const
    {

      assert_valid_row_(row_begin, where);
      if (row_begin < row_end)
        assert_valid_row_(row_end-1, where);
      if (row_begin <= row_end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 251) << "ASSERTION FAILED: \"" << "row_begin <= row_end" << "\" "
        << "SparseMatrix " << where
        << ": Invalid row range: [" << row_begin
        << ".." << row_end << "): "
        << "- Beginning should be <= end of range";

    }

    inline void assert_valid_col_range_(size_type col_begin, size_type col_end,
                                        const char* where) const
    {

      assert_valid_col_(col_begin, where);
      if (col_begin < col_end)
        assert_valid_col_(col_end-1, where);
      if (col_begin <= col_end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 266) << "ASSERTION FAILED: \"" << "col_begin <= col_end" << "\" "
        << "SparseMatrix " << where
        << ": Invalid col range: [" << col_begin
        << ".." << col_end << "): "
        << "- Beginning should be <= end of range";

    }

    inline void assert_valid_box_(size_type row_begin, size_type row_end,
                                  size_type col_begin, size_type col_end,
                                  const char* where) const
    {

      assert_valid_row_range_(row_begin, row_end, where);
      assert_valid_col_range_(col_begin, col_end, where);

    }

    template <typename It>
    inline void assert_valid_row_it_range_(It begin, It end, const char* where) const
    {


      ASSERT_VALID_RANGE(begin, end, where);
      while (begin != end) {
        assert_valid_row_(*begin, where);
        ++begin;
      }

    }

    template <typename It>
    inline void assert_valid_col_it_range_(It begin, It end, const char* where) const
    {


      ASSERT_VALID_RANGE(begin, end, where);
      while (begin != end) {
        assert_valid_col_(*begin, where);
        ++begin;
      }

    }

    template <typename InputIterator1>
    inline void
    assert_valid_sorted_index_range_(size_type m,
                                     InputIterator1 ind_it, InputIterator1 ind_end,
                                     const char* where) const
    {


      boost::function_requires<boost::InputIteratorConcept<InputIterator1> >();;

      if (ind_end - ind_it >= 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 320) << "ASSERTION FAILED: \"" << "ind_end - ind_it >= 0" << "\" "
        << "SparseMatrix " << where << ": Invalid iterators";

      for (size_type j = 0, prev = 0; ind_it != ind_end; ++ind_it, ++j) {

        size_type index = *ind_it;

        if (0 <= index && index < m) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 327) << "ASSERTION FAILED: \"" << "0 <= index && index < m" << "\" "
          << "SparseMatrix " << where
          << ": Invalid index: " << index
          << " - Should be >= 0 and < " << m;

        if (j > 0) {
          if (prev < index) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 333) << "ASSERTION FAILED: \"" << "prev < index" << "\" "
            << "SparseMatrix " << where
            << ": Indices need to be in strictly increasing order"
            << " without duplicates, found: " << prev
            << " and " << index;
        }

        prev = index;
      }

    }

    template <typename InputIterator1, typename InputIterator2>
    inline void
    assert_valid_ivp_range_(size_type m,
                            InputIterator1 ind_it, InputIterator1 ind_end,
                            InputIterator2 nz_it,
                            const char* where) const
    {



      boost::function_requires<boost::InputIteratorConcept<InputIterator1> >();;
      boost::function_requires<boost::InputIteratorConcept<InputIterator2> >();;

      if (ind_end - ind_it >= 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 358) << "ASSERTION FAILED: \"" << "ind_end - ind_it >= 0" << "\" "
        << "SparseMatrix " << where << ": Invalid iterators";

      for (size_type j = 0, prev = 0; ind_it != ind_end; ++ind_it, ++nz_it, ++j) {

        size_type index = *ind_it;

        if (0 <= index && index < m) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 365) << "ASSERTION FAILED: \"" << "0 <= index && index < m" << "\" "
          << "SparseMatrix " << where
          << ": Invalid index: " << index
          << " - Should be >= 0 and < " << m;

        if (!isZero_(*nz_it)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 370) << "ASSERTION FAILED: \"" << "!isZero_(*nz_it)" << "\" "
          << "SparseMatrix " << where
          << ": Passed zero at index: " << j
          << " - Should pass non-zeros only";

        if (j > 0) {
          if (prev < index) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 376) << "ASSERTION FAILED: \"" << "prev < index" << "\" "
            << "SparseMatrix " << where
            << ": Indices need to be in strictly increasing order"
            << " without duplicates, found: " << prev
            << " and " << index;
        }

        prev = index;
      }

    }






    inline void invariants() const
    {
      const char* where = "SparseMatrix::invariants: ";

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          if (!isZero_(*nz)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 399) << "ASSERTION FAILED: \"" << "!isZero_(*nz)" << "\" "
            << where
            << "Near zero value: " << *nz
            << " at (" << row << ", " << *ind << ") "
            << "nta::Epsilon= " << nta::Epsilon;
          if (row < nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 404) << "ASSERTION FAILED: \"" << "row < nRows()" << "\" "
            << where
            << "Invalid row index: " << row
            << " nRows= " << nRows();
          if (*ind < nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 408) << "ASSERTION FAILED: \"" << "*ind < nCols()" << "\" "
            << where
            << "Invalid col index: " << *ind
            << " nCols= " << nCols();
        }

        assert_valid_sorted_index_range_(nCols(), ind_begin_(row), ind_end_(row), where);
      }






    }
# 440 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void reAllocateBuffers_(size_type ncols)
    {
      {
        if (0 <= ncols) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 443) << "ASSERTION FAILED: \"" << "0 <= ncols" << "\" "
          << "SparseMatrix reAllocateBuffers_: "
          << "Bad ncols: " << ncols;
      }

      delete [] indb_;
      delete [] nzb_;

      indb_ = new size_type[ncols];
      nzb_ = new value_type[ncols];



    }
# 477 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void allocate_(size_type nrows_max, size_type ncols)
    {
      {
        if (0 <= nrows_max) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 480) << "ASSERTION FAILED: \"" << "0 <= nrows_max" << "\" "
          << "SparseMatrix allocate_: Bad nrows_max: " << nrows_max;
        if (0 <= ncols) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 482) << "ASSERTION FAILED: \"" << "0 <= ncols" << "\" "
          << "SparseMatrix allocate_: Bad ncols: " << ncols;
      }

      nrows_max_ = std::max<size_type>(8, nrows_max);

      nnzr_ = new size_type [nrows_max_];
      ind_ = new size_type* [nrows_max_];
      nz_ = new value_type* [nrows_max_];

      std::fill(nnzr_, nnzr_ + nrows_max_, (size_type)0);
      std::fill(ind_, ind_ + nrows_max_, (size_type*)0);
      std::fill(nz_, nz_ + nrows_max_, (value_type*)0);

      indb_ = new size_type [ncols];
      nzb_ = new value_type [ncols];
    }
# 517 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void deallocate_()
    {
      if (isCompact()) {


        delete [] ind_mem_;
        delete [] nz_mem_;

        ind_mem_ = 0;
        nz_mem_ = 0;

      } else {

        const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {

          delete [] ind_[row];
          delete [] nz_[row];

          ind_[row] = 0;
          nz_[row] = 0;
        }
      }

      delete [] ind_;
      ind_ = 0;
      delete [] nz_;
      nz_ = 0;
      delete [] nnzr_;
      nnzr_ = 0;
      delete [] indb_;
      indb_ = 0;
      delete [] nzb_;
      nzb_ = 0;

      nrows_ = ncols_ = nrows_max_ = 0;
    }
# 567 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void reserve_(size_type new_nrow)
    {
      {
        if (0 <= new_nrow) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 570) << "ASSERTION FAILED: \"" << "0 <= new_nrow" << "\" "
          << "SparseMatrix reserve_: Bad new number of rows: " << new_nrow;
      }

      if (new_nrow > nrows_max_-1) {

        nrows_max_ = std::max<size_type>(2 * nrows_max_, new_nrow);

        size_type *nnzr_new = new size_type[nrows_max_];
        size_type **ind_new = new size_type*[nrows_max_];
        value_type **nz_new = new value_type*[nrows_max_];

        std::copy(nnzr_, nnzr_ + nrows_, nnzr_new);
        std::copy(ind_, ind_ + nrows_, ind_new);
        std::copy(nz_, nz_ + nrows_, nz_new);

        std::fill(nnzr_new + nrows_, nnzr_new + nrows_max_, (size_type)0);
        std::fill(ind_new + nrows_, ind_new + nrows_max_, (size_type*)0);
        std::fill(nz_new + nrows_, nz_new + nrows_max_, (value_type*)0);

        delete [] nnzr_;
        delete [] ind_;
        delete [] nz_;

        nnzr_ = nnzr_new;
        ind_ = ind_new;
        nz_ = nz_new;
      }
    }
# 621 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator>
    inline void set_row_(size_type row, InputIterator nz_begin, InputIterator nz_end)
    {
      {
        boost::function_requires<boost::InputIteratorConcept<InputIterator> >();;

        assert_valid_row_(row, "set_row_");

        if (nz_begin <= nz_end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 629) << "ASSERTION FAILED: \"" << "nz_begin <= nz_end" << "\" "
          << "SparseMatrix set_row_: Invalid or empty input range";

        if ((size_type)(nz_end - nz_begin) <= nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 632) << "ASSERTION FAILED: \"" << "(size_type)(nz_end - nz_begin) <= nCols()" << "\" "
          << "SparseMatrix set_row_: Range too large, has: "
          << (size_type)(nz_end - nz_begin) << " elements "
          << " - Should be less than number of columns: " << nCols();
      }

      size_type *indb_it = indb_;
      InputIterator nz_it = nz_begin;
      value_type* nzb_it = nzb_;





      while (nz_it != nz_end) {
        value_type val = *nz_it;
        if (!isZero_(val)) {
          *indb_it = size_type(nz_it - nz_begin);
          *nzb_it = val;
          ++indb_it; ++nzb_it;
        }
        ++nz_it;
      }

      size_type nnzr = size_type(indb_it - indb_);

      if (nnzr > nnzr_[row]) {




        if (isCompact())
          decompact();

        delete [] ind_[row];
        delete [] nz_[row];

        ind_[row] = new size_type[nnzr];
        nz_[row] = new value_type[nnzr];
      }

      nnzr_[row] = nnzr;
      std::copy(indb_, indb_ + nnzr, ind_[row]);
      std::copy(nzb_, nzb_ + nnzr, nz_[row]);
    }
# 690 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void to_nzb_(size_type row)
    {
      {
        assert_valid_row_(row, "to_nzb_");
      }

      std::fill(nzb_, nzb_ + nCols(), (value_type)0);

      size_type *ind = ind_begin_(row), *ind_end = ind_end_(row);
      value_type *nz = nz_begin_(row);

      for (; ind != ind_end; ++ind, ++nz)
        *(nzb_ + *ind) = *nz;
    }
# 725 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void erase_(size_type row, size_type *ind_it)
    {
      {
        assert_valid_row_(row, "erase_");
        assert_valid_row_ptr_(row, ind_it, "erase_");
        if (nnzr_[row] > 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 730) << "ASSERTION FAILED: \"" << "nnzr_[row] > 0" << "\" "
          << "SparseMatrix erase_: Empty row #" << row;
      }

      value_type *nz_it = nz_begin_(row) + (ind_it - ind_begin_(row));

      std::copy(ind_it + 1, ind_end_(row), ind_it);
      std::copy(nz_it + 1, nz_end_(row), nz_it);

      -- nnzr_[row];
    }
# 751 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline size_type* ind_begin_(size_type row) const
    {
      {
        assert_valid_row_(row, "ind_begin_");
      }

      return ind_[row];
    }

    inline size_type* ind_end_(size_type row) const
    {
      {
        assert_valid_row_(row, "ind_end_");
      }

      return ind_[row] + nnzr_[row];
    }

    inline value_type* nz_begin_(size_type row) const
    {
      {
        assert_valid_row_(row, "nz_begin_");
      }

      return nz_[row];
    }

    inline value_type* nz_end_(size_type row) const
    {
      {
        assert_valid_row_(row, "nz_end_");
      }

      return nz_[row] + nnzr_[row];
    }

    inline size_type index_(size_type row, size_type offset) const
    {
      {
        assert_valid_row_(row, "index_");
        if (0 <= offset && offset < nnzr_[row]) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 791) << "ASSERTION FAILED: \"" << "0 <= offset && offset < nnzr_[row]" << "\" "
          << "SparseMatrix index_: "
          << "Invalid offset value: " << offset
          << " - Should be in [0.." << nnzr_[row] << ") "
          << "for row: " << row;
      }

      return ind_[row][offset];
    }

    inline value_type value_(size_type row, size_type offset) const
    {
      {
        assert_valid_row_(row, "value_");
        if (0 <= offset && offset < nnzr_[row]) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 805) << "ASSERTION FAILED: \"" << "0 <= offset && offset < nnzr_[row]" << "\" "
          << "SparseMatrix value_: "
          << "Invalid offset value: " << offset
          << " - Should be in [0.." << nnzr_[row] << ") "
          << "for row: " << row;
      }

      return nz_[row][offset];
    }
# 834 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline size_type* pos_(size_type row, size_type col) const
    {
      {
        assert_valid_row_col_(row, col, "pos_");
      }

      return std::lower_bound(ind_begin_(row), ind_end_(row), col);
    }
# 860 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline difference_type pos_(size_type row, size_type begin, size_type end,
                                size_type*& begin_ptr, size_type*& end_ptr) const
    {
      {
        assert_valid_row_(row, "pos_ 2");
        assert_valid_col_range_(begin, end, "pos_ 2");
      }

      size_type *b = ind_begin_(row), *e = ind_end_(row);

      begin_ptr = std::lower_bound(b, e, begin);
      end_ptr = end == nCols() ? e : std::lower_bound(begin_ptr, e, end);

      return (difference_type)(begin_ptr - b);
    }
# 893 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline difference_type col_(size_type row, size_type col) const
    {
      {
        assert_valid_row_col_(row, col, "col_");
      }

      const size_type *begin = ind_begin_(row), *end = ind_end_(row);
      const size_type *where = std::lower_bound(begin, end, col);

      if (where != end && *where == col)
        return difference_type(where - begin);
      else
        return difference_type(-1);
    }
# 929 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void insertNewNonZero_(size_type i, size_type j,
                                  size_type *hint, const value_type& val)
    {
      {
        assert_valid_row_col_(i, j, "insertNewNonZero_");
        assert_valid_row_ptr_(i, hint, "insertNewNonZero_");
        assert_not_zero_value_(val, "insertNewNonZero_");
        if (isZero_(get(i,j))) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 936) << "ASSERTION FAILED: \"" << "isZero_(get(i,j))" << "\" "
          << "SparseMatrix: Can't call insertNewNonZero_ when element "
          << "at that position is not a zero";
      }

      size_type *ind = ind_begin_(i), *ind_end = ind_end_(i), *indb = indb_;
      value_type* nz = nz_begin_(i), *nzb = nzb_;

      while (ind != hint) {
        *indb = *ind;
        *nzb = *nz;
        ++ind; ++nz;
        ++indb; ++nzb;
      }

      *indb = j;
      *nzb = val;
      ++indb; ++nzb;

      while (ind != ind_end) {
        *indb = *ind;
        *nzb = *nz;
        ++ind; ++nz;
        ++indb; ++nzb;
      }

      if (isCompact())
        decompact();

      delete [] ind_[i];
      delete [] nz_[i];

      nnzr_[i] += 1;
      ind_[i] = new size_type [nnzr_[i]];
      nz_[i] = new value_type [nnzr_[i]];
      std::copy(indb_, indb_ + nnzr_[i], ind_[i]);
      std::copy(nzb_, nzb_ + nnzr_[i], nz_[i]);
    }

  public:







    inline SparseMatrix()
      : nrows_(0), nrows_max_(0), ncols_(0),
        nnzr_(0), ind_mem_(0), nz_mem_(0),
        ind_(0), nz_(0),
        indb_(0), nzb_(0),
        isZero_()
    {
      allocate_(0,0);
    }
# 1006 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline SparseMatrix(size_type nrows, size_type ncols)
      : nrows_(0), nrows_max_(0), ncols_(0),
        nnzr_(0), ind_mem_(0), nz_mem_(0),
        ind_(0), nz_(0),
        indb_(0), nzb_(0),
        isZero_()
    {
      {
        if (nrows >= 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 1014) << "CHECK FAILED: \"" << "nrows >= 0" << "\" "
          << "SparseMatrix::SparseMatrix(nrows, ncols): "
          << "Invalid number of rows: " << nrows
          << " - Should be >= 0";

        if (ncols >= 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 1019) << "CHECK FAILED: \"" << "ncols >= 0" << "\" "
          << "SparseMatrix::SparseMatrix(nrows, ncols): "
          << "Invalid number of columns: " << ncols
          << " - Should be >= 0";
      }

      allocate_(nrows, ncols);
      nrows_ = nrows;
      ncols_ = ncols;
    }
# 1049 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator>
    inline SparseMatrix(size_type nrows, size_type ncols, InputIterator dense)
      : nrows_(0), nrows_max_(0), ncols_(0),
        nnzr_(0), ind_mem_(0), nz_mem_(0),
        ind_(0), nz_(0),
        indb_(0), nzb_(0),
        isZero_()
    {
      {
        boost::function_requires<boost::InputIteratorConcept<InputIterator> >();;

        if (nrows >= 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 1060) << "CHECK FAILED: \"" << "nrows >= 0" << "\" "
          << "SparseMatrix::SparseMatrix(nrows, ncols, dense): "
          << "Invalid number of rows: " << nrows
          << " - Should be >= 0";

        if (ncols >= 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 1065) << "CHECK FAILED: \"" << "ncols >= 0" << "\" "
          << "SparseMatrix::SparseMatrix(nrows, ncols, dense): "
          << "Invalid number of columns: " << ncols
          << " - Should be >= 0";
      }

      fromDense(nrows, ncols, dense);
    }
# 1087 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline SparseMatrix(std::istream& inStream)
      : nrows_(0), nrows_max_(0), ncols_(0),
        nnzr_(0), ind_mem_(0), nz_mem_(0),
        ind_(0), nz_(0),
        indb_(0), nzb_(0),
        isZero_()
    {
      fromCSR(inStream);
    }
# 1111 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline SparseMatrix(const SparseMatrix& other)
      : nrows_(0), nrows_max_(0), ncols_(0),
        nnzr_(0), ind_mem_(0), nz_mem_(0),
        ind_(0), nz_(0),
        indb_(0), nzb_(0),
        isZero_()
    {
      copy(other);
    }
# 1129 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator>
    inline SparseMatrix(const SparseMatrix& other,
                        InputIterator take, InputIterator take_end,
                        int rowCol =1)
      : nrows_(0), nrows_max_(0), ncols_(0),
        nnzr_(0), ind_mem_(0), nz_mem_(0),
        ind_(0), nz_(0),
        indb_(0), nzb_(0),
        isZero_()
    {
      {
        if (rowCol == 0 || rowCol == 1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 1140) << "ASSERTION FAILED: \"" << "rowCol == 0 || rowCol == 1" << "\" "
          << "SparseMatrix: constructor from set of rows/cols: "
          << "Invalid flag: " << rowCol
          << " - Should be 0 for rows, or 1 for cols";
      }

      if (rowCol == 0)
        initializeWithRows(other, take, take_end);
      else if (rowCol == 1)
        initializeWithCols(other, take, take_end);
    }
# 1160 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator>
    inline void initializeWithRows(const SparseMatrix& other,
                                   InputIterator take, InputIterator take_end)
    {
      {
        if ((size_type)(take_end - take) == other.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 1165) << "ASSERTION FAILED: \"" << "(size_type)(take_end - take) == other.nRows()" << "\" "
          << "SparseMatrix::initializeWithRows: "
          << "Wrong size for vector of indices";
      }

      deallocate_();
      allocate_(other.nRows(), other.nCols());
      nrows_ = other.nRows();
      ncols_ = other.nCols();

      for (size_type row = 0; take != take_end; ++take, ++row) {
        if (*take == 1) {
          nnzr_[row] = other.nnzr_[row];
          ind_[row] = new size_type [nnzr_[row]];
          nz_[row] = new value_type [nnzr_[row]];
          std::copy(other.ind_begin_(row), other.ind_end_(row), ind_[row]);
          std::copy(other.nz_begin_(row), other.nz_end_(row), nz_[row]);
        }
      }
    }
# 1194 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator>
    inline void initializeWithCols(const SparseMatrix& other,
                                   InputIterator take, InputIterator take_end)
    {
      {
        if ((size_type)(take_end - take) == other.nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 1199) << "ASSERTION FAILED: \"" << "(size_type)(take_end - take) == other.nCols()" << "\" "
          << "SparseMatrix::initializeWithRows: "
          << "Wrong size for vector of indices";
      }

      deallocate_();
      allocate_(other.nRows(), other.nCols());
      nrows_ = other.nRows();
      ncols_ = other.nCols();

      for (size_type row = 0; row != nRows(); ++row) {
        size_type *o_ind = other.ind_begin_(row);
        size_type *o_ind_end = other.ind_end_(row);
        value_type *o_nz = other.nz_begin_(row);
        size_type *s_ind = other.indb_;
        value_type *s_nz = other.nzb_;
        for (; o_ind != o_ind_end; ++o_ind, ++o_nz) {
          if (take[*o_ind] == 1) {
            *s_ind++ = *o_ind;
            *s_nz++ = *o_nz;
          }
        }
        nnzr_[row] = (size_type)(s_ind - other.indb_);
        ind_[row] = new size_type [nnzr_[row]];
        nz_[row] = new value_type [nnzr_[row]];
        std::copy(other.indb_, other.indb_ + nnzr_[row], ind_[row]);
        std::copy(other.nzb_, other.nzb_ + nnzr_[row], nz_[row]);
      }
    }







    inline void
    initializeWithFixedNNZR(size_type nnzr, value_type v =1,
                            size_type mode =0, size_type seed =42)
    {
      {
        if (nnzr <= nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 1240) << "ASSERTION FAILED: \"" << "nnzr <= nCols()" << "\" ";
      }

      nta::Random rng(seed);

      size_type nrows = nRows(), ncols = nCols();

      deallocate_();
      allocate_(nrows, ncols);
      nrows_ = nrows;
      ncols_ = ncols;

      std::vector<size_type> col_ind(ncols);

      for (size_type c = 0; c != ncols; ++c)
        col_ind[c] = c;

      for (size_type r = 0; r != nrows; ++r) {

        std::random_shuffle(col_ind.begin(), col_ind.end(), rng);
        std::sort(col_ind.begin(), col_ind.begin() + nnzr);
        nnzr_[r] = nnzr;
        ind_[r] = new size_type [nnzr];
        std::copy(col_ind.begin(), col_ind.begin() + nnzr, ind_[r]);
        nz_[r] = new value_type [nnzr];
        std::fill(nz_[r], nz_[r] + nnzr, (value_type) v);
      }
    }
# 1283 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline SparseMatrix& operator=(const SparseMatrix& other)
    {
      if (this != &other)
        copy(other);
      return *this;
    }
# 1304 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename UI2, typename R2, typename I2, typename RP2, typename DTZ2>
    inline void copy(const SparseMatrix<UI2,R2,I2,RP2,DTZ2>& other)
    {
      deallocate_();
      allocate_(2*other.nRows(), other.nCols());
      nrows_ = other.nRows();
      ncols_ = other.nCols();

      size_type nnz = other.nNonZeros();
      ind_mem_ = new size_type[nnz];
      nz_mem_ = new value_type[nnz];
      size_type *indp = ind_mem_;
      value_type *nzp = nz_mem_;

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        nnz = other.nNonZerosOnRow(row);
        nnzr_[row] = nnz;
        ind_[row] = indp;
        nz_[row] = nzp;
        std::copy(other.row_nz_index_begin(row), other.row_nz_index_end(row), indp);
        std::copy(other.row_nz_value_begin(row), other.row_nz_value_end(row), nzp);
        indp += nnz;
        nzp += nnz;
      }
    }
# 1342 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline ~SparseMatrix()
    {
      deallocate_();
    }
# 1362 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline bool isZero() const { return nNonZeros() == 0; }
# 1374 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline const IsNearlyZero<DTZ>& getIsNearlyZeroFunction() const
    {
      return isZero_;
    }
# 1398 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline bool isCompact() const { return ind_mem_ != 0; }
# 1412 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline size_type nRows() const { return nrows_; }
# 1426 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline size_type nCols() const { return ncols_; }





    inline size_type nBytes() const
    {
      size_type n =
        7 * sizeof(size_type)
        + 3 * sizeof(value_type)
        + nCols() * (sizeof(size_type) + sizeof(value_type));

      for (size_type i = 0; i != nRows(); ++i)
        n += (nNonZerosOnRow(i) + 2) * (sizeof(size_type) + sizeof(value_type));

      return n;
    }
# 1459 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline size_type nNonZerosOnRow(size_type row) const
    {
      {
        assert_valid_row_(row, "nNonZerosOnRow");
      }

      size_type nnzr = nnzr_[row];

      {
        if (0 <= nnzr && nnzr <= nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 1468) << "ASSERTION FAILED: \"" << "0 <= nnzr && nnzr <= nCols()" << "\" "
          << "SparseMatrix nNonZerosOnRow: "
          << "post-condition: nnzr = " << nnzr
          << " when ncols = " << nCols();
      }

      return nnzr;
    }
# 1491 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline size_type nNonZerosOnCol(size_type col) const
    {
      {
        assert_valid_col_(col, "nNonZerosOnCol");
      }

      size_type nnzc = 0;

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row)
        if (col_(row, col) >= 0)
          ++nnzc;

      {
        if (0 <= nnzc && nnzc <= nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 1504) << "ASSERTION FAILED: \"" << "0 <= nnzc && nnzc <= nRows()" << "\" "
          << "SparseMatrix nNonZerosOnCol: "
          << "post-condition: nnzc = " << nnzc
          << " when nrows = " << nRows();
      }

      return nnzc;
    }
# 1525 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline size_type nNonZeros() const
    {
      size_type nnz = 0;

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row)
        nnz += nNonZerosOnRow(row);

      {
        if (0 <= nnz && nnz <= nRows() * nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 1533) << "ASSERTION FAILED: \"" << "0 <= nnz && nnz <= nRows() * nCols()" << "\" "
          << "SparseMatrix nNonZeros: "
          << "post-condition: Invalid nnz = " << nnz
          << " when nrows = " << nRows()
          << " and ncols = " << nCols();
      }

      return nnz;
    }
# 1557 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename OutputIterator>
    inline void nNonZerosPerRow(OutputIterator it) const
    {
      {
        boost::function_requires<boost::OutputIteratorConcept<OutputIterator, size_type> >();;
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        *it = nNonZerosOnRow(row);
        ++it;
      }
    }
# 1584 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename OutputIterator>
    inline void nNonZerosPerCol(OutputIterator it) const
    {
      {
        boost::function_requires<boost::OutputIteratorConcept<OutputIterator, size_type> >();;
      }

      std::fill(it, it + nCols(), 0);

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *ind = ind_begin_(row), *end = ind_end_(row);
        while (ind != end)
          ++ *(it + *ind++);
      }
    }
# 1613 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline bool isRowZero(size_type row) const
    {
      {
        assert_valid_row_(row, "isRowZero");
      }

      return nNonZerosOnRow(row) == 0;
    }
# 1635 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline bool isColZero(size_type col) const
    {
      {
        assert_valid_col_(col, "isColZero");
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row)
        if (col_(row, col) >= 0)
          return false;

      return true;
    }
# 1661 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline size_type nNonZeroRows() const
    {
      size_type count = 0;

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row)
        if (nnzr_[row] > 0)
          ++ count;

      return count;
    }
# 1685 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline size_type nNonZeroCols() const
    {
      const size_type ncols = nCols();

      size_type count = 0;

      for (size_type col = 0; col != ncols; ++col)
        if (!isColZero(col))
          ++ count;

      return count;
    }
# 1711 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline size_type nZeroRows() const
    {
      return nRows() - nNonZeroRows();
    }
# 1729 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline size_type nZeroCols() const
    {
      return nCols() - nNonZeroCols();
    }
# 1748 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline std::pair<size_type, value_type> firstNonZeroOnRow(size_type row) const
    {
      {
        assert_valid_row_(row, "firstNonZeroOnRow");
      }

      if (isRowZero(row))
        return std::make_pair(nRows(), 0);

      return std::make_pair(ind_[row][0], nz_[row][0]);
    }
# 1774 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline std::pair<size_type, value_type> lastNonZeroOnRow(size_type row) const
    {
      {
        assert_valid_row_(row, "lastNonZeroOnRow");
      }

      if (isRowZero(row))
        return std::make_pair(nRows(), 0);

      const size_type idx = nnzr_[row] - 1;

      return std::make_pair(ind_[row][idx], nz_[row][idx]);
    }
# 1802 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline size_type rowBandwidth(size_type row) const
    {
      {
        assert_valid_row_(row, "rowBandwidth");
      }

      if (isRowZero(row))
        return 0;

      if (nNonZerosOnRow(row) == 1)
        return 1;

      return ind_[row][nnzr_[row] - 1] - ind_[row][0];
    }
# 1831 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename OutputIterator>
    inline void rowBandwidths(OutputIterator it) const
    {
      {
        boost::function_requires<boost::OutputIteratorConcept<OutputIterator, size_type> >();;
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        *it = rowBandwidth(row);
        ++it;
      }
    }
# 1858 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline std::pair<size_type, value_type> firstNonZeroOnCol(size_type col) const
    {
      {
        assert_valid_col_(col, "firstNonZeroOnCol");
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *j = pos_(row, col);
        if (j != ind_end_(row) && *j == col)
          return std::make_pair(row, nz_[row][j - ind_begin_(row)]);
      }

      return std::make_pair(nCols(), 0);
    }
# 1887 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline std::pair<size_type, value_type> lastNonZeroOnCol(size_type col) const
    {
      {
        assert_valid_col_(col, "lastNonZeroOnCol");
      }

      for (int row = (int) nRows() - 1; row != -1; --row) {
        size_type *j = pos_(row, col);
        if (j != ind_end_(row) && *j == col)
          return std::make_pair((size_type) row, nz_[row][j - ind_begin_(row)]);
      }

      return std::make_pair(nCols(), 0);
    }
# 1917 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline size_type colBandwidth(size_type col) const
    {
      {
        assert_valid_col_(col, "colBandwidth");
      }

      int first = -1, last = -1;

      const int nrows(nRows());

      for (int row = 0; row != nrows && first == -1; ++row) {
        size_type *j = pos_(row, col);
        if (j != ind_end_(row) && *j == col) {
          first = row;
        }
      }

      if (first == -1)
        return size_type(0);

      for (int row = nrows - 1; row != -1 && last == -1; --row) {
        size_type *j = pos_(row, col);
        if (j != ind_end_(row) && *j == col) {
          last = row;
        }
      }

      if (first == last)
        return size_type(1);

      return size_type(last - first);
    }
# 1964 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename OutputIterator>
    inline void colBandwidths(OutputIterator it) const
    {
      {
        boost::function_requires<boost::OutputIteratorConcept<OutputIterator, size_type> >();;
      }

      const size_type ncols = nCols();
      for (size_type col = 0; col != ncols; ++col, ++it)
        *it = colBandwidth(col);
    }






    inline bool
    nonZerosInRowRange(size_type row, size_type col_begin, size_type col_end) const
    {
      {
        assert_valid_row_(row, "intersectsRowRange");
        assert_valid_col_range_(col_begin, col_end, "intersectsRowRange");
      }

      if (nNonZerosOnRow(row) == 0)
        return false;

      if (col_begin > ind_[row][nnzr_[row]-1] || col_end < ind_[row][0])
        return false;

      return true;
    }





    inline
    size_type
    nNonZerosInRowRange(size_type row, size_type col_begin, size_type col_end) const
    {
      {
        assert_valid_row_(row, "nNonZerosInRowRange");
        assert_valid_col_range_(col_begin, col_end, "nNonZerosInRowRange");
      }

      if (!nonZerosInRowRange(row, col_begin, col_end))
        return 0;

      size_type *c1 = pos_(row, col_begin);
      size_type *c2 = col_end == nCols() ? ind_end_(row)
        : std::lower_bound(c1, ind_end_(row), col_end);

      return (size_type) (c2 - c1);
    }
# 2043 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline
    size_type nNonZerosInBox(size_type row_begin, size_type row_end,
                             size_type col_begin, size_type col_end) const
    {
      {
        assert_valid_row_range_(row_begin, row_end, "nNonZerosInBox");
        assert_valid_col_range_(col_begin, col_end, "nNonZerosInBox");
      }

      size_type count = 0;

      for (size_type row = row_begin; row != row_end; ++row)
        count += nNonZerosInRowRange(row, col_begin, col_end);

      return count;
    }
# 2087 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator, typename Summary>
    inline void
    nNonZerosPerBox(InputIterator row_inds_begin, InputIterator row_inds_end,
                    InputIterator col_inds_begin, InputIterator col_inds_end,
                    Summary& summary) const
    {
      {
        boost::function_requires<boost::InputIteratorConcept<InputIterator> >();;
        ASSERT_VALID_RANGE(row_inds_begin, row_inds_end, "SparseMatrix nNonZerosPerBox");
        ASSERT_VALID_RANGE(col_inds_begin, col_inds_end, "SparseMatrix nNonZerosPerBox");

      }

      size_type n_i = (size_type)(row_inds_end - row_inds_begin);
      size_type n_j = (size_type)(col_inds_end - col_inds_begin);
      summary.resize(n_i, n_j);

      size_type box_i = 0, prev_row = 0;
      for (InputIterator row = row_inds_begin; row != row_inds_end; ++row, ++box_i) {
        size_type prev_col = 0, box_j = 0;
        for (InputIterator col = col_inds_begin; col != col_inds_end; ++col, ++box_j) {
          value_type nnzib = (value_type) nNonZerosInBox(prev_row, *row, prev_col, *col);
          summary.set(box_i, box_j, nnzib);
          prev_col = *col;
        }
        prev_row = *row;
      }
    }
# 2128 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline bool isSymmetric() const
    {
      if (nRows() != nCols())
        return false;

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *ind = ind_begin_(row);
        size_type *ind_end = ind_end_(row);
        value_type *nz = nz_begin_(row);
        for (; ind != ind_end && *ind < row; ++ind, ++nz)
          if (get(*ind, row) != *nz)
            return false;
      }

      return true;
    }






    inline bool isBinary() const
    {
      value_type nnz0 = 0;

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          if (nnz0 == 0)
            nnz0 = *nz;
          else if (*nz != nnz0)
            return false;
        }
      }

      return true;
    }
# 2179 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename OutputIterator>
    inline void nonZeroRows(OutputIterator it) const
    {
      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row)
        if (!this->isRowZero(row))
          *it++ = row;
    }
# 2200 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename OutputIterator>
    inline void zeroRows(OutputIterator it) const
    {
      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row)
        if (this->isRowZero(row))
          *it++ = row;
    }
# 2221 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename OutputIterator>
    inline void nonZeroCols(OutputIterator it) const
    {
      const size_type ncols = nCols(); for (size_type col = 0; col != ncols; ++col)
        if (!this->isColZero(col))
          *it++ = col;
    }
# 2242 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename OutputIterator>
    inline void zeroCols(OutputIterator it) const
    {
      const size_type ncols = nCols(); for (size_type col = 0; col != ncols; ++col)
        if (this->isColZero(col))
          *it++ = col;
    }
# 2265 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename OutputIterator>
    inline void zeroRowCol(OutputIterator it) const
    {
      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        if (isRowZero(row)) {
          if (row < nCols() && isColZero(row))
            *it++ = row;
        }
      }
    }







    template <typename OutputIterator>
    inline size_type zeroRowAndCol(OutputIterator it) const
    {
      {
        if (nRows() == nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2286) << "ASSERTION FAILED: \"" << "nRows() == nCols()" << "\" "
          << "SparseMatrix zeroRowAndCol: Matrix needs to be square";
      }

      size_type count = 0;

      for (size_type i = 0; i != nRows(); ++i)
        if (isRowZero(i))
          if (isColZero(i)) {
            *it++ = i;
            ++count;
          }

      return count;
    }
# 2325 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline bool equals(const SparseMatrix& B) const
    {
      if (B.nRows() != nRows())
        return false;
      if (B.nCols() != nCols())
        return false;
      if (B.nNonZeros() != nNonZeros())
        return false;

      for (size_type i = 0; i != nRows(); ++i) {

        if (nnzr_[i] != B.nnzr_[i])
          return false;

        size_type *ind = ind_[i], *ind_end = ind + nnzr_[i];
        size_type *ind_b = B.ind_[i];
        value_type *nz = nz_[i], *nz_b = B.nz_[i];

        while (ind != ind_end) {
          if (*ind != *ind_b)
            return false;
          if (*nz != *nz_b)
            return false;
          ++ind; ++ind_b;
          ++nz; ++nz_b;
        }
      }

      return true;
    }






    inline bool sameRowNonZeroIndices(size_type row, const SparseMatrix& B) const
    {
      {
        if (0 <= row && row < nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2364) << "ASSERTION FAILED: \"" << "0 <= row && row < nRows()" << "\" "
          << "SparseMatrix::sameRowNonZeroIndices: "
          << "Invalid row index: " << row
          << " - SparseMatrix has only: " << nRows() << " rows";

        if (0 <= row && row < B.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2369) << "ASSERTION FAILED: \"" << "0 <= row && row < B.nRows()" << "\" "
          << "SparseMatrix::sameRowNonZeroIndices: "
          << "Invalid row index: " << row
          << " - B matrix has only: " << nRows() << " rows";
      }

      if (nNonZerosOnRow(row) != B.nNonZerosOnRow(row))
        return false;

      size_type *ind = ind_[row], *ind_end = ind + nnzr_[row];
      size_type *ind_b = B.ind_[row];

      for (; ind != ind_end; ++ind, ++ind_b)
        if (*ind != *ind_b)
          return false;

      return true;
    }





    inline bool sameNonZeroIndices(const SparseMatrix& B) const
    {
      {
        if (nRows() <= B.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2395) << "ASSERTION FAILED: \"" << "nRows() <= B.nRows()" << "\" ";
        if (nCols() <= B.nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2396) << "ASSERTION FAILED: \"" << "nCols() <= B.nCols()" << "\" ";
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row)
        if (!sameRowNonZeroIndices(row, B))
          return false;

      return true;
    }
# 2414 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline bool nonZeroIndicesIncluded(size_type row, const SparseMatrix& B) const
    {
      {
        if (0 <= row && row < nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2417) << "ASSERTION FAILED: \"" << "0 <= row && row < nRows()" << "\" "
          << "SparseMatrix::sameRowNonZeroIndices: "
          << "Invalid row index: " << row
          << " - SparseMatrix has only: " << nRows() << " rows";

        if (0 <= row && row < B.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2422) << "ASSERTION FAILED: \"" << "0 <= row && row < B.nRows()" << "\" "
          << "SparseMatrix::sameRowNonZeroIndices: "
          << "Invalid row index: " << row
          << " - B matrix has only: " << nRows() << " rows";
      }

      if (nNonZerosOnRow(row) > B.nNonZerosOnRow(row))
        return false;

      size_type *ind = ind_begin_(row), *ind_end = ind_end_(row);
      size_type *ind_b = B.ind_begin_(row);

      size_type n = 0;

      while (ind != ind_end) {
        if (*ind == *ind_b) {
          ++n;
          ++ind; ++ind_b;
        } else if (*ind < *ind_b) {
          return false;
        } else if (*ind_b < *ind) {
          ++ind_b;
        }
      }

      return n == nNonZerosOnRow(row);
    }






    inline bool nonZeroIndicesIncluded(const SparseMatrix& B) const
    {
      {
        if (nRows() <= B.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2458) << "ASSERTION FAILED: \"" << "nRows() <= B.nRows()" << "\" ";
        if (nCols() <= B.nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2459) << "ASSERTION FAILED: \"" << "nCols() <= B.nCols()" << "\" ";
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row)
        if (!nonZeroIndicesIncluded(row, B))
          return false;

      return true;
    }
# 2487 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void compact()
    {
      if (isCompact())
        return;

      size_type nnz = nNonZeros();

      ind_mem_ = new size_type[nnz];
      size_type *indp = ind_mem_;

      nz_mem_ = new value_type[nnz];
      value_type *nzp = nz_mem_;

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {

        nnz = nnzr_[row];
        std::copy(ind_[row], ind_[row] + nnz, indp);
        std::copy(nz_[row], nz_[row] + nnz, nzp);

        delete [] ind_[row];
        delete [] nz_[row];

        ind_[row] = indp;
        nz_[row] = nzp;
        indp += nnz;
        nzp += nnz;
      }
    }
# 2532 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void decompact()
    {
      if (!isCompact())
        return;

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type nnzr = nnzr_[row];
        if (nnzr > 0) {
          size_type* new_ind = new size_type[nnzr];
          value_type* new_nz = new value_type[nnzr];
          std::copy(ind_[row], ind_[row] + nnzr, new_ind);
          std::copy(nz_[row], nz_[row] + nnzr, new_nz);
          ind_[row] = new_ind;
          nz_[row] = new_nz;
        } else {
          ind_[row] = 0;
          nz_[row] = 0;
        }
      }

      delete [] ind_mem_;
      delete [] nz_mem_;
      ind_mem_ = 0;
      nz_mem_ = 0;
    }
# 2579 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator>
    inline void fromDense(size_type nrows, size_type ncols, InputIterator dense)
    {
      {
        boost::function_requires<boost::InputIteratorConcept<InputIterator> >();;

        if (nrows >= 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2585) << "CHECK FAILED: \"" << "nrows >= 0" << "\" "
          << "SparseMatrix::fromDense(): "
          << "Invalid number of rows: " << nrows
          << " - Should be >= 0";

        if (ncols >= 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2590) << "CHECK FAILED: \"" << "ncols >= 0" << "\" "
          << "SparseMatrix::fromDense(): "
          << "Invalid number of columns: " << ncols
          << " - Should be > 0";
      }

      deallocate_();
      allocate_(nrows, ncols);
      nrows_ = 0;
      ncols_ = ncols;

      for (size_type i = 0; i != nrows; ++i, dense += ncols)
        addRow(dense);
    }
# 2617 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename OutputIterator>
    inline void toDense(OutputIterator dense) const
    {
      {
        boost::function_requires<boost::OutputIteratorConcept<OutputIterator, value_type> >();;
      }

      const size_type ncols = nCols();

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row)
        getRowToDense(row, dense + row*ncols);
    }





    inline size_type CSRSize() const
    {
      char buffer[64];

      size_type n =
        sprintf(buffer, "sm_csr_1.5 %lu %lu %lu ",
                (unsigned long) nRows(),
                (unsigned long) nCols(),
                (unsigned long) nNonZeros());

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        n += sprintf(buffer, "%lu ", (unsigned long) nNonZerosOnRow(row));
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          n += sprintf(buffer, "%lu ", (unsigned long) *ind);
          n += sprintf(buffer, "%.15g ", *nz);
        }
      }

      n += sprintf(buffer, "%lu ", (unsigned long) n - 5);

      return n;
    }
# 2698 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline std::istream&
    fromCSR(std::istream& inStreamParam, bool zero_permissive=false)
    {
      const char* where = "SparseMatrix::fromCSR(): ";

      {
        if (inStreamParam.good()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2704) << "CHECK FAILED: \"" << "inStreamParam.good()" << "\" "
          << where << "Bad stream";
      }

      std::string tag;
      inStreamParam >> tag;
      if (tag == "csr" || tag == "sm_csr_1.5") {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2710) << "CHECK FAILED: \"" << "tag == \"csr\" || tag == \"sm_csr_1.5\"" << "\" "
        << where
        << "Stream is not in csr format"
        << " - Should start with 'csr' or 'sm_csr_1.5' tag";


      long totalBytes;
      inStreamParam >> totalBytes;
      if (totalBytes < 0)
        totalBytes = 0;
# 2796 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
      MemParser inStream(inStreamParam, totalBytes);

      size_type i, j, k, nrows, ncols, nnz, nnzr;
      nta::Real64 val;

      inStream >> nrows >> ncols >> nnz;

      {
        if (nrows >= 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2804) << "CHECK FAILED: \"" << "nrows >= 0" << "\" "
          << where
          << "Invalid number of rows: " << nrows
          << " - Should be >= 0";

        if (ncols >= 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2809) << "CHECK FAILED: \"" << "ncols >= 0" << "\" "
          << where
          << "Invalid number of columns: " << ncols
          << " - Should be > 0";

        if (nnz >= 0 && (double) nnz <= (double) nrows * ncols) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2814) << "CHECK FAILED: \"" << "nnz >= 0 && (double) nnz <= (double) nrows * ncols" << "\" "
          << where
          << "Invalid number of non-zeros: " << nnz
          << " - Should be >= 0 && nrows * ncols = " << (double) nrows * ncols;
      }

      deallocate_();
      allocate_(nrows, ncols);
      nrows_ = 0;
      ncols_ = ncols;

      for (i = 0; i != nrows; ++i) {

        inStream >> nnzr;

        {
          if (nnzr >= 0 && nnzr <= ncols) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2830) << "CHECK FAILED: \"" << "nnzr >= 0 && nnzr <= ncols" << "\" "
            << where
            << "Invalid number of non-zeros: " << nnzr
            << " - Should be >= 0 && < ncols = " << ncols;
        }

        size_type* indb_it = indb_;
        value_type* nzb_it = nzb_;

        for (k = 0; k != nnzr; ++k) {

          inStream >> j >> val;

          value_type vval = (value_type) val;

          {
            if (j >= 0 && j < ncols) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2846) << "CHECK FAILED: \"" << "j >= 0 && j < ncols" << "\" "
              << where
              << "Invalid index: " << j
              << " - Should be >= 0 and < ncols = " << ncols;
          }

          if (zero_permissive) {
            *indb_it++ = j;
            *nzb_it++ = vval;
          } else {
            if (!isZero_(vval)) {
              *indb_it++ = j;
              *nzb_it++ = vval;
            }
          }
        }



        addRow(indb_, indb_it, nzb_, zero_permissive);
      }


      return inStreamParam;
    }
# 2898 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline std::ostream& toCSR(std::ostream& out) const
    {
      {
        if (out.good()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2901) << "CHECK FAILED: \"" << "out.good()" << "\" "
          << "SparseMatrix::toCSR(): Bad stream";
      }

      out << "sm_csr_1.5 ";

      OMemStream buf;
      buf << std::setprecision(15);
      buf << nRows() << ' '
          << nCols() << ' '
          << nNonZeros() << ' ';

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        buf << nnzr_[row] << ' ';
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          buf << *ind << ' ' << *nz << ' ';
        }
      }




      out << buf.pcount() << ' ';
      out.write(buf.str(), UInt(buf.pcount()));
      return out;
    }
# 2937 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void fromBinary(std::istream& inStream)
    {





      {
        if (inStream.good()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2945) << "CHECK FAILED: \"" << "inStream.good()" << "\" "
          << "SparseMatrix::fromBinary: Bad stream";
      }

      const char* where = "SparseMatrix::fromBinary ";

      std::string version;
      inStream >> version;

      if (version == "sm_bin_1.5") {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2954) << "CHECK FAILED: \"" << "version == \"sm_bin_1.5\"" << "\" "
        << "SparseMatrix::fromBinary: Bad version: " << version;

      int littleEndian;
      size_type s1, s2, s3, s4;
      inStream >> littleEndian >> s1 >> s2 >> s3 >> s4;

      {
        if (s1 == sizeof(size_type)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2962) << "CHECK FAILED: \"" << "s1 == sizeof(size_type)" << "\" "
          << where << "Bad size_type: " << s1;

        if (s2 == sizeof(value_type)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2965) << "CHECK FAILED: \"" << "s2 == sizeof(value_type)" << "\" "
          << where << "Bad value_type: " << s2;

        if (s3 == sizeof(difference_type)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2968) << "CHECK FAILED: \"" << "s3 == sizeof(difference_type)" << "\" "
          << where << "Bad difference_type: " << s3;

        if (s4 == sizeof(prec_value_type)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2971) << "CHECK FAILED: \"" << "s4 == sizeof(prec_value_type)" << "\" "
          << where << "Bad prec_value_type: " << s4;
      }

      size_type nrows, nrows_max, ncols, nnz;
      nrows = nrows_max = ncols = nnz = 0;

      inStream >> nrows >> nrows_max >> ncols >> nnz;

      {
        if (0 <= nrows) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2981) << "CHECK FAILED: \"" << "0 <= nrows" << "\" "
          << where << "Bad number of rows: " << nrows;
        if (0 <= nrows_max) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2983) << "CHECK FAILED: \"" << "0 <= nrows_max" << "\" "
          << where << "Bad max number of rows: " << nrows_max;
        if (nrows <= nrows_max) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2985) << "CHECK FAILED: \"" << "nrows <= nrows_max" << "\" "
          << where << "Number of rows: " << nrows
          << " should be less than max number of rows: " << nrows_max;
        if (0 <= ncols) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2988) << "CHECK FAILED: \"" << "0 <= ncols" << "\" "
          << where << "Bad number of columns: " << ncols;
        if (0 <= nnz) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 2990) << "CHECK FAILED: \"" << "0 <= nnz" << "\" "
          << where << "Bad number of non-zeros: " << nnz;
      }

      deallocate_();

      nrows_ = nrows;
      nrows_max_ = nrows_max;
      ncols_ = ncols;

      allocate_(nrows_max, ncols);

      ind_mem_ = new size_type [nnz];
      nz_mem_ = new value_type [nnz];

      char separator;
      inStream.read(&separator, 1);
      nta::binary_load(inStream, nnzr_, nnzr_ + nrows_max_);
      nta::binary_load(inStream, ind_mem_, ind_mem_ + nnz);
      nta::binary_load(inStream, nz_mem_, nz_mem_ + nnz);

      bool littleEndian_bool = littleEndian == 1;

      if (littleEndian_bool != IsSystemLittleEndian()) {
        SwapBytesInPlace(nnzr_, nrows_max_);
        SwapBytesInPlace(ind_mem_, nnz);
        SwapBytesInPlace(nz_mem_, nnz);
      }

      size_type *curr_ind_ptr = ind_mem_;
      value_type *curr_nz_ptr = nz_mem_;

      for (size_type row = 0; row != nrows_; ++row) {
        ind_[row] = curr_ind_ptr;
        nz_[row] = curr_nz_ptr;
        curr_ind_ptr += nnzr_[row];
        curr_nz_ptr += nnzr_[row];
      }
    }
# 3039 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void toBinary(std::ostream& outStream)
    {





      {
        if (outStream.good()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 3047) << "CHECK FAILED: \"" << "outStream.good()" << "\" "
          << "SparseMatrix::toBinary: Bad stream";
      }

      if (!isCompact())
        compact();

      const size_type nnz = nNonZeros();

      outStream << "sm_bin_1.5 "
                << (int) IsSystemLittleEndian() << ' '
                << sizeof(size_type) << ' '
                << sizeof(value_type) << ' '
                << sizeof(difference_type) << ' '
                << sizeof(prec_value_type) << ' '
                << nrows_ << ' '
                << nrows_max_ << ' '
                << ncols_ << ' '
                << nnz << ' ';

      nta::binary_save(outStream, nnzr_, nnzr_ + nrows_max_);
      nta::binary_save(outStream, ind_mem_, ind_mem_ + nnz);
      nta::binary_save(outStream, nz_mem_, nz_mem_ + nnz);
    }
# 3088 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void resize(size_type new_nrows, size_type new_ncols, bool setToZero =false)
    {
      {
        if (0 <= new_nrows) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 3091) << "ASSERTION FAILED: \"" << "0 <= new_nrows" << "\" "
          << "SparseMatrix resize: "
          << "New number of rows: " << new_nrows
          << " should be positive";

        if (0 <= new_ncols) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 3096) << "ASSERTION FAILED: \"" << "0 <= new_ncols" << "\" "
          << "SparseMatrix resize: "
          << "New number of columns: " << new_ncols
          << " should be positive";
      }

      const size_type nrows = nRows();

      if (new_nrows > nrows_max_-1)
        reserve_(new_nrows);

      if (new_nrows < nrows) {

        if (isCompact())
          decompact();

        for (size_type row = new_nrows; row != nrows; ++row) {
          delete [] ind_[row];
          delete [] nz_[row];
          ind_[row] = 0;
          nz_[row] = 0;
          nnzr_[row] = 0;
        }
      }

      if (new_ncols < nCols()) {
        const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
          size_type k = 0, *ind = ind_[row];
          while (k < nnzr_[row] && ind[k] < new_ncols)
            ++k;
          nnzr_[row] = k;
        }
      }



      if (new_ncols > ncols_ || new_ncols < ncols_/2)
        reAllocateBuffers_(new_ncols);

      nrows_ = new_nrows;
      ncols_ = new_ncols;

      if (setToZero)
        this->setToZero();
    }
# 3152 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void reshape(size_type new_nrows, size_type new_ncols)
    {
      {
        if (0 <= new_nrows) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 3155) << "ASSERTION FAILED: \"" << "0 <= new_nrows" << "\" "
          << "SparseMatrix reshape: "
          << "New number of rows: " << new_nrows
          << " should be positive";

        if (0 <= new_ncols) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 3160) << "ASSERTION FAILED: \"" << "0 <= new_ncols" << "\" "
          << "SparseMatrix reshape: "
          << "New number of columns: " << new_ncols
          << " should be positive";

        if ((double) new_nrows * new_ncols == (double) nRows() * nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 3165) << "ASSERTION FAILED: \"" << "(double) new_nrows * new_ncols == (double) nRows() * nCols()" << "\" "
          << "SparseMatrix reshape: "
          << "New number of elements must be equal to "
          << "old number of elements";
      }

      if (!isCompact())
        compact();

      const size_type old_nrows = nRows();
      const size_type old_ncols = nCols();

      size_type *ind_it = ind_mem_;
      value_type *nz_it = nz_mem_;
      size_type count = 0, last_row = 0;

      size_type *old_nnzr = new size_type [old_nrows];
      std::copy(nnzr_, nnzr_ + old_nrows, old_nnzr);

      nrows_max_ = std::max<size_type>(8, new_nrows);

      delete [] nnzr_;
      nnzr_ = new size_type [nrows_max_];
      delete [] ind_;
      ind_ = new size_type* [nrows_max_];
      delete [] nz_;
      nz_ = new value_type* [nrows_max_];

      std::fill(nnzr_, nnzr_ + nrows_max_, (size_type)0);
      std::fill(ind_, ind_ + nrows_max_, (size_type*)0);
      std::fill(nz_, nz_ + nrows_max_, (value_type*)0);

      delete [] indb_;
      indb_ = new size_type [new_ncols];
      delete [] nzb_;
      nzb_ = new value_type [new_ncols];

      std::fill(indb_, indb_ + new_ncols, (size_type)0);
      std::fill(nzb_, nzb_ + new_ncols, (value_type)0);

      for (size_type row = 0; row != old_nrows; ++row) {
        size_type *ind_end = ind_it + old_nnzr[row];
        while (ind_it != ind_end) {
          size_type old_idx = row * old_ncols + *ind_it;
          size_type new_row = old_idx / new_ncols;
          size_type new_col = old_idx % new_ncols;
          *ind_it = new_col;
          if (new_row != last_row) {
            nnzr_[last_row] = count;
            last_row = new_row;
            count = 0;
          }
          ++ind_it; ++nz_it;
          ++count;
        }
      }

      nnzr_[last_row] = count;

      size_type *ind_ptr = ind_mem_;
      value_type *nz_ptr = nz_mem_;

      for (size_type row = 0; row != new_nrows; ++row) {
        ind_[row] = ind_ptr;
        ind_ptr += nnzr_[row];
        nz_[row] = nz_ptr;
        nz_ptr += nnzr_[row];
      }

      delete [] old_nnzr;
      old_nnzr = 0;

      nrows_ = new_nrows;
      ncols_ = new_ncols;
    }





    void deleteRow(size_type del_row)
    {
      {
        assert_valid_row_(del_row, "deleteRow");
      }

      if (isCompact())
        decompact();

      const size_type nrows = nRows();

      nnzr_[del_row] = 0;
      delete [] ind_[del_row];
      ind_[del_row] = 0;
      delete [] nz_[del_row];
      nz_[del_row] = 0;

      for (size_type row = del_row + 1; row != nrows; ++row) {
        nnzr_[row-1] = nnzr_[row];
        ind_[row-1] = ind_[row];
        nz_[row-1] = nz_[row];
      }

      nnzr_[nrows-1] = 0;
      ind_[nrows-1] = 0;
      nz_[nrows-1] = 0;

      -- nrows_;
    }
# 3298 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator>
    inline void deleteRows(InputIterator del_it, InputIterator del_end)
    {
      ptrdiff_t n_del = del_end - del_it;

      if (n_del <= 0 || nRows() == 0)
        return;

      {
        boost::function_requires<boost::InputIteratorConcept<InputIterator> >();;

        if (n_del > 0) {

          if (n_del <= (ptrdiff_t)nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 3311) << "CHECK FAILED: \"" << "n_del <= (ptrdiff_t)nRows()" << "\" "
            << "SparseMatrix::deleteRows(): "
            << " Passed more indices of rows to delete"
            << " than there are rows";



          InputIterator d = del_it, d_next = del_it + 1;
          while (d < del_end - 1) {
            if (0 <= *d && *d < nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 3320) << "CHECK FAILED: \"" << "0 <= *d && *d < nRows()" << "\" "
              << "SparseMatrix::deleteRows(): "
              << "Invalid row index: " << *d
              << " - Row indices should be between 0 and " << nRows();
            if (*d < *d_next) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 3324) << "CHECK FAILED: \"" << "*d < *d_next" << "\" "
              << "SparseMatrix::deleteRows(): "
              << "Invalid row indices " << *d << " and " << *d_next
              << " - Row indices need to be passed "
              << "in strictly increasing order";
            ++d; ++d_next;
          }

          if (0 <= *d && *d < nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 3332) << "CHECK FAILED: \"" << "0 <= *d && *d < nRows()" << "\" "
            << "SparseMatrix::deleteRows(): "
            << "Invalid row index: " << *d
            << " - Row indices should be between 0 and " << nRows();

        }
# 3352 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
      }

      if (isCompact())
        decompact();

      const size_type nrows = nRows();
      size_type i_new = 0;

      for (size_type i_old = 0; i_old != nrows; ++i_old) {
        if (del_it != del_end && i_old == *del_it) {
          nnzr_[i_old] = 0;
          delete [] ind_[i_old];
          delete [] nz_[i_old];
          ++del_it;
        } else {
          nnzr_[i_new] = nnzr_[i_old];
          ind_[i_new] = ind_[i_old];
          nz_[i_new] = nz_[i_old];
          ++i_new;
        }
      }

      nrows_ = i_new;

      for (; i_new != nrows_max_; ++i_new) {
        nnzr_[i_new] = 0;
        ind_[i_new] = 0;
        nz_[i_new] = 0;
      }
    }





    template <typename Container>
    inline void deleteRows(const Container& c)
    {
      deleteRows(c.begin(), c.end());
    }





    void deleteCol(size_type del_col)
    {
      {
        assert_valid_col_(del_col, "deleteCol");
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {

        if (isRowZero(row))
          continue;

        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row);
        value_type *nz = nz_begin_(row);
        size_type *lb = std::lower_bound(ind, ind_end, del_col);

        if (lb != ind_end && *lb == del_col) {

          nz += lb - ind + 1;
          ind = lb + 1;
          while (ind != ind_end) {
            *(ind - 1) = *ind - 1;
            *(nz - 1) = *nz;
            ++ind; ++nz;
          }

          -- nnzr_[row];

        } else if (lb != ind_end) {

          ind = lb;
          while (ind != ind_end) {
            -- *ind;
            ++ind;
          }
        }
      }





      -- ncols_;
    }
# 3462 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator>
    inline void deleteCols(InputIterator del_it, InputIterator del_end)
    {
      ptrdiff_t n_del = del_end - del_it;

      if (n_del <= 0 || nCols() == 0)
        return;

      {
        boost::function_requires<boost::InputIteratorConcept<InputIterator> >();;

        if (n_del > 0) {

          if (n_del <= (ptrdiff_t)nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 3475) << "ASSERTION FAILED: \"" << "n_del <= (ptrdiff_t)nCols()" << "\" "
            << "SparseMatrix::deleteCols(): "
            << " Passed more indices of columns to delete"
            << " than there are columns";



          InputIterator d = del_it, d_next = del_it + 1;
          while (d < del_end - 1) {
            if (0 <= *d && *d < nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 3484) << "ASSERTION FAILED: \"" << "0 <= *d && *d < nCols()" << "\" "
              << "SparseMatrix::deleteCols(): "
              << "Invalid column index: " << *d
              << " - Col indices should be between 0 and " << nCols();
            if (*d < *d_next) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 3488) << "ASSERTION FAILED: \"" << "*d < *d_next" << "\" "
              << "SparseMatrix::deleteCols(): "
              << "Invalid column indices " << *d << " and " << *d_next
              << " - Col indices need to be passed "
              << "in strictly increasing order";
            ++d; ++d_next;
          }

          if (0 <= *d && *d < nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 3496) << "ASSERTION FAILED: \"" << "0 <= *d && *d < nCols()" << "\" "
            << "SparseMatrix::deleteCols(): "
            << "Invalid column index: " << *d
            << " - Col indices should be between 0 and " << nCols();

        }
# 3516 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {

        size_type j = 0;
        InputIterator d = del_it;
        size_type *ind = ind_[row], *ind_old = ind, *ind_end = ind + nnzr_[row];
        value_type *nz = nz_[row], *nz_old = nz;

        while (ind_old != ind_end && d != del_end) {
          if (*d == *ind_old) {
            ++d; ++j;
            ++ind_old;
            ++nz_old;
          } else if (*d < *ind_old) {
            ++d; ++j;
          } else {
            *ind++ = *ind_old++ - j;
            *nz++ = *nz_old++;
          }
        }

        while (ind_old != ind_end) {
          *ind++ = *ind_old++ - j;
          *nz++ = *nz_old++;
        }

        nnzr_[row] = size_type(ind - ind_[row]);
      }





      ncols_ -= size_type(n_del);
    }





    template <typename Container>
    inline void deleteCols(const Container& c)
    {
      deleteCols(c.begin(), c.end());
    }
# 3589 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator1, typename InputIterator2>
    inline size_type
    addRow(InputIterator1 ind_it, InputIterator1 ind_end, InputIterator2 nz_it,
           bool zero_permissive =false)
    {
      {
        boost::function_requires<boost::InputIteratorConcept<InputIterator1> >();;
        boost::function_requires<boost::InputIteratorConcept<InputIterator2> >();;

        if (!zero_permissive)
          assert_valid_ivp_range_(nCols(), ind_it, ind_end, nz_it, "addRow");
      }

      const size_type row_num = nRows();
      const size_type nnzr = (size_type) (ind_end - ind_it);

      if (isCompact())
        decompact();

      if (row_num > nrows_max_-1)
        reserve_(row_num);

      nnzr_[row_num] = nnzr;

      if (nnzr > 0) {

        ind_[row_num] = new size_type[nnzr];
        nz_[row_num] = new value_type[nnzr];

        size_type* ind_ptr = ind_[row_num];
        value_type* nz_ptr = nz_[row_num];

        while (ind_it != ind_end) {
          *ind_ptr = *ind_it;
          *nz_ptr = *nz_it;
          ++ind_ptr; ++nz_ptr;
          ++ind_it; ++nz_it;
        }

      } else {

        ind_[row_num] = 0;
        nz_[row_num] = 0;
      }

      ++nrows_;
      return row_num;
    }
# 3652 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator>
    inline size_type addRow(InputIterator x_begin)
    {
      {
        boost::function_requires<boost::InputIteratorConcept<InputIterator> >();;
      }

      size_type *indb_it = indb_;
      value_type val, *nzb_it = nzb_;
      InputIterator x_it = x_begin, x_end = x_begin + nCols();

      while (x_it != x_end) {
        val = *x_it;
        if (!isZero_(val)) {
          *indb_it = size_type(x_it - x_begin);
          *nzb_it = val;
          ++indb_it; ++nzb_it;
        }
        ++x_it;
      }

      return addRow(indb_, indb_it, nzb_);
    }
# 3694 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator1, typename InputIterator2>
    inline void
    addCol(InputIterator1 ind_it, InputIterator1 ind_end, InputIterator2 nz_it)
    {
      {
        boost::function_requires<boost::InputIteratorConcept<InputIterator1> >();;
        boost::function_requires<boost::InputIteratorConcept<InputIterator2> >();;
        assert_valid_ivp_range_(nRows(), ind_it, ind_end, nz_it, "addCol");
      }

      if (isCompact())
        decompact();

      while (ind_it != ind_end) {
        size_type row = *ind_it;
        size_type old_nnzr = nnzr_[row];
        size_type new_nnzr = old_nnzr + 1;
        size_type *new_ind = new size_type [new_nnzr];
        value_type * new_nz = new value_type [new_nnzr];
        std::copy(ind_[row], ind_[row] + old_nnzr, new_ind);
        std::copy(nz_[row], nz_[row] + old_nnzr, new_nz);
        delete [] ind_[row];
        ind_[row] = new_ind;
        delete [] nz_[row];
        nz_[row] = new_nz;
        ind_[row][old_nnzr] = nCols();
        nz_[row][old_nnzr] = *nz_it;
        ++ nnzr_[row];
        ++ind_it; ++nz_it;
      }

      ++ ncols_;
      reAllocateBuffers_(ncols_);
    }
# 3743 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator>
    inline void addCol(InputIterator x_begin)
    {
      {
        boost::function_requires<boost::InputIteratorConcept<InputIterator> >();;
      }

      if (isCompact())
        decompact();

      bool new_non_zeros = false;

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        value_type val = *x_begin;
        if (! isZero_(val)) {
          new_non_zeros = true;
          size_type old_nnzr = nnzr_[row];
          size_type new_nnzr = old_nnzr + 1;
          size_type *new_ind = new size_type [new_nnzr];
          value_type * new_nz = new value_type [new_nnzr];
          std::copy(ind_[row], ind_[row] + old_nnzr, new_ind);
          std::copy(nz_[row], nz_[row] + old_nnzr, new_nz);
          delete [] ind_[row];
          ind_[row] = new_ind;
          delete [] nz_[row];
          nz_[row] = new_nz;
          ind_[row][old_nnzr] = nCols();
          nz_[row][old_nnzr] = val;
          ++ nnzr_[row];
        }
        ++x_begin;
      }

      if (new_non_zeros) {
        ++ ncols_;
        reAllocateBuffers_(ncols_);
      }
    }
# 3789 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void append(const self_type& other, bool zero_permissive =false)
    {
      if (other.nCols() > this->nCols())
        this->resize(nRows(), other.nCols());

      for (size_type row = 0; row != other.nRows(); ++row)
        this->addRow(other.ind_begin_(row),
                     other.ind_end_(row),
                     other.nz_begin_(row),
                     zero_permissive);
    }






    inline void duplicateRow(size_type row)
    {
      {
        assert_valid_row_(row, "duplicateRow");
      }

      addRow(ind_begin_(row), ind_end_(row), nz_begin_(row));
    }
# 3831 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void setZero(size_type row, size_type col, bool resizeYesNo=false)
    {
      {
        if (!resizeYesNo)
          assert_valid_row_col_(row, col, "setZero");
      }

      if (resizeYesNo)
        resize(std::max(row+1, nRows()), std::max(row+1, nCols()));

      size_type *it = pos_(row, col);

      if (it != ind_end_(row) && *it == col)
        erase_(row, it);
    }
# 3856 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void setDiagonalToZero()
    {
      size_type m = std::min(nRows(), nCols());

      for (size_type i = 0; i != m; ++i)
        setZero(i, i);
    }





    inline void setDiagonalToVal(const value_type& val)
    {
      size_type m = std::min(nRows(), nCols());

      for (size_type i = 0; i != m; ++i)
        set(i, i, val);
    }





    template <typename InIter>
    inline void setDiagonal(InIter begin)
    {
      size_type m = std::min(nRows(), nCols());

      for (size_type i = 0; i != m; ++i)
        set(i, i, *begin++);
    }
# 3909 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void setNonZero(size_type i, size_type j, const value_type& val,
                           bool resizeYesNo=false)
    {
      {
        if (!resizeYesNo)
          assert_valid_row_col_(i,j,"setNonZero");
        assert_not_zero_value_(val, "setNonZero");
      }

      if (resizeYesNo)
        resize(std::max(i+1, nRows()), std::max(j+1, nCols()));

      size_type *ind = ind_begin_(i), *ind_end = ind_end_(i);
      size_type *it = pos_(i, j);

      if (it != ind_end && *it == j) {





        nz_[i][it - ind] = val;

      } else {

        insertNewNonZero_(i, j, it, val);
      }
    }
# 3956 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void set(size_type i, size_type j, const value_type& val,
                    bool resizeYesNo=false)
    {
      {
        if (!resizeYesNo)
          assert_valid_row_col_(i,j,"set");
      }

      if (resizeYesNo)
        resize(std::max(i+1, nRows()), std::max(j+1, nCols()));

      if (isZero_(val))
        setZero(i, j);
      else
        setNonZero(i, j, val);
    }





    inline void setBoxToZero(size_type row_begin, size_type row_end,
                             size_type col_begin, size_type col_end)
    {
      {
        assert_valid_row_range_(row_begin, row_end, "setBoxToZero");
        assert_valid_col_range_(col_begin, col_end, "setBoxToZero");
      }

      for (size_type row = row_begin; row != row_end; ++row) {
        size_type *ind = __null, *ind_end = __null;
        difference_type offset = pos_(row, col_begin, col_end, ind, ind_end);
        if (ind != ind_end_(row)) {
          value_type *nz = nz_begin_(row) + offset;
          std::copy(ind_end, ind_end_(row), ind);
          std::copy(nz + (ind_end - ind), nz_end_(row), nz);
          nnzr_[row] -= ind_end - ind;
        }
      }
    }





    inline void setBox(size_type row_begin, size_type row_end,
                       size_type col_begin, size_type col_end,
                       const value_type& val)
    {
      {
        assert_valid_row_range_(row_begin, row_end, "setBox");
        assert_valid_col_range_(col_begin, col_end, "setBox");
      }

      if (isZero_(val))
        setBoxToZero(row_begin, row_end, col_begin, col_end);

      size_type box_ncols = col_end - col_begin;

      for (size_type row = row_begin; row != row_end; ++row) {

        size_type *ind_begin = __null, *ind_end = __null;
        difference_type offset = pos_(row, col_begin, col_end, ind_begin, ind_end);
        value_type *nz_begin = nz_begin_(row) + offset;

        if ((size_type)(ind_end - ind_begin) == box_ncols) {

          std::fill(nz_begin, nz_begin + box_ncols, val);

        } else {

          decompact();

          std::copy(ind_begin_(row), ind_begin, indb_);
          std::copy(nz_begin_(row), nz_begin, nzb_);
          size_type *indb = indb_ + offset;
          value_type *nzb = nzb_ + offset;
          for (size_type col = col_begin; col != col_end; ++col) {
            *indb++ = col;
            *nzb++ = val;
          }
          std::copy(ind_end, ind_end_(row), indb);
          std::copy(nz_begin + (ind_end - ind_begin), nz_end_(row), nzb);

          size_type new_nnzr = (size_type)(indb - indb_ + ind_end_(row) - ind_end);

          delete [] ind_[row];
          delete [] nz_[row];
          ind_[row] = new size_type [new_nnzr];
          nz_[row] = new value_type [new_nnzr];
          std::copy(indb_, indb_ + new_nnzr, ind_[row]);
          std::copy(nzb_, nzb_ + new_nnzr, nz_[row]);
          nnzr_[row] = new_nnzr;
        }
      }
    }






    inline void increment(size_type i, size_type j, value_type delta =1,
                          bool resizeYesNo =false)
    {
      {
        if (!resizeYesNo)
          assert_valid_row_col_(i,j,"increment");
      }

      if (isZero_(delta))
        return;

      if (resizeYesNo)
        resize(std::max(i+1, nRows()), std::max(j+1, nCols()));

      size_type *ind = ind_begin_(i), *ind_end = ind_end_(i);
      size_type *it = pos_(i,j);

      if (it != ind_end && *it == j) {
        nz_[i][it - ind] += delta;
      } else {
        insertNewNonZero_(i, j, it, delta);
      }
    }





    inline void incrementWNZ(size_type i, size_type j, value_type delta =1,
                             bool resizeYesNo =false)
    {
      {
        if (!resizeYesNo)
          assert_valid_row_col_(i,j,"increment");
        if (!isZero_(delta)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 4092) << "ASSERTION FAILED: \"" << "!isZero_(delta)" << "\" "
          << "SparseMatrix incrementWNZ: Expects non-zero delta only";
      }

      if (resizeYesNo)
        resize(std::max(i+1, nRows()), std::max(j+1, nCols()));

      size_type *ind = ind_begin_(i), *ind_end = ind_end_(i);
      size_type *it = pos_(i,j);

      if (it != ind_end && *it == j) {
        nz_[i][it - ind] += delta;
      } else {
        insertNewNonZero_(i, j, it, delta);
      }
    }





    template <typename InputIterator>
    inline void incrementOnOuterWNZ(InputIterator i_begin, InputIterator i_end,
                                    InputIterator j_begin, InputIterator j_end,
                                    value_type delta =1)
    {
      {
        boost::function_requires<boost::InputIteratorConcept<InputIterator> >();;
        assert_valid_sorted_index_range_(nRows(), i_begin, i_end,
                                         "incrementOnOuterWNZ");
        assert_valid_sorted_index_range_(nCols(), j_begin, j_end,
                                         "incrementOnOuterWNZ");
        if (!isZero_(delta)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 4124) << "ASSERTION FAILED: \"" << "!isZero_(delta)" << "\" "
          << "SparseMatrix incrementOnOuterWNZ: Expects non-zero delta only";
      }

      for (InputIterator i = i_begin; i != i_end; ++i) {
        for (InputIterator j = j_begin; j != j_end; ++j) {
          size_type *ind = ind_begin_(*i), *ind_end = ind_end_(*i);
          size_type *it = std::lower_bound(ind, ind_end, *j);
          if (it != ind_end && *it == *j) {
            nz_[*i][it - ind] += delta;
          } else {
            insertNewNonZero_(*i,*j,it,delta);
          }
        }
      }
    }





    template <typename InputIterator>
    inline void incrementOnOuterWNZWThreshold(InputIterator i_begin, InputIterator i_end,
                                              InputIterator j_begin, InputIterator j_end,
                                              value_type threshold,
                                              value_type delta =1)
    {
      {
        boost::function_requires<boost::InputIteratorConcept<InputIterator> >();;
        assert_valid_sorted_index_range_(nRows(), i_begin, i_end,
                                         "incrementOnOuterWNZ");
        assert_valid_sorted_index_range_(nCols(), j_begin, j_end,
                                         "incrementOnOuterWNZ");
        if (!isZero_(delta)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 4157) << "ASSERTION FAILED: \"" << "!isZero_(delta)" << "\" "
          << "SparseMatrix incrementOnOuterWNZ: Expects non-zero delta only";
      }

      for (InputIterator i = i_begin; i != i_end; ++i) {
        for (InputIterator j = j_begin; j != j_end; ++j) {
          size_type *ind = ind_begin_(*i), *ind_end = ind_end_(*i);
          for (size_type *it = ind; it != ind_end; ++it)
            if (*it == *j && nz_[*i][it - ind] > threshold)
              nz_[*i][it - ind] += delta;
        }
      }
    }
# 4186 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline value_type get(size_type row, size_type col) const
    {
      {
        assert_valid_row_col_(row, col, "get");
      }

      difference_type offset = col_(row, col);

      if (offset >= 0)
        return nz_[row][offset];

      return value_type(0);
    }





    inline const_row_nz_index_iterator row_nz_index_begin(size_type row) const
    {
      return ind_begin_(row);
    }




    inline const_row_nz_index_iterator row_nz_index_end(size_type row) const
    {
      return ind_end_(row);
    }




    inline const_row_nz_value_iterator row_nz_value_begin(size_type row) const
    {
      return nz_begin_(row);
    }




    inline const_row_nz_value_iterator row_nz_value_end(size_type row) const
    {
      return nz_end_(row);
    }






    template <typename OutputIterator>
    inline void getAllNonZeros(OutputIterator ijv_iterator) const
    {
      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          ijv_iterator->i(row);
          ijv_iterator->j(*ind);
          if (!isZero_(*nz)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 4245) << "ASSERTION FAILED: \"" << "!isZero_(*nz)" << "\" "
            << "SparseMatrix::getAllNonZeros (ijv): "
            << "Zero at " << row << ", " << *ind << ": " << *nz
            << " epsilon= " << nta::Epsilon;
          ijv_iterator->v(*nz);
          ++ijv_iterator;
        }
      }
    }






    template <typename OutputIterator>
    inline void getAllNonZeros(size_type row_begin, size_type row_end,
                               size_type col_begin, size_type col_end,
                               OutputIterator ijv_iterator) const
    {
      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        if (row >= row_begin && row < row_end) {
          size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
            if (*ind >= col_begin && *ind < col_end) {
              ijv_iterator->i(row);
              ijv_iterator->j(*ind);
              if (!isZero_(*nz)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 4271) << "ASSERTION FAILED: \"" << "!isZero_(*nz)" << "\" "
                << "SparseMatrix::getAllNonZeros (rect): "
                << "Zero at " << row << ", " << *ind << ": " << *nz
                << " epsilon= " << nta::Epsilon;
              ijv_iterator->v(*nz);
              ++ijv_iterator;
            }
          }
        }
      }
    }







    template <typename OutputIterator1, typename OutputIterator2>
    inline void getAllNonZeros(OutputIterator1 nz_i, OutputIterator1 nz_j,
                               OutputIterator2 nz_val) const
    {
      {
        boost::function_requires<boost::OutputIteratorConcept<OutputIterator1, size_type> >();;
        boost::function_requires<boost::OutputIteratorConcept<OutputIterator2, value_type> >();;
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          *nz_i = row;
          *nz_j = *ind;
          if (!isZero_(*nz)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 4302) << "ASSERTION FAILED: \"" << "!isZero_(*nz)" << "\" "
            << "SparseMatrix::getAllNonZeros (3 lists): "
            << "Zero at " << row << ", " << *ind << ": " << *nz
            << " epsilon= " << nta::Epsilon;
          *nz_val = *nz;
          ++nz_i; ++nz_j;
          ++nz_val;
        }
      }
    }
# 4330 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator1, typename InputIterator2>
    inline void setAllNonZeros(size_type nrows, size_type ncols,
                               InputIterator1 i_begin, InputIterator1 i_end,
                               InputIterator1 j_begin, InputIterator1 j_end,
                               InputIterator2 v_begin, InputIterator2 v_end,
                               bool clean =true)
    {
      {
        const char* where = "SparseMatrix::setAllNonZeros: ";

        boost::function_requires<boost::InputIteratorConcept<InputIterator1> >();;
        boost::function_requires<boost::InputIteratorConcept<InputIterator2> >();;

        if (i_end - i_begin == j_end - j_begin) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 4343) << "ASSERTION FAILED: \"" << "i_end - i_begin == j_end - j_begin" << "\" "
          << where << "Inconsistent index ranges";
        if (v_end - v_begin == i_end - i_begin) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 4345) << "ASSERTION FAILED: \"" << "v_end - v_begin == i_end - i_begin" << "\" "
          << where << "Inconsistent value range";

        ASSERT_VALID_RANGE(i_begin, i_end, where);
        for (InputIterator1 ii = i_begin; ii != i_end; ++ii)
          if (*ii < nrows) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 4350) << "ASSERTION FAILED: \"" << "*ii < nrows" << "\" "
            << where << "Invalid row index: " << *ii
            << " - Should be >= 0 and < " << nrows;

        ASSERT_VALID_RANGE(j_begin, j_end, where);
        for (InputIterator1 jj = j_begin; jj != j_end; ++jj)
          if (*jj < ncols) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 4356) << "ASSERTION FAILED: \"" << "*jj < ncols" << "\" "
            << where << "Invalid col index: " << *jj
            << " - Should be >= 0 and < " << ncols;



        if (clean) {

          for (InputIterator2 it_v = v_begin; it_v != v_end; ++it_v)
            if (!isZero_(*it_v)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 4365) << "ASSERTION FAILED: \"" << "!isZero_(*it_v)" << "\" "
              << where << "Passed in zero: " << *it_v
              << " epsilon= " << nta::Epsilon;

          if (i_begin != i_end) {
            InputIterator1 ii = i_begin, jj = j_begin, iip = ii, jjp = jj;
            InputIterator2 vv = v_begin, vvp = vv;
            ++ii; ++jj;
            for (; ii != i_end; ++ii, ++jj, ++vv) {
              if (*iip < *ii || *jjp < *jj) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 4374) << "ASSERTION FAILED: \"" << "*iip < *ii || *jjp < *jj" << "\" "
                << where
                << "Passed in duplicate or out-of-order non-zeros: "
                << *vvp << " and " << *vv
                << ", (" << *iip << ", " << *jjp << ") and ("
                << *ii << ", " << *jj << ")";
              iip = ii; jjp = jj; vvp = vv;
            }
          }
        }


      }


      typedef std::set<IJV, typename IJV::lexicographic> S;
      typename S::const_iterator it;
      S s;

      InputIterator1 it_i = i_begin, it_j = j_begin;
      InputIterator2 it_v = v_begin;

      deallocate_();
      allocate_(nrows,ncols);
      nrows_ = nrows;
      ncols_ = ncols;

      size_type nnz = 0;

      if (clean) {

        nnz = (size_type)(i_end - i_begin);
        for (; it_i != i_end; ++it_i)
          ++ nnzr_[*it_i];

      } else {

        for (; it_i != i_end; ++it_i, ++it_j, ++it_v)
          if (!isZero_(*it_v)) {
            IJV ijv(*it_i, *it_j, *it_v);
            it = s.find(ijv);
            if (it == s.end()) {
              s.insert(ijv);
              ++ nnzr_[*it_i];
            }
          }

        nnz = s.size();
      }

      ind_mem_ = new size_type [nnz];
      nz_mem_ = new value_type [nnz];
      size_type *ind_ptr = ind_mem_;
      value_type *nz_ptr = nz_mem_;

      it_i = i_begin; it_j = j_begin; it_v = v_begin;

      if (clean) {

        for (size_type i = 0; i != nrows; ++i) {
          ind_[i] = ind_ptr;
          nz_[i] = nz_ptr;
          for (size_type k = 0; k != nnzr_[i]; ++k) {
            *ind_ptr++ = *it_j;
            *nz_ptr++ = *it_v;
            ++it_j;
            ++it_v;
          }
        }

      } else {

        it = s.begin();

        for (size_type i = 0; i != nrows; ++i) {
          ind_[i] = ind_ptr;
          nz_[i] = nz_ptr;
          for (size_type k = 0; k != nnzr_[i]; ++k, ++it) {
            *ind_ptr++ = it->j();
            *nz_ptr++ = it->v();
          }
        }
      }
    }






    template <typename OutputIterator1, typename OutputIterator2>
    inline void getNonZerosInBox(size_type row_begin, size_type row_end,
                                 size_type col_begin, size_type col_end,
                                 OutputIterator1 nz_i, OutputIterator1 nz_j,
                                 OutputIterator2 nz_v) const
    {
      {
        assert_valid_row_range_(row_begin, row_end, "getNonZerosInBox");
        assert_valid_col_range_(col_begin, col_end, "getNonZerosInBox");
      }

      for (size_type row = row_begin; row != row_end; ++row) {
        if (!nonZerosInRowRange(row, col_begin, col_end))
          continue;
        size_type *c1 = pos_(row, col_begin);
        size_type *c2 = col_end == nCols() ? ind_end_(row) : pos_(row, col_end);
        value_type *nz = nz_begin_(row) + (c1 - ind_begin_(row));
        for (size_type *col = c1; col != c2; ++col) {
          *nz_i++ = row;
          *nz_j++ = *col;
          if (!isZero_(*nz)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 4484) << "ASSERTION FAILED: \"" << "!isZero_(*nz)" << "\" "
            << "SparseMatrix::getNonZerosInBox: "
            << "Zero at " << row << ", " << *col << ": " << *nz
            << " epsilon= " << nta::Epsilon;
          *nz_v++ = *nz++;
        }
      }
    }





    template <typename OutputIterator, typename StrictWeakOrdering>
    inline size_type
    getNonZerosSorted(OutputIterator out_begin, int n =-1,
                      StrictWeakOrdering o = IJV::greater_value()) const
    {
      if (nNonZeros() == 0)
        return 0;

      if (n < 0 || (size_type) n > nNonZeros())
        n = nNonZeros();

      std::vector<IJV> ijvs(nNonZeros());
      getAllNonZeros(ijvs.begin());
      std::partial_sort(ijvs.begin(), ijvs.begin() + n, ijvs.end(), o);
      std::copy(ijvs.begin(), ijvs.begin() + n, out_begin);

      return n;
    }





    template <typename OutputIterator>
    inline size_type getDiagonalToSparse(OutputIterator out) const
    {
      {


      }

      size_type count = 0;

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        difference_type offset = col_(row, row);
        if (offset >= 0) {
          *out = std::make_pair(row, nz_[row][offset]);
          ++out; ++count;
        }
      }

      return count;
    }





    template <typename OutputIterator>
    inline void getDiagonalToDense(OutputIterator out) const
    {
      {
        boost::function_requires<boost::OutputIteratorConcept<OutputIterator, value_type> >();;
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        difference_type offset = col_(row, row);
        if (offset >= 0) {
          *out = nz_[row][offset];
        } else {
          *out = 0;
        }
        ++out;
      }
    }
# 4570 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator1, typename InputIterator2>
    inline void setElements(InputIterator1 i_begin, InputIterator1 i_end,
                            InputIterator1 j_begin,
                            InputIterator2 v_begin)
    {
      {
        boost::function_requires<boost::InputIteratorConcept<InputIterator1> >();;
        boost::function_requires<boost::InputIteratorConcept<InputIterator2> >();;
        assert_valid_row_it_range_(i_begin, i_end, "setElements");
      }

      while (i_begin != i_end) {
        set(*i_begin, *j_begin, value_type(*v_begin));
        ++i_begin; ++j_begin; ++v_begin;
      }
    }
# 4596 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator1, typename OutputIterator1>
    inline void getElements(InputIterator1 i_begin, InputIterator1 i_end,
                            InputIterator1 j_begin,
                            OutputIterator1 v_begin) const
    {
      {
        boost::function_requires<boost::InputIteratorConcept<InputIterator1> >();;
        boost::function_requires<boost::OutputIteratorConcept<OutputIterator1, value_type> >();;
        assert_valid_row_it_range_(i_begin, i_end, "getElements");
      }

      while (i_begin != i_end) {
        *v_begin = get(*i_begin, *j_begin);
        ++i_begin; ++j_begin; ++v_begin;
      }
    }







    template <typename InputIterator1, typename Other>
    inline void setOuter(InputIterator1 i_begin, InputIterator1 i_end,
                         InputIterator1 j_begin, InputIterator1 j_end,
                         const Other& values)
    {
      {
        boost::function_requires<boost::InputIteratorConcept<InputIterator1> >();;
        if ((size_type)values.nRows() >= (size_type)(i_end - i_begin)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 4626) << "ASSERTION FAILED: \"" << "(size_type)values.nRows() >= (size_type)(i_end - i_begin)" << "\" "
          << "SparseMatrix setOuter: "
          << "Matrix to set has too few rows: " << values.nRows()
          << " - Should be at least: " << (size_type)(i_end - i_begin);
        if ((size_type)values.nCols() >= (size_type)(j_end - j_begin)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 4630) << "ASSERTION FAILED: \"" << "(size_type)values.nCols() >= (size_type)(j_end - j_begin)" << "\" "
          << "SparseMatrix setOuter: "
          << "Matrix to set has too few columns: " << values.nCols()
          << " - Should be at least: " << (size_type)(j_end - j_begin);
        assert_valid_row_it_range_(i_begin, i_end, "setOuter");
        assert_valid_col_it_range_(i_begin, i_end, "setOuter");
      }

      InputIterator1 j_begin_cache = j_begin;

      for (size_type ii = 0; i_begin != i_end; ++ii, ++i_begin) {
        j_begin = j_begin_cache;
        for (size_type jj = 0; j_begin != j_end; ++jj, ++j_begin) {
          this->set(*i_begin, *j_begin, values.get(ii, jj));
        }
      }
    }
# 4655 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator1, typename InputIterator2, typename Other>
    inline void getOuter(InputIterator1 i_begin, InputIterator1 i_end,
                         InputIterator2 j_begin, InputIterator2 j_end,
                         Other& values) const
    {
      {
        boost::function_requires<boost::InputIteratorConcept<InputIterator1> >();;
        boost::function_requires<boost::InputIteratorConcept<InputIterator2> >();;
        assert_valid_row_it_range_(i_begin, i_end, "getOuter");
        assert_valid_col_it_range_(i_begin, i_end, "getOuter");
      }

      InputIterator1 j_begin_cache = j_begin;
      size_t nrows = (size_t)(i_end - i_begin);
      size_t ncols = (size_t)(j_end - j_begin);

      values.resize(nrows, ncols);

      for (size_type ii = 0; i_begin != i_end; ++ii, ++i_begin) {
        j_begin = j_begin_cache;
        for (size_type jj = 0; j_begin != j_end; ++jj, ++j_begin) {
          values.set(ii, jj, this->get(*i_begin, *j_begin));
        }
      }
    }






    template <typename Container1, typename Container2, typename Other>
    inline void
    getOuter(const Container1& c1, const Container2& c2, Other& other) const
    {
      typedef typename Container1::const_iterator iterator1;
      typedef typename Container2::const_iterator iterator2;

      iterator1 i_begin = c1.begin(), i_end = c1.end();
      iterator2 j_begin = c2.begin(), j_end = c2.end(), j_begin_cache = j_begin;

      other.resize(c1.size(), c2.size());

      for (size_type ii = 0; i_begin != i_end; ++ii, ++i_begin) {
        j_begin = j_begin_cache;
        for (size_type jj = 0; j_begin != j_end; ++jj, ++j_begin)
          other.set(ii, jj, this->get(*i_begin, *j_begin));
      }
    }






    template <typename Other>
    inline void
    setSlice(size_type dst_first_row, size_type dst_first_col, const Other& src)
    {
      {




      }

      size_type nrows = src.nRows(), ncols = src.nCols();
      for (size_type row = 0; row != nrows; ++row) {
        for (size_type col = 0; col != ncols; ++col) {
          set(row + dst_first_row, col + dst_first_col, src.get(row,col));
        }
      }
    }
# 4745 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename Other>
    inline void
    getSlice(size_type src_first_row, size_type src_row_end,
             size_type src_first_col, size_type src_col_end,
             Other& other) const
    {
      {
        assert_valid_row_col_(src_first_row, src_first_col, "getSlice");
        assert_valid_row_col_(src_row_end-1, src_col_end-1, "getSlice");
        if (src_first_row <= src_row_end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 4754) << "ASSERTION FAILED: \"" << "src_first_row <= src_row_end" << "\" "
          << "SparseMatrix getSlice"
          << ": Invalid row range: [" << src_first_row
          << ".." << src_row_end << "): "
          << "- Beginning should be <= end of range";
        if (src_first_col <= src_col_end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 4759) << "ASSERTION FAILED: \"" << "src_first_col <= src_col_end" << "\" "
          << "SparseMatrix getSlice"
          << ": Invalid column range: [" << src_first_col
          << ".." << src_col_end << "): "
          << "- Beginning should be <= end of range";
      }


      other.resize(src_row_end - src_first_row, src_col_end - src_first_col);

      for (size_type row = src_first_row; row != src_row_end; ++row) {
        for (size_type col = src_first_col; col != src_col_end; ++col) {
          const value_type v = this->get(row, col);
          other.set(row - src_first_row, col - src_first_col, v);
        }
      }
    }






    inline void getSlice2(size_type src_first_row, size_type src_row_end,
                          size_type src_first_col, size_type src_col_end,
                          SparseMatrix& other) const
    {
      {
        assert_valid_row_col_(src_first_row, src_first_col, "getSlice2");
        assert_valid_row_col_(src_row_end-1, src_col_end-1, "getSlice2");
        if (src_first_row <= src_row_end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 4789) << "ASSERTION FAILED: \"" << "src_first_row <= src_row_end" << "\" "
          << "SparseMatrix getSlice2"
          << ": Invalid row range: [" << src_first_row
          << ".." << src_row_end << "): "
          << "- Beginning should be <= end of range";
        if (src_first_col <= src_col_end) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 4794) << "ASSERTION FAILED: \"" << "src_first_col <= src_col_end" << "\" "
          << "SparseMatrix getSlice2"
          << ": Invalid column range: [" << src_first_col
          << ".." << src_col_end << "): "
          << "- Beginning should be <= end of range";
      }

      size_type o_nrows = src_row_end - src_first_row;
      size_type o_ncols = src_col_end - src_first_col;

      other.resize(o_nrows, o_ncols);
      other.ind_mem_ = __null;
      other.nz_mem_ = __null;
      other.nrows_ = o_nrows;
      other.ncols_ = o_ncols;

      size_type orow = 0;

      for (size_type row = src_first_row; row != src_row_end; ++row, ++orow) {
        for (size_type col = src_first_col; col != src_col_end; ++col) {
          size_type *ind = __null, *ind_end = __null;
          difference_type offset = pos_(row, src_first_col, src_col_end, ind, ind_end);
          value_type *nz = nz_begin_(row) + offset;
          size_type nnzr = ind_end - ind;
          if (nnzr > other.nnzr_[orow]) {
            if (other.isCompact())
              other.decompact();
            delete [] other.ind_[orow];
            delete [] other.nz_[orow];
            other.ind_[orow] = new size_type[nnzr];
            other.nz_[orow] = new value_type[nnzr];
          }
          other.nnzr_[orow] = nnzr;
          size_type *o_ind = other.ind_begin_(orow);
          value_type *o_nz = other.nz_begin_(orow);
          for (; ind != ind_end; ++ind, ++nz, ++o_ind, ++o_nz) {
            *o_ind = *ind - src_first_col;
            *o_nz = *nz;
          }
        }
      }
    }
# 4849 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void setRowToZero(size_type row)
    {
      {
        assert_valid_row_(row, "setRowToZero");
      }

      nnzr_[row] = 0;
    }


    inline void setRowToVal(size_type row, value_type val)
    {
      {
        assert_valid_row_(row, "setRowToVal");
      }

      for (size_type col = 0; col != nCols(); ++col)
        set(row, col, val);
    }
# 4881 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void setColToZero(size_type col)
    {
      {
        assert_valid_col_(col, "setColToZero");
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row)
        setZero(row, col);
    }


    inline void setColToVal(size_type col, value_type val)
    {
      {
        assert_valid_col_(col, "setColToVal");
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row)
        set(row, col, val);
    }






    inline void setToZero()
    {
      if (isCompact())
        decompact();

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        delete [] ind_[row];
        delete [] nz_[row];
        ind_[row] = 0;
        nz_[row] = 0;
        nnzr_[row] = 0;
      }
    }





    template <typename InputIterator>
    inline void setRowsToZero(InputIterator it, InputIterator end)
    {
      for (; it != end; ++it)
        nnzr_[*it] = 0;
    }







    template <typename InputIterator>
    inline void setColsToZero(InputIterator it, InputIterator end)
    {
      {

      }

      boost::unordered_set<size_type> skip(it, end);

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type k = 0;
        size_type *row_ind = ind_[row];
        value_type *row_nz = nz_[row];
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          if (skip.find(*ind) == skip.end()) {
            row_ind[k] = *ind;
            row_nz[k] = *nz;
            ++k;
          }
        }
        nnzr_[row] = k;
      }
    }
# 4969 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void setFromOuter(const std::vector<value_type>& x,
                             const std::vector<value_type>& y,
                             bool keepMemory =false)
    {
      if (!keepMemory) {
        deallocate_();
        allocate_(x.size(), y.size());
        nrows_ = x.size();
        ncols_ = y.size();
      } else {
        if (nrows_ == x.size()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 4979) << "ASSERTION FAILED: \"" << "nrows_ == x.size()" << "\" "
          << "setFromOuter, keeping memory: Wrong number of rows";
        if (ncols_ == y.size()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 4981) << "ASSERTION FAILED: \"" << "ncols_ == y.size()" << "\" "
          << "setFromOuter, keeping memory: Wrong number of columns";
        compact();
      }

      typename std::vector<value_type>::const_iterator it;
      size_type *indb = indb_;
      value_type *nzb = nzb_;

      for (it = y.begin(); it != y.end(); ++it)
        if (!isZero_(*it)) {
          *indb++ = (size_type)(it - y.begin());
          *nzb++ = *it;
        }

      size_type nnzr = (size_type)(indb - indb_);
      size_type *indb_end = indb;
      size_type k = 0;

      for (it = x.begin(); it != x.end(); ++it) {
        size_type row = (size_type)(it - x.begin());
        if (isZero_(*it)) {
          nnzr_[row] = 0;
          continue;
        }
        if (!keepMemory) {
          ind_[row] = new size_type[nnzr];
          nz_[row] = new value_type[nnzr];
        } else {
          ind_[row] = ind_mem_ + k * nnzr;
          nz_[row] = nz_mem_ + k * nnzr;
        }
        indb = indb_;
        nzb = nzb_;
        size_type *ind = ind_[row];
        value_type *nz = nz_[row];
        while (indb != indb_end) {
          value_type val = *it * *nzb;
          if (!isZero_(val)) {
            *ind++ = *indb;
            *nz++ = val;
          }
          ++indb; ++nzb;
        }
        nnzr_[row] = (size_type)(ind - ind_[row]);
        if (nnzr_[row] > 0)
          ++k;
      }
    }





    inline void
    setFromElementMultiplyWithOuter(const std::vector<value_type>& x,
                                    const std::vector<value_type>& y,
                                    const SparseMatrix& b)
    {
      deallocate_();
      allocate_(x.size(), y.size());
      nrows_ = x.size();
      ncols_ = y.size();

      typename std::vector<value_type>::const_iterator it;
      size_type *indb = indb_;
      value_type *nzb = nzb_;

      for (it = y.begin(); it != y.end(); ++it)
        if (!isZero_(*it)) {
          *indb++ = (size_type)(it - y.begin());
          *nzb++ = *it;
        }

      size_type nnzr = (size_type)(indb - indb_);
      size_type *indb_end = indb;

      for (it = x.begin(); it != x.end(); ++it) {
        size_type row = (size_type)(it - x.begin());
        if (isZero_(*it) || b.nNonZerosOnRow(row) == 0)
          continue;
        ind_[row] = new size_type[nnzr];
        nz_[row] = new value_type[nnzr];
        indb = indb_;
        nzb = nzb_;
        size_type *ind_a = ind_begin_(row);
        size_type *ind_b = b.ind_begin_(row);
        size_type *ind_b_end = b.ind_end_(row);
        value_type *nz_a = nz_begin_(row);
        value_type *nz_b = b.nz_begin_(row);
        while (indb != indb_end && ind_b != ind_b_end) {
          if (*indb == *ind_b) {
            value_type val = *it * *nzb * *nz_b;
            if (!isZero_(val)) {
              *ind_a++ = *indb;
              *nz_a++ = val;
            }
            ++indb; ++nzb;
            ++ind_b; ++nz_b;
          } else if (*indb < *ind_b) {
            ++indb; ++nzb;
          } else if (*ind_b < *indb) {
            ++ind_b; ++nz_b;
          }
        }
        nnzr_[row] = (size_type)(ind_a - ind_begin_(row));
      }
    }
# 5102 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator>
    inline void setRowFromDense(size_type row, InputIterator begin)
    {
      {
        boost::function_requires<boost::InputIteratorConcept<InputIterator> >();;
      }

      set_row_(row, begin, begin + nCols());
    }


    inline void setRowFromDense(size_type row, const std::vector<value_type>& x)
    {
      {
        if (x.size() == nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 5116) << "ASSERTION FAILED: \"" << "x.size() == nCols()" << "\" "
          << "setRowFromDense: Need vector with as many elements as "
          << "number of colums= " << nCols();
      }

      set_row_(row, x.begin(), x.end());
    }
# 5146 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator1, typename InputIterator2>
    inline void setRowFromSparse(size_type row,
                                 InputIterator1 ind_it, InputIterator1 ind_end,
                                 InputIterator2 nz_it)
    {
      {
        boost::function_requires<boost::InputIteratorConcept<InputIterator1> >();;
        boost::function_requires<boost::InputIteratorConcept<InputIterator2> >();;

        assert_valid_row_(row, "setRowFromSparse");
        assert_valid_sorted_index_range_(nCols(), ind_it, ind_end, "setRowFromSparse");

        for (InputIterator2 nz = nz_it; nz != nz_it + (ind_end - ind_it); ++nz)
          if (!isZero_(*nz)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 5159) << "ASSERTION FAILED: \"" << "!isZero_(*nz)" << "\" "
            << "SparseMatrix setRowFromSparse: Expecing only non-zeros";
      }

      size_type new_nnzr = (size_type)(ind_end - ind_it);

      if (new_nnzr > nnzr_[row]) {
        if (isCompact())
          decompact();
        delete [] ind_[row];
        delete [] nz_[row];
        ind_[row] = new size_type [new_nnzr];
        nz_[row] = new value_type [new_nnzr];
      }

      std::copy(ind_it, ind_end, ind_[row]);
      std::copy(nz_it, nz_it + new_nnzr, nz_[row]);
      nnzr_[row] = new_nnzr;
    }





    template <typename InputIterator1>
    inline void setRowFromSparseWInitVal(size_type row,
                                         InputIterator1 ind_it, InputIterator1 ind_end,
                                         value_type init_val)
    {
      {
        if (init_val != 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 5189) << "ASSERTION FAILED: \"" << "init_val != 0" << "\" ";
        boost::function_requires<boost::InputIteratorConcept<InputIterator1> >();;

        assert_valid_row_(row, "setRowFromSparseWInitVal");
        assert_valid_sorted_index_range_(nCols(), ind_it, ind_end,
                                         "setRowFromSparseWInitVal");
      }

      size_type new_nnzr = (size_type)(ind_end - ind_it);

      if (new_nnzr > nnzr_[row]) {
        if (isCompact())
          decompact();
        delete [] ind_[row];
        delete [] nz_[row];
        ind_[row] = new size_type [new_nnzr];
        nz_[row] = new value_type [new_nnzr];
      }

      std::copy(ind_it, ind_end, ind_[row]);
      std::fill(nz_[row], nz_[row] + new_nnzr, init_val);
      nnzr_[row] = new_nnzr;
    }
# 5231 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename OutputIterator>
    inline void getRowToDense(size_type row, OutputIterator it) const
    {
      {
        boost::function_requires<boost::OutputIteratorConcept<OutputIterator, value_type> >();;
        assert_valid_row_(row, "getRowToDense");
      }

      std::fill(it, it + nCols(), (value_type)0);

      size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
        *(it + *ind) = *nz;
      }
    }


    inline void getRowToDense(size_type row, std::vector<value_type>& dense) const
    {
      {
        assert_valid_row_(row, "getRowToDense");
      }

      typename std::vector<value_type>::iterator it = dense.begin();

      std::fill(it, it + nCols(), (value_type)0);

      size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
        *(it + *ind) = *nz;
      }
    }
# 5282 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename OutputIterator1, typename OutputIterator2>
    inline size_type
    getRowToSparse(size_type row, OutputIterator1 indIt, OutputIterator2 nzIt) const
    {
      {
        boost::function_requires<boost::OutputIteratorConcept<OutputIterator1, size_type> >();;
        boost::function_requires<boost::OutputIteratorConcept<OutputIterator2, value_type> >();;
        assert_valid_row_(row, "getRowToSparse");
      }

      size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
        *indIt = *ind;
        *nzIt = *nz;
        ++indIt; ++nzIt;
      }

      return nNonZerosOnRow(row);
    }


    template <typename OutputIterator1>
    inline size_type
    getRowIndicesToSparse(size_type row, OutputIterator1 indIt) const
    {
      {
        boost::function_requires<boost::OutputIteratorConcept<OutputIterator1, size_type> >();;
        assert_valid_row_(row, "getRowIndicesToSparse");
      }

      size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz)
        *indIt++ = *ind;

      return nNonZerosOnRow(row);
    }
# 5331 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename OutputIterator1>
    inline size_type getRowToSparse(size_type row, OutputIterator1 idxValIt) const
    {
      {
        assert_valid_row_(row, "getRowToSparse(pair<idx,val>)");
      }

      size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
        *idxValIt = std::make_pair(*ind, *nz);
        ++idxValIt;
      }

      return nNonZerosOnRow(row);
    }





    inline void copyRow(size_type dst_row, size_type src_row, SparseMatrix& other)
    {
      {
        assert_valid_row_(dst_row, "copyRow");
        other.assert_valid_row_(src_row, "copyRow");
      }

      if (&other == this && src_row == dst_row)
        return;

      size_type new_nnzr = other.nNonZerosOnRow(src_row);

      if (new_nnzr > nNonZerosOnRow(dst_row)) {
        if (isCompact())
          decompact();
        delete [] ind_[dst_row];
        delete [] nz_[dst_row];
        ind_[dst_row] = new size_type [new_nnzr];
        nz_[dst_row] = new value_type [new_nnzr];
      }

      std::copy(other.ind_[src_row], other.ind_[src_row] + new_nnzr, ind_[dst_row]);
      std::copy(other.nz_[src_row], other.nz_[src_row] + new_nnzr, nz_[dst_row]);
      nnzr_[dst_row] = new_nnzr;
    }
# 5390 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename OutputIterator>
    inline void getColToDense(size_type col, OutputIterator dense) const
    {
      {
        boost::function_requires<boost::OutputIteratorConcept<OutputIterator, value_type> >();;
        assert_valid_col_(col, "getColToDense");
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        const difference_type offset = col_(row, col);
        *dense = offset >= 0 ? *(nz_begin_(row) + offset) : value_type(0);
        ++dense;
      }
    }


    inline void getColToDense(size_type col, std::vector<value_type>& dense) const
    {
      {
        assert_valid_col_(col, "getColToDense");
      }

      typename std::vector<value_type>::iterator it = dense.begin();

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        const difference_type offset = col_(row, col);
        *it = offset >= 0 ? *(nz_begin_(row) + offset) : value_type(0);
        ++it;
      }
    }
# 5435 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename OutputIterator1, typename OutputIterator2>
    inline size_type
    getColToSparse(size_type col, OutputIterator1 indIt, OutputIterator2 nzIt) const
    {
      {
        boost::function_requires<boost::OutputIteratorConcept<OutputIterator1, size_type> >();;
        boost::function_requires<boost::OutputIteratorConcept<OutputIterator2, value_type> >();;
        assert_valid_col_(col, "getColToSparse");
      }

      size_type count = 0;

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        const difference_type offset = col_(row, col);
        if (offset >= 0) {
          *indIt = row;
          *nzIt = *(nz_begin_(row) + offset);
          ++indIt; ++nzIt;
          ++count;
        }
      }

      return count;
    }
# 5478 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename OutputIterator1>
    inline size_type getColToSparse(size_type col, OutputIterator1 idxValIt) const
    {
      {
        assert_valid_col_(col, "getColToSparse(pair<idx,val>)");
      }

      size_type count = 0;

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        const difference_type offset = col_(row, col);
        if (offset >= 0) {
          *idxValIt = std::make_pair(row, *(nz_begin_(row) + offset));
          ++idxValIt;
          ++count;
        }
      }

      return count;
    }


    template <typename InputIterator1>
    inline void setColFromDense(size_type col, InputIterator1 it)
    {
      {
        assert_valid_col_(col, "setColFromDense");
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        this->set(row, col, *it);
        ++it;
      }
    }


    inline void setColFromDense(size_type col, const std::vector<value_type>& x)
    {
      {
        if (x.size() == nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 5517) << "ASSERTION FAILED: \"" << "x.size() == nRows()" << "\" "
          << "SparseMatrix setColFromDense std: "
          << "Need vector with as many elements as "
          << "number of rows= " << nRows();
      }

      setColFromDense(col, x.begin());
    }
# 5549 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename UnaryFunction>
    inline void filterRow(size_type row, const UnaryFunction& f1)
    {
      {
        boost::function_requires<boost::UnaryFunctionConcept<UnaryFunction, bool, value_type> >();;
        assert_valid_row_(row, "filterRow");
      }

      size_type nnzr1 = nnzr_[row], nnzr2 = 0, *ind = ind_begin_(row);
      value_type *nz = nz_begin_(row);

      for (size_type k = 0; k != nnzr1; ++k)
        if (f1(nz[k])) {
          ind[nnzr2] = ind[k];
          nz[nnzr2] = nz[k];
          ++nnzr2;
        }

      nnzr_[row] = nnzr2;
    }


    template <typename UnaryFunction,
              typename OutputIterator1,
              typename OutputIterator2>
    inline size_type
    filterRow(size_type row, const UnaryFunction& f1,
              OutputIterator1 cut_ind, OutputIterator2 cut_nz)
    {
      {
        boost::function_requires<boost::UnaryFunctionConcept<UnaryFunction, bool, value_type> >();;
        assert_valid_row_(row, "filterRow");
      }

      size_type nnzr1 = nnzr_[row], nnzr2 = 0, *ind = ind_begin_(row);
      value_type *nz = nz_begin_(row);

      size_type count = 0;

      for (size_type k = 0; k != nnzr1; ++k)
        if (f1(nz[k])) {
          ind[nnzr2] = ind[k];
          nz[nnzr2] = nz[k];
          ++nnzr2;
        } else {
          *cut_ind++ = ind[k];
          *cut_nz++ = nz[k];
          ++count;
        }

      nnzr_[row] = nnzr2;

      return count;
    }
# 5618 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename UnaryFunction>
    inline void filterCol(size_type col, const UnaryFunction& f1)
    {
      {
        boost::function_requires<boost::UnaryFunctionConcept<UnaryFunction, bool, value_type> >();;
        assert_valid_col_(col, "filterCol");
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *ind_it = pos_(row, col);
        if (ind_it != ind_end_(row) && *ind_it == col) {
          size_type offset = size_type(ind_it - ind_begin_(row));
          if (!f1(nz_[row][offset]))
            erase_(row, ind_it);
        }
      }
    }
# 5652 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename UnaryFunction>
    inline void filter(const UnaryFunction& f1)
    {
      {
        boost::function_requires<boost::UnaryFunctionConcept<UnaryFunction, bool, value_type> >();;
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row)
        filterRow(row, f1);
    }


    template <typename UnaryFunction,
              typename OutputIterator1,
              typename OutputIterator2>
    inline size_type filter(const UnaryFunction& f1,
                            OutputIterator1 cut_i,
                            OutputIterator1 cut_j,
                            OutputIterator2 cut_nz)
    {
      {
        boost::function_requires<boost::UnaryFunctionConcept<UnaryFunction, bool, value_type> >();;
      }

      size_type count = 0;
      std::vector<size_type> indb(nCols());
      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type c = filterRow(row, f1, indb.begin(), cut_nz);
        for (size_type i = 0; i != c; ++i) {
          *cut_i++ = row;
          *cut_j++ = indb[i];
        }
        count += c;
      }

      return count;
    }
# 5700 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InIter>
    inline void permuteRows(InIter p)
    {
      std::vector<size_type> nnzr_old(nnzr_, nnzr_ + nrows_);
      std::vector<size_type*> ind_old(ind_, ind_ + nrows_);
      std::vector<value_type*> nz_old(nz_, nz_ + nrows_);

      for (size_type row = 0; row != nRows(); ++row, ++p) {
        nnzr_[row] = nnzr_old[*p];
        ind_[row] = ind_old[*p];
        nz_[row] = nz_old[*p];
      }
    }
# 5734 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InIter>
    inline void permuteCols(InIter p)
    {
      InIter p_begin = p, p_end = p + nCols();

      for (size_type row = 0; row != nRows(); ++row) {
        size_type* indb_end = indb_ + nNonZerosOnRow(row);
        std::copy(ind_begin_(row), ind_end_(row), indb_);
        std::copy(nz_begin_(row), nz_end_(row), nzb_);
        size_type *ind = ind_begin_(row);
        value_type *nz = nz_begin_(row);
        for (InIter i = p_begin; i != p_end; ++i) {
          size_type* w = std::lower_bound(indb_, indb_end, *i);
          if (w != indb_end && *w == *i) {
            *ind = size_type(std::find(p_begin, p_end, *i) - p_begin);
            *nz = *(nzb_ + (w - indb_));
            ++ind; ++nz;
          }
        }
      }
    }






    void shiftRows(int n)
    {
      if (n == 0)
        return;

      const size_type nrows = nRows();

      if ((size_type) ::abs(n) >= nrows)
        {
          setToZero();
          return;
        }

      size_type beginSource, endSource, beginDest,
        beginDelete, endDelete, beginZero, endZero;

      if (n > 0) {
        beginSource = 0;
        endSource = nrows - n;
        beginDest = n;
        beginDelete = endSource;
        endDelete = nrows;
        beginZero = beginSource;
        endZero = beginDest;
      } else {
        const size_type ln = -n;
        beginSource = ln;
        endSource = nrows;
        beginDest = 0;
        beginDelete = 0;
        endDelete = beginSource;
        beginZero = nrows - ln;
        endZero = endSource;
      }


      if (!isCompact()) {
        for (size_type i = beginDelete; i != endDelete; ++i) {
          if (nnzr_[i]) {
            delete[] ind_[i]; ind_[i] = 0;
            delete[] nz_[i]; nz_[i] = 0;
            nnzr_[i] = 0;
          }
        }
      } else {
        std::fill(ind_ + beginDelete, ind_ + endDelete, (size_type *) 0);
        std::fill(nz_ + beginDelete, nz_ + endDelete, (value_type *) 0);
        std::fill(nnzr_ + beginDelete, nnzr_ + endDelete, (size_type) 0);
      }

      if (beginSource < beginDest) {

        size_type nMove = (endSource - beginSource);
        std::copy(nnzr_ + beginSource, nnzr_ + beginSource + nMove, nnzr_ + beginDest);
        std::copy(ind_ + beginSource, ind_ + beginSource + nMove, ind_ + beginDest);
        std::copy(nz_ + beginSource, nz_ + beginSource + nMove, nz_ + beginDest);







      } else {
        std::copy(ind_ + beginSource, ind_ + endSource, ind_ + beginDest);
        std::copy(nz_ + beginSource, nz_ + endSource, nz_ + beginDest);
        std::copy(nnzr_ + beginSource, nnzr_ + endSource, nnzr_ + beginDest);
      }

      std::fill(ind_ + beginZero, ind_ + endZero, (size_type *) 0);
      std::fill(nz_ + beginZero, nz_ + endZero, (value_type *) 0);
      std::fill(nnzr_ + beginZero, nnzr_ + endZero, (size_type) 0);
    }






    void shiftCols(int n)
    {
      if (n == 0)
        return;

      const size_type ncols = nCols();
      if ((size_type) ::abs(n) >= ncols)
        {
          setToZero();
          return;
        }

      const size_type nrows = nRows();

      if (n > 0) {

        const size_type max = ncols - n;

        for (size_type row = 0; row != nrows; ++row) {

          size_type *ind_write = ind_begin_(row);
          const size_type *ind_begin = ind_write;
          const size_type *ind_end =
            std::lower_bound(ind_begin,
                             const_cast<const size_type *>(ind_end_(row)), max);

          for(; ind_write != ind_end; ++ind_write)
            *ind_write += n;

          nnzr_[row] = ind_write - ind_begin;
        }
      } else {

        size_type ln = -n;

        for (size_type row = 0; row != nrows; ++row) {

          size_type *ind_write = ind_begin_(row);
          const size_type *ind_end = ind_end_(row);

          const size_type *ind_begin =
            std::lower_bound(const_cast<const size_type *>(ind_write), ind_end, ln);
          size_type offset = ind_begin - ind_write;

          std::copy(ind_begin, ind_end, ind_write);

          value_type *nz_write = nz_begin_(row);
          const value_type *nz_begin = nz_write + offset;
          const value_type *nz_end = nz_end_(row);

          std::copy(nz_begin, nz_end, nz_write);

          nnzr_[row] -= offset;
          ind_end -= offset;
          for(; ind_write != ind_end; ++ind_write)
            *ind_write -= ln;
        }
      }
    }
# 5927 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename UnaryFunction>
    inline void elementRowNZApply(size_type row, const UnaryFunction& f1)
    {
      {
        boost::function_requires<boost::UnaryFunctionConcept<UnaryFunction, value_type, value_type> >();;
        assert_valid_row_(row, "elementRowNZApply");
      }

      size_type *ind = ind_begin_(row), *ind_end = ind_end_(row);
      value_type *nz = nz_begin_(row);
      size_type offset = 0;

      for (; ind != ind_end; ++ind, ++nz) {
        value_type val = f1(*nz);
        if (isZero_(val)) {
          ++ offset;
        } else {
          *(nz - offset) = val;
          *(ind - offset) = *ind;
        }
      }

      nnzr_[row] -= offset;
    }
# 5967 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename UnaryFunction>
    inline void elementColNZApply(size_type col, const UnaryFunction& f1)
    {
      {
        boost::function_requires<boost::UnaryFunctionConcept<UnaryFunction, value_type, value_type> >();;
        assert_valid_col_(col, "elementColNZApply");
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        const difference_type offset = col_(row, col);
        if (offset >= 0) {
          value_type *nz = nz_begin_(row) + offset;
          *nz = f1(*nz);
          if (isZero_(*nz))
            erase_(row, ind_begin_(row) + offset);
        }
      }
    }
# 6000 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename UnaryFunction>
    inline void elementNZApply(const UnaryFunction& f1)
    {
      {
        boost::function_requires<boost::UnaryFunctionConcept<UnaryFunction, value_type, value_type> >();;
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row)
        elementRowNZApply(row, f1);
    }
# 6029 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename UnaryFunction>
    inline void elementRowApply(size_type row, const UnaryFunction& f1)
    {
      {
        boost::function_requires<boost::UnaryFunctionConcept<UnaryFunction, value_type, value_type> >();;
        assert_valid_row_(row, "elementRowApply");
      }

      to_nzb_(row);

      value_type *nzb = nzb_, *nzb_end = nzb_ + nCols();

      for (; nzb != nzb_end; ++nzb)
        *nzb = f1(*nzb);

      set_row_(row, nzb_, nzb_ + nCols());
    }
# 6066 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename UnaryFunction>
    inline void elementColApply(size_type col, const UnaryFunction& f1)
    {
      {
        boost::function_requires<boost::UnaryFunctionConcept<UnaryFunction, value_type, value_type> >();;
        assert_valid_col_(col, "elementColApply");
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row)
        set(row, col, f1(get(row, col)));
    }
# 6093 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename UnaryFunction>
    inline void elementApply(const UnaryFunction& f1)
    {
      {
        boost::function_requires<boost::UnaryFunctionConcept<UnaryFunction, value_type, value_type> >();;
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row)
        elementRowApply(row, f1);
    }
# 6121 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename BinaryFunction, typename InputIterator>
    inline void
    elementRowNZApply(size_type row, const BinaryFunction& f2, InputIterator x_begin)
    {
      {
        boost::function_requires<boost::BinaryFunctionConcept<BinaryFunction, value_type, value_type, value_type> >();;
        boost::function_requires<boost::InputIteratorConcept<InputIterator> >();;
        assert_valid_row_(row, "elementRowNZApply");
      }

      size_type *ind = ind_begin_(row), *ind_end = ind_end_(row);
      value_type *nz = nz_begin_(row);
      size_type offset = 0;

      for (; ind != ind_end; ++ind, ++nz) {
        value_type val = f2(*nz, *(x_begin + *ind));
        if (isZero_(val)) {
          ++ offset;
        } else {
          *(nz - offset) = val;
          *(ind - offset) = *ind;
        }
      }

      nnzr_[row] -= offset;
    }






    template <typename BinaryFunction, typename InputIterator, typename OutputIterator>
    inline void
    elementRowNZApply(size_type row, const BinaryFunction& f2,
                      InputIterator x, OutputIterator y) const
    {
      {
        boost::function_requires<boost::BinaryFunctionConcept<BinaryFunction, value_type, value_type, value_type> >();;
        boost::function_requires<boost::InputIteratorConcept<InputIterator> >();;
        assert_valid_row_(row, "elementRowNZApply");
      }

      if (nnzr_[row] == 0) {
        std::fill(y, y + nCols(), (value_type) 0);
        return;
      }

      size_type *ind = ind_begin_(row), *ind_end = ind_end_(row);
      value_type *nz = nz_begin_(row);

      for (size_type col = 0; col != nCols(); ++col, ++y, ++x) {
        if (ind != ind_end && *ind == col) {
          *y = f2(*nz, *x);
          ++ind; ++nz;
        } else {
          *y = 0;
        }
      }
    }
# 6199 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename BinaryFunction, typename InputIterator>
    inline void
    elementRowApply(size_type row, const BinaryFunction& f2, InputIterator x_begin)
    {
      {
        boost::function_requires<boost::BinaryFunctionConcept<BinaryFunction, value_type, value_type, value_type> >();;
        boost::function_requires<boost::InputIteratorConcept<InputIterator> >();;
        assert_valid_row_(row, "elementRowApply");
      }

      value_type *nzb_end = nzb_ + nCols();

      to_nzb_(row);

      for (value_type *nzb = nzb_; nzb != nzb_end; ++nzb, ++x_begin)
        *nzb = f2(*nzb, *x_begin);

      set_row_(row, nzb_, nzb_ + nCols());
    }






    template <typename BinaryFunction, typename InputIterator, typename OutputIterator>
    inline void
    elementRowApply(size_type row, const BinaryFunction& f2,
                    InputIterator x, OutputIterator y) const
    {
      {
        boost::function_requires<boost::BinaryFunctionConcept<BinaryFunction, value_type, value_type, value_type> >();;
        boost::function_requires<boost::InputIteratorConcept<InputIterator> >();;
        assert_valid_row_(row, "elementRowApply");
      }

      if (nnzr_[row] == 0) {
        InputIterator x_end = x + nCols();
        for (; x != x_end; ++x, ++y)
          *y = f2(0, *x);
        return;
      }

      size_type *ind = ind_begin_(row), *ind_end = ind_end_(row);
      value_type *nz = nz_begin_(row);

      for (size_type col = 0; col != nCols(); ++col, ++y, ++x) {
        if (ind != ind_end && *ind == col) {
          *y = f2(*nz, *x);
          ++ind; ++nz;
        } else {
          *y = f2(0, *x);
        }
      }
    }
# 6272 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename BinaryFunction, typename InputIterator>
    inline void
    elementColNZApply(size_type col, const BinaryFunction& f2, InputIterator x_begin)
    {
      {
        boost::function_requires<boost::BinaryFunctionConcept<BinaryFunction, value_type, value_type, value_type> >();;
        boost::function_requires<boost::InputIteratorConcept<InputIterator> >();;
        assert_valid_col_(col, "elementColNZApply");
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        const difference_type offset = col_(row, col);
        if (offset >= 0) {
          value_type *nz = nz_begin_(row) + offset;
          *nz = f2(*nz, *x_begin);
          if (isZero_(*nz))
            erase_(row, ind_begin_(row) + offset);
        }
        ++x_begin;
      }
    }


    template <typename BinaryFunction, typename InputIterator, typename OutputIterator>
    inline void
    elementColNZApply(size_type col, const BinaryFunction& f2,
                      InputIterator x, OutputIterator y) const
    {
      {
        boost::function_requires<boost::BinaryFunctionConcept<BinaryFunction, value_type, value_type, value_type> >();;
        boost::function_requires<boost::InputIteratorConcept<InputIterator> >();;
        assert_valid_col_(col, "elementColNZApply");
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        const difference_type offset = col_(row, col);
        *y = offset >= 0 ? f2(*(nz_begin_(row) + offset), *x) : 0;
        ++x; ++y;
      }
    }
# 6330 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename BinaryFunction, typename InputIterator>
    inline void
    elementColApply(size_type col, const BinaryFunction& f2, InputIterator x_begin)
    {
      {
        boost::function_requires<boost::BinaryFunctionConcept<BinaryFunction, value_type, value_type, value_type> >();;
        boost::function_requires<boost::InputIteratorConcept<InputIterator> >();;
        assert_valid_col_(col, "elementColApply");
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        set(row, col, f2(get(row, col), *x_begin));
        ++x_begin;
      }
    }
# 6360 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename BinaryFunction>
    inline void
    elementNZApply(const SparseMatrix& other, const BinaryFunction& f2)
    {
      {
        boost::function_requires<boost::BinaryFunctionConcept<BinaryFunction, value_type, value_type, value_type> >();;
        if (other.nRows() == nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 6366) << "ASSERTION FAILED: \"" << "other.nRows() == nRows()" << "\" "
          << "SparseMatrix elementNZApply: Number of rows don't match: "
          << nRows() << " and " << other.nRows();
        if (other.nCols() == nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 6369) << "ASSERTION FAILED: \"" << "other.nCols() == nCols()" << "\" "
          << "SparseMatrix elementNZApply: Number of columns don't match: "
          << nCols() << " and " << other.nCols();
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type nnzr2 = 0;
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          value_type val = f2(*nz, other.get(row, *ind));
          if (!isZero_(val)) {
            ind_[row][nnzr2] = *ind;
            nz_[row][nnzr2] = val;
            ++nnzr2;
          }
        }
        nnzr_[row] = nnzr2;
      }
    }
# 6401 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename BinaryFunction>
    inline void
    elementApply(const SparseMatrix& other, const BinaryFunction& f2)
    {
      {
        boost::function_requires<boost::BinaryFunctionConcept<BinaryFunction, value_type, value_type, value_type> >();;
        if (other.nRows() == nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 6407) << "ASSERTION FAILED: \"" << "other.nRows() == nRows()" << "\" "
          << "SparseMatrix elementApply: Number of rows don't match: "
          << nRows() << " and " << other.nRows();
        if (other.nCols() == nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 6410) << "ASSERTION FAILED: \"" << "other.nCols() == nCols()" << "\" "
          << "SparseMatrix elementApply: Number of columns don't match: "
          << nCols() << " and " << other.nCols();

      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        const_cast<SparseMatrix&>(other).to_nzb_(row);
        elementRowApply(row, f2, other.nzb_);
      }
    }
# 6431 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator, typename UnaryFunction>
    inline void
    applyOuter(InputIterator row_begin, InputIterator row_end,
               InputIterator col_begin, InputIterator col_end,
               const UnaryFunction& f1)
    {
      {
        boost::function_requires<boost::UnaryFunctionConcept<UnaryFunction, value_type, value_type> >();;
        boost::function_requires<boost::InputIteratorConcept<InputIterator> >();;
      }

      for (InputIterator row = row_begin; row != row_end; ++row) {
        for (InputIterator col = col_begin; col != col_end; ++col) {
          size_type i = *row, j = *col;
          set(i, j, f1(get(i, j)));
        }
      }
    }
# 6462 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator, typename BinaryFunction, typename Other>
    inline void
    applyOuter(InputIterator row_begin, InputIterator row_end,
               InputIterator col_begin, InputIterator col_end,
               const BinaryFunction& f2, const Other& other)
    {
      {
        boost::function_requires<boost::BinaryFunctionConcept<BinaryFunction, value_type, value_type, value_type> >();;
        boost::function_requires<boost::InputIteratorConcept<InputIterator> >();;
      }

      size_type i_other = 0;
      for (InputIterator row = row_begin; row != row_end; ++row, ++i_other) {
        size_type j_other = 0;
        for (InputIterator col = col_begin; col != col_end; ++col, ++j_other) {
          size_type i = *row, j = *col;
          set(i, j, f2(get(i,j), other.get(i_other, j_other)));
        }
      }
    }
# 6503 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename BinaryFunction>
    inline value_type accumulateRowNZ(size_type row, const BinaryFunction& f2,
                                      const value_type& init =0) const
    {
      {
        boost::function_requires<boost::BinaryFunctionConcept<BinaryFunction, value_type, value_type, value_type> >();;
        assert_valid_row_(row, "accumulateRowNZ");
      }

      value_type *nz = nz_begin_(row);
      value_type *nz_end1 = nz + 4*(nnzr_[row] / 4), *nz_end2 = nz_end_(row);
      value_type result = init;

      for (; nz != nz_end1; nz += 4) {
        result = f2(result, *nz);
        result = f2(result, *(nz+1));
        result = f2(result, *(nz+2));
        result = f2(result, *(nz+3));
      }

      for (; nz != nz_end2; ++nz)
        result = f2(result, *nz);

      return result;


    }
# 6550 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename OutputIterator, typename BinaryFunction>
    inline void accumulateAllRowsNZ(OutputIterator result, const BinaryFunction& f2,
                                    const value_type& init =0) const
    {
      {
        boost::function_requires<boost::BinaryFunctionConcept<BinaryFunction, value_type, value_type, value_type> >();;
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        *result = accumulateRowNZ(row, f2, init);
        ++result;
      }
    }
# 6579 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename BinaryFunction>
    inline value_type accumulateRow(size_type row, const BinaryFunction& f2,
                                    const value_type& init =0) const
    {
      {
        boost::function_requires<boost::BinaryFunctionConcept<BinaryFunction, value_type, value_type, value_type> >();;
        assert_valid_row_(row, "accumulateRow");
      }

      size_type col = 0;
      value_type result = init;

      size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
        size_type ind_end2 = *ind;
        while (col != ind_end2) {
          result = f(result, value_type(0));
          ++col;
        }
        result = f2(result, *nz);
      }

      return result;
    }
# 6622 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename OutputIterator, typename BinaryFunction>
    inline void accumulateAllRows(OutputIterator result, const BinaryFunction& f2,
                                  const value_type& init =0) const
    {
      {
        boost::function_requires<boost::BinaryFunctionConcept<BinaryFunction, value_type, value_type, value_type> >();;
        boost::function_requires<boost::OutputIteratorConcept<OutputIterator, value_type> >();;
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        *result = accumulateRow(row, f2, init);
        ++result;
      }
    }
# 6652 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename BinaryFunction>
    inline value_type accumulateColNZ(size_type col, const BinaryFunction& f2,
                                      const value_type& init =0) const
    {
      {
        boost::function_requires<boost::BinaryFunctionConcept<BinaryFunction, value_type, value_type, value_type> >();;
        assert_valid_col_(col, "accumulateColNZ");
      }

      value_type result = init;

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        const difference_type offset = col_(row, col);
        if (offset >= 0)
          result = f2(result, value_(row, offset));
      }

      return result;
    }
# 6691 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename OutputIterator, typename BinaryFunction>
    inline void accumulateAllColsNZ(OutputIterator result, const BinaryFunction& f2,
                                    const value_type& init =0) const
    {
      {
        boost::function_requires<boost::BinaryFunctionConcept<BinaryFunction, value_type, value_type, value_type> >();;
        boost::function_requires<boost::OutputIteratorConcept<OutputIterator, value_type> >();;
      }

      std::fill(result, result + nCols(), (value_type)init);

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          value_type& res = result[*ind];
          res = f2(res, *nz);
        }
      }
    }
# 6725 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename BinaryFunction>
    inline value_type accumulateCol(size_type col, const BinaryFunction& f2,
                                    const value_type& init =0) const
    {
      {
        boost::function_requires<boost::BinaryFunctionConcept<BinaryFunction, value_type, value_type, value_type> >();;
        assert_valid_col_(col, "accumulate");
      }

      value_type result = init;

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        const difference_type offset = col_(row, col);
        if (offset >= 0)
          result = f2(result, value_(row, offset));
        else
          result = f2(result, value_type(0));
      }

      return result;
    }
# 6766 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename OutputIterator, typename BinaryFunction>
    inline void accumulateAllCols(OutputIterator result, const BinaryFunction& f2,
                                  const value_type& init =0) const
    {
      {
        boost::function_requires<boost::BinaryFunctionConcept<BinaryFunction, value_type, value_type, value_type> >();;
        boost::function_requires<boost::OutputIteratorConcept<OutputIterator, value_type> >();;
      }

      const size_type ncols = nCols();

      std::fill(result, result + nCols(), (value_type)init);

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *ind = ind_begin_(row);
        value_type *nz = nz_begin_(row);
        for (size_type col = 0; col != ncols; ++col) {
          if (col == *ind) {
            value_type& res = result[*ind];
            res = f(res, *nz);
            ++ind; ++nz;
          } else {
            result[col] = f(result[col], value_type(0));
          }
        }
      }
    }
# 6810 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename BinaryFunction>
    inline value_type accumulateNZ(BinaryFunction f2, const value_type& init) const
    {
      {
        boost::function_requires<boost::BinaryFunctionConcept<BinaryFunction, value_type, value_type, value_type> >();;
      }

      value_type result = init;

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row)
        result = accumulateRowNZ(row, f2, result);

      return result;
    }
# 6841 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename BinaryFunction>
    inline value_type accumulate(BinaryFunction f2, const value_type& init) const
    {
      {
        boost::function_requires<boost::BinaryFunctionConcept<BinaryFunction, value_type, value_type, value_type> >();;
      }

      value_type result = init;

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row)
        result = accumulateRow(row, f2, result);

      return result;
    }
# 6870 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void transpose(SparseMatrix& tr) const
    {
      using namespace std;

      vector<vector<size_type> > tind(nCols());
      vector<vector<value_type> > tnz(nCols());

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          tind[*ind].push_back(row);
          tnz[*ind].push_back(*nz);
        }
      }

      size_type nnz = nNonZeros();
      size_type tnrows = nCols();
      size_type tncols = nRows();

      tr.deallocate_();
      tr.allocate_(tnrows, tncols);
      tr.nrows_ = tnrows;
      tr.ncols_ = tncols;

      tr.ind_mem_ = new size_type[nnz];
      size_type *indp = tr.ind_mem_;
      tr.nz_mem_ = new value_type[nnz];
      value_type *nzp = tr.nz_mem_;

      for (size_type row = 0; row != tnrows; ++row) {
        const vector<size_type>& rind = tind[row];
        const vector<value_type>& rnz = tnz[row];
        size_type nk = (size_type) rind.size();
        tr.nnzr_[row] = nk;
        tr.ind_[row] = indp;
        tr.nz_[row] = nzp;
        for (size_type k = 0; k != nk; ++k) {
          *indp++ = rind[k];
          *nzp++ = rnz[k];
        }
      }
    }





    inline void transpose()
    {
      using namespace std;

      vector<vector<size_type> > tind(nCols());
      vector<vector<value_type> > tnz(nCols());

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          tind[*ind].push_back(row);
          tnz[*ind].push_back(*nz);
        }
      }

      size_type nnz = nNonZeros();
      size_type tnrows = nCols();
      size_type tncols = nRows();

      deallocate_();
      allocate_(tnrows, tncols);
      ind_mem_ = new size_type [nnz];
      nz_mem_ = new value_type [nnz];

      nrows_ = tnrows;
      ncols_ = tncols;

      size_type *indp = ind_mem_;
      value_type *nzp = nz_mem_;

      for (size_type row = 0; row != tnrows; ++row) {
        const vector<size_type>& rind = tind[row];
        const vector<value_type>& rnz = tnz[row];
        size_type nk = rind.size();
        nnzr_[row] = nk;
        ind_[row] = indp;
        nz_[row] = nzp;
        for (size_type k = 0; k != nk; ++k) {
          *indp++ = rind[k];
          *nzp++ = rnz[k];
        }
      }
    }





    inline void addToTranspose(SparseMatrix& sm) const
    {
      {
        if (nRows() == nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 6966) << "ASSERTION FAILED: \"" << "nRows() == nCols()" << "\" "
          << "SparseMatrix addToTranspose: "
          << "Matrix needs to be square";
      }

      SparseMatrix tmp(nCols(), nCols());
      this->transpose(tmp);
      sm.copy(*this);
      sm.add(tmp);
    }





    inline void addToTranspose()
    {
      {
        if (nRows() == nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 6984) << "ASSERTION FAILED: \"" << "nRows() == nCols()" << "\" "
          << "SparseMatrix addToTranspose: "
          << "Matrix needs to be square";
      }

      SparseMatrix tmp(nCols(), nCols());
      this->transpose(tmp);
      this->add(tmp);
    }
# 7010 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void
    thresholdRow(size_type row, const value_type& threshold =nta::Epsilon)
    {
      {
        assert_valid_row_(row, "thresholdRow");
      }

      filterRow(row, std::bind2nd(std::greater_equal<value_type>(), threshold));
    }


    template <typename OutputIterator1, typename OutputIterator2>
    inline size_type thresholdRow(size_type row,
                                  const value_type& threshold,
                                  OutputIterator1 cut_j,
                                  OutputIterator2 cut_nz)
    {
      {
        assert_valid_row_(row, "thresholdRow");
      }

      return filterRow(row,
                       std::bind2nd(std::greater_equal<value_type>(),threshold),
                       cut_j, cut_nz);
    }
# 7049 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline
    void thresholdCol(size_type col, const value_type& threshold =nta::Epsilon)
    {
      {
        assert_valid_col_(col, "thresholdCol");
      }

      filterCol(col, std::bind2nd(std::greater_equal<value_type>(), threshold));
    }
# 7071 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void threshold(const value_type& threshold =nta::Epsilon)
    {
      filter(std::bind2nd(std::greater_equal<value_type>(),threshold));
    }


    template <typename OutputIterator1, typename OutputIterator2>
    inline size_type threshold(const value_type& threshold,
                               OutputIterator1 cut_i,
                               OutputIterator1 cut_j,
                               OutputIterator2 cut_nz)
    {
      return filter(std::bind2nd(std::greater_equal<value_type>(),threshold),
                    cut_i, cut_j, cut_nz);
    }
# 7107 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline
    void clipRow(size_type row, value_type val, bool above =true)
    {
      {
        assert_valid_row_(row, "clipRow");
      }

      if (above)
        elementRowNZApply(row, ClipAbove<value_type>(val));
      else
        elementRowNZApply(row, ClipBelow<value_type>(val));
    }





    inline void
    clipRowAboveAndBelow(size_type row, value_type a, value_type b)
    {
      {
        assert_valid_row_(row, "clipRowAboveAndBelow");
        if (a <= b) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 7129) << "ASSERTION FAILED: \"" << "a <= b" << "\" ";
      }

      elementRowNZApply(row, ClipBelow<value_type>(a));
      elementRowNZApply(row, ClipAbove<value_type>(b));
    }
# 7154 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline
    void clipCol(size_type col, value_type val, bool above =true)
    {
      {
        assert_valid_col_(col, "clipCol");
      }

      if (above)
        elementColNZApply(col, ClipAbove<value_type>(val));
      else
        elementColNZApply(col, ClipBelow<value_type>(val));
    }





    inline void
    clipColAboveAndBelow(size_type col, value_type a, value_type b)
    {
      {
        assert_valid_col_(col, "clipColAboveAndBelow");
        if (a <= b) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 7176) << "ASSERTION FAILED: \"" << "a <= b" << "\" ";
      }

      elementColNZApply(col, ClipBelow<value_type>(a));
      elementColNZApply(col, ClipAbove<value_type>(b));
    }
# 7196 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void clip(value_type val, bool above =true)
    {
      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row)
        clipRow(row, val, above);
    }





    inline void clipAboveAndBelow(value_type a, value_type b)
    {
      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row)
        clipRowAboveAndBelow(row, a, b);
    }
# 7238 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename UnaryPredicate>
    inline size_type
    countWhere(size_type begin_row, size_type end_row,
               size_type begin_col, size_type end_col,
               const UnaryPredicate& f1) const
    {
      {
        boost::function_requires<boost::UnaryPredicateConcept<UnaryPredicate, value_type> >();;
        assert_valid_box_(begin_row, end_row, begin_col, end_col, "countWhere");
      }

      size_type count = 0;

      for (size_type row = begin_row; row != end_row; ++row) {
        size_type *ind = __null, *ind_end = __null; value_type *nz = nz_begin_(row) + pos_(row, begin_col, end_col, ind, ind_end); for (; ind != ind_end; ++ind, ++nz) {
          if (f1(*nz))
            ++count;
        }
      }

      if (f1(0))
        count += (end_row-begin_row)*(end_col-begin_col)
          - nNonZerosInBox(begin_row, end_row, begin_col, end_col);

      {
        if (0 <= count && count <= (end_row-begin_row)*(end_col-begin_col)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 7263) << "ASSERTION FAILED: \"" << "0 <= count && count <= (end_row-begin_row)*(end_col-begin_col)" << "\" "
          << "SparseMatrix countWhere: "
          << "post-condition: Found count = " << count
          << " when box has size = " << (end_row-begin_row)*(end_col-begin_col);
      }

      return count;
    }
# 7298 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename UnaryPredicate, typename OutputIterator1>
    inline void
    findIndices(size_type begin_row, size_type end_row,
                size_type begin_col, size_type end_col,
                const UnaryPredicate& f1,
                OutputIterator1 row_it, OutputIterator1 col_it) const
    {
      {
        boost::function_requires<boost::UnaryPredicateConcept<UnaryPredicate, value_type> >();;
        boost::function_requires<boost::OutputIteratorConcept<OutputIterator1, size_type> >();;
        assert_valid_box_(begin_row, end_row, begin_col, end_col, "findIndices");
      }

      if (!f1(0)) {

        for (size_type row = begin_row; row != end_row; ++row) {
          size_type *ind = __null, *ind_end = __null; value_type *nz = nz_begin_(row) + pos_(row, begin_col, end_col, ind, ind_end); for (; ind != ind_end; ++ind, ++nz) {
            value_type v = *nz;
            if (f1(v)) {
              *row_it = row;
              *col_it = *ind;
              ++row_it; ++col_it;
            }
          }
        }

      } else {

        for (size_type row = begin_row; row != end_row; ++row) {
          size_type j = begin_col;
          size_type *ind = __null, *ind_end = __null; value_type *nz = nz_begin_(row) + pos_(row, begin_col, end_col, ind, ind_end); for (; ind != ind_end; ++ind, ++nz) {
            size_type l = *ind;
            for (; j != l; ++j) {
              *row_it = row;
              *col_it = j;
              ++row_it; ++col_it;
            }
            value_type v = *nz;
            if (f1(v)) {
              *row_it = row;
              *col_it = *ind;
              ++row_it; ++col_it;
            }
            ++j;
          }
          size_type l = std::min(end_col, nCols());
          for (; j != l; ++j) {
            *row_it = row;
            *col_it = j;
            ++row_it; ++col_it;
          }
        }
      }
    }
# 7372 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline size_type countWhereEqual(size_type begin_row, size_type end_row,
                                     size_type begin_col, size_type end_col,
                                     const value_type& value) const
    {
      {
      }

      return countWhere(begin_row, end_row, begin_col, end_col,
                        std::bind2nd(std::equal_to<value_type>(), value));
    }
# 7405 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename OutputIterator1>
    inline void whereEqual(size_type begin_row, size_type end_row,
                           size_type begin_col, size_type end_col,
                           const value_type& value,
                           OutputIterator1 row_it, OutputIterator1 col_it) const
    {
      {
        boost::function_requires<boost::OutputIteratorConcept<OutputIterator1, size_type> >();;
      }

      findIndices(begin_row, end_row, begin_col, end_col,
                  std::bind2nd(std::equal_to<value_type>(), value),
                  row_it, col_it);
    }
# 7439 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline size_type countWhereGreater(size_type begin_row, size_type end_row,
                                       size_type begin_col, size_type end_col,
                                       const value_type& value) const
    {
      {
      }

      return countWhere(begin_row, end_row, begin_col, end_col,
                        std::bind2nd(std::greater<value_type>(), value));
    }
# 7472 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename OutputIterator1>
    inline void whereGreater(size_type begin_row, size_type end_row,
                             size_type begin_col, size_type end_col,
                             const value_type& value,
                             OutputIterator1 row_it, OutputIterator1 col_it) const
    {
      {
        boost::function_requires<boost::OutputIteratorConcept<OutputIterator1, size_type> >();;
      }

      findIndices(begin_row, end_row, begin_col, end_col,
                  std::bind2nd(std::greater<value_type>(), value),
                  row_it, col_it);
    }
# 7506 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline size_type countWhereGreaterEqual(size_type begin_row, size_type end_row,
                                            size_type begin_col, size_type end_col,
                                            const value_type& value) const
    {
      {
      }

      return countWhere(begin_row, end_row, begin_col, end_col,
                        std::bind2nd(std::greater_equal<value_type>(), value));
    }
# 7539 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename OutputIterator1>
    inline void whereGreaterEqual(size_type begin_row, size_type end_row,
                                  size_type begin_col, size_type end_col,
                                  const value_type& value,
                                  OutputIterator1 row_it, OutputIterator1 col_it) const
    {
      {
        boost::function_requires<boost::OutputIteratorConcept<OutputIterator1, size_type> >();;
      }

      findIndices(begin_row, end_row, begin_col, end_col,
                  std::bind2nd(std::greater_equal<value_type>(), value),
                  row_it, col_it);
    }
# 7562 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename IndIt, typename NzIt>
    inline size_type findRow(size_type nnzr, IndIt ind_it, NzIt nz_it)
    {
      {
        if (nnzr >= 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 7566) << "ASSERTION FAILED: \"" << "nnzr >= 0" << "\" "
          << "SparseMatrix::findRow(): "
          << "Passed in " << nnzr << " non-zeros";

        if (nnzr <= nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 7570) << "ASSERTION FAILED: \"" << "nnzr <= nCols()" << "\" "
          << "SparseMatrix::findRow(): "
          << "Passed in " << nnzr << " non-zeros "
          << "but there are only " << nCols() << " columns";


        IndIt jj = ind_it;
        NzIt nn = nz_it;
        size_type j = 0, prev = 0;
        for (j = 0; j != nnzr; ++j, ++jj, ++nn) {
          if (0 <= *jj && *jj < nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 7580) << "ASSERTION FAILED: \"" << "0 <= *jj && *jj < nCols()" << "\" "
            << "SparseMatrix::findRow(): "
            << "Invalid column index"
            << " - Should be >= 0 and < " << nCols();
          if (!isZero_(*nn)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 7584) << "ASSERTION FAILED: \"" << "!isZero_(*nn)" << "\" "
            << "SparseMatrix::findRow(): "
            << "Passed zero at index: " << *jj
            << " - Should pass non-zeros only";
          if (j > 0) {
            if (prev < *jj) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 7589) << "ASSERTION FAILED: \"" << "prev < *jj" << "\" "
              << "SparseMatrix::findRow(): "
              << "Indices need to be in strictly increasing order";
          }
          prev = *jj;
        }

      }

      for (size_type i = 0; i != nnzr; ++i, ++ind_it, ++nz_it) {
        indb_[i] = *ind_it;
        nzb_[i] = *nz_it;
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        if (nnzr == nnzr_[row]) {
          size_type j = 0, *ind = ind_[row];
          value_type *nz = nz_[row];
          while ((j != nnzr) && (indb_[j] == ind[j]) && (nearlyEqual(nzb_[j], nz[j])))
            ++j;
          if (j == nnzr)
            return row;
        }
      }

      return nrows;
    }






    template <typename F, typename MatchIt>
    inline void findAllRows(F f, MatchIt m_it) const
    {
      for (size_type i = 0; i != nRows(); ++i) {
        if (f(ind_[i], ind_[i] + nnzr_[i], nz_[i])) {
          *m_it = i;
          ++m_it;
        }
      }
    }
# 7641 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename BinaryFunction>
    inline void
    extremumNZ(size_type& ext_row, size_type& ext_col, value_type& ext_val,
               const BinaryFunction& f2) const
    {
      ext_row = ext_col = 0;

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          value_type val = *nz;
          if (f2(val, ext_val)) {
            ext_val = val;
            ext_row = row;
            ext_col = *ind;
          }
        }
      }
    }
# 7672 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void max(size_type& max_row, size_type& max_col, value_type& max_val) const
    {
      max_val = - std::numeric_limits<value_type>::max();
      extremumNZ(max_row, max_col, max_val, std::greater<value_type>());

      if (max_val == - std::numeric_limits<value_type>::max())
        max_val = 0;
    }
# 7693 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void min(size_type& min_row, size_type& min_col, value_type& min_val) const
    {
      min_val = std::numeric_limits<value_type>::max();
      extremumNZ(min_row, min_col, min_val, std::less<value_type>());

      if (min_val == std::numeric_limits<value_type>::max())
        min_val = 0;
    }





    template <typename BinaryFunction>
    inline void
    rowExtremumNZ(size_type row, size_type& idx, value_type& ext_val,
                  const BinaryFunction& f2) const
    {
      idx = 0;

      size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
        value_type val = *nz;
        if (f2(val, ext_val)) {
          ext_val = val;
          idx = *ind;
        }
      }
    }
# 7733 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void rowMax(size_type row, size_type& row_max_j, value_type& row_max) const
    {
      {
        assert_valid_row_(row, "rowMax");
      }

      row_max = - std::numeric_limits<value_type>::max();

      rowExtremumNZ(row, row_max_j, row_max, std::greater<value_type>());

      if (row_max == - std::numeric_limits<value_type>::max())
        row_max = value_type(0);
    }
# 7758 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void rowMin(size_type row, size_type& row_min_j, value_type& row_min) const
    {
      {
        assert_valid_row_(row, "rowMin");
      }

      row_min = std::numeric_limits<value_type>::max();

      rowExtremumNZ(row, row_min_j, row_min, std::less<value_type>());

      if (row_min == std::numeric_limits<value_type>::max())
        row_min = value_type(0);
    }
# 7787 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename Maxima>
    inline void rowMax(Maxima maxima) const
    {
      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row)
        rowMax(row, maxima[row].first, maxima[row].second);
    }





    template <typename OutputIterator1, typename OutputIterator2>
    inline void rowMax(OutputIterator1 indices, OutputIterator2 values) const
    {
      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        rowMax(row, *indices, *values);
        ++indices; ++values;
      }
    }
# 7823 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename Minima>
    inline void rowMin(Minima minima) const
    {
      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row)
        rowMin(row, minima[row].first, minima[row].second);
    }





    template <typename OutputIterator1, typename OutputIterator2>
    inline void rowMin(OutputIterator1 indices, OutputIterator2 values) const
    {
      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        rowMin(row, *indices, *values);
        ++indices; ++values;
      }
    }






    template <typename BinaryFunction>
    inline void
    colExtremumNZ(size_type col, size_type& idx, value_type& ext_val,
                  const BinaryFunction& f2) const
    {
      idx = 0;

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *ind_it = pos_(row, col);
        if (ind_it != ind_end_(row) && *ind_it == col) {
          size_type offset = size_type(ind_it - ind_begin_(row));
          value_type val = nz_[row][offset];
          if (f2(val, ext_val)) {
            ext_val = val;
            idx = row;
          }
        }
      }
    }
# 7879 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void colMax(size_type col, size_type& col_max_i, value_type& col_max) const
    {
      {
        assert_valid_col_(col, "colMax");
      }

      col_max = - std::numeric_limits<value_type>::max();

      colExtremumNZ(col, col_max_i, col_max, std::greater<value_type>());

      if (col_max == - std::numeric_limits<value_type>::max())
        col_max = 0;
    }
# 7904 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void colMin(size_type col, size_type& col_min_i, value_type& col_min) const
    {
      {
        assert_valid_col_(col, "colMin");
      }

      col_min = std::numeric_limits<value_type>::max();

      colExtremumNZ(col, col_min_i, col_min, std::less<value_type>());

      if (col_min == std::numeric_limits<value_type>::max())
        col_min = 0;
    }
# 7936 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename Maxima>
    inline void colMax(Maxima maxima) const
    {
      const size_type ncols = nCols();

      std::pair<size_type, value_type> init_p(0, - std::numeric_limits<value_type>::max());
      std::fill(maxima, maxima + ncols, init_p);

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {

          const size_type col = *ind;
          const value_type val = *nz;

          if (val > maxima[col].second) {
            maxima[col].first = row;
            maxima[col].second = val;
          }
        }
      }

      for (size_type j = 0; j != ncols; ++j) {
        if (maxima[j].second == - std::numeric_limits<value_type>::max())
          maxima[j].second = 0;
      }
    }






    template <typename OutputIterator1, typename OutputIterator2>
    inline void colMax(OutputIterator1 indices, OutputIterator2 maxima) const
    {
      const size_type ncols = nCols();

      std::fill(indices, indices + ncols, 0);
      std::fill(maxima, maxima + ncols, - std::numeric_limits<value_type>::max());

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {

          const size_type col = *ind;
          const value_type val = *nz;

          if (val > maxima[col]) {
            indices[col] = row;
            maxima[col] = val;
          }
        }
      }

      for (size_type j = 0; j != ncols; ++j) {
        if (maxima[j] == - std::numeric_limits<value_type>::max())
          maxima[j] = 0;
      }
    }
# 8011 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename Minima>
    inline void colMin(Minima minima) const
    {
      const size_type ncols = nCols();

      std::pair<size_type, value_type> init_p(0, std::numeric_limits<value_type>::max());
      std::fill(minima, minima + ncols, init_p);

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {

          const size_type col = *ind;
          const value_type val = *nz;

          if (val < minima[col].second) {
            minima[col].first = row;
            minima[col].second = val;
          }
        }
      }

      for (size_type j = 0; j != ncols; ++j) {
        if (minima[j].second == std::numeric_limits<value_type>::max())
          minima[j].second = 0;
      }
    }






    template <typename OutputIterator1, typename OutputIterator2>
    inline void colMin(OutputIterator1 indices, OutputIterator2 minima) const
    {
      const size_type ncols = nCols();

      std::fill(indices, indices + ncols, 0);
      std::fill(minima, minima + ncols, std::numeric_limits<value_type>::max());

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {

          const size_type col = *ind;
          const value_type val = *nz;

          if (val < minima[col]) {
            indices[col] = row;
            minima[col] = val;
          }
        }
      }

      for (size_type j = 0; j != ncols; ++j) {
        if (minima[j] == std::numeric_limits<value_type>::max())
          minima[j] = 0;
      }
    }





    inline void boxMin(size_type begin_row, size_type end_row,
                       size_type begin_col, size_type end_col,
                       size_type& min_row, size_type& min_col, value_type& min_val) const
    {
      {
        assert_valid_row_range_(begin_row, end_row, "boxMin");
        assert_valid_col_range_(begin_col, end_col, "boxMin");
      }

      min_row = begin_row;
      min_col = begin_col;
      min_val = std::numeric_limits<value_type>::max();

      for (size_type row = begin_row; row != end_row; ++row) {
        size_type *ind = __null, *ind_end = __null; value_type *nz = nz_begin_(row) + pos_(row, begin_col, end_col, ind, ind_end); for (; ind != ind_end; ++ind, ++nz) {
          if (*nz < min_val) {
            min_row = row;
            min_col = *ind;
            min_val = *nz;
          }
        }
      }

      if (min_val == std::numeric_limits<value_type>::max())
        min_val = (value_type) 0;
    }





    inline void boxMax(size_type begin_row, size_type end_row,
                       size_type begin_col, size_type end_col,
                       size_type& max_row, size_type& max_col, value_type& max_val) const
    {
      {
        assert_valid_row_range_(begin_row, end_row, "boxMax");
        assert_valid_col_range_(begin_col, end_col, "boxMax");
      }

      max_row = begin_row;
      max_col = begin_col;
      max_val = - std::numeric_limits<value_type>::max();

      for (size_type row = begin_row; row != end_row; ++row) {
        size_type *ind = __null, *ind_end = __null; value_type *nz = nz_begin_(row) + pos_(row, begin_col, end_col, ind, ind_end); for (; ind != ind_end; ++ind, ++nz) {
          if (*nz > max_val) {
            max_row = row;
            max_col = *ind;
            max_val = *nz;
          }
        }
      }

      if (max_val == - std::numeric_limits<value_type>::max())
        max_val = (value_type) 0;
    }


    inline std::pair<size_type, size_type> argmax() const
    {
      size_type max_row = 0, max_col = 0;
      value_type m = - std::numeric_limits<value_type>::max();

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          if (*nz > m) {
            m = *nz;
            max_row = row;
            max_col = *ind;
          }
        }
      }

      return std::make_pair(max_row, max_col);
    }


    inline std::pair<size_type, size_type> argmin() const
    {
      size_type min_row = 0, min_col = 0;
      value_type m = std::numeric_limits<value_type>::max();

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          if (*nz < m) {
            m = *nz;
            min_row = row;
            min_col = *ind;
          }
        }
      }

      return std::make_pair(min_row, min_col);
    }
# 8190 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline
    value_type normalizeRow(size_type row, const value_type& val =1.0, bool exact =false)
    {
      {
        assert_valid_row_(row, "normalizeRow");
        assert_not_zero_value_(val, "normalizeRow");
      }

      value_type sum = rowSum(row);

      if (isZero_(sum))
        return sum;

      elementRowNZApply(row, nta::MultipliesByVal<value_type>(val / sum));

      if (exact)
        normalizeRow(row, val, false);

      return sum;
    }
# 8229 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline
    value_type normalizeCol(size_type col, const value_type& val =1.0, bool exact =false)
    {
      {
        assert_valid_col_(col, "normalizeCol");
        assert_not_zero_value_(val, "normalizeCol");
      }

      value_type sum = colSum(col);

      if (isZero_(sum))
        return sum;

      elementColNZApply(col, nta::MultipliesByVal<value_type>(val / sum));

      if (exact)
        normalizeCol(col, val, false);

      return sum;
    }
# 8264 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void normalizeRows(const value_type& val =1.0, bool exact =false)
    {
      {
        assert_not_zero_value_(val, "normalizeRows");
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row)
        normalizeRow(row, val, exact);
    }
# 8288 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void normalizeCols(const value_type& val =1.0, bool exact =false)
    {
      {
        assert_not_zero_value_(val, "normalizeCols");
      }

      const size_type ncols = nCols();

      colSums(nzb_);

      value_type *nz = nzb_, *nz_end = nzb_ + ncols;
      while (nz != nz_end) {
        value_type& col_sum = *nz;
        if (!isZero_(col_sum))
          col_sum = val / col_sum;
        else
          col_sum = (value_type) 1;
        ++nz;
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          *nz *= nzb_[*ind];
        }
        thresholdRow(row, nta::Epsilon);
      }

      if (exact)
        normalizeCols(val, false);
    }
# 8336 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void normalize(const value_type& val =1.0, bool exact =false)
    {
      {
        assert_not_zero_value_(val, "normalize");
      }

      value_type k = val / sum();

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          *nz *= k;
        }
        thresholdRow(row, nta::Epsilon);
      }

      if (exact)
        normalize(val, false);
    }





    inline void normalize_max(const value_type& val =1.0)
    {
      {
        assert_not_zero_value_(val, "normalize");
      }

      value_type max_val = std::numeric_limits<value_type>::max();

      {
        const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
          size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
            if (*nz > max_val) {
              max_val = *nz;
            }
          }
        }
      }

      value_type k = val / max_val;

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          *nz *= k;
        }
        thresholdRow(row, nta::Epsilon);
      }
    }
# 8395 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator>
    inline void
    normalizeBlockByRows(InputIterator begin, InputIterator end,
                         const value_type& val=-1.0, const value_type& eps_n =1e-6)
    {
      {
        assert_valid_sorted_index_range_(nRows(), begin, end, "normalizeBlockByRows");
        assert_not_zero_value_(val, "normalizeBlockByRows");
      }

      using namespace std;

      vector<value_type*> nz_ptrs(nCols());

      for (InputIterator i = begin; i != end; ++i) {
        size_type row = *i;
        size_type *ind = ind_begin_(row);
        size_type *ind_end = ind_end_(row);
        value_type *nz = nz_begin_(row);
        InputIterator j = begin;
        value_type s = 0;
        size_type k = 0;
        while (j != end && ind != ind_end) {
          size_type col = *j;
          if (col == *ind) {
            s += *nz;
            nz_ptrs[k++] = nz;
            ++ind; ++nz; ++j;
          } else if (col < *ind) {
            s += eps_n;
            ++j;
          } else if (*ind < col) {
            ++ind; ++nz;
          }
        }
        s += size_type(end - j) * eps_n;
        if (val > 0)
          s /= val;
        for (size_type i = 0; i != k; ++i)
          *(nz_ptrs[i]) /= s;
      }
    }
# 8446 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator>
    inline void
    normalizeBlockByRows_binary(InputIterator begin, InputIterator end,
                                const value_type& val=-1.0, const value_type& eps_n =1e-6)
    {
      {
        assert_valid_sorted_index_range_(nRows(), begin, end,
                                         "normalizeBlockByRows_binary");
        assert_not_zero_value_(val, "normalizeBlockByRows_binary");
      }

      using namespace std;

      vector<value_type*> nz_ptrs(nCols());

      for (InputIterator i = begin; i != end; ++i) {
        size_type row = *i;
        size_type *ind_begin = ind_begin_(row);
        size_type *ind_end = ind_end_(row);
        size_type *p = ind_begin;
        value_type *nz_begin = nz_begin_(row);
        value_type s = 0;
        size_type k = 0;
        for (InputIterator j = begin; j != end; ++j) {
          p = std::lower_bound(p, ind_end, *j);
          value_type *ptr = nz_begin + (p - ind_begin);
          if (p != ind_end && *p == *j) {
            s += *ptr;
            nz_ptrs[k++] = ptr;
          } else {
            s += eps_n;
          }
        }
        if (val > 0)
          s /= val;
        for (size_type i = 0; i != k; ++i)
          *(nz_ptrs[i]) /= s;
      }
    }
# 8493 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InIter>
    inline void scaleRows(InIter s_begin)
    {
      {
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        value_type val = *s_begin;
        if (isZero_(val)) {
          nnzr_[row] = 0;
        } else {
          size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz)
            *nz *= val;
        }
        ++s_begin;
      }
    }





    template <typename InIter>
    inline void scaleCols(InIter s_begin)
    {
      {
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz)
          *nz *= s_begin[*ind];
      }
    }
# 8542 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline value_type rowSum(size_type row) const
    {
      {
        assert_valid_row_(row, "rowSum");
      }

      if (isRowZero(row))
        return value_type(0);
      else
        return accumulateRowNZ(row, std::plus<value_type>(), (value_type)0);
    }
# 8568 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename OutputIterator>
    inline void rowSums(OutputIterator sums, value_type init =0) const
    {
      accumulateAllRowsNZ(sums, std::plus<value_type>(), (value_type)init);
    }


    inline void rowSums(std::vector<value_type>& sums) const
    {
      {
        if (sums.size() == nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 8578) << "ASSERTION FAILED: \"" << "sums.size() == nRows()" << "\" "
          << "rowSums: Wrong size for vector";
      }

      rowSums(sums.begin());
    }
# 8597 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline value_type rowProd(size_type row) const
    {
      {
        assert_valid_row_(row, "rowProd");
      }

      if (isRowZero(row))
        return value_type(0);
      else
        return accumulateRowNZ(row, std::multiplies<value_type>(), (value_type)1);
    }
# 8623 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename OutputIterator>
    inline void rowProds(OutputIterator prods) const
    {
      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        *prods = rowProd(row);
        ++prods;
      }
    }
# 8644 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline value_type colSum(size_type col) const
    {
      {
        assert_valid_col_(col, "colSum");
      }

      return accumulateColNZ(col, std::plus<value_type>(), (value_type)0);
    }
# 8667 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename OutputIterator>
    inline void colSums(OutputIterator sums, value_type init =0) const
    {
      accumulateAllColsNZ(sums, std::plus<value_type>(), (value_type)init);
    }





    template <typename InIt, typename OutIt>
    inline void addRows(InIt indicator, InIt indicator_end,
                        OutIt result, OutIt result_end) const
    {
      {
        if ((size_type)(indicator_end - indicator) == nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 8682) << "ASSERTION FAILED: \"" << "(size_type)(indicator_end - indicator) == nRows()" << "\" ";
        if (nCols() <= (size_type)(result_end - result)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 8683) << "ASSERTION FAILED: \"" << "nCols() <= (size_type)(result_end - result)" << "\" ";
      }

      std::fill(result, result + nCols(), (value_type) 0);

      for (size_type r = 0; indicator != indicator_end; ++indicator, ++r) {

        if (! *indicator)
          continue;

        size_type *ind = ind_[r], *ind_end = ind + nnzr_[r];
        value_type *nz = nz_[r];

        for (; ind != ind_end; ++ind, ++nz)
          result[*ind] += *nz;
      }
    }


    template <typename InIt, typename OutIt>
    inline void addListOfRows(InIt whichRows, InIt whichRows_end,
                              OutIt result, OutIt result_end) const
    {
      {
        if (nCols() <= (size_type)(result_end - result)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 8707) << "ASSERTION FAILED: \"" << "nCols() <= (size_type)(result_end - result)" << "\" ";
      }

      std::fill(result, result + nCols(), (value_type) 0);

      for (; whichRows != whichRows_end; ++whichRows) {

        size_type r = *whichRows;
        size_type *ind = ind_[r], *ind_end = ind + nnzr_[r];
        value_type *nz = nz_[r];

        for (; ind != ind_end; ++ind, ++nz)
          result[*ind] += *nz;
      }
    }
# 8735 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline value_type colProd(size_type col) const
    {
      {
        assert_valid_col_(col, "colProd");
      }

      if (isColZero(col))
        return value_type(0);
      else
        return accumulateColNZ(col, std::multiplies<value_type>(), (value_type)1);
    }
# 8763 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename OutputIterator>
    inline void colProds(OutputIterator prods) const
    {
      OutputIterator prods_end = prods + nCols();
      size_type col = 0;
      while (prods != prods_end) {
        *prods = colProd(col);
        ++prods;
        ++col;
      }
    }
# 8784 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline value_type sum() const
    {
      return accumulateNZ(std::plus<value_type>(), (value_type)0);
    }
# 8798 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline value_type prod() const
    {
      if (isZero())
        return value_type(0);
      else
        return accumulateNZ(std::multiplies<value_type>(), value_type(1));
    }
# 8831 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator>
    inline void axby(size_type row, value_type a, value_type b, InputIterator x)
    {
      {
        assert_valid_row_(row, "axby");
      }

      size_type nnzr = nnzr_[row], *ind = ind_[row], ncols = nCols();
      size_type *end1 = ind + 4*(nnzr/4), *end2 = ind + nnzr;
      value_type *nz = nzb_;
      InputIterator end_x1 = x + 4*(ncols/4), end_x2 = x + ncols;

      if (a == 1.0 && b == 1.0) {

        for (; x != end_x1; x += 4, nz += 4) {
          *nz = *x; *(nz+1) = *(x+1);
          *(nz+2) = *(x+2); *(nz+3) = *(x+3);
        }

        while (x != end_x2)
          *nz++ = *x++;

        nz = nz_[row];

        for (; ind != end1; ind += 4, nz += 4) {
          nzb_[*ind] += *nz; nzb_[*(ind+1)] += *(nz+1);
          nzb_[*(ind+2)] += *(nz+2); nzb_[*(ind+3)] += *(nz+3);
        }

        while (ind != end2)
          nzb_[*ind++] += *nz++;

      } else if (a == 1.0 && b == -1.0) {

        for (; x != end_x1; x += 4, nz += 4) {
          *nz = *x; *(nz+1) = *(x+1);
          *(nz+2) = *(x+2); *(nz+3) = *(x+3);
        }

        while (x != end_x2)
          *nz++ = *x++;

        nz = nz_[row];

        for (; ind != end1; ind += 4, nz += 4) {
          nzb_[*ind] -= *nz; nzb_[*(ind+1)] -= *(nz+1);
          nzb_[*(ind+2)] -= *(nz+2); nzb_[*(ind+3)] -= *(nz+3);
        }

        while (ind != end2)
          nzb_[*ind++] -= *nz++;

      } else {



        for (; x != end_x1; x += 4, nz += 4) {
          *nz = b * *x; *(nz+1) = b * *(x+1);
          *(nz+2) = b * *(x+2); *(nz+3) = b * *(x+3);
        }

        while (x != end_x2)
          *nz++ = b * *x++;



        nz = nz_[row];

        for (; ind != end1; ind += 4, nz += 4) {
          nzb_[*ind] += a * *nz; nzb_[*(ind+1)] += a * *(nz+1);
          nzb_[*(ind+2)] += a * *(nz+2); nzb_[*(ind+3)] += a * *(nz+3);
        }

        while (ind != end2)
          nzb_[*ind++] += a * *nz++;
      }

      set_row_(row, nzb_, nzb_ + nCols());
    }
# 8927 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator>
    inline void axby(value_type a, value_type b, InputIterator x)
    {
      for (size_type i = 0; i != nRows(); ++i)
        axby(i, a, b, x);
    }
# 8953 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void lerp(value_type a, value_type b, const SparseMatrix& B)
    {
      {
        if (B.nRows() == this->nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 8956) << "ASSERTION FAILED: \"" << "B.nRows() == this->nRows()" << "\" "
          << "SparseMatrix::lerp(): "
          << " B matrix has " << B.nRows() << " rows"
          << " when this matrix has " << this->nRows() << " rows"
          << " - Both matrices need to have the same number of rows";

        if (B.nCols() == this->nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 8962) << "ASSERTION FAILED: \"" << "B.nCols() == this->nCols()" << "\" "
          << "SparseMatrix::lerp(): "
          << " B matrix has " << B.nCols() << " columns"
          << " when this matrix has " << this->nCols() << " columns"
          << " - Both matrices need to have the same number of columns";
      }

      const size_type nrows = nRows();
      const size_type ncols = nCols();

      for (size_type i = 0; i != nrows; ++i) {

        std::fill(nzb_, nzb_ + ncols, (value_type)0);

        size_type *ind = ind_[i];
        value_type *nz = nz_[i], *nz_end = nz + nnzr_[i];

        if (a != 0)
          while (nz != nz_end)
            nzb_[*ind++] = a * *nz++;

        ind = B.ind_[i];
        nz = B.nz_[i];
        nz_end = nz + B.nnzr_[i];

        if (b != 0)
          while (nz != nz_end)
            nzb_[*ind++] += b * *nz++;

        set_row_(i, nzb_, nzb_ + nCols());
      }
    }
# 9013 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    void addTwoRows(size_type src_row, size_type dst_row)
    {
      {
        assert_valid_row_(src_row, "addTwoRows");
        assert_valid_row_(dst_row, "addTwoRows");
      }

      if (isRowZero(src_row))
        return;

      size_type *ind_src = ind_begin_(src_row);
      size_type *ind_dst = ind_begin_(dst_row);
      size_type *ind_src_end = ind_end_(src_row);
      size_type *ind_dst_end = ind_end_(dst_row);

      value_type *nz_src = nz_begin_(src_row);
      value_type *nz_dst = nz_begin_(dst_row);

      size_type k = 0;

      while (ind_src != ind_src_end && ind_dst != ind_dst_end) {
        size_type i_src = *ind_src, i_dst = *ind_dst;
        if (i_src == i_dst) {
          value_type val = *nz_src + *nz_dst;
          if (!isZero_(val)) {
            indb_[k] = i_src;
            nzb_[k] = val;
            ++k;
          }
          ++ind_src; ++ind_dst;
          ++nz_src; ++nz_dst;
        } else if (i_src < i_dst) {
          indb_[k] = i_src;
          nzb_[k] = *nz_src;
          ++ind_src; ++nz_src;
          ++k;
        } else {
          indb_[k] = i_dst;
          nzb_[k] = *nz_dst;
          ++ind_dst; ++nz_dst;
          ++k;
        }
      }

      size_type *ind = __null, *ind_end = ind;
      value_type *nz = __null;

      if (ind_src == ind_src_end) {
        ind = ind_dst;
        ind_end = ind_dst_end;
        nz = nz_dst;
      } else {
        ind = ind_src;
        ind_end = ind_src_end;
        nz = nz_src;
      }

      while (ind != ind_end) {
        indb_[k] = *ind;
        nzb_[k] = *nz;
        ++ind; ++nz;
        ++k;
      }

      if (isCompact())
        decompact();

      delete [] ind_[dst_row];
      delete [] nz_[dst_row];

      nnzr_[dst_row] = k;
      ind_[dst_row] = new size_type [nnzr_[dst_row]];
      nz_[dst_row] = new value_type [nnzr_[dst_row]];
      std::copy(indb_, indb_ + nnzr_[dst_row], ind_[dst_row]);
      std::copy(nzb_, nzb_ + nnzr_[dst_row], nz_[dst_row]);
    }
# 9108 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    void addTwoCols(size_type src_col, size_type dst_col)
    {
      {
        assert_valid_col_(src_col, "addTwoCols");
        assert_valid_col_(dst_col, "addTwoCols");
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {

        size_type *ind_begin = ind_begin_(row), *ind_end = ind_end_(row);
        size_type *p_src = std::lower_bound(ind_begin, ind_end, src_col);

        if (p_src != ind_end && *p_src == src_col) {

          size_type *p_dst = dst_col > src_col ?
            std::lower_bound(p_src, ind_end, dst_col) :
            std::lower_bound(ind_begin, p_src, dst_col);

          if (*p_dst != dst_col) {
            insertNewNonZero_(row, dst_col, p_dst, nz_[row][p_src - ind_begin]);
          } else {
            value_type* nz = nz_[row];
            nz[p_dst - ind_begin] += nz[p_src - ind_begin];
          }
        }
      }
    }







    inline void add(const SparseMatrix& other)
    {
      {
        if (other.nRows() == nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 9145) << "ASSERTION FAILED: \"" << "other.nRows() == nRows()" << "\" "
          << "add: Wrong number of rows: " << other.nRows()
          << " and " << nRows();
        if (other.nCols() == nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 9148) << "ASSERTION FAILED: \"" << "other.nCols() == nCols()" << "\" "
          << "add: Wrong number of columns: " << other.nCols()
          << " and " << nCols();
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {

        size_type *ind = ind_begin_(row);
        size_type *ind_end = ind_end_(row);
        value_type *nz = nz_begin_(row);
        size_type *ind_b = other.ind_begin_(row);
        size_type *ind_b_end = other.ind_end_(row);
        value_type *nz_b = other.nz_begin_(row);
        size_type *indb = indb_;
        value_type *nzb = nzb_;

        while (ind != ind_end && ind_b != ind_b_end) {
          if (*ind == *ind_b) {
            value_type val = *nz++ + *nz_b++;
            if (!isZero_(val)) {
              *indb++ = *ind;
              *nzb++ = val;
            }
            ++ind; ++ind_b;
          } else if (*ind < *ind_b) {
            *indb++ = *ind++;
            *nzb++ = *nz++;
          } else if (*ind_b < *ind) {
            *indb++ = *ind_b++;
            *nzb++ = *nz_b++;
          }
        }

        while (ind != ind_end) {
          *indb++ = *ind++;
          *nzb++ = *nz++;
        }

        while (ind_b != ind_b_end) {
          *indb++ = *ind_b++;
          *nzb++ = *nz_b++;
        }

        size_type nnzr = (size_type)(indb - indb_);

        if (nnzr > nnzr_[row]) {
          decompact();
          delete [] ind_[row];
          delete [] nz_[row];
          ind_[row] = new size_type [nnzr];
          nz_[row] = new value_type [nnzr];
        }

        std::copy(indb_, indb_ + nnzr, ind_[row]);
        std::copy(nzb_, nzb_ + nnzr, nz_[row]);
        nnzr_[row] = nnzr;
      }
    }
# 9226 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void multiply(const SparseMatrix& B, SparseMatrix& C) const
    {
      {
        if (nCols() == B.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 9229) << "ASSERTION FAILED: \"" << "nCols() == B.nRows()" << "\" "
          << "SparseMatrix::multiply(): "
          << "A matrix's number of columns (" << nCols() << ") "
          << "should be the same as B matrix's number of rows ("
          << B.nRows() << ")";
      }

      C.resize(nRows(), B.nCols());

      size_type nrowsB = B.nRows();
      size_type nrowsC = C.nRows();
      size_type ncolsC = C.nCols();

      std::vector<size_type> front;
      front.resize(nrowsB);

      for (size_type iC = 0; iC < nrowsC; ++iC) {

        size_type nnzrA = nnzr_[iC];
        size_type *indA = ind_[iC];
        value_type *nzA = nz_[iC];

        std::fill(front.begin(), front.end(), (size_type)0);
        std::fill(C.nzb_, C.nzb_ + ncolsC, (value_type)0);

        for (size_type jC = 0; jC != ncolsC; ++jC) {
          for (size_type kA = 0; kA != nnzrA; ++kA) {

            size_type k = indA[kA];
            size_type nnzrB = B.nnzr_[k];
            size_type *indB = B.ind_[k];
            value_type *nzB = B.nz_[k];

            if (nnzrB > 0) {

              size_type kB = front[k];
              for (; kB != nnzrB && indB[kB] < jC; ++kB);

              if (kB < nnzrB && indB[kB] == jC) {
                C.nzb_[jC] += nzA[kA] * nzB[kB];
                front[k] = kB;
              }
            }
          }
        }

        C.set_row_(iC, C.nzb_, C.nzb_ + C.nCols());
      }
    }





    inline void elementMultiply(const SparseMatrix& b)
    {
      {
        if (b.nRows() == nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 9286) << "ASSERTION FAILED: \"" << "b.nRows() == nRows()" << "\" "
          << "elementMultiply needs same number of rows in both matrices";
        if (b.nCols() == nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 9288) << "ASSERTION FAILED: \"" << "b.nCols() == nCols()" << "\" "
          << "elementMultiply needs same number of columns in both matrices";
      }

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        if (nNonZerosOnRow(row) == 0 || b.nNonZerosOnRow(row) == 0)
          nnzr_[row] = 0;
        else {
          size_type *ind_a = ind_begin_(row);
          size_type *ind_a_end = ind_end_(row);
          size_type *ind_a_2 = ind_a;
          value_type *nz_a = nz_begin_(row);
          value_type *nz_a_2 = nz_a;
          size_type *ind_b = b.ind_begin_(row);
          size_type *ind_b_end = b.ind_end_(row);
          value_type *nz_b = b.nz_begin_(row);
          while (ind_a != ind_a_end && ind_b != ind_b_end) {
            if (*ind_a == *ind_b) {
              value_type val = *nz_a * *nz_b;
              if (!isZero_(val)) {
                *ind_a_2++ = *ind_a;
                *nz_a_2++ = val;
              }
              ++ind_a; ++nz_a;
              ++ind_b; ++nz_b;
            } else if (*ind_a < *ind_b) {
              ++ind_a; ++nz_a;
            } else if (*ind_b < *ind_a) {
              ++ind_b; ++nz_b;
            }
          }
          nnzr_[row] = (size_type)(ind_a_2 - ind_begin_(row));
        }
      }
    }





    inline void elementMultiply(const SparseMatrix& m, SparseMatrix& result) const
    {
      {
        if (m.nRows() == nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 9331) << "ASSERTION FAILED: \"" << "m.nRows() == nRows()" << "\" "
          << "elementMultiply needs same number of rows in both matrices";
        if (m.nCols() == nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 9333) << "ASSERTION FAILED: \"" << "m.nCols() == nCols()" << "\" "
          << "elementMultiply needs same number of columns in both matrices";
      }

      result.resize(nRows(), nCols());
      result.setToZero();

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          size_type col = *ind;
          result.set(row, col, *nz * m.get(row,col));
        }
      }
    }





    inline void elementMultiply(value_type* dense)
    {
      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type offset = 0;
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          size_type col = *ind;
          value_type val = *nz * *(dense + row * nCols() + col);
          if (isZero_(val)) {
            ++offset;
          } else {
            *(nz - offset) = val;
            *(ind - offset) = col;
          }
        }
        nnzr_[row] -= offset;
      }
    }





    inline void elementMultiply(value_type* dense, SparseMatrix& result) const
    {
      result.resize(nRows(), nCols());
      result.setToZero();

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          size_type col = *ind;
          result.set(row, col, *nz * *(dense + row * nCols() + col));
        }
      }
    }
# 9395 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename Dense>
    inline void rightDenseMatProd(const Dense& B, Dense& C) const
    {
      typedef typename Dense::size_type size_type2;

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        for (size_type2 col = 0 ; col != B.nCols(); ++col) {
          value_type val = 0;
          size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz)
            val += *nz * B.get(*ind,col);
          C.set(row,col,val);
        }
      }
    }
# 9418 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename Dense>
    inline void rightDenseMatProdAtNZ(const Dense& B, Dense& C) const
    {
      typedef typename Dense::size_type size_type2;

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        for (size_type2 col = 0 ; col != B.nCols(); ++col) {
          value_type val = 0;
          size_type *ind = ind_begin_(row), *ind_end = ind_end_(row);
          for (; ind != ind_end; ++ind)
            val += B.get(*ind,col);
          C.set(row,col,val);
        }
      }
    }




    template <typename Dense>
    inline void denseMatExtract(const Dense& B, Dense& C) const
    {
      typedef typename Dense::size_type size_type2;

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        for (size_type2 col = 0 ; col != B.nCols(); ++col) {
          if (nNonZerosOnRow(row) == 1)
            C.set(row,col,B.get(*(ind_[row]),col));
          else
            C.set(row,col,0);
        }
      }
    }
# 9469 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator>
    inline value_type rightVecProd(size_type row, InputIterator x) const
    {
      {
        assert_valid_row_(row, "rightVecProd for single row");
      }

      const size_type nnzr = nnzr_[row];

      if (nnzr == 0)
        return 0;

      value_type a, b, val = 0;
      size_type *ind = ind_begin_(row);
      size_type *end1 = ind + 4*(nnzr/4), *end2 = ind_end_(row);
      value_type *nz = nz_begin_(row);

      while (ind != end1) {
        a = *nz++ * x[*ind++];
        b = *nz++ * x[*ind++];
        val += a + b;
        a = *nz++ * x[*ind++];
        b = *nz++ * x[*ind++];
        val += a + b;
      }

      while (ind != end2)
        val += *nz++ * x[*ind++];

      return val;
    }
# 9518 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator, typename OutputIterator>
    inline void rightVecProd(InputIterator x, OutputIterator y) const
    {
      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        *y = rightVecProd(row, x);
        ++y;
      }
    }
# 9544 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator, typename InputIterator2, typename OutputIterator>
    inline void rightVecProd(InputIterator2 begin, InputIterator2 end,
                             InputIterator x, OutputIterator y) const
    {
      {
        assert_valid_row_it_range_(begin, end, "rightVecProd for several rows");
      }

      for (InputIterator2 i = begin; i != end; ++i, ++y)
        *y = rightVecProd(*i, x);
    }







    inline value_type
    rightVecProd(size_type row, const std::vector<value_type>& x) const
    {
      return rightVecProd(row, x.begin());
    }
# 9578 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void rightVecProd(const std::vector<value_type>& x,
                             std::vector<value_type>& y) const
    {
      if (y.size() < nRows())
        y.resize(nRows());

      rightVecProd(x.begin(), y.begin());
    }
# 9611 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator>
    inline void
    blockRightVecProd(size_type block_size, InputIterator x, SparseMatrix& C) const
    {
      {
        if (0 < block_size && block_size <= nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 9616) << "ASSERTION FAILED: \"" << "0 < block_size && block_size <= nCols()" << "\" "
          << "blockRightVecProd: Invalid block size: " << block_size
          << " - Needs to be > 0 and <= nCols = " << nCols();
        if (nCols() % block_size == 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 9619) << "ASSERTION FAILED: \"" << "nCols() % block_size == 0" << "\" "
          << "blockRightVecProd: Invalid block size: " << block_size
          << " - Needs to be a divisor of nCols = " << nCols();
      }

      const size_type nrows = nRows();

      C.resize(nRows(), nCols() / block_size);

      for (size_type i = 0; i != nrows; ++i) {

        size_type *ind = ind_begin_(i);
        value_type *nz = nz_begin_(i);
        size_type block_end = block_size;
        size_type end = nCols() + block_end;
        size_type block_idx = 0;

        while (block_end != end) {
          value_type val = 0;
          while (*ind < block_end)
            val += *nz++ * x[*ind++];
          block_end += block_size;
          C.set(i, block_idx++, val);
        }
      }
    }
# 9664 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator>
    inline value_type leftVecProd(size_type col, InputIterator x) const
    {
      {
        assert_valid_col_(col, "leftVecProd for one col");
      }

      value_type y = 0;

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {

        value_type x_val = x[row];

        if (isZero_(x_val) || nnzr_[row] == 0)
          continue;

        size_type *p = std::lower_bound(ind_begin_(row), ind_end_(row), col);

        if (p != ind_end_(row) && *p == col)
          y += *(nz_begin_(row) + (p - ind_begin_(row))) * x_val;
      }

      return y;
    }
# 9708 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator, typename OutputIterator>
    inline void leftVecProd(InputIterator x, OutputIterator y) const
    {
      std::fill(y, y + nCols(), (value_type) 0);

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {

        value_type val = x[row];

        if (isZero_(val))
          continue;

        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz)
          y[*ind] += *nz * val;
      }
    }
# 9746 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator, typename InputIterator2, typename OutputIterator>
    inline void leftVecProd(InputIterator2 begin, InputIterator2 end,
                            InputIterator x, OutputIterator y) const
    {
      {
        assert_valid_col_it_range_(begin, end, "leftVecProd");
      }

      size_type c = 0;
      for (InputIterator2 i = begin; i != end; ++i, ++c)
        indb_[*i] = c;
      std::fill(y, y + c, (value_type) 0);

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {

        value_type val = x[row];
        size_type *ind = ind_begin_(row);
        size_type *ind_end = ind_end_(row);
        value_type *nz = nz_begin_(row);
        InputIterator2 j = begin;
        while (j != end && ind != ind_end) {
          size_type col = *j;
          if (col == *ind) {
            y[indb_[col]] += *nz * val;
            ++ind; ++nz; ++j;
          } else if (col < *ind) {
            ++j;
          } else if (*ind < col) {
            ++ind; ++nz;
          }
        }
      }
    }
# 9801 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator, typename InputIterator2, typename OutputIterator>
    inline void leftVecProd_binary(InputIterator2 begin, InputIterator2 end,
                                   InputIterator x, OutputIterator y) const
    {
      {
        assert_valid_sorted_index_range_(nCols(), begin, end, "leftVecProd_binary");
      }

      size_type c = 0;
      for (InputIterator2 i = begin; i != end; ++i, ++c)
        indb_[*i] = c;
      std::fill(y, y + c, (value_type) 0);

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {

        value_type val = x[row];
        size_type *ind_begin = ind_begin_(row);
        size_type *ind_end = ind_end_(row);
        size_type *p = ind_begin;
        value_type *nz_begin = nz_begin_(row);
        for (InputIterator2 j = begin; j != end; ++j) {
          size_type col = *j;
          p = std::lower_bound(p, ind_end, col);
          if (p != ind_end && *p == col)
            y[indb_[col]] += *(nz_begin + (p - ind_begin)) * val;
        }
      }
    }






    inline value_type
    leftVecProd(size_type col, const std::vector<value_type>& x) const
    {
      return leftVecProd(col, x.begin());
    }






    inline void
    leftVecProd(const std::vector<value_type>& x, std::vector<value_type>& y) const
    {
      if (y.size() < nCols())
        y.resize(nCols());

      leftVecProd(x.begin(), y.begin());
    }
# 9874 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator, typename OutputIterator>
    inline void rightVecProdAtNZ(InputIterator x, OutputIterator y) const
    {
      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {

        size_type nnzr = nnzr_[row];
        size_type *ind = ind_[row];
        size_type *end1 = ind + 4*(nnzr/4), *end2 = ind + nnzr;
        value_type val = 1.0;

        for (; ind != end1; ind += 4)
          val *= x[*ind] * x[*(ind+1)] * x[*(ind+2)] * x[*(ind+3)];

        while (ind != end2)
          val *= x[*ind++];

        *y++ = val;
      }
    }
# 9908 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator, typename OutputIterator>
    inline void leftVecProdAtNZ(InputIterator x, OutputIterator y) const
    {
      std::fill(y, y + nCols(), (value_type) 1.0);

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {

        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row);
        value_type val = x[row];

        while (ind != ind_end)
          y[*ind++] *= val;
      }
    }
# 9937 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator, typename OutputIterator>
    inline void rightVecSumAtNZ(InputIterator x, OutputIterator y) const
    {
      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {

        size_type nnzr = nnzr_[row];
        size_type *ind = ind_[row];
        size_type *end1 = ind + 4*(nnzr/4), *end2 = ind + nnzr;
        value_type val = 0.0;

        for (; ind != end1; ind += 4)
          val += x[*ind] + x[*(ind+1)] + x[*(ind+2)] + x[*(ind+3)];

        while (ind != end2)
          val += x[*ind++];

        *y++ = val;
      }
    }






    template <typename InputIterator, typename OutputIterator>
    inline void rightVecSumAtNZGtThreshold(InputIterator x, OutputIterator y,
                                           value_type threshold) const
    {
      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {

        size_type nnzr = nnzr_[row];
        size_type *ind = ind_[row];
        value_type *nz = nz_[row];
        value_type val = 0.0;

        for (size_type i = 0; i != nnzr; ++i)
          if (nz[i] > threshold)
            val += x[ind[i]];

        *y++ = val;
      }
    }
# 9995 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator, typename OutputIterator>
    inline void leftVecSumAtNZ(InputIterator x, OutputIterator y) const
    {
      std::fill(y, y + nCols(), (value_type) 0.0);

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {

        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row);
        value_type val = x[row];

        while (ind != ind_end)
          y[*ind++] += val;
      }
    }
# 10024 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator, typename OutputIterator>
    inline void rightVecMaxAtNZ(InputIterator x, OutputIterator y) const
    {
      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        value_type max_val = - std::numeric_limits<value_type>::max();
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          if (x[*ind] > max_val)
            max_val = x[*ind];
        }
        *y++ = max_val != - std::numeric_limits<value_type>::max() ? max_val : (value_type) 0;
      }
    }
# 10051 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator, typename OutputIterator>
    inline void leftVecMaxAtNZ(InputIterator x, OutputIterator y) const
    {
      std::fill(y, y + nCols(), (value_type) - std::numeric_limits<value_type>::max());

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          if (x[row] > y[*ind])
            y[*ind] = x[row];
        }
      }

      for (size_type i = 0; i != nCols(); ++i)
        if (y[i] == (value_type) - std::numeric_limits<value_type>::max())
          y[i] = 0;
    }
# 10082 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator, typename OutputIterator>
    inline void rightVecProdAtNZ(InputIterator x, OutputIterator y,
                                 const value_type& lb) const
    {
      size_type k, nnzr, end, *ind;
      double val;

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {

        nnzr = nnzr_[row];
        ind = ind_[row];
        val = 1;
        end = 4*(nnzr / 4);

        for (k = 0; k < end && val > lb; k += 4)
          val *= x[ind[k]] * x[ind[k+1]] * x[ind[k+2]] * x[ind[k+3]];

        if (val > lb)
          for (k = end; k != nnzr; ++k)
            val *= x[ind[k]];

        if (val > lb)
          *y++ = val;
        else
          *y++ = lb;
      }
    }
# 10125 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator, typename OutputIterator>
    inline void vecMaxAtNZ(InputIterator x, OutputIterator y) const
    {
      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {

        value_type max_v = - std::numeric_limits<value_type>::max();

        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          value_type a = x[*ind];
          if (a > max_v)
            max_v = a;
        }

        *y++ = max_v == - std::numeric_limits<value_type>::max() ? 0 : max_v;
      }
    }
# 10157 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator, typename OutputIterator>
    inline void vecArgMaxAtNZ(InputIterator x, OutputIterator y) const
    {
      size_type j, arg_j = 0;
      value_type val, max_val;

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {

        arg_j = 0;
        max_val = - std::numeric_limits<value_type>::max();

        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          j = *ind;
          val = x[j];
          if (val > max_val) {
            arg_j = j;
            max_val = val;
          }
        }

        *y++ = arg_j;
      }
    }
# 10200 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator, typename OutputIterator>
    inline void rowVecProd(InputIterator x, OutputIterator y) const
    {
      typedef typename std::iterator_traits<OutputIterator>::value_type OVT;

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        prec_value_type val = (prec_value_type) 1.0;
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz)
          val *= ((prec_value_type)*nz) * ((prec_value_type)x[*ind]);
        *y++ = (OVT) val;
      }
    }
# 10230 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator, typename OutputIterator>
    inline void rowVecProd(InputIterator x, OutputIterator y,
                           const value_type& lb) const
    {
      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        prec_value_type val = (prec_value_type) 1.0;
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz)
          val *= *nz * x[*ind];
        *y++ = val > lb ? val : lb;
      }
    }
# 10257 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator, typename OutputIterator>
    inline void vecMaxProd(InputIterator x, OutputIterator y) const
    {
      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {

        value_type max_v = nnzr_[row] == 0 ? 0 : nz_[row][0] * x[ind_[row][0]];

        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          value_type p = *nz * x[*ind];
          if (p > max_v)
            max_v = p;
        }

        *y++ = max_v;
      }
    }
# 10293 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator, typename OutputIterator>
    inline void vecArgMaxProd(InputIterator x, OutputIterator y) const
    {
      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {

        size_type max_i = 0;
        value_type max_v = - std::numeric_limits<value_type>::max();

        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          value_type p = *nz * x[*ind];
          if (!isZero_(p) && p >= max_v) {
            max_v = p;
            max_i = *ind;
          }
        }

        *y++ = max_i;
      }
    }







    inline void map(const SparseMatrix& B, SparseMatrix& C) const
    {
      {
        if (C.nRows() == 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 10322) << "ASSERTION FAILED: \"" << "C.nRows() == 0" << "\" ";
        if (nCols() == B.nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 10323) << "ASSERTION FAILED: \"" << "nCols() == B.nCols()" << "\" ";
        if (C.nCols() == B.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 10324) << "ASSERTION FAILED: \"" << "C.nCols() == B.nRows()" << "\" ";
      }

      nzb_[0] = (value_type) 1;
      bool matched = false;

      for (size_type i = 0; i != this->nRows(); ++i) {

        matched = false;
        for (size_type i2 = 0; i2 != B.nRows(); ++i2) {
          if (nnzr_[i] == B.nnzr_[i2]) {
            size_type j = 0, nnzr = nnzr_[i];
            while ((j < nnzr) && (ind_[i][j] == B.ind_[i2][j])
                   && (nearlyEqual(nz_[i][j], B.nz_[i2][j])))
              ++j;
            if (j == nnzr) {
              indb_[0] = i2;
              matched = true;
              break;
            }
          }
        }
        if (matched)
          C.addRow(indb_, indb_ + 1, nzb_);
      }
    }
# 10361 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator>
    inline void
    incrementWithOuterProduct(InputIterator x_begin, InputIterator x_end,
                              InputIterator y_begin, InputIterator y_end)
    {
      {
        boost::function_requires<boost::InputIteratorConcept<InputIterator> >();;
        if ((size_type)(x_end - x_begin) == nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 10368) << "ASSERTION FAILED: \"" << "(size_type)(x_end - x_begin) == nRows()" << "\" "
          << "incrementWithOuterProduct: Wrong size for x vector: "
          << (size_type)(x_end - x_begin)
          << " - Should be = nrows = " << nRows();
        if ((size_type)(y_end - y_begin) == nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 10372) << "ASSERTION FAILED: \"" << "(size_type)(y_end - y_begin) == nCols()" << "\" "
          << "incrementWithOuterProduct: Wrong size for y vector: "
          << (size_type)(y_end - y_begin)
          << " - Should be = ncols = " << nCols();
      }

      std::vector<size_type> ind(nCols());
      std::vector<value_type> nz(nCols());
      typename std::vector<size_type>::iterator ind_it = ind.begin();
      typename std::vector<value_type>::iterator nz_it = nz.begin();

      for (InputIterator y = y_begin; y != y_end; ++y) {
        value_type val = *y;
        if (!isZero_(val)) {
          *ind_it++ = (size_type)(y - y_begin);
          *nz_it++ = val;
        }
      }

      typename std::vector<size_type>::iterator ind_end = ind_it;

      for (InputIterator x = x_begin; x != x_end; ++x) {
        value_type val1 = *x;
        if (isZero_(val1))
          continue;
        size_type row = (size_type)(x - x_begin);
        ind_it = ind.begin();
        nz_it = nz.begin();
        for (; ind_it != ind_end; ++ind_it, ++nz_it)
          increment(row, *ind_it, val1 * *nz_it);
      }
    }





    inline void
    incrementWithOuterProduct(const std::vector<value_type>& x,
                              const std::vector<value_type>& y)
    {
      incrementWithOuterProduct(x.begin(), x.end(), y.begin(), y.end());
    }
# 10423 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator>
    inline void
    incrementOnOuterProductVal(InputIterator row_begin, InputIterator row_end,
                               InputIterator col_begin, InputIterator col_end,
                               const value_type& val)
    {
      {
        boost::function_requires<boost::InputIteratorConcept<InputIterator> >();;
      }

      this->applyOuter(row_begin, row_end, col_begin, col_end, nta::PlusVal(val));
    }
# 10443 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void
    incrementOnOuterProductVal(const std::vector<size_type>& rows,
                               const std::vector<size_type>& cols,
                               const value_type& val =1.0)
    {
      for (size_type i = 0; i != rows.size(); ++i)
        for (size_type j = 0; j != cols.size(); ++j)
          set(rows[i], cols[j], get(rows[i], cols[j]) + val);
    }
# 10460 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    template <typename InputIterator, typename Other>
    inline void
    incrementOnOuterProductMat(InputIterator row_begin, InputIterator row_end,
                               InputIterator col_begin, InputIterator col_end,
                               const Other& other)
    {
      {
        boost::function_requires<boost::InputIteratorConcept<InputIterator> >();;
      }

      this->applyOuter(row_begin, row_end, col_begin, col_end,
                       nta::Plus<value_type>(), other);
    }




    template <typename StrictWeakOrdering>
    inline void
    stable_sort_rows(size_type row_begin, size_type row_end, StrictWeakOrdering o)
    {
      if (isCompact())
        decompact();

      const size_type nrows = nRows();
      std::vector<size_type> sorted(nrows);
      for (size_type row = 0; row != nrows; ++row)
        sorted[row] = row;
      std::stable_sort(sorted.begin(), sorted.end(), o);
      std::vector<size_type> tmp_nnzr(nrows);
      std::vector<size_type*> tmp_ind(nrows);
      std::vector<value_type*> tmp_nz(nrows);
      for (size_type row = 0; row != nrows; ++row) {
        tmp_nnzr[row] = nnzr_[sorted[row]];
        tmp_ind[row] = ind_[sorted[row]];
        tmp_nz[row] = nz_[sorted[row]];
      }
      std::copy(tmp_nnzr.begin(), tmp_nnzr.end(), nnzr_);
      std::copy(tmp_ind.begin(), tmp_ind.end(), ind_);
      std::copy(tmp_nz.begin(), tmp_nz.end(), nz_);
    }


  private:
    class AscendingNNZ
    {
    public:
      AscendingNNZ(const SparseMatrix& sm) :sm_(sm) {}
      AscendingNNZ(const AscendingNNZ& other) : sm_(other.sm_) {}



      inline bool operator()(const size_type& row1, const size_type& row2) const
      {
        return sm_.nNonZerosOnRow(row1) < sm_.nNonZerosOnRow(row2);
      }

    private:
      const SparseMatrix& sm_;
      AscendingNNZ();
    };

  public:
    inline void sortRowsAscendingNNZ()
    {
      stable_sort_rows(0, nRows(), AscendingNNZ(*this));
    }







    inline void
    print(std::ostream& outStream, size_type precision=2, size_type width=6) const
    {
      size_type i, j, k;
      for (i = 0; i != nRows(); ++i) {
        for (j = 0, k = 0; j != nCols(); ++j) {
          outStream.width(width);
          outStream.precision(precision);
          outStream << (k < nnzr_[i] && ind_[i][k] == j ? nz_[i][k++] : 0) << " ";
        }
        if (i < nRows()-1)
          outStream << std::endl;
      }
    }
# 10558 "/home/marek/devel/nupic/nta/math/SparseMatrix.hpp"
    inline void replaceNZ(const value_type& val =1.0)
    {
      elementNZApply(nta::AssignVal(val));
    }




    inline value_type diagNZProd() const
    {
      value_type res = 1.0;
      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        difference_type offset = col_(row, row);
        if (offset >= 0)
          res *= nz_[row][offset];
      }
      return res;
    }




    inline value_type diagSum() const
    {
      value_type res = 0.0;
      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        difference_type offset = col_(row, row);
        if (offset >= 0)
          res += nz_[row][offset];
      }
      return res;
    }




    inline value_type diagNZLogSum() const
    {
      nta::Log<value_type> nta_log;
      value_type res = 0.0;
      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        difference_type offset = col_(row, row);
        if (offset >= 0)
          res += nta_log(nz_[row][offset]);
      }
      return res;
    }





    template <typename OutputIterator>
    inline void logRowSums(OutputIterator out, OutputIterator out_end) const
    {
      {
        if ((size_type)(out_end - out) == nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 10614) << "ASSERTION FAILED: \"" << "(size_type)(out_end - out) == nRows()" << "\" "
          << "SparseMatrix::logRowSums: Invalid size for output vector";
      }

      nta::Log<value_type> log_f;

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        value_type s = 0;
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          s +=log_f(*nz);
        }
        *out++ = s;
      }
    }





    template <typename OutputIterator>
    inline void logColSums(OutputIterator out, OutputIterator out_end) const
    {
      {
        if ((size_type)(out_end - out) == nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 10637) << "ASSERTION FAILED: \"" << "(size_type)(out_end - out) == nCols()" << "\" "
          << "SparseMatrix::logColSums: Invalid size for output vector";
      }

      nta::Log<value_type> log_f;

      nta::zero(out, out_end);

      const size_type nrows = nRows(); for (size_type row = 0; row != nrows; ++row) {
        size_type *ind = ind_begin_(row), *ind_end = ind_end_(row); value_type *nz = nz_begin_(row); for (; ind != ind_end; ++ind, ++nz) {
          out[*ind] += log_f(*nz);
        }
      }
    }





    inline void rowNegate(size_type idx)
    {
      elementRowNZApply(idx, nta::Negate<value_type>());
    }

    inline void colNegate(size_type idx)
    {
      elementColNZApply(idx, nta::Negate<value_type>());
    }

    inline void negate()
    {
      elementNZApply(nta::Negate<value_type>());
    }

    inline void rowAbs(size_type idx)
    {
      elementRowNZApply(idx, nta::Abs<value_type>());
    }

    inline void colAbs(size_type idx)
    {
      elementColNZApply(idx, nta::Abs<value_type>());
    }

    inline void abs()
    {
      elementNZApply(nta::Abs<value_type>());
    }

    inline void elementRowSquare(size_type idx)
    {
      elementRowNZApply(idx, nta::Square<value_type>());
    }

    inline void elementColSquare(size_type idx)
    {
      elementColNZApply(idx, nta::Square<value_type>());
    }

    inline void elementSquare()
    {
      elementNZApply(nta::Square<value_type>());
    }

    inline void elementRowCube(size_type idx)
    {
      elementRowNZApply(idx, nta::Cube<value_type>());
    }

    inline void elementColCube(size_type idx)
    {
      elementColNZApply(idx, nta::Cube<value_type>());
    }

    inline void elementCube()
    {
      elementNZApply(nta::Cube<value_type>());
    }

    inline void elementRowNZInverse(size_type idx)
    {
      elementRowNZApply(idx, nta::Inverse<value_type>());
    }

    inline void elementColNZInverse(size_type idx)
    {
      elementColNZApply(idx, nta::Inverse<value_type>());
    }

    inline void elementNZInverse()
    {
      elementNZApply(nta::Inverse<value_type>());
    }

    inline void elementRowSqrt(size_type idx)
    {
      elementRowNZApply(idx, nta::Sqrt<value_type>());
    }

    inline void elementColSqrt(size_type idx)
    {
      elementColNZApply(idx, nta::Sqrt<value_type>());
    }

    inline void elementSqrt()
    {
      elementNZApply(nta::Sqrt<value_type>());
    }

    inline void elementRowNZLog(size_type idx)
    {
      elementRowNZApply(idx, nta::Log<value_type>());
    }

    inline void elementColNZLog(size_type idx)
    {
      elementColNZApply(idx, nta::Log<value_type>());
    }

    inline void elementNZLog()
    {
      elementNZApply(nta::Log<value_type>());
    }

    inline void elementRowNZExp(size_type idx)
    {
      elementRowNZApply(idx, nta::Exp<value_type>());
    }

    inline void elementColNZExp(size_type idx)
    {
      elementColNZApply(idx, nta::Exp<value_type>());
    }

    inline void elementNZExp()
    {
      elementNZApply(nta::Exp<value_type>());
    }


    inline void elementRowMultiply(size_type row, const value_type& val)
    {
      elementRowNZApply(row, nta::MultipliesByVal(val));
    }

    template <typename InputIterator>
    inline void elementRowMultiply(size_type row, InputIterator x)
    {
      elementRowNZApply(row, std::multiplies<value_type>(), x);
    }

    template <typename InputIterator, typename OutputIterator>
    inline void
    elementRowMultiply(size_type row, InputIterator x, OutputIterator y) const
    {
      elementRowNZApply(row, std::multiplies<value_type>(), x, y);
    }

    inline void
    elementRowMultiply(size_type row, const std::vector<value_type>& x,
                       std::vector<value_type>& y) const
    {
      elementRowMultiply(row, x.begin(), y.begin());
    }



    inline void elementColMultiply(size_type col, const value_type& val)
    {
      elementColNZApply(col, nta::MultipliesByVal(val));
    }

    template <typename InputIterator>
    inline void elementColMultiply(size_type col, InputIterator x)
    {
      elementColNZApply(col, std::multiplies<value_type>(), x);
    }

    template <typename InputIterator, typename OutputIterator>
    inline void
    elementColMultiply(size_type col, InputIterator x, OutputIterator y) const
    {
      elementColNZApply(col, std::multiplies<value_type>(), x, y);
    }

    inline void
    elementColMultiply(size_type col, const std::vector<value_type>& x,
                       std::vector<value_type>& y) const
    {
      elementColMultiply(col, x.begin(), y.begin());
    }



    inline void multiply(const value_type& val)
    {
      elementNZApply(nta::MultipliesByVal(val));
    }

    inline void elementRowDivide(size_type idx, const value_type& val)
    {
      elementRowNZApply(idx, nta::DividesByVal(val));
    }

    inline void elementColDivide(size_type idx, const value_type& val)
    {
      elementColNZApply(idx, nta::DividesByVal(val));
    }

    inline void divide(const value_type& val)
    {
      {
        if (!isZero_(val)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrix.hpp", 10849) << "ASSERTION FAILED: \"" << "!isZero_(val)" << "\" "
          << "divide: Division by zero";
      }

      elementNZApply(nta::DividesByVal(val));
    }

    inline void elementRowNZPow(size_type idx, const value_type& val)
    {
      elementRowNZApply(idx, nta::PowVal(val));
    }

    inline void elementColNZPow(size_type idx, const value_type& val)
    {
      elementColNZApply(idx, nta::PowVal(val));
    }

    inline void elementNZPow(const value_type& val)
    {
      elementNZApply(nta::PowVal(val));
    }

    inline void elementRowNZLogk(size_type idx, const value_type& val)
    {
      elementRowNZApply(idx, nta::LogkVal(val));
    }

    inline void elementColNZLogk(size_type idx, const value_type& val)
    {
      elementColNZApply(idx, nta::LogkVal(val));
    }

    inline void elementNZLogk(const value_type& val)
    {
      elementNZApply(nta::LogkVal(val));
    }

    template <typename InputIterator>
    inline void elementRowAdd(size_type idx, InputIterator x)
    {
      elementRowApply(idx, std::plus<value_type>(), x);
    }

    template <typename InputIterator>
    inline void elementRowSubtract(size_type idx, InputIterator x)
    {
      elementRowApply(idx, std::minus<value_type>(), x);
    }

    template <typename InputIterator>
    inline void elementRowDivide(size_type idx, InputIterator x)
    {
      elementRowNZApply(idx, std::divides<value_type>(), x);
    }

    template <typename InputIterator>
    inline void elementColAdd(size_type idx, InputIterator x)
    {
      elementColApply(idx, std::plus<value_type>(), x);
    }

    template <typename InputIterator>
    inline void elementColSubtract(size_type idx, InputIterator x)
    {
      elementColApply(idx, std::minus<value_type>(), x);
    }

    template <typename InputIterator>
    inline void elementColDivide(size_type idx, InputIterator x)
    {
      elementColNZApply(idx, std::divides<value_type>(), x);
    }

    inline void rowAdd(size_type idx, const value_type& val)
    {
      elementRowApply(idx, nta::PlusVal(val));
    }

    inline void colAdd(size_type idx, const value_type& val)
    {
      elementColApply(idx, nta::PlusVal(val));
    }

    inline void add(const value_type& val)
    {
      elementApply(nta::PlusVal(val));
    }

    inline void elementNZAdd(const value_type& val)
    {
      elementNZApply(nta::PlusVal(val));
    }

    inline void rowSubtract(size_type idx, const value_type& val)
    {
      elementRowApply(idx, nta::MinusVal(val));
    }

    inline void colSubtract(size_type idx, const value_type& val)
    {
      elementColApply(idx, nta::MinusVal(val));
    }

    inline void subtract(const value_type& val)
    {
      elementApply(nta::MinusVal(val));
    }

    inline void elementNZMultiply(const SparseMatrix& other)
    {
      elementMultiply(other);
    }

    inline void elementNZDivide(const SparseMatrix& other)
    {
      elementNZApply(other, nta::Divides<value_type>());
    }

    inline void subtract(const SparseMatrix& other)
    {
      elementApply(other, nta::Minus<value_type>());
    }





    inline void operator +=(const value_type& val)
    {
      add(val);
    }


    inline void operator -=(const value_type& val)
    {
      subtract(val);
    }


    inline void operator *=(const value_type& val)
    {
      multiply(val);
    }


    inline void operator /=(const value_type& val)
    {
      divide(val);
    }



  };


  template <typename I,typename F,typename I2,typename F2,typename ZeroTest>
  inline std::ostream& operator<<(std::ostream& out_stream,
                                  const SparseMatrix<I,F,I2,F2,ZeroTest>& x)
  {
    if (io_control.sparse_io == AS_DENSE) {
      x.print(out_stream, 2, 5);
    } else if (io_control.sparse_io == CSR)
      x.toCSR(out_stream);
    else if (io_control.sparse_io == BINARY)
      const_cast<SparseMatrix<I,F,I2,F2,ZeroTest>&>(x).toBinary(out_stream);
    return out_stream;
  }


  template <typename I,typename F,typename I2,typename F2,typename ZeroTest>
  inline std::istream& operator>>(std::istream& in_stream,
                                  SparseMatrix<I,F,I2,F2,ZeroTest>& x)
  {
    if (io_control.sparse_io == CSR)
      x.fromCSR(in_stream);
    else if (io_control.sparse_io == BINARY)
      x.fromBinary(in_stream);
    return in_stream;
  }





  template <typename I,typename F,typename I2,typename F2,typename ZeroTest>
  inline
  bool operator==(const SparseMatrix<I,F,I2,F2,ZeroTest>& A,
                  const SparseMatrix<I,F,I2,F2,ZeroTest>& B)
  {
    return A.equals(B);
  }

  template <typename I,typename F,typename I2,typename F2,typename ZeroTest>
  inline
  bool operator!=(const SparseMatrix<I,F,I2,F2,ZeroTest>& A,
                  const SparseMatrix<I,F,I2,F2,ZeroTest>& B)
  {
    return !A.equals(B);
  }



}
# 32 "/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp" 2



namespace nta {

  template <typename T>
  class NearestNeighbor : public T
  {
  public:
    typedef T parent_type;
    typedef NearestNeighbor self_type;

    typedef typename parent_type::size_type size_type;
    typedef typename parent_type::difference_type difference_type;
    typedef typename parent_type::value_type value_type;
    typedef typename parent_type::prec_value_type prec_value_type;




    inline NearestNeighbor()
      : parent_type()
    {}
# 69 "/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp"
    inline NearestNeighbor(size_type nrows, size_type ncols)
      : parent_type(nrows, ncols)
    {}
# 89 "/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp"
    template <typename InputIterator>
    inline NearestNeighbor(size_type nrows, size_type ncols, InputIterator dense)
      : parent_type(nrows, ncols, dense)
    {}






    inline NearestNeighbor(std::istream& inStream)
      : parent_type(inStream)
    {}
# 111 "/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp"
    inline NearestNeighbor(const NearestNeighbor& other)
      : parent_type(other)
    {}





    inline NearestNeighbor& operator=(const NearestNeighbor& other)
    {
      parent_type::operator=(other);
      return *this;
    }





  private:
    template <typename InputIterator, typename F>
    inline void
    compute_powers_(value_type& Sp_x, value_type* p_x, InputIterator x, F f)
    {
      const size_type ncols = this->nCols();
      InputIterator end1 = x + 4*(ncols/4), end2 = x + ncols;
      Sp_x = (value_type) 0;

      for (; x != end1; x += 4, p_x += 4) {
 *p_x = f(Sp_x, *x);
 *(p_x+1) = f(Sp_x, *(x+1));
 *(p_x+2) = f(Sp_x, *(x+2));
 *(p_x+3) = f(Sp_x, *(x+3));
      }

      for (; x != end2; ++x)
 *p_x++ = f(Sp_x, *x);
    }






  private:
    template <typename InputIterator, typename F>
    inline value_type
    sum_of_p_diff_(size_type row, InputIterator x, value_type Sp_x, value_type *p_x,
     F f) const
    {
      size_type nnzr = this->nnzr_[row], j, *ind = this->ind_[row];
      value_type *nz = this->nz_[row];
      value_type val = Sp_x, val1 = 0, val2 = 0;
      size_type *end1 = ind + 4*(nnzr/4), *end2 = ind + nnzr;

      while (ind != end1) {
 j = *ind++;
 val1 = *nz++ - x[j];
 f(val, val1);
 val -= p_x[j];
 j = *ind++;
 val2 = *nz++ - x[j];
 f(val, val2);
 val -= p_x[j];
 j = *ind++;
 val1 = *nz++ - x[j];
 f(val, val1);
 val -= p_x[j];
 j = *ind++;
 val2 = *nz++ - x[j];
 f(val, val2);
 val -= p_x[j];
      }

      while (ind != end2) {
 j = *ind++;
 val1 = *nz++ - x[j];
 f(val, val1);
 val -= p_x[j];
      }



      if (val <= (value_type) 0)
 val = (value_type) 0;

      return val;
    }
# 206 "/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp"
  private:
    template <typename InputIterator, typename F>
    inline value_type
    one_row_dist_1(size_type row, InputIterator x, F f) const
    {
      const size_type ncols = this->nCols();
      size_type *ind = this->ind_[row], *ind_end = ind + this->nnzr_[row], j = 0;
      value_type *nz = this->nz_[row], d = (value_type) 0.0;

      while (ind != ind_end) {
 size_type j_end = *ind++;
 while (j != j_end)
   f(d, x[j++]);
 f(d, x[j++] - *nz++);
      }

      if (j < ncols)
 while (j != ncols)
   f(d, x[j++]);

      return d;
    }
# 237 "/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp"
  private:
    template <typename InputIterator, typename F>
    inline value_type
    one_row_dist_2(size_type row, InputIterator x, F f,
     bool take_root =false) const
    {
      value_type Sp_x = 0.0;

      const_cast<self_type*>(this)->compute_powers_(Sp_x, this->nzb_, x, f);
      value_type val = sum_of_p_diff_(row, x, Sp_x, this->nzb_, f);

      if (take_root)
 val = f.root(val);

      return val;
    }
# 263 "/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp"
  private:
    template <typename InputIterator, typename OutputIterator, typename F>
    inline void
    all_rows_dist_(InputIterator x, OutputIterator y, F f,
     bool take_root =false) const
    {
      {
 if (this->nRows() > 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 270) << "ASSERTION FAILED: \"" << "this->nRows() > 0" << "\" "
   << "NearestNeighbor::all_rows_dist_(): "
   << "No vector stored yet";
      }

      const size_type nrows = this->nRows();
      OutputIterator y_begin = y, y_end = y + nrows;
      value_type Sp_x = 0.0;

      const_cast<self_type*>(this)->compute_powers_(Sp_x, this->nzb_, x, f);

      for (size_type i = 0; i != nrows; ++i, ++y)
 *y = sum_of_p_diff_(i, x, Sp_x, this->nzb_, f);

      if (take_root)
 for (y = y_begin; y != y_end; ++y)
   *y = f.root(*y);
    }





  private:
    template <typename InputIterator, typename OutputIterator, typename F>
    inline void
    k_nearest_(InputIterator x, OutputIterator nn, F f,
        size_type k =1, bool take_root =false) const
    {
      {
 if (k >= 1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 300) << "ASSERTION FAILED: \"" << "k >= 1" << "\" "
   << "NearestNeighbor::k_nearest_(): "
   << "Invalid number of nearest rows: " << k
   << " - Should be >= 1, default value is 1";

 if (this->nRows() > 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 305) << "ASSERTION FAILED: \"" << "this->nRows() > 0" << "\" "
   << "NearestNeighbor::k_nearest_(): "
   << "No vector stored yet";
      }

      std::vector<value_type> b(this->nRows());
      all_rows_dist_(x, b.begin(), f, take_root);
      partial_sort_2nd(k, b, nn, std::less<value_type>());
    }

  public:
# 334 "/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp"
    template <typename InputIterator>
    inline value_type rowL0Dist(size_type row, InputIterator x) const
    {
      {
 if (this->nRows() > 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 338) << "ASSERTION FAILED: \"" << "this->nRows() > 0" << "\" "
   << "NearestNeighbor::rowL0Dist(): "
   << "No vector stored yet";

 if (row >= 0 && row < this->nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 342) << "ASSERTION FAILED: \"" << "row >= 0 && row < this->nRows()" << "\" "
   << "NearestNeighbor::rowL0Dist(): "
   << "Invalid row index: " << row
   << " - Should be >= 0 and < nrows = " << this->nRows();
      }

      return one_row_dist_1(row, x, Lp0<value_type>());
    }
# 369 "/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp"
    template <typename InputIterator>
    inline value_type rowL1Dist(size_type row, InputIterator x) const
    {
      {
 if (this->nRows() > 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 373) << "ASSERTION FAILED: \"" << "this->nRows() > 0" << "\" "
   << "NearestNeighbor::rowL1Dist(): "
   << "No vector stored yet";

 if (row >= 0 && row < this->nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 377) << "ASSERTION FAILED: \"" << "row >= 0 && row < this->nRows()" << "\" "
   << "NearestNeighbor::rowL1Dist(): "
   << "Invalid row index: " << row
   << " - Should be >= 0 and < nrows = " << this->nRows();
      }

      return one_row_dist_1(row, x, Lp1<value_type>());
    }
# 408 "/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp"
    template <typename InputIterator>
    inline value_type
    rowL2Dist(size_type row, InputIterator x, bool take_root =false) const
    {
      {
 if (this->nRows() > 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 413) << "ASSERTION FAILED: \"" << "this->nRows() > 0" << "\" "
   << "NearestNeighbor::rowL2Dist(): "
   << "No vector stored yet";

 if (row >= 0 && row < this->nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 417) << "ASSERTION FAILED: \"" << "row >= 0 && row < this->nRows()" << "\" "
   << "NearestNeighbor::rowL2Dist(): "
   << "Invalid row index: " << row
   << " - Should be >= 0 and < nrows = " << this->nRows();
      }

      return one_row_dist_2(row, x, Lp2<value_type>(), take_root);
    }
# 444 "/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp"
    template <typename InputIterator>
    inline value_type rowLMaxDist(size_type row, InputIterator x) const
    {
      {
 if (this->nRows() > 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 448) << "ASSERTION FAILED: \"" << "this->nRows() > 0" << "\" "
   << "NearestNeighbor::rowLMaxDist(): "
   << "No vector stored yet";

 assert_valid_row_(row, "rowLMaxDist");
      }

      return one_row_dist_1(row, x, LpMax<value_type>());
    }
# 480 "/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp"
    template <typename InputIterator>
    inline value_type
    rowLpDist(value_type p, size_type row, InputIterator x,
       bool take_root =false) const
    {
      {
 if (this->nRows() > 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 486) << "ASSERTION FAILED: \"" << "this->nRows() > 0" << "\" "
   << "NearestNeighbor::rowLpDist(): "
   << "No vector stored yet";

 assert_valid_row_(row, "rowLpDist");

 if (p >= (value_type)0.0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 492) << "ASSERTION FAILED: \"" << "p >= (value_type)0.0" << "\" "
   << "NearestNeighbor::rowLpDist():"
   << "Invalid value for parameter p: " << p
   << " - Only positive values (p >= 0) are supported";
      }

      if (p == (value_type)0.0)
 return rowL0Dist(row, x);

      if (p == (value_type)1.0)
 return rowL1Dist(row, x);

      if (p == (value_type)2.0)
 return rowL2Dist(row, x, take_root);

      return one_row_dist_2(row, x, Lp<value_type>(p), take_root);
    }
# 527 "/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp"
    template <typename InputIterator, typename OutputIterator>
    inline void L0Dist(InputIterator x, OutputIterator y) const
    {
      {
 if (this->nRows() > 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 531) << "ASSERTION FAILED: \"" << "this->nRows() > 0" << "\" "
   << "NearestNeighbor::L0Dist(): "
   << "No vector stored yet";
      }

      const size_type nrows = this->nRows();
      Lp0<value_type> f;

      for (size_type i = 0; i != nrows; ++i, ++y)
 *y = one_row_dist_1(i, x, f);
    }
# 560 "/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp"
    template <typename InputIterator, typename OutputIterator>
    inline void L1Dist(InputIterator x, OutputIterator y) const
    {
      {
 if (this->nRows() > 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 564) << "ASSERTION FAILED: \"" << "this->nRows() > 0" << "\" "
   << "NearestNeighbor::L1Dist(): "
   << "No vector stored yet";
      }

      const size_type nrows = this->nRows(), ncols = this->nCols();
      value_type s = 0.0;
      Lp1<value_type> f;

      InputIterator x_ptr = x;
      for (size_type j = 0; j != ncols; ++j, ++x_ptr)
 this->nzb_[j] = f(s, *x_ptr);

      for (size_type i = 0; i != nrows; ++i, ++y) {
 size_type *ind = this->ind_[i], *ind_end = ind + this->nnzr_[i];
 value_type *nz = this->nz_[i], d = s;
 for (; ind != ind_end; ++ind, ++nz) {
   size_type j = *ind;
   f(d, x[j] - *nz);
   d -= this->nzb_[j];
 }
        if (d <= (value_type) 0)
          d = (value_type) 0;
 *y = d;
      }
    }
# 609 "/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp"
    template <typename InputIterator, typename OutputIterator>
    inline void L2Dist(InputIterator x, OutputIterator y, bool take_root =false) const
    {
      {
 if (this->nRows() > 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 613) << "ASSERTION FAILED: \"" << "this->nRows() > 0" << "\" "
   << "NearestNeighbor::L2Dist(): "
   << "No vector stored yet";
      }

      all_rows_dist_(x, y, Lp2<value_type>(), take_root);
    }
# 633 "/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp"
    template <typename InputIterator, typename OutputIterator>
    inline void LMaxDist(InputIterator x, OutputIterator y) const
    {
      {
 if (this->nRows() > 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 637) << "ASSERTION FAILED: \"" << "this->nRows() > 0" << "\" "
   << "NearestNeighbor::LMaxDist(): "
   << "No vector stored yet";
      }

      const size_type nrows = this->nRows();
      LpMax<value_type> f;

      for (size_type i = 0; i != nrows; ++i, ++y)
 *y = one_row_dist_1(i, x, f);
    }
# 667 "/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp"
    template <typename InputIterator, typename OutputIterator>
    inline void
    LpDist(value_type p,
    InputIterator x, OutputIterator y, bool take_root=false) const
    {
      {
 if (this->nRows() > 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 673) << "ASSERTION FAILED: \"" << "this->nRows() > 0" << "\" "
   << "NearestNeighbor::LpDist(): "
   << "No vector stored yet";

 if (p >= (value_type)0.0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 677) << "ASSERTION FAILED: \"" << "p >= (value_type)0.0" << "\" "
   << "NearestNeighbor::LpDist():"
   << "Invalid value for parameter p: " << p
   << " - Only positive values (p >= 0) are supported";
      }

      if (p == (value_type)0.0) {
 L0Dist(x, y);
 return;
      }

      if (p == (value_type)1.0) {
 L1Dist(x, y);
 return;
      }

      if (p == (value_type)2.0) {
 L2Dist(x, y, take_root);
 return;
      }

      all_rows_dist_(x, y, Lp<value_type>(p), take_root);
    }
# 715 "/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp"
    template <typename InputIterator, typename OutputIterator>
    inline void
    L0Nearest(InputIterator x, OutputIterator nn, size_type k =1) const
    {
      {
 if (this->nRows() > 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 720) << "ASSERTION FAILED: \"" << "this->nRows() > 0" << "\" "
   << "NearestNeighbor::L0Nearest(): "
   << "No vector stored yet";

 if (k >= 1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 724) << "ASSERTION FAILED: \"" << "k >= 1" << "\" "
   << "NearestNeighbor::L0Nearest():"
   << "Invalid number of nearest rows: " << k
   << " - Should be >= 1, default is 1";
      }

      k_nearest_(x, nn, Lp0<value_type>(), k);
    }
# 747 "/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp"
    template <typename InputIterator, typename OutputIterator>
    inline void
    L1Nearest(InputIterator x, OutputIterator nn, size_type k =1) const
    {
      {
 if (this->nRows() > 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 752) << "ASSERTION FAILED: \"" << "this->nRows() > 0" << "\" "
   << "NearestNeighbor::L1Nearest(): "
   << "No vector stored yet";

 if (k >= 1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 756) << "ASSERTION FAILED: \"" << "k >= 1" << "\" "
   << "NearestNeighbor::L1Nearest():"
   << "Invalid number of nearest rows: " << k
   << " - Should be >= 1, default is 1";
      }

      k_nearest_(x, nn, Lp1<value_type>(), k);
    }
# 782 "/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp"
    template <typename InputIterator, typename OutputIterator>
    inline void
    L2Nearest(InputIterator x, OutputIterator nn, size_type k =1,
       bool take_root =false) const
    {
      {
 if (this->nRows() > 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 788) << "ASSERTION FAILED: \"" << "this->nRows() > 0" << "\" "
   << "NearestNeighbor::L2Nearest(): "
   << "No vector stored yet";

 if (k >= 1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 792) << "ASSERTION FAILED: \"" << "k >= 1" << "\" "
   << "NearestNeighbor::L2Nearest():"
   << "Invalid number of nearest rows: " << k
   << " - Should be >= 1, default is 1";
      }

      k_nearest_(x, nn, Lp2<value_type>(), k, take_root);
    }
# 815 "/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp"
    template <typename InputIterator, typename OutputIterator>
    inline void
    LMaxNearest(InputIterator x, OutputIterator nn, size_type k =1) const
    {
      {
 if (this->nRows() > 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 820) << "ASSERTION FAILED: \"" << "this->nRows() > 0" << "\" "
   << "NearestNeighbor::LMaxNearest(): "
   << "No vector stored yet";

 if (k >= 1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 824) << "ASSERTION FAILED: \"" << "k >= 1" << "\" "
   << "NearestNeighbor::LMaxNearest():"
   << "Invalid number of nearest rows: " << k
   << " - Should be >= 1, default is 1";
      }

      std::vector<value_type> b(this->nRows());
      LMaxDist(x, b.begin());
      partial_sort_2nd(k, b, nn, std::less<value_type>());
    }
# 853 "/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp"
    template <typename InputIterator, typename OutputIterator>
    inline void
    LpNearest(value_type p, InputIterator x, OutputIterator nn,
       size_type k =1, bool take_root =false) const
    {
      {
 if (this->nRows() > 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 859) << "ASSERTION FAILED: \"" << "this->nRows() > 0" << "\" "
   << "NearestNeighbor::LpNearest(): "
   << "No vector stored yet";

 if (p >= (value_type)0.0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 863) << "ASSERTION FAILED: \"" << "p >= (value_type)0.0" << "\" "
   << "NearestNeighbor::LpNearest():"
   << "Invalid value for parameter p: " << p
   << " - Only positive values (p >= 0) are supported";

 if (k >= 1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 868) << "ASSERTION FAILED: \"" << "k >= 1" << "\" "
   << "NearestNeighbor::LpNearest():"
   << "Invalid number of nearest rows: " << k
   << " - Should be >= 1, default is 1";
      }

      if (p == (value_type)0.0) {
 L0Nearest(x, nn, k);
 return;
      }

      if (p == (value_type)1.0) {
 L1Nearest(x, nn, k);
 return;
      }

      if (p == (value_type)2.0) {
 L2Nearest(x, nn, k, take_root);
 return;
      }

      k_nearest_(x, nn, Lp<value_type>(p), k, take_root);
    }


    template <typename InputIterator1,
       typename InputIterator2,
       typename OutputIterator>
    inline void
    LpNearest(value_type p, InputIterator1 ind, InputIterator1 ind_end,
       InputIterator2 nz, OutputIterator nn,
       size_type k =1, bool take_root =false) const
    {
      std::vector<value_type> x(this->nCols());
      to_dense(ind, ind_end, nz, nz + (ind_end - ind), x.begin(), x.end());
      LpNearest(p, x.begin(), nn, k, take_root);
    }
# 925 "/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp"
    template <typename InputIterator>
    inline std::pair<size_type, value_type> dotNearest(InputIterator x) const
    {
      {
 if (this->nRows() > 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 929) << "ASSERTION FAILED: \"" << "this->nRows() > 0" << "\" "
   << "NearestNeighbor::dotNearest(): "
   << "No vector stored yet";
      }

      size_type i, k, nnzr, *ind, end, nrows = this->nRows();
      value_type val, *nz;

      size_type arg_i = 0;
      value_type max_v = - std::numeric_limits<value_type>::max();

      for (i = 0; i != nrows; ++i) {

 val = 0;
 nnzr = this->nnzr_[i];
 ind = this->ind_[i];
 nz = this->nz_[i];
 end = 4 * (nnzr / 4);

 for (k = 0; k != end; k += 4)
   val += nz[k] * x[ind[k]] + nz[k+1] * x[ind[k+1]]
     + nz[k+2] * x[ind[k+2]] + nz[k+3] * x[ind[k+3]];

 for (k = end; k != nnzr; ++k)
   val += nz[k] * x[ind[k]];

 if (val > max_v) {
   arg_i = i;
   max_v = val;
 }
      }

      return std::make_pair(arg_i, max_v);
    }
# 971 "/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp"
    std::vector<value_type> stddev_;

    template <typename InputIterator, typename OutputIterator>
    inline void
    LpNearest_w(value_type p, InputIterator x, OutputIterator nn,
  size_type k =1, bool take_root =false)
    {
      {
 if (p >= (value_type)0.0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 979) << "ASSERTION FAILED: \"" << "p >= (value_type)0.0" << "\" "
   << "NearestNeighbor::LpNearest_w():"
   << "Invalid value for parameter p: " << p
   << " - Only positive values (p >= 0) are supported";

 if (k >= 1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 984) << "ASSERTION FAILED: \"" << "k >= 1" << "\" "
   << "NearestNeighbor::LpNearest_w():"
   << "Invalid number of nearest rows: " << k
   << " - Should be >= 1, default is 1";
      }

      const size_type nrows = this->nRows(), ncols = this->nCols();
      std::vector<value_type> e(ncols, 0), e2(ncols, 0);

      if (stddev_.empty()) {

 stddev_.resize(ncols, 0);

 for (size_type i = 0; i != nrows; ++i) {
   size_type *ind = this->ind_[i], *ind_end = ind + this->nnzr_[i];
   value_type *nz = this->nz_[i];
   while (ind != ind_end) {
     size_type idx = *ind++;
     value_type val = *nz++;
     e[idx] += val;
     e2[idx] += val * val;
   }
 }

 nta::Sqrt<value_type> sf;

 for (size_type j = 0; j != ncols; ++j)
   stddev_[j] = sf((e2[j] - e[j]*e[j]/nrows) / (nrows-1));
      }

      Lp<value_type> f(p);
      value_type Sp_x = 0;
      for (size_type j = 0; j != ncols; ++j)
 this->nzb_[j] = f(Sp_x, x[j]/stddev_[j]);

      std::vector<value_type> b(nrows);

      for (size_type i = 0; i != nrows; ++i) {
 size_type *ind = this->ind_[i], *ind_end = ind + this->nnzr_[i];
 value_type *nz = this->nz_[i], d = Sp_x;
 while (ind != ind_end) {
   size_type j = *ind++;
   f(d, (*nz++ - x[j])/stddev_[j]);
   d -= this->nzb_[j];
 }
 if (d <= (value_type) 0)
   d = (value_type) 0;
 b[i] = d;
      }

      partial_sort_2nd(k, b, nn, std::less<value_type>());
    }




    template <typename InputIterator, typename OutputIterator>
    inline void rbf(value_type p, value_type k,
      InputIterator in_begin, OutputIterator out_begin) const
    {
     {
 if (this->nRows() > 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 1045) << "ASSERTION FAILED: \"" << "this->nRows() > 0" << "\" "
   << "NearestNeighbor::rbf(): "
   << "No vector stored yet";

 if (p >= (value_type)0.0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 1049) << "ASSERTION FAILED: \"" << "p >= (value_type)0.0" << "\" "
   << "NearestNeighbor::rbf():"
   << "Invalid value for parameter p: " << p
   << " - Only positive values (p >= 0) are supported";
      }

     LpDist(p, in_begin, out_begin, false);

     range_exp(k, out_begin, out_begin + this->nRows());
    }




  private:
    template <typename InputIterator, typename OutputIterator, typename F>
    inline void
    proj_all_rows_dist_(InputIterator x, OutputIterator y, F f,
   bool take_root =false) const
    {
      const size_type nrows = this->nRows();
      OutputIterator y_begin = y, y_end = y_begin + nrows;

      for (size_type row = 0; row != nrows; ++row, ++y) {
 size_type *ind = this->ind_[row];
 size_type *ind_end = ind + this->nNonZerosOnRow(row);
 value_type *nz = this->nz_[row], val = 0;
 for (; ind != ind_end; ++ind, ++nz)
   f(val, *nz - *(x + *ind));
 *y = val;
      }

      if (take_root) {
 for (y = y_begin; y != y_end; ++y)
   *y = f.root(*y);
      }
    }


  public:
    template <typename InputIterator, typename OutputIterator>
    inline void
    projLpDist(value_type p, InputIterator x, OutputIterator y,
        bool take_root =false) const
    {
       {
 if (this->nRows() > 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 1095) << "ASSERTION FAILED: \"" << "this->nRows() > 0" << "\" "
   << "NearestNeighbor::projLpDist(): "
   << "No vector stored yet";

 if (p >= (value_type)0.0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 1099) << "ASSERTION FAILED: \"" << "p >= (value_type)0.0" << "\" "
   << "NearestNeighbor::projLpDist():"
   << "Invalid value for parameter p: " << p
   << " - Only positive values (p >= 0) are supported";
      }

       if (p == (value_type) 0.0) {
  proj_all_rows_dist_(x, y, Lp0<value_type>(), take_root);

       } else if (p == (value_type) 1.0) {
  proj_all_rows_dist_(x, y, Lp1<value_type>(), take_root);

       } else if (p == (value_type) 2.0) {
  proj_all_rows_dist_(x, y, Lp2<value_type>(), take_root);

       } else {
  proj_all_rows_dist_(x, y, Lp<value_type>(p), take_root);
       }
    }






    template <typename InputIterator, typename OutputIterator>
    inline void
    projLpNearest(value_type p, InputIterator x, OutputIterator nn,
    size_type k =1, bool take_root =false) const
    {
      {
 if (this->nRows() > 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 1130) << "ASSERTION FAILED: \"" << "this->nRows() > 0" << "\" "
   << "NearestNeighbor::projLpNearest(): "
   << "No vector stored yet";

 if (p >= (value_type)0.0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 1134) << "ASSERTION FAILED: \"" << "p >= (value_type)0.0" << "\" "
   << "NearestNeighbor::projLpNearest():"
   << "Invalid value for parameter p: " << p
   << " - Only positive values (p >= 0) are supported";

 if (k >= 1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 1139) << "ASSERTION FAILED: \"" << "k >= 1" << "\" "
   << "NearestNeighbor::projLpNearest():"
   << "Invalid number of nearest rows: " << k
   << " - Should be >= 1, default is 1";
      }

      std::vector<value_type> b(this->nRows());
      projLpDist(p, x, b.begin(), take_root);
      partial_sort_2nd(k, b, nn, std::less<value_type>());
    }


    template <typename InputIterator1,
       typename InputIterator2,
       typename OutputIterator>
    inline void
    projLpNearest(value_type p, InputIterator1 ind, InputIterator1 ind_end,
    InputIterator2 nz, OutputIterator nn,
    size_type k =1, bool take_root =false) const
    {
      std::vector<value_type> x(this->nCols());
      to_dense(ind, ind_end, nz, nz + (ind_end - ind), x.begin(), x.end());
      projLpNearest(p, x.begin(), nn, k, take_root);
    }


    template <typename InputIterator, typename OutputIterator>
    inline void projRbf(value_type p, value_type k,
   InputIterator in_begin, OutputIterator out_begin) const
    {
      {
 if (this->nRows() > 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 1170) << "ASSERTION FAILED: \"" << "this->nRows() > 0" << "\" "
   << "NearestNeighbor::projRbf(): "
   << "No vector stored yet";

 if (p >= (value_type)0.0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/NearestNeighbor.hpp", 1174) << "ASSERTION FAILED: \"" << "p >= (value_type)0.0" << "\" "
   << "NearestNeighbor::projRbf():"
   << "Invalid value for parameter p: " << p
   << " - Only positive values (p >= 0) are supported";
      }

      projLpDist(p, in_begin, out_begin, false);

      range_exp(k, out_begin, out_begin + this->nRows());
    }

  };



}
# 39 "/home/marek/devel/nupic/nta/algorithms/SparsePooler.hpp" 2

namespace nta {







  class SparsePoolerInputMasks
  {
  public:

    typedef nta::UInt size_type;
    typedef nta::Real value_type;


    typedef std::vector<std::pair<size_type, size_type> > Mask;

    SparsePoolerInputMasks();
    SparsePoolerInputMasks(size_type ss, const std::vector<Mask>& masks);
    SparsePoolerInputMasks(std::istream& inStream);
    SparsePoolerInputMasks& operator=(const SparsePoolerInputMasks& other);

    inline size_t nMasks() const { return masks_.size(); }
    inline bool empty() const { return nMasks() == 0; }
    inline size_type segmentSize() const { return segment_size_; }
    inline size_type minSize() const { return min_size_; }
    inline size_type maxSize() const { return max_size_; }
    inline size_type size(size_type i) const { return sizes_[i]; }
    inline const Mask& mask(size_type i) const { return masks_[i]; }

    inline value_type ratio(size_type i) const
    {

      return (value_type)sizes_[i] / (value_type)min_size_;
    }

    void saveState(std::ostream& outStream) const;
    void readState(std::istream& inStream);

  private:
    size_type segment_size_;
    size_type min_size_;
    size_type max_size_;
    std::vector<size_type> sizes_;
    std::vector<Mask> masks_;

    void compute_cache_();
  };


  class SparsePooler
  {
  public:
    typedef nta::UInt size_type;
    typedef nta::Real value_type;

    typedef SparseMatrix<size_type, value_type> SM;
    typedef NearestNeighbor<SM> Prototypes;

    typedef enum { none, kWinners, threshold } SparsificationMode;
    typedef enum { gaussian, dot, product, kthroot_product } InferenceMode;

    static SparsificationMode convertSparsificationMode(const std::string& name)
    {
      if (name == "0") return none;
      else if (name == "1") return kWinners;
      else if (name == "2") return threshold;
      else if (name == "none") return none;
      else if (name == "kWinners") return kWinners;
      else if (name == "threshold") return threshold;

      throw nta::LoggingException("/home/marek/devel/nupic/nta/algorithms/SparsePooler.hpp", 112) << "Invalid SparsePooler sparsification mode: "
  << name
  << " - Should be one of: 0,1,2 or "
  << "none,kWinners,threshold.";
      return none;
    }

    static std::string convertSparsificationMode(SparsificationMode mode)
    {
      if (mode == none)
 return std::string("none");
      else if (mode == kWinners)
 return std::string("kWinners");
      else if (mode == threshold)
 return std::string("threshold");
      return std::string("Unknown");
    }

    static InferenceMode convertInferenceMode(const std::string& name)
    {
      if (name == "0") return gaussian;
      else if (name == "1") return dot;
      else if (name == "2") return product;
      else if (name == "3") return kthroot_product;
      else if (name == "gaussian") return gaussian;
      else if (name == "dot") return dot;
      else if (name == "product") return product;
      else if (name == "kthroot_product") return kthroot_product;

      throw nta::LoggingException("/home/marek/devel/nupic/nta/algorithms/SparsePooler.hpp", 141) << "Invalid SparsePooler inference mode: "
  << name
  << " - Should be one of: 0,1,2,3 or "
  << "gaussian,dot,product,kthroot_product.";
      return gaussian;
    }

    static std::string convertInferenceMode(InferenceMode mode)
    {
      if (mode == gaussian)
 return std::string("gaussian");
      else if (mode == dot)
 return std::string("dot");
      else if (mode == product)
 return std::string("product");
      else if (mode == kthroot_product)
 return std::string("kthroot_product");
      return std::string("Unknown");
    }

    SparsePooler();

    SparsePooler(const SparsePoolerInputMasks& inputMasks,
   size_type normalize,
   value_type norm,
   size_type sparsification_mode,
   size_type inference_mode,
   size_type kWinners,
   value_type threshold,
   value_type min_accept_distance,
   value_type min_accept_norm,
   value_type min_proto_sum,
   value_type sigma,
   UInt32 seed =0);

    SparsePooler(std::istream& inStream, UInt32 seed =0);

    ~SparsePooler();

    void saveState(std::ostream& outStream) const;
    void readState(std::istream& inStream);

    inline void setDoNormalization(size_type flag)
    {
      if (flag == 0 || flag == 1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/algorithms/SparsePooler.hpp", 185) << "CHECK FAILED: \"" << "flag == 0 || flag == 1" << "\" "
 << "SparsePooler::setDoNormalization: "
 << "Invalid value: " << flag
 << " - Should be boolean";

      normalize_ = flag == (size_type) 1;
    }

    inline size_type getDoNormalization() const
    {
      return (size_type) normalize_;
    }

    inline void setNorm(value_type lp)
    {
      if (0 <= lp) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/algorithms/SparsePooler.hpp", 200) << "CHECK FAILED: \"" << "0 <= lp" << "\" "
 << "SparsePooler::setNorm: "
 << "Invalid value for norm: " << lp
 << " - Should be >= 0";

      lp_ = lp;
    }

    inline value_type getNorm() const
    {
      return lp_;
    }

    inline void setSparsificationMode(size_type mode)
    {
      if (0 <= mode && mode < 3) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/algorithms/SparsePooler.hpp", 215) << "CHECK FAILED: \"" << "0 <= mode && mode < 3" << "\" "
 << "SparsePooler::setSparsificationMode: "
 << "Invalid value: " << mode
 << " - Should be 0, 1, or 2";

      sparsification_mode_ = (SparsificationMode) mode;
    }

    inline size_type getSparsificationMode() const
    {
      return (size_type) sparsification_mode_;
    }

    inline std::string getSparsificationModeStr() const
    {
      return SparsePooler::convertSparsificationMode(sparsification_mode_);
    }

    inline void setKWinners(size_type kWinners)
    {
      if (0 <= kWinners && kWinners <= getSegmentSize()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/algorithms/SparsePooler.hpp", 235) << "CHECK FAILED: \"" << "0 <= kWinners && kWinners <= getSegmentSize()" << "\" "
 << "SparsePooler::setKWinners: "
 << "Invalid k: " << kWinners
 << " - Should be 0 <= and <= " << getSegmentSize();

      k_winners_ = kWinners;
    }

    inline size_type getKWinners() const
    {
      return k_winners_;
    }

    inline void setThreshold(value_type threshold)
    {
      if (threshold >= 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/algorithms/SparsePooler.hpp", 250) << "CHECK FAILED: \"" << "threshold >= 0" << "\" "
 << "SparsePooler::setThreshold: "
 << "Invalid threshold: " << threshold
 << " - Should be >= 0";

      threshold_ = threshold;
    }

    inline value_type getThreshold() const
    {
      return threshold_;
    }

    inline void setMinAcceptDistance(value_type d)
    {
      if (nta::Epsilon <= d) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/algorithms/SparsePooler.hpp", 265) << "CHECK FAILED: \"" << "nta::Epsilon <= d" << "\" "
 << "SparsePooler::setMinAcceptDistance: "
 << "Invalid distance: " << d
 << " - Should be >= nta::Epsilon = "
 << nta::Epsilon;

      min_accept_distance_ = d;
    }

    inline value_type getMinAcceptDistance() const
    {
      return min_accept_distance_;
    }

    inline void setMinAcceptNorm(value_type d)
    {
      if (0 <= d) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/algorithms/SparsePooler.hpp", 281) << "CHECK FAILED: \"" << "0 <= d" << "\" "
 << "SparsePooler::setMinAcceptNorm: "
 << "Invalid norm: " << d
 << " - Should be positive";

      min_accept_norm_ = d;
    }

    inline value_type getMinAcceptNorm() const
    {
      return min_accept_norm_;
    }

    inline void setMinProtoSum(value_type x)
    {
      if (0 < x) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/algorithms/SparsePooler.hpp", 296) << "CHECK FAILED: \"" << "0 < x" << "\" "
 << "SparsePooler::setMinProtoSum: "
 << "Invalid value: " << x
 << " - Should be > 0";

      min_proto_sum_ = x;
    }

    inline value_type getMinProtoSum() const
    {
      return min_proto_sum_;
    }

    inline void setInferenceMode(size_type mode)
    {
      if (0 <= mode && mode < 4) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/algorithms/SparsePooler.hpp", 311) << "CHECK FAILED: \"" << "0 <= mode && mode < 4" << "\" "
 << "SparsePooler::setInferenceMode: "
 << "Invalid value: " << mode
 << " - Should be 0, 1, 2 or 3";

      inference_mode_ = (InferenceMode) mode;
    }

    inline size_type getInferenceMode() const
    {
      return (size_type) inference_mode_;
    }

    inline std::string getInferenceModeStr() const
    {
      return SparsePooler::convertInferenceMode(inference_mode_);
    }

    inline void setSigma(value_type s)
    {
      if (0 < s) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/algorithms/SparsePooler.hpp", 331) << "CHECK FAILED: \"" << "0 < s" << "\" "
 << "SparsePooler::setSigma: "
 << "Invalid sigma: " << s
 << " - Should be positive";

      sigma_ = s;
    }

    inline value_type getSigma() const
    {
      return sigma_;
    }

    inline const std::string& getCurrentSparsePoolerVersion() const
    {
      return current_sparse_pooler_version_;
    }

    inline size_type getSegmentSize() const
    {
      return getInputMasks().segmentSize();
    }

    inline const SparsePoolerInputMasks& getInputMasks() const
    {
      return input_masks_;
    }

    inline SparsePoolerInputMasks& getInputMasks()
    {
      return input_masks_;
    }

    inline void setInputMasks(const SparsePoolerInputMasks& masks)
    {
      input_masks_ = masks;
      prototypes_.resize(masks.nMasks());
      for (size_type i = 0; i != masks.nMasks(); ++i)
        prototypes_[i].resize(0, masks.size(i));
    }

    inline size_type getTotalNPrototypes() const
    {
      size_type n = 0;
      for (size_type i = 0; i != prototypes_.size(); ++i)
 n += prototypes_[i].nRows();
      return n;
    }

    inline size_t getNPrototypeSizes() const
    {
      return prototypes_.size();
    }

    inline size_type getNPrototypes(size_type i) const
    {
      {
 if (0 <= i && i < prototypes_.size()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/algorithms/SparsePooler.hpp", 388) << "ASSERTION FAILED: \"" << "0 <= i && i < prototypes_.size()" << "\" "
   << "SparsPooler::getNPrototypes: "
   << "Invalid index: " << i
   << " - Should be between 0 and " << prototypes_.size();
      }

      return prototypes_[i].nRows();
    }

    inline const Prototypes& getPrototypes(size_type i) const
    {
      {
 if (0 <= i && i < prototypes_.size()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/algorithms/SparsePooler.hpp", 400) << "ASSERTION FAILED: \"" << "0 <= i && i < prototypes_.size()" << "\" "
   << "SparsePooler::getPrototypes: Invalid index: " << i
   << " - Should be between 0 and " << prototypes_.size();
      }
      return prototypes_[i];
    }


    inline SM* getCoincidenceMatrixHandle() const
    {

      cachedCM_ .resize(0, getInputMasks().maxSize(), true);
      for (size_type i = 0; i != prototypes_.size(); ++i)
 cachedCM_.append(getPrototypes(i), true);
      return &cachedCM_;
    }

    inline void
    getCoincidenceMatrix(std::ostream& buf, bool dense =false) const
    {
      SM* cm = getCoincidenceMatrixHandle();
      if (dense) {
 cm->print(buf);
      } else {
 cm->toCSR(buf);
      }
    }

    template <typename InputIterator, typename OutputIterator>
    inline bool
    learn(InputIterator input_begin, InputIterator input_end,
   OutputIterator output);

    template <typename InputIterator, typename OutputIterator>
    inline void
    infer(InputIterator input_begin, InputIterator input_end,
   OutputIterator output_begin, OutputIterator output_end);

    template <typename InputIterator, typename InputIterator2, typename OutputIterator>
    inline void
    topDownInfer(InputIterator bu_in, InputIterator bu_in_end,
   InputIterator2 td_in, InputIterator2 td_in_end,
   OutputIterator td_out);

    inline void setRNGSeed(UInt32 seed)
    {
      rng_ = Random(seed);
    }

  private:
    static const std::string current_sparse_pooler_version_;

    typedef std::vector<value_type> Buffer;
    typedef Buffer::iterator buffer_iterator;

    bool normalize_;
    value_type lp_;

    SparsificationMode sparsification_mode_;
    size_type k_winners_;
    value_type threshold_;

    value_type min_accept_distance_;
    value_type min_accept_norm_;
    value_type min_proto_sum_;

    InferenceMode inference_mode_;
    value_type sigma_;

    SparsePoolerInputMasks input_masks_;

    size_type p_;
    Buffer buf_;

    std::vector<Prototypes> prototypes_;

    nta::Random rng_;

    mutable SM cachedCM_;

    void init_invariants_() const;
  };



}


# 1 "/home/marek/devel/nupic/nta/algorithms/SparsePooler_t.hpp" 1
# 30 "/home/marek/devel/nupic/nta/algorithms/SparsePooler_t.hpp"
# 1 "/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp" 1
# 32 "/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp"
# 1 "/home/marek/devel/nupic/nta/utils/Random.hpp" 1
# 29 "/home/marek/devel/nupic/nta/utils/Random.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdlib" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdlib" 3
# 30 "/home/marek/devel/nupic/nta/utils/Random.hpp" 2
# 33 "/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp" 2


namespace nta {
# 46 "/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp"
  struct SparseMatrixAlgorithms
  {
# 76 "/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp"
    template <typename SM>
    static typename SM::value_type entropy_rate(const SM& sm)
    {
      typedef typename SM::size_type size_type;
      typedef typename SM::value_type value_type;

      SM m(sm);

      std::vector<value_type> s(m.nRows());

      m.rowSums(s);
      nta::normalize(s);
      m.normalizeRows();

      value_type e = 0;

      Log2<value_type> log2_f;

      for (size_type i = 0; i != m.nRows(); ++i) {
        value_type ee = 0;
        const value_type* nz = m.nz_begin_(i);
        const value_type* nz_end = m.nz_end_(i);
        for (; nz != nz_end; ++nz)
          ee += *nz * log2_f(*nz);
        e -= s[i] * ee;
      }

      return e;
    }






    template <typename SM, typename OutputIter>
    static void matrix_entropy(const SM& sm, OutputIter row_out, OutputIter row_out_end,
                               OutputIter col_out, OutputIter col_out_end,
                               typename SM::value_type s = 1.0)
    {
      typedef typename SM::size_type size_type;
      typedef typename SM::value_type value_type;

      {
        if ((size_type)(row_out_end - row_out) == sm.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 120) << "CHECK FAILED: \"" << "(size_type)(row_out_end - row_out) == sm.nRows()" << "\" "
          << "entropy_smooth: Invalid size for output vector: "
          << (size_type)(row_out_end - row_out)
          << " - Should be number of rows: " << sm.nRows();
        if ((size_type)(col_out_end - col_out) == sm.nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 124) << "CHECK FAILED: \"" << "(size_type)(col_out_end - col_out) == sm.nCols()" << "\" "
          << "entropy_smooth: Invalid size for output vector: "
          << (size_type)(col_out_end - col_out)
          << " - Should be number of columns: " << sm.nCols();
      }

      size_type m = sm.nRows(), n = sm.nCols();

      std::vector<value_type> row_sums(m, (value_type) n * s);
      std::fill(sm.indb_, sm.indb_ + n, (size_type) 0);
      std::fill(sm.nzb_, sm.nzb_ + n, (value_type) m * s);

      for (size_type row = 0; row != m; ++row) {
        size_type *ind = sm.ind_[row], *ind_end = ind + sm.nnzr_[row];
        value_type *nz = sm.nz_[row];
        for (; ind != ind_end; ++ind, ++nz) {
          row_sums[row] += *nz;
          sm.nzb_[*ind] += *nz;
          sm.indb_[*ind] += (size_type) 1;
        }
      }

      Log2<value_type> log2_f;

      for (size_type c = 0; c != n; ++c) {
        value_type v = s / sm.nzb_[c];
        *(col_out + c) = - ((value_type)(m - sm.indb_[c]) * v * log2_f(v));
      }

      for (size_type row = 0; row != m; ++row, ++row_out) {
        size_type *ind = sm.ind_[row], *ind_end = ind + sm.nnzr_[row];
        value_type *nz = sm.nz_[row];
        value_type v = s / row_sums[row];
        *row_out = - ((value_type)(n - sm.nnzr_[row]) * v * log2_f(v));
        for (; ind != ind_end; ++ind, ++nz) {
          v = *nz + s;
          value_type val_row = v / row_sums[row];
          *row_out -= val_row * log2_f(val_row);
          value_type val_col = v / sm.nzb_[*ind];
          *(col_out + *ind) -= val_col * log2_f(val_col);
        }
      }
    }
# 181 "/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp"
    template <typename SM1, typename SM2>
    static void
    aX_plus_bX_elementMultiply_Y(const typename SM1::value_type &a, SM1 &Xoutput,
                                 const typename SM1::value_type &b, const SM2& Y)
    {
      typedef typename SM1::size_type size_type;
      typedef typename SM1::value_type value_type;

      const size_type nrows = Xoutput.nRows();

      for (size_type row = 0; row != nrows; ++row) {

        value_type *nz_write = Xoutput.nz_begin_(row);
        size_type *ind_write = Xoutput.ind_begin_(row);
        const size_type *ind_x_begin = ind_write;

        const value_type *nz_x = Xoutput.nz_begin_(row);
        const size_type *ind_x = ind_x_begin;
        const size_type *ind_x_end = Xoutput.ind_end_(row);

        const typename SM2::value_type *nz_y = Y.nz_begin_(row);
        const typename SM2::size_type *ind_y = Y.ind_begin_(row);
        const typename SM2::size_type *ind_y_begin = ind_y;
        const typename SM2::size_type *ind_y_end = Y.ind_end_(row);

        while (ind_x != ind_x_end) {

          const size_type column = *(ind_x++);
          const value_type vx = *(nz_x++);
          value_type val = vx * a;
          ind_y = std::lower_bound(ind_y, ind_y_end, column);

          if (ind_y != ind_y_end && column == *ind_y) {
            const value_type vy = (value_type) nz_y[ind_y - ind_y_begin];
            val += vx * vy * b;
            ++ind_y;
          }



          if (!Xoutput.isZero_(val)) {
            *ind_write++ = column;
            *nz_write++ = val;
          }
        }

        Xoutput.nnzr_[row] = (size_type)(ind_write - ind_x_begin);
      }
    }







    template <typename SM, typename InIter1, typename OutIter>
    static void
    kthroot_product(const SM& sm,
                    typename SM::size_type ss, InIter1 x, OutIter y,
                    const typename SM::value_type& min_input)
    {
      using namespace std;

      typedef typename SM::size_type size_type;
      typedef typename SM::value_type value_type;

      {
        if (sm.nCols() % ss == 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 249) << "ASSERTION FAILED: \"" << "sm.nCols() % ss == 0" << "\" "
          << "SparseMatrix kthroot_product: "
          << "Invalid segment size: " << ss
          << "Needs to be a divisor of nCols() = " << sm.nCols();
      }

      Log<value_type> log_f;
      Exp<value_type> exp_f;

      const size_type k = sm.nCols() / ss;
      const value_type log_min_input = logf(min_input);

      OutIter y_begin = y, y_end = y_begin + sm.nCols();

      for (size_type row = 0; row != sm.nRows(); ++row) {

        value_type sum = (value_type) 0.0f;
        size_type seg_begin = 0, seg_end = ss;
        size_type *ind = sm.ind_begin_(row), *ind_end = sm.ind_end_(row);
        for (; seg_begin != sm.nCols(); seg_begin += ss, seg_end += ss) {
          if (ind < ind_end && seg_begin <= *ind && *ind < seg_end) {
            size_type *c2 = seg_end == sm.nCols() ? ind_end : sm.pos_(row, seg_end);
            for (; ind != c2; ++ind) {
              value_type val = x[*ind];
              if (sm.isZero_(val))
                sum += log_min_input;
              else
                sum += log_f(val);
            }
          } else {
            value_type max_value = - std::numeric_limits<value_type>::max();
            for (size_type i = seg_begin; i != seg_end; ++i)
              max_value = std::max(x[i], max_value);
            sum += log_f(std::max((value_type)1.0f - max_value, min_input));
            ind = seg_end == sm.nCols() ? ind_end : sm.pos_(row, seg_end);
          }
        }






        *y = exp_f(sum / k);
        ++y;
      }
      if (positive_less_than(y_begin, y_end, min_input))
        std::fill(y_begin, y_end, (value_type) 0);
    }
# 309 "/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp"
    template <typename SM, typename InputIterator1, typename InputIterator2>
    static void sparseRightVecProd(const SM& sm,
                                   typename SM::size_type x_begin,
                                   typename SM::size_type x_end,
                                   InputIterator1 x,
                                   InputIterator2 y)
    {
      {
        sm.assert_valid_col_range_(x_begin, x_end, "sparseRightVecProd: Invalid range");
      }

      typedef typename SM::size_type size_type;
      typedef typename SM::value_type value_type;

      for (size_type row = 0; row != sm.nRows(); ++row, ++y) {
        size_type nnzr = sm.nNonZerosOnRow(row);
        if (nnzr == 0) {
          *y = 0;
          continue;
        }
        size_type *ind = sm.ind_begin_(row), *ind_end = sm.ind_end_(row);
        size_type *p1 = std::lower_bound(ind, ind_end, x_begin);
        if (p1 == ind_end) {
          *y = 0;
          continue;
        }
        size_type *p2 = std::lower_bound(p1, ind_end, x_end);
        value_type *nz = sm.nz_begin_(row) + (p1 - ind);
        value_type val = 0;
        for (ind = p1; ind != p2; ++ind, ++nz)
          val += *nz * *(x + *ind);
        *y = val;
      }
    }
# 380 "/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp"
    template <typename SM, typename InputIterator, typename OutputIterator>
    static void smoothVecMaxProd(const SM& sm,
     typename SM::value_type k,
     InputIterator x, InputIterator x_end,
     OutputIterator y, OutputIterator y_end)
    {
      typedef typename SM::size_type size_type;
      typedef typename SM::value_type value_type;

      {
 if ((size_type)(x_end - x) == sm.nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 390) << "ASSERTION FAILED: \"" << "(size_type)(x_end - x) == sm.nCols()" << "\" ";
 if ((size_type)(y_end - y) == sm.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 391) << "ASSERTION FAILED: \"" << "(size_type)(y_end - y) == sm.nRows()" << "\" ";
      }


      for (size_type j = 0; j != sm.nCols(); ++j)
 sm.nzb_[j] = k * x[j];

      for (size_type row = 0; row != sm.nRows(); ++row) {

        value_type max_v = - std::numeric_limits<value_type>::max();
 size_type *ind = sm.ind_[row], *ind_end = ind + sm.nnzr_[row];
        value_type *nz = sm.nz_[row];

 for (size_type col = 0; col != sm.nCols(); ++col) {

   value_type p = sm.nzb_[col];
   if (ind != ind_end && col == *ind)
     p += *nz++ * x[*ind++];
          if (p > max_v)
            max_v = p;
        }

        *y++ = max_v;
      }
    }
# 425 "/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp"
    template <typename SM, typename InputIterator, typename OutputIterator>
    static void smoothVecArgMaxProd(const SM& sm,
        typename SM::value_type k,
        InputIterator x, InputIterator x_end,
        OutputIterator y, OutputIterator y_end)
    {
      typedef typename SM::size_type size_type;
      typedef typename SM::value_type value_type;

      {
 if ((size_type)(x_end - x) == sm.nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 435) << "ASSERTION FAILED: \"" << "(size_type)(x_end - x) == sm.nCols()" << "\" ";
 if ((size_type)(y_end - y) == sm.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 436) << "ASSERTION FAILED: \"" << "(size_type)(y_end - y) == sm.nRows()" << "\" ";
      }


      for (size_type j = 0; j != sm.nCols(); ++j)
 sm.nzb_[j] = k * x[j];

      for (size_type row = 0; row != sm.nRows(); ++row) {

 size_type arg_max = 0;
        value_type max_v = - std::numeric_limits<value_type>::max();
 size_type *ind = sm.ind_[row], *ind_end = ind + sm.nnzr_[row];
        value_type *nz = sm.nz_[row];

 for (size_type col = 0; col != sm.nCols(); ++col) {

   value_type p = sm.nzb_[col];
   if (ind != ind_end && col == *ind)
     p += *nz++ * x[*ind++];
          if (p > max_v) {
            max_v = p;
     arg_max = col;
   }
        }

        *y++ = arg_max;
      }
    }
# 477 "/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp"
    template <typename SM>
    static void addToNZOnly(SM& A, double val, typename SM::value_type minFloor =0)
    {
      {
        if (minFloor == 0 || nta::Epsilon < minFloor) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 481) << "ASSERTION FAILED: \"" << "minFloor == 0 || nta::Epsilon < minFloor" << "\" ";
      }

      typedef typename SM::size_type size_type;
      typedef typename SM::value_type value_type;

      size_type M = A.nRows();

      if (minFloor == 0) {


        for (size_type row = 0; row != M; ++row) {

          value_type *nz = A.nz_begin_(row);
          value_type *nz_end = A.nz_end_(row);
          value_type *nz_dst = nz;

          for (; nz != nz_end; ++nz) {
            value_type v = *nz + val;
            if (!A.isZero_(v))
              *nz_dst++ = v;
          }

          A.nnzr_[row] = nz_dst - A.nz_begin_(row);
        }

      } else {

        nta::Abs<value_type> abs_f;


        for (size_type row = 0; row != M; ++row) {

          size_type *ind = A.ind_begin_(row);
          size_type *ind_end = ind + A.nnzr_[row];
          value_type *nz = A.nz_begin_(row);

          for (; ind != ind_end; ++ind, ++nz) {
            *nz += val;
            if (abs_f(*nz) < minFloor)
              *nz = minFloor;
          }
        }
      }
    }






    template <typename SM, typename U>
    static void addToNZDownCols(SM& A, U begin, U end,
                                typename SM::value_type minFloor =0)
    {
      typedef typename SM::size_type size_type;
      typedef typename SM::value_type value_type;

      {
        if ((size_type)(end - begin) == A.nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 540) << "ASSERTION FAILED: \"" << "(size_type)(end - begin) == A.nCols()" << "\" ";
        if (minFloor == 0 || nta::Epsilon < minFloor) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 541) << "ASSERTION FAILED: \"" << "minFloor == 0 || nta::Epsilon < minFloor" << "\" ";
      }

      if (minFloor == 0) {

        for (size_type row = 0; row != A.nRows(); ++row) {
          size_type *ind = A.ind_begin_(row);
          value_type *nz = A.nz_begin_(row);
          value_type *nz_end = A.nz_end_(row);
          for (; nz != nz_end; ++ind) {
            *nz += *(begin + *ind);
            if (!A.isZero_(*nz))
              ++nz;
          }
          A.nnzr_[row] = (size_type) (nz - A.nz_begin_(row));
        }

      } else {

        nta::Abs<value_type> abs_f;

        for (size_type row = 0; row != A.nRows(); ++row) {
          size_type *ind = A.ind_begin_(row);
          value_type *nz = A.nz_begin_(row);
          value_type *nz_end = A.nz_end_(row);
          for (; nz != nz_end; ++ind, ++nz) {
            *nz += *(begin + *ind);
            if (abs_f(*nz) < minFloor)
              *nz = minFloor;
          }
        }
      }
    }






    template <typename SM, typename U>
    static void addToNZAcrossRows(SM& A, U begin, U end,
                                  typename SM::value_type minFloor =0)
    {
      typedef typename SM::size_type size_type;
      typedef typename SM::value_type value_type;

      {
        if ((size_type)(end - begin) == A.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 588) << "ASSERTION FAILED: \"" << "(size_type)(end - begin) == A.nRows()" << "\" ";
        if (minFloor == 0 || nta::Epsilon < minFloor) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 589) << "ASSERTION FAILED: \"" << "minFloor == 0 || nta::Epsilon < minFloor" << "\" ";
      }

      if (minFloor == 0) {


        for (size_type row = 0; row != A.nRows(); ++row) {
          size_type *ind = A.ind_begin_(row);
          value_type *nz = A.nz_begin_(row);
          value_type *nz_end = A.nz_end_(row);
          for (; nz != nz_end; ++ind) {
            *nz += *begin;
            if (!A.isZero_(*nz))
              ++nz;
          }
          A.nnzr_[row] = (size_type) (nz - A.nz_begin_(row));
          ++begin;
        }

      } else {

        nta::Abs<value_type> abs_f;


        for (size_type row = 0; row != A.nRows(); ++row) {
          size_type *ind = A.ind_begin_(row);
          value_type *nz = A.nz_begin_(row);
          value_type *nz_end = A.nz_end_(row);
          for (; nz != nz_end; ++ind, ++nz) {
            *nz += *begin;
            if (abs_f(*nz) < minFloor)
              *nz = minFloor;
          }
          ++begin;
        }
      }
    }
# 634 "/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp"
    template <typename SM>
    static void NZOneMinus(SM& A)
    {
      typedef typename SM::size_type size_type;
      typedef typename SM::value_type value_type;

      for (size_type row = 0; row != A.nRows(); ++row) {
        size_type *ind = A.ind_begin_(row);
        value_type *nz = A.nz_begin_(row);
        value_type *nz_end = A.nz_end_(row);
        for (; nz != nz_end; ++ind) {
          *nz = (value_type) 1.0 - *nz;
          if (!A.isZero_(*nz))
            ++nz;
        }
        A.nnzr_[row] = (size_type) (nz - A.nz_begin_(row));
      }
    }
# 662 "/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp"
    template <typename SM>
    static void addNoAlloc(SM& A, const SM& B, typename SM::value_type minFloor =0)
    {
      {
        if (A.nRows() == B.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 666) << "ASSERTION FAILED: \"" << "A.nRows() == B.nRows()" << "\" ";
        if (A.nCols() == B.nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 667) << "ASSERTION FAILED: \"" << "A.nCols() == B.nCols()" << "\" ";
        if (B.nonZeroIndicesIncluded(A)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 668) << "ASSERTION FAILED: \"" << "B.nonZeroIndicesIncluded(A)" << "\" ";
        if (minFloor == 0 || nta::Epsilon < minFloor) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 669) << "ASSERTION FAILED: \"" << "minFloor == 0 || nta::Epsilon < minFloor" << "\" ";
      }

      typedef typename SM::size_type size_type;
      typedef typename SM::value_type value_type;

      nta::Abs<value_type> abs_f;

      size_type M = A.nRows();

      for (size_type row = 0; row != M; ++row) {

        size_type *ind_a = A.ind_begin_(row);
        size_type *ind_b = B.ind_begin_(row);
        size_type *ind_b_end = B.ind_end_(row);
        value_type *nz_a = A.nz_begin_(row);
        value_type *nz_b = B.nz_begin_(row);

        while (ind_b != ind_b_end) {
          if (*ind_a == *ind_b) {
            value_type a = *nz_a;
            value_type b = *nz_b;
            a += b;
            if (minFloor > 0 && abs_f(a) < minFloor)
              a = minFloor;
            *nz_a = a;
            if (!A.isZero_(*nz_a)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 695) << "ASSERTION FAILED: \"" << "!A.isZero_(*nz_a)" << "\" ";
            ++ind_a; ++nz_a;
            ++ind_b; ++nz_b;
          } else if (*ind_a < *ind_b) {
            ++ind_a; ++nz_a;
          }
        }
      }
    }
# 714 "/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp"
    template <typename SM>
    static void subtractNoAlloc(SM& A, const SM& B, typename SM::value_type minFloor =0)
    {
      {
        if (A.nRows() == B.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 718) << "ASSERTION FAILED: \"" << "A.nRows() == B.nRows()" << "\" ";
        if (A.nCols() == B.nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 719) << "ASSERTION FAILED: \"" << "A.nCols() == B.nCols()" << "\" ";
        if (B.nonZeroIndicesIncluded(A)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 720) << "ASSERTION FAILED: \"" << "B.nonZeroIndicesIncluded(A)" << "\" ";
        if (minFloor == 0 || nta::Epsilon < minFloor) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 721) << "ASSERTION FAILED: \"" << "minFloor == 0 || nta::Epsilon < minFloor" << "\" ";
      }

      typedef typename SM::size_type size_type;
      typedef typename SM::value_type value_type;

      nta::Abs<value_type> abs_f;

      size_type M = A.nRows();

      for (size_type row = 0; row != M; ++row) {

        size_type *ind_a = A.ind_begin_(row);
        size_type *ind_b = B.ind_begin_(row);
        size_type *ind_b_end = B.ind_end_(row);
        value_type *nz_a = A.nz_begin_(row);
        value_type *nz_b = B.nz_begin_(row);

        while (ind_b != ind_b_end) {
          if (*ind_a == *ind_b) {
            value_type a = *nz_a;
            value_type b = *nz_b;
            a -= b;
            if (minFloor > 0 && abs_f(a) < minFloor)
              a = minFloor;
            *nz_a = a;
            if (!A.isZero_(*nz_a)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 747) << "ASSERTION FAILED: \"" << "!A.isZero_(*nz_a)" << "\" ";
            ++ind_a; ++nz_a;
            ++ind_b; ++nz_b;
          } else if (*ind_a < *ind_b) {
            ++ind_a; ++nz_a;
          }
        }
      }
    }
# 764 "/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp"
    template <typename SM>
    static void assignNoAlloc(SM& A, const SM&B)
    {
      {
        if (A.nRows() == B.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 768) << "ASSERTION FAILED: \"" << "A.nRows() == B.nRows()" << "\" ";
        if (A.nCols() == B.nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 769) << "ASSERTION FAILED: \"" << "A.nCols() == B.nCols()" << "\" ";
      }

      typedef typename SM::size_type size_type;
      typedef typename SM::value_type value_type;

      const size_type M = A.nRows();

      for (size_type row = 0; row != M; ++row) {

        size_type *ind_a = A.ind_begin_(row);
        size_type *ind_b = B.ind_begin_(row);
        value_type *nz_a = A.nz_begin_(row);
        value_type *nz_a_end = A.nz_end_(row);
        value_type *nz_b = B.nz_begin_(row);
        value_type *nz_b_end = B.nz_end_(row);

        while (nz_a != nz_a_end && nz_b != nz_b_end)
          if (*ind_a == *ind_b) {
            *nz_a = *nz_b;
            ++ind_a; ++ind_b;
            ++nz_a; ++nz_b;
          } else if (*ind_a < *ind_b) {
            ++ind_a; ++nz_a;
          } else if (*ind_b < *ind_a) {
            ++ind_b; ++nz_b;
          }
      }
    }
# 808 "/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp"
    template <typename SM, typename SM01>
    static void assignNoAllocFromBinary(SM& A, const SM01&B)
    {
      {
        if (A.nRows() == B.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 812) << "ASSERTION FAILED: \"" << "A.nRows() == B.nRows()" << "\" ";
        if (A.nCols() == B.nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 813) << "ASSERTION FAILED: \"" << "A.nCols() == B.nCols()" << "\" ";
      }

      typedef typename SM::size_type size_type;
      typedef typename SM01::nz_index_type size_type2;
      typedef typename SM::value_type value_type;

      const size_type M = A.nRows();

      for (size_type row = 0; row != M; ++row) {

        size_type *ind_a = A.ind_begin_(row);
        typename SM01::Row::const_iterator ind_b = B.ind_begin_(row);
        typename SM01::Row::const_iterator ind_b_end = B.ind_end_(row);
 value_type *nz_a = A.nz_begin_(row);
 value_type *nz_a_end = A.nz_end_(row);

        while (nz_a != nz_a_end && ind_b != ind_b_end)
          if (*ind_a == *ind_b) {
            *nz_a = (value_type) 1;
            ++ind_a; ++ind_b;
            ++nz_a;
          } else if (*ind_a < *ind_b) {
            ++ind_a; ++nz_a;
          } else if (*ind_b < *ind_a) {
            ++ind_b;
          }
      }
    }




   template <typename SM, typename SM01>
   static void addConstantOnNonZeros(SM& A, const SM01& B,
          typename SM::value_type cval)
   {
    {
     if (A.nRows() == B.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 851) << "ASSERTION FAILED: \"" << "A.nRows() == B.nRows()" << "\" "
     << "add: Wrong number of rows: " << A.nRows()
     << " and " << B.nRows();
     if (A.nCols() == B.nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 854) << "ASSERTION FAILED: \"" << "A.nCols() == B.nCols()" << "\" "
     << "add: Wrong number of columns: " << A.nCols()
     << " and " << B.nCols();
    }

    typedef typename SM::size_type size_type;
    typedef typename SM::value_type value_type;

    const size_type nrows = A.nRows();
    for (size_type row = 0; row != nrows; ++row) {

     size_type *ind = A.ind_begin_(row);
     size_type *ind_end = A.ind_end_(row);
     value_type *nz = A.nz_begin_(row);

     typename SM01::Row::const_iterator ind_b = B.ind_begin_(row);
     typename SM01::Row::const_iterator ind_b_end = B.ind_end_(row);

     std::vector<size_type> indb_;
     std::vector<value_type> nzb_;

     while (ind != ind_end && ind_b != ind_b_end) {
      if (*ind == *ind_b) {
       value_type val = *nz++ + cval;
       if (!A.isZero_(val)) {
        indb_.push_back(*ind);
        nzb_.push_back(val);
       }
       ++ind; ++ind_b;
      } else if (*ind < *ind_b) {
       indb_.push_back(*ind++);
       nzb_.push_back(*nz++);
      } else if (*ind_b < *ind) {
       if (!A.isZero_(cval)) {
        indb_.push_back(*ind_b++);
        nzb_.push_back(cval);
       }
      }
     }

     while (ind != ind_end) {
      indb_.push_back(*ind++);
      nzb_.push_back(*nz++);
     }

     while (ind_b != ind_b_end) {
      if (!A.isZero_(cval)) {
       indb_.push_back(*ind_b++);
       nzb_.push_back(cval);
      }
     }

     A.setRowFromSparse(row, indb_.begin(), indb_.end(), nzb_.begin());
    }
   }
# 921 "/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp"
    template <typename SM>
    static void logSumNoAlloc(SM& A, const SM& B, typename SM::value_type minFloor =0)
    {
      {
        if (A.nRows() == B.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 925) << "ASSERTION FAILED: \"" << "A.nRows() == B.nRows()" << "\" ";
        if (A.nCols() == B.nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 926) << "ASSERTION FAILED: \"" << "A.nCols() == B.nCols()" << "\" ";
        if (B.nonZeroIndicesIncluded(A)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 927) << "ASSERTION FAILED: \"" << "B.nonZeroIndicesIncluded(A)" << "\" ";
        if (minFloor == 0 || nta::Epsilon < minFloor) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 928) << "ASSERTION FAILED: \"" << "minFloor == 0 || nta::Epsilon < minFloor" << "\" ";
      }

      typedef typename SM::size_type size_type;
      typedef typename SM::value_type value_type;

      nta::Exp<value_type> exp_f;
      nta::Log<value_type> log_f;
      nta::Log1p<value_type> log1p_f;
      nta::Abs<value_type> abs_f;

      size_type M = A.nRows();
      value_type minExp = log_f(std::numeric_limits<value_type>::epsilon());

      for (size_type row = 0; row != M; ++row) {

        size_type *ind_a = A.ind_begin_(row);
        size_type *ind_b = B.ind_begin_(row);
        size_type *ind_b_end = B.ind_end_(row);
        value_type *nz_a = A.nz_begin_(row);
        value_type *nz_b = B.nz_begin_(row);

        while (ind_b != ind_b_end) {
          if (*ind_a == *ind_b) {
            value_type a = *nz_a;
            value_type b = *nz_b;
            if (a < b)
              std::swap(a,b);
            value_type d = b - a;
            if (d >= minExp) {
              a += log1p_f(exp_f(d));
              if (minFloor > 0 && abs_f(a) < minFloor)
                a = minFloor;
              *nz_a = a;
            } else {
              *nz_a = a;
            }
            if (!A.isZero_(*nz_a)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 965) << "ASSERTION FAILED: \"" << "!A.isZero_(*nz_a)" << "\" ";
            ++ind_a; ++nz_a;
            ++ind_b; ++nz_b;
          } else if (*ind_a < *ind_b) {
            ++ind_a; ++nz_a;
          }
        }
      }
    }






    template <typename SM>
    static void
    logAddValNoAlloc(SM& A,
                     typename SM::value_type val, typename SM::value_type minFloor =0)
    {
      {
        if (minFloor == 0 || nta::Epsilon < minFloor) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 986) << "ASSERTION FAILED: \"" << "minFloor == 0 || nta::Epsilon < minFloor" << "\" ";
      }

      typedef typename SM::size_type size_type;
      typedef typename SM::value_type value_type;

      nta::Exp<value_type> exp_f;
      nta::Log<value_type> log_f;
      nta::Log1p<value_type> log1p_f;
      nta::Abs<value_type> abs_f;

      size_type M = A.nRows();
      value_type minExp = log_f(std::numeric_limits<value_type>::epsilon());
      value_type b;

      for (size_type row = 0; row != M; ++row) {

        size_type *ind_a = A.ind_begin_(row);
        size_type *ind_a_end = A.ind_end_(row);
        value_type *nz_a = A.nz_begin_(row);

        while (ind_a != ind_a_end) {
          value_type a = *nz_a;


          if (a < val) {
            b = a;
            a = val;
          } else {
            b = val;
          }
          value_type d = b - a;
          if (d >= minExp) {
            a += log1p_f(exp_f(d));
            if (minFloor > 0 && abs_f(a) < minFloor)
              a = minFloor;
            *nz_a = a;
          } else
            *nz_a = a;
          if (!A.isZero_(*nz_a)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1025) << "ASSERTION FAILED: \"" << "!A.isZero_(*nz_a)" << "\" ";
          ++ind_a; ++nz_a;
        }
      }
    }
# 1043 "/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp"
    template <typename SM>
    static void logDiffNoAlloc(SM& A, const SM& B, typename SM::value_type minFloor =0)
    {
      {
        if (A.nRows() == B.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1047) << "ASSERTION FAILED: \"" << "A.nRows() == B.nRows()" << "\" ";
        if (A.nCols() == B.nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1048) << "ASSERTION FAILED: \"" << "A.nCols() == B.nCols()" << "\" ";
        if (B.nonZeroIndicesIncluded(A)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1049) << "ASSERTION FAILED: \"" << "B.nonZeroIndicesIncluded(A)" << "\" ";
        if (minFloor == 0 || nta::Epsilon < minFloor) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1050) << "ASSERTION FAILED: \"" << "minFloor == 0 || nta::Epsilon < minFloor" << "\" ";
      }

      typedef typename SM::size_type size_type;
      typedef typename SM::value_type value_type;



      nta::Exp<double> exp_f;
      nta::Log<value_type> log_f;
      nta::Log1p<double> log1p_f;
      nta::Abs<double> abs_f;

      size_type M = A.nRows();
      value_type minExp = log_f(std::numeric_limits<value_type>::epsilon());



      double minDiff = -std::numeric_limits<double>::epsilon();
      value_type logOfZero = -1.0/std::numeric_limits<value_type>::epsilon();

      for (size_type row = 0; row != M; ++row) {

        size_type *ind_a = A.ind_begin_(row);
        size_type *ind_b = B.ind_begin_(row);
        size_type *ind_b_end = B.ind_end_(row);
        value_type *nz_a = A.nz_begin_(row);
        value_type *nz_b = B.nz_begin_(row);

        while (ind_b != ind_b_end) {
          if (*ind_a == *ind_b) {
            double a = *nz_a;
            double b = *nz_b;
            if (a >= b) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1083) << "ASSERTION FAILED: \"" << "a >= b" << "\" ";
            double d = b - a;


            if (d >= minDiff)
              *nz_a = logOfZero;
            else if (d >= minExp) {
              a += log1p_f(-exp_f(d));
              if (minFloor > 0 && abs_f(a) < minFloor)
                a = minFloor;
              *nz_a = (value_type) a;
            } else {
              *nz_a = (value_type) a;
            }
            if (!A.isZero_(*nz_a)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1097) << "ASSERTION FAILED: \"" << "!A.isZero_(*nz_a)" << "\" ";
            ++ind_a; ++nz_a;
            ++ind_b; ++nz_b;
          } else if (*ind_a < *ind_b) {
            ++ind_a; ++nz_a;
          }
        }
      }
    }
# 1120 "/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp"
    template <typename SM>
    static void LBP_piPrime(SM& mat, typename SM::value_type max_floor)
    {
      {
        if (max_floor < 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1124) << "ASSERTION FAILED: \"" << "max_floor < 0" << "\" ";
      }

      typedef typename SM::size_type size_type;
      typedef typename SM::value_type value_type;

      size_type M = mat.nRows();
      size_type N = mat.nCols();

      nta::Abs<value_type> abs_f;

      std::fill(mat.nzb_, mat.nzb_ + N, (value_type) 0);


      for (size_type row = 0; row != M; ++row) {

        if (mat.nnzr_[row] == 0)
          continue;

        size_type *ind = mat.ind_begin_(row);
        size_type *ind_end = mat.ind_end_(row);
        value_type *nz = mat.nz_begin_(row);

        for (; ind != ind_end; ++ind, ++nz)
          mat.nzb_[*ind] += *nz;
      }


      for (size_type row = 0; row != M; ++row) {

        if (mat.nnzr_[row] == 0)
          continue;

        size_type *ind = mat.ind_begin_(row);
        size_type *ind_end = mat.ind_end_(row);
        value_type *nz = mat.nz_begin_(row);

        value_type absFloor = abs_f(max_floor);

        for (; ind != ind_end; ++ind, ++nz) {

          value_type v = mat.nzb_[*ind] - *nz;

          if (abs_f(v) < absFloor)
            v = max_floor;

          *nz = v;
        }
      }
    }






    template <typename SM, typename STR3F>
    static void assignNoAlloc(SM& A, const STR3F& B, typename SM::size_type s)
    {
      {
        if (A.nRows() == B.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1184) << "ASSERTION FAILED: \"" << "A.nRows() == B.nRows()" << "\" ";
        if (A.nCols() == B.nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1185) << "ASSERTION FAILED: \"" << "A.nCols() == B.nCols()" << "\" ";
      }

      typedef typename SM::size_type size_type;
      typedef typename STR3F::col_index_type col_index_type;
      typedef typename SM::value_type value_type;

      const size_type M = A.nRows();

      for (size_type row = 0; row != M; ++row) {

        size_type *ind_a = A.ind_begin_(row);
        col_index_type *ind_b = B.ind_begin_(row);
        value_type *nz_a = A.nz_begin_(row);
        value_type *nz_a_end = A.nz_end_(row);
        value_type *nz_b = B.nz_begin_(s, row);
        value_type *nz_b_end = B.nz_end_(s, row);

        while (nz_a != nz_a_end && nz_b != nz_b_end)
          if (*ind_a == (size_type) *ind_b) {
            *nz_a = *nz_b;
            ++ind_a; ++ind_b;
            ++nz_a; ++nz_b;
          } else if (*ind_a < (size_type) *ind_b) {
            ++ind_a; ++nz_a;
          } else if ((size_type) *ind_b < *ind_a) {
            ++ind_b; ++nz_b;
          }
      }
    }
# 1228 "/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp"
    template <typename SM, typename STR3F>
    static void logSumNoAlloc(STR3F& A, typename SM::size_type s,
         const SM& B, typename SM::value_type minFloor =0)
    {
      {
        if (A.nRows() == B.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1233) << "ASSERTION FAILED: \"" << "A.nRows() == B.nRows()" << "\" ";
        if (A.nCols() == B.nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1234) << "ASSERTION FAILED: \"" << "A.nCols() == B.nCols()" << "\" ";
        if (minFloor == 0 || nta::Epsilon < minFloor) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1235) << "ASSERTION FAILED: \"" << "minFloor == 0 || nta::Epsilon < minFloor" << "\" ";
      }

      typedef typename STR3F::col_index_type col_index_type;
      typedef typename SM::size_type size_type;
      typedef typename SM::value_type value_type;

      nta::Exp<value_type> exp_f;
      nta::Log<value_type> log_f;
      nta::Log1p<value_type> log1p_f;
      nta::Abs<value_type> abs_f;

      size_type M = (size_type) A.nRows();
      value_type minExp = log_f(std::numeric_limits<value_type>::epsilon());

      if (nta::Epsilon < minFloor) {

        for (size_type row = 0; row != M; ++row) {

          col_index_type *ind_a = A.ind_begin_(row);
          size_type *ind_b = B.ind_begin_(row);
          size_type *ind_b_end = B.ind_end_(row);
          value_type *nz_a = A.nz_begin_(s, row);
          value_type *nz_b = B.nz_begin_(row);

          while (ind_b != ind_b_end) {
            if ((size_type) *ind_a == *ind_b) {
              value_type a = *nz_a;
              value_type b = *nz_b;
              if (a < b)
                std::swap(a,b);
              value_type d = b - a;
              if (d >= minExp) {
                a += log1p_f(exp_f(d));
                if (abs_f(a) < minFloor)
                  a = minFloor;
                *nz_a = a;
              } else {
                *nz_a = a;
              }
              ++ind_a; ++nz_a;
              ++ind_b; ++nz_b;
            } else if ((size_type) *ind_a < *ind_b) {
              ++ind_a; ++nz_a;
            }
          }
        }

      } else {

        for (size_type row = 0; row != M; ++row) {

          col_index_type *ind_a = A.ind_begin_(row);
          size_type *ind_b = B.ind_begin_(row);
          size_type *ind_b_end = B.ind_end_(row);
          value_type *nz_a = A.nz_begin_(s, row);
          value_type *nz_b = B.nz_begin_(row);

          while (ind_b != ind_b_end) {
            if ((size_type) *ind_a == *ind_b) {
              value_type a = *nz_a;
              value_type b = *nz_b;
              if (a < b)
                std::swap(a,b);
              value_type d = b - a;
              if (d >= minExp) {
                a += log1p_f(exp_f(d));
                *nz_a = a;
              } else {
                *nz_a = a;
              }
              ++ind_a; ++nz_a;
              ++ind_b; ++nz_b;
            } else if ((size_type) *ind_a < *ind_b) {
              ++ind_a; ++nz_a;
            }
          }
        }
      }
    }
# 1328 "/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp"
    template <typename SM, typename STR3F>
    static void logDiffNoAlloc(STR3F& A, typename SM::size_type s,
          const SM& B, typename SM::value_type minFloor =0)
    {
      {
        if (A.nRows() == B.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1333) << "ASSERTION FAILED: \"" << "A.nRows() == B.nRows()" << "\" ";
        if (A.nCols() == B.nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1334) << "ASSERTION FAILED: \"" << "A.nCols() == B.nCols()" << "\" ";
        if (minFloor == 0 || nta::Epsilon < minFloor) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1335) << "ASSERTION FAILED: \"" << "minFloor == 0 || nta::Epsilon < minFloor" << "\" ";
      }

      typedef typename STR3F::col_index_type col_index_type;
      typedef typename SM::size_type size_type;
      typedef typename SM::value_type value_type;



      nta::Exp<double> exp_f;
      nta::Log<value_type> log_f;
      nta::Log1p<double> log1p_f;
      nta::Abs<double> abs_f;

      size_type M = (size_type) A.nRows();
      value_type minExp = log_f(std::numeric_limits<value_type>::epsilon());



      double minDiff = -std::numeric_limits<double>::epsilon();
      value_type logOfZero = ((value_type)-1.0)/std::numeric_limits<value_type>::epsilon();

      if (nta::Epsilon < minFloor) {

        for (size_type row = 0; row != M; ++row) {

          col_index_type *ind_a = A.ind_begin_(row);
          size_type *ind_b = B.ind_begin_(row);
          size_type *ind_b_end = B.ind_end_(row);
          value_type *nz_a = A.nz_begin_(s, row);
          value_type *nz_b = B.nz_begin_(row);

          while (ind_b != ind_b_end) {
            if ((size_type) *ind_a == *ind_b) {
              double a = *nz_a;
              double b = *nz_b;
              if (a >= b) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1371) << "ASSERTION FAILED: \"" << "a >= b" << "\" ";
              double d = b - a;


              if (d >= minDiff)
                *nz_a = logOfZero;
              else if (d >= minExp) {
                a += log1p_f(-exp_f(d));
                if (abs_f(a) < minFloor)
                  a = minFloor;
                *nz_a = (value_type) a;
              } else {
                *nz_a = (value_type) a;
              }
              ++ind_a; ++nz_a;
              ++ind_b; ++nz_b;
            } else if ((size_type) *ind_a < *ind_b) {
              ++ind_a; ++nz_a;
            }
          }
        }

      } else {

        for (size_type row = 0; row != M; ++row) {

          col_index_type *ind_a = A.ind_begin_(row);
          size_type *ind_b = B.ind_begin_(row);
          size_type *ind_b_end = B.ind_end_(row);
          value_type *nz_a = A.nz_begin_(s, row);
          value_type *nz_b = B.nz_begin_(row);

          while (ind_b != ind_b_end) {
            if ((size_type) *ind_a == *ind_b) {
              double a = *nz_a;
              double b = *nz_b;
              if (a >= b) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1407) << "ASSERTION FAILED: \"" << "a >= b" << "\" ";
              double d = b - a;


              if (d >= minDiff)
                *nz_a = logOfZero;
              else if (d >= minExp) {
                a += log1p_f(-exp_f(d));
                *nz_a = (value_type) a;
              } else {
                *nz_a = (value_type) a;
              }
              ++ind_a; ++nz_a;
              ++ind_b; ++nz_b;
            } else if ((size_type) *ind_a < *ind_b) {
              ++ind_a; ++nz_a;
            }
          }
        }
      }
    }






    template <typename STR3F>
    static void assignNoAlloc(STR3F& A, typename STR3F::size_type slice_a,
         const STR3F& B, typename STR3F::size_type slice_b)
    {
      {
        if (A.nRows() == B.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1439) << "ASSERTION FAILED: \"" << "A.nRows() == B.nRows()" << "\" ";
        if (A.nCols() == B.nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1440) << "ASSERTION FAILED: \"" << "A.nCols() == B.nCols()" << "\" ";
      }

      typedef typename STR3F::row_index_type row_index_type;
      typedef typename STR3F::col_index_type col_index_type;
      typedef typename STR3F::value_type value_type;

      for (row_index_type row = 0; row != A.nRows(); ++row) {

        col_index_type *ind_a = A.ind_begin_(row);
        col_index_type *ind_b = B.ind_begin_(row);
        value_type *nz_a = A.nz_begin_(slice_a, row);
        value_type *nz_a_end = A.nz_end_(slice_a, row);
        value_type *nz_b = B.nz_begin_(slice_b, row);
        value_type *nz_b_end = B.nz_end_(slice_b, row);

        while (nz_a != nz_a_end && nz_b != nz_b_end)
          if (*ind_a == *ind_b) {
            *nz_a = *nz_b;
            ++ind_a; ++ind_b;
            ++nz_a; ++nz_b;
          } else if (*ind_a < *ind_b) {
            ++ind_a; ++nz_a;
          } else {
            ++ind_b; ++nz_b;
          }
      }
    }
# 1481 "/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp"
    template <typename STR3F>
    static void logSumNoAlloc(STR3F& A, typename STR3F::size_type slice_a,
         const STR3F& B, typename STR3F::size_type slice_b,
         typename STR3F::value_type minFloor =0)
    {
      {
        if (A.nRows() == B.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1487) << "ASSERTION FAILED: \"" << "A.nRows() == B.nRows()" << "\" ";
        if (A.nCols() == B.nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1488) << "ASSERTION FAILED: \"" << "A.nCols() == B.nCols()" << "\" ";
        if (minFloor == 0 || nta::Epsilon < minFloor) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1489) << "ASSERTION FAILED: \"" << "minFloor == 0 || nta::Epsilon < minFloor" << "\" ";
      }

      typedef typename STR3F::col_index_type col_index_type;
      typedef typename STR3F::size_type size_type;
      typedef typename STR3F::value_type value_type;

      nta::Exp<value_type> exp_f;
      nta::Log<value_type> log_f;
      nta::Log1p<value_type> log1p_f;
      nta::Abs<value_type> abs_f;

      size_type M = (size_type) A.nRows();
      value_type minExp = log_f(std::numeric_limits<value_type>::epsilon());

      for (size_type row = 0; row != M; ++row) {

        col_index_type *ind_a = A.ind_begin_(row);
        col_index_type *ind_b = B.ind_begin_(row);
        col_index_type *ind_b_end = B.ind_end_(row);
        value_type *nz_a = A.nz_begin_(slice_a, row);
        value_type *nz_b = B.nz_begin_(slice_b, row);

        while (ind_b != ind_b_end) {
          if (*ind_a == *ind_b) {
            value_type a = *nz_a;
            value_type b = *nz_b;
            if (a < b)
              std::swap(a,b);
            value_type d = b - a;
            if (d >= minExp) {
              a += log1p_f(exp_f(d));
              if (minFloor > 0 && abs_f(a) < minFloor)
                a = minFloor;
              *nz_a = a;
            } else {
              *nz_a = a;
            }
            if (!A.isZero_(*nz_a)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1527) << "ASSERTION FAILED: \"" << "!A.isZero_(*nz_a)" << "\" ";
            ++ind_a; ++nz_a;
            ++ind_b; ++nz_b;
          } else if ( *ind_a < *ind_b) {
            ++ind_a; ++nz_a;
          }
        }
      }
    }
# 1549 "/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp"
    template <typename STR3F>
    static void logDiffNoAlloc(STR3F& A, typename STR3F::size_type slice_a,
          const STR3F& B, typename STR3F::size_type slice_b,
          typename STR3F::value_type minFloor =0)
    {
      {
        if (A.nRows() == B.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1555) << "ASSERTION FAILED: \"" << "A.nRows() == B.nRows()" << "\" ";
        if (A.nCols() == B.nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1556) << "ASSERTION FAILED: \"" << "A.nCols() == B.nCols()" << "\" ";
        if (minFloor == 0 || nta::Epsilon < minFloor) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1557) << "ASSERTION FAILED: \"" << "minFloor == 0 || nta::Epsilon < minFloor" << "\" ";
      }

      typedef typename STR3F::col_index_type col_index_type;
      typedef typename STR3F::size_type size_type;
      typedef typename STR3F::value_type value_type;



      nta::Exp<double> exp_f;
      nta::Log<value_type> log_f;
      nta::Log1p<double> log1p_f;
      nta::Abs<double> abs_f;

      size_type M = (size_type) A.nRows();
      value_type minExp = log_f(std::numeric_limits<value_type>::epsilon());



      double minDiff = -std::numeric_limits<double>::epsilon();
      value_type logOfZero = ((value_type)-1.0)/std::numeric_limits<value_type>::epsilon();

      for (size_type row = 0; row != M; ++row) {

        col_index_type *ind_a = A.ind_begin_(row);
        col_index_type *ind_b = B.ind_begin_(row);
        col_index_type *ind_b_end = B.ind_end_(row);
        value_type *nz_a = A.nz_begin_(slice_a, row);
        value_type *nz_b = B.nz_begin_(slice_b, row);

        while (ind_b != ind_b_end) {
          if (*ind_a == *ind_b) {
            double a = *nz_a;
            double b = *nz_b;
            if (a >= b) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1591) << "ASSERTION FAILED: \"" << "a >= b" << "\" ";
            double d = b - a;


            if (d >= minDiff)
              *nz_a = logOfZero;
            else if (d >= minExp) {
              a += log1p_f(-exp_f(d));
              if (minFloor > 0 && abs_f(a) < minFloor)
                a = minFloor;
              *nz_a = (value_type) a;
            } else {
              *nz_a = (value_type) a;
            }
            if (!A.isZero_(*nz_a)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1605) << "ASSERTION FAILED: \"" << "!A.isZero_(*nz_a)" << "\" ";
            ++ind_a; ++nz_a;
            ++ind_b; ++nz_b;
          } else if (*ind_a < *ind_b) {
            ++ind_a; ++nz_a;
          }
        }
      }
    }






  };
# 1761 "/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp"
  class LogSumApprox {

  public:

    typedef float value_type;

  private:
    value_type min_a, max_a;
    value_type step_a;
    static std::vector<value_type> table;


    value_type minFloor, minExp, logOfZero;
    double minDiff;
    bool trace;

    LogSumApprox(const LogSumApprox&);
    LogSumApprox& operator=(const LogSumApprox&);


    nta::Exp<double> exp_f;
    nta::Log1p<double> log1p_f;

  public:
# 1801 "/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp"
    inline LogSumApprox(int n_ = 5000000,
                        value_type min_a_ =-28, value_type max_a_ =28,
                        bool trace_ =false)
      : min_a(min_a_), max_a(max_a_),
        step_a((value_type)((max_a - min_a)/n_)),
        minFloor((value_type)(1.1 * 1e-6)),
        minExp(logf(std::numeric_limits<value_type>::epsilon())),
        logOfZero(((value_type)-1.0)/std::numeric_limits<value_type>::epsilon()),
        minDiff(-std::numeric_limits<double>::epsilon()),
        trace(trace_)
    {
      {
        if (min_a < max_a) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1813) << "ASSERTION FAILED: \"" << "min_a < max_a" << "\" ";
        if (0 < step_a) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1814) << "ASSERTION FAILED: \"" << "0 < step_a" << "\" ";
      }

      if (table.empty()) {
        table.resize(n_);
        compute_table();
      }

      if (trace)
        std::cout << "Sum of logs table: " << table.size() << " "
                  << min_a << " " << max_a << " " << step_a << " "
                  << (4*table.size()/(1024*1024)) << "MB" << std::endl;
    }
# 1838 "/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp"
    inline void compute_table()
    {
      double a = min_a, step = step_a;

      for (size_t ia = 0; ia < table.size(); ++ia, a += step)
        table[ia] = sum_of_logs_f((value_type)a,(value_type)0);
    }





    inline int index(value_type a, value_type b) const
    {
      return (int)((a - (b + min_a)) / step_a);
    }


  private:






    inline value_type sum_of_logs_f(value_type a, value_type b) const
    {
      if (a < b)
        std::swap(a,b);
      value_type d = b - a;
      if (d >= minExp) {
        a += (value_type) log1p_f(exp_f(d));
        if (fabs(a) < minFloor)
          a = minFloor;
      }

      return a;
    }

  public:






    inline value_type fast_sum_of_logs(value_type a, value_type b) const
    {
      {
        if (minFloor <= fabs(a)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1887) << "ASSERTION FAILED: \"" << "minFloor <= fabs(a)" << "\" " << a;
        if (minFloor <= fabs(b)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1888) << "ASSERTION FAILED: \"" << "minFloor <= fabs(b)" << "\" " << b;
      }

      value_type val = table[index(a,b)] + b;

      if (fabs(val) < minFloor)
        val = minFloor;

      return val;
    }







    inline value_type sum_of_logs(value_type a, value_type b) const
    {
      {
        if (minFloor <= fabs(a)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1908) << "ASSERTION FAILED: \"" << "minFloor <= fabs(a)" << "\" " << a;
        if (minFloor <= fabs(b)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1909) << "ASSERTION FAILED: \"" << "minFloor <= fabs(b)" << "\" " << b;
      }

      value_type val;

      if (-14 <= a && a < 14 && -14 <= b && b < 14)
        val = fast_sum_of_logs(a, b);
      else
        val = sum_of_logs_f(a, b);

      return val;
    }






    template <typename SM, typename STR3F>
    inline void logSum(STR3F& A, typename SM::size_type s, const SM& B)
    {
      {
        if (A.nRows() == B.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1931) << "ASSERTION FAILED: \"" << "A.nRows() == B.nRows()" << "\" ";
        if (A.nCols() == B.nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1932) << "ASSERTION FAILED: \"" << "A.nCols() == B.nCols()" << "\" ";
        if (nta::Epsilon < minFloor) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1933) << "ASSERTION FAILED: \"" << "nta::Epsilon < minFloor" << "\" ";
      }

      typedef typename STR3F::col_index_type col_index_type;
      typedef typename SM::size_type size_type;

      size_type M = (size_type) A.nRows();

      for (size_type row = 0; row != M; ++row) {

        col_index_type *ind_a = A.ind_begin_(row);
        const size_type *ind_b = B.row_nz_index_begin(row);
        const size_type *ind_b_end = B.row_nz_index_end(row);
        value_type *nz_a = A.nz_begin_(s, row);
        const value_type *nz_b = B.row_nz_value_begin(row);

        while (ind_b != ind_b_end) {
          if ((size_type) *ind_a == *ind_b) {
            *nz_a = sum_of_logs(*nz_a, *nz_b);
            ++ind_a; ++nz_a;
            ++ind_b; ++nz_b;
          } else if ((size_type) *ind_a < *ind_b) {
            ++ind_a; ++nz_a;
          }
        }
      }
    }






    template <typename SM, typename STR3F>
    inline void fastLogSum(STR3F& A, typename SM::size_type s, const SM& B)
    {
      {
        if (A.nRows() == B.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1970) << "ASSERTION FAILED: \"" << "A.nRows() == B.nRows()" << "\" ";
        if (A.nCols() == B.nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1971) << "ASSERTION FAILED: \"" << "A.nCols() == B.nCols()" << "\" ";
        if (nta::Epsilon < minFloor) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 1972) << "ASSERTION FAILED: \"" << "nta::Epsilon < minFloor" << "\" ";
      }

      typedef typename STR3F::col_index_type col_index_type;
      typedef typename SM::size_type size_type;

      size_type M = (size_type) A.nRows();

      for (size_type row = 0; row != M; ++row) {

        col_index_type *ind_a = A.ind_begin_(row);
        const size_type *ind_b = B.row_nz_index_begin(row);
        const size_type *ind_b_end = B.row_nz_index_end(row);
        value_type *nz_a = A.nz_begin_(s, row);
        const value_type *nz_b = B.row_nz_value_begin(row);

        while (ind_b != ind_b_end) {
          if ((size_type) *ind_a == *ind_b) {
            *nz_a = fast_sum_of_logs(*nz_a, *nz_b);
            ++ind_a; ++nz_a;
            ++ind_b; ++nz_b;
          } else if ((size_type) *ind_a < *ind_b) {
            ++ind_a; ++nz_a;
          }
        }
      }
    }
  };
# 2016 "/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp"
  class LogDiffApprox {

  public:

    typedef float value_type;

  private:
    value_type min_a, max_a;
    value_type step_a;
    static std::vector<value_type> table;


    value_type minFloor, minExp, logOfZero;
    double minDiff;
    bool trace;

    LogDiffApprox(const LogDiffApprox&);
    LogDiffApprox& operator=(const LogDiffApprox&);

    nta::Exp<double> exp_f;
    nta::Log1p<double> log1p_f;

  public:
# 2047 "/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp"
    inline LogDiffApprox(int n_ = 5000000,
                         value_type min_a_ =1e-10, value_type max_a_ =28,
                         bool trace_ =false)
      : min_a(min_a_), max_a(max_a_),
        step_a((value_type)((max_a - min_a)/n_)),
        minFloor((value_type)(1.1 * 1e-6)),
        minExp(logf(std::numeric_limits<value_type>::epsilon())),
        logOfZero(((value_type)-1.0)/std::numeric_limits<value_type>::epsilon()),
        minDiff(-std::numeric_limits<double>::epsilon()),
        trace(trace_)
    {
      {
        if (min_a < max_a) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 2059) << "ASSERTION FAILED: \"" << "min_a < max_a" << "\" ";
        if (0 < step_a) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 2060) << "ASSERTION FAILED: \"" << "0 < step_a" << "\" ";
      }

      if (table.empty()) {
        table.resize(n_);
        compute_table();
      }

      if (trace)
        std::cout << "Diff of logs table: " << table.size() << " "
                  << min_a << " " << max_a << " " << step_a << " "
                  << (4*table.size()/(1024*1024)) << "MB" << std::endl;
    }





    inline void compute_table()
    {
      double a = min_a, step = step_a;

      for (size_t ia = 0; ia < table.size(); ++ia, a += step)
        table[ia] = diff_of_logs_f((value_type)a,(value_type)0);
    }





    inline int index(value_type a, value_type b) const
    {
      return (int)((a - (b + min_a)) / step_a);
    }

  private:







    inline value_type diff_of_logs_f(value_type a, value_type b) const
    {
      double d = b - a;
      if (d >= minDiff)
        a = logOfZero;
      else if (d >= minExp) {
        a += (value_type) log1p_f(-exp_f(d));
        if (fabs(a) < minFloor)
          a = minFloor;
      }

      return a;
    }

  public:






    inline value_type fast_diff_of_logs(value_type a, value_type b) const
    {
      {
        if (b < a) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 2127) << "ASSERTION FAILED: \"" << "b < a" << "\" ";
        if (minFloor <= fabs(a)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 2128) << "ASSERTION FAILED: \"" << "minFloor <= fabs(a)" << "\" " << a;
        if (minFloor <= fabs(b)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 2129) << "ASSERTION FAILED: \"" << "minFloor <= fabs(b)" << "\" " << b;
      }

      value_type val = table[index(a,b)] + b;

      if (fabs(val) < minFloor)
        val = minFloor;

      return val;
    }







    inline value_type diff_of_logs(value_type a, value_type b) const
    {
      {
        if (b < a) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 2149) << "ASSERTION FAILED: \"" << "b < a" << "\" ";
        if (minFloor <= fabs(a)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 2150) << "ASSERTION FAILED: \"" << "minFloor <= fabs(a)" << "\" " << a;
        if (minFloor <= fabs(b)) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 2151) << "ASSERTION FAILED: \"" << "minFloor <= fabs(b)" << "\" " << b;
      }

      value_type val;

      if (-14 <= a && a < 14 && -14 <= b && b < 14)
        val = fast_diff_of_logs(a, b);
      else
        val = diff_of_logs_f(a, b);

      return val;
    }






    template <typename SM, typename STR3F>
    inline void logDiff(STR3F& A, typename SM::size_type s, const SM& B)
    {
      {
        if (A.nRows() == B.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 2173) << "ASSERTION FAILED: \"" << "A.nRows() == B.nRows()" << "\" ";
        if (A.nCols() == B.nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 2174) << "ASSERTION FAILED: \"" << "A.nCols() == B.nCols()" << "\" ";
        if (nta::Epsilon < minFloor) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 2175) << "ASSERTION FAILED: \"" << "nta::Epsilon < minFloor" << "\" ";
      }

      typedef typename STR3F::col_index_type col_index_type;
      typedef typename SM::size_type size_type;

      size_type M = (size_type) A.nRows();

      for (size_type row = 0; row != M; ++row) {

        col_index_type *ind_a = A.ind_begin_(row);
        const size_type *ind_b = B.row_nz_index_begin(row);
        const size_type *ind_b_end = B.row_nz_index_end(row);
        value_type *nz_a = A.nz_begin_(s, row);
        const value_type *nz_b = B.row_nz_value_begin(row);

        while (ind_b != ind_b_end) {
          if ((size_type) *ind_a == *ind_b) {
            *nz_a = diff_of_logs(*nz_a, *nz_b);
            ++ind_a; ++nz_a;
            ++ind_b; ++nz_b;
          } else if ((size_type) *ind_a < *ind_b) {
            ++ind_a; ++nz_a;
          }
        }
      }
    }






    template <typename SM, typename STR3F>
    inline void fastLogDiff(STR3F& A, typename SM::size_type s, const SM& B)
    {
      {
        if (A.nRows() == B.nRows()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 2212) << "ASSERTION FAILED: \"" << "A.nRows() == B.nRows()" << "\" ";
        if (A.nCols() == B.nCols()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 2213) << "ASSERTION FAILED: \"" << "A.nCols() == B.nCols()" << "\" ";
        if (nta::Epsilon < minFloor) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/math/SparseMatrixAlgorithms.hpp", 2214) << "ASSERTION FAILED: \"" << "nta::Epsilon < minFloor" << "\" ";
      }

      typedef typename STR3F::col_index_type col_index_type;
      typedef typename SM::size_type size_type;

      size_type M = (size_type) A.nRows();

      for (size_type row = 0; row != M; ++row) {

        col_index_type *ind_a = A.ind_begin_(row);
        const size_type *ind_b = B.row_nz_index_begin(row);
        const size_type *ind_b_end = B.row_nz_index_end(row);
        value_type *nz_a = A.nz_begin_(s, row);
        const value_type *nz_b = B.row_nz_value_begin(row);

        while (ind_b != ind_b_end) {
          if ((size_type) *ind_a == *ind_b) {
            *nz_a = fast_diff_of_logs(*nz_a, *nz_b);
            ++ind_a; ++nz_a;
            ++ind_b; ++nz_b;
          } else if ((size_type) *ind_a < *ind_b) {
            ++ind_a; ++nz_a;
          }
        }
      }
    }
  };





};
# 31 "/home/marek/devel/nupic/nta/algorithms/SparsePooler_t.hpp" 2

namespace nta {


  template <typename InputIterator, typename OutputIterator>
  bool
  SparsePooler::learn(InputIterator input_begin, InputIterator input_end,
                      OutputIterator output)
  {
    using namespace std;

    p_ %= input_masks_.nMasks();
    buffer_iterator buf_begin = buf_.begin();
    buffer_iterator buf_end = buf_begin + input_masks_.size(p_);
    const SparsePoolerInputMasks::Mask& mask = input_masks_.mask(p_);

    vector<size_type> ind;
    vector<value_type> nz;
    vector<pair<size_type, value_type> > nn(1, make_pair(0,0));

    concatenate(input_begin, mask.begin(), mask.end(), buf_begin);

    if (min_accept_norm_ > 0) {
      value_type norm = lp_norm(lp_, buf_begin, buf_end);
      if (norm < min_accept_norm_ * input_masks_.ratio(p_))
        return false;
    }

    if (normalize_)
      normalize(buf_begin, buf_end, lp_);

    if (inference_mode_ == kthroot_product) {

      size_type ss = getSegmentSize();
      size_type nnz = 0;
      value_type the_max(0);
      size_type n = (size_type)(buf_end - buf_begin) / ss;

      for (size_type i = 0; i != n; ++i) {
        value_type M(0);
        size_type arg_M = 0;
        for (size_type j = i*ss; j != (i+1)*ss; ++j) {
          value_type val = *(buf_begin + j);
          if (val > M) {
            M = val;
            arg_M = j;
          }
        }
        if (M > the_max)
          the_max = M;
        if (*(buf_begin + arg_M) > nta::Epsilon) {
          ind.push_back(arg_M);
          nz.push_back(1);
          ++nnz;
        }
      }

      if (nnz < min_proto_sum_ || the_max < nta::Epsilon)
        return false;

      if (getNPrototypes(p_) > 0) {

        prototypes_[p_].LpNearest(1.0, ind.begin(), ind.end(), nz.begin(),
                                  nn.begin(), 1, false);

        if (nn[0].second < nta::Epsilon)
          return false;
      }

      prototypes_[p_].addRow(ind.begin(), ind.end(), nz.begin(), true);

      ++p_;
      return true;
    }

    if (sparsification_mode_ == none) {

      from_dense(buf_begin, buf_end, back_inserter(ind), back_inserter(nz));


      if (getNPrototypes(p_) > 0)
        prototypes_[p_].LpNearest(lp_, buf_begin, nn.begin(), 1, true);

    } else {



      if (getNPrototypes(p_) > 0)
        prototypes_[p_].projLpNearest(lp_, buf_begin, nn.begin(), 1, true);

      if (sparsification_mode_ == kWinners) {
        winnerTakesAll3(k_winners_, getSegmentSize(), buf_begin, buf_end,
                        back_inserter(ind), back_inserter(nz), rng_);

      } else if (sparsification_mode_ == threshold) {

        nta::threshold(buf_begin, buf_end,
                       back_inserter(ind), back_inserter(nz),
                       threshold_);
      }
    }


    value_type distance = nn[0].second;
    if (distance >= 0 && distance <= std::numeric_limits<value_type>::max()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/algorithms/SparsePooler_t.hpp", 135) << "CHECK FAILED: \"" << "distance >= 0 && distance <= std::numeric_limits<value_type>::max()" << "\" "
      << "\nSparsePooler encountered an overflow error in calculating the distance "
      << "of the input from the existing prototypes. The most likely cause is that "
      << "the inputs to the SpatialPooler node are too large. ";


    if (getNPrototypes(p_) > 0 && distance <= min_accept_distance_)
      return false;


    prototypes_[p_].addRow(ind.begin(), ind.end(), nz.begin(), true);


    if (sparsification_mode_ == none && inference_mode_ != kthroot_product) {



      UInt nRows = 0;
      bool canInfer = true;
      UInt protoStartIdx = 0;
      for (size_type p = 0; p != input_masks_.nMasks(); ++p) {
        if (prototypes_[p].nRows() == 0)
          canInfer = false;
        if (p == p_)
          protoStartIdx = nRows;
        nRows += prototypes_[p].nRows();
      }



      if (canInfer) {
        Real* outP = new Real[nRows];
        infer(input_begin, input_end, outP, outP + nRows);
        Real* protoOutP = outP + protoStartIdx;
        UInt protoNumRows = prototypes_[p_].nRows();
        UInt winner = (UInt) (std::max_element(protoOutP, protoOutP + protoNumRows)
                               - protoOutP);
        if (winner != protoNumRows-1) {
          infer(input_begin, input_end, outP, outP + nRows);
        }
        delete[] outP;
        if (winner == protoNumRows-1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/algorithms/SparsePooler_t.hpp", 176) << "CHECK FAILED: \"" << "winner == protoNumRows-1" << "\" " << "New coincidence #" << protoNumRows-1
              << " is not far enough away from existing one at index " << winner << ".\n"
              << "The probable cause is that maxDistance, " << min_accept_distance_
              << ", might be set too low for the available precision.\n";
        }
    }


    ++ p_;
    return true;
  }





  template <typename InputIterator, typename OutputIterator>
  void
  SparsePooler::infer(InputIterator input_begin, InputIterator input_end,
                      OutputIterator output_begin, OutputIterator output_end)
  {
    using namespace std;

    {
      if (getTotalNPrototypes() > 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/algorithms/SparsePooler_t.hpp", 200) << "ASSERTION FAILED: \"" << "getTotalNPrototypes() > 0" << "\" "
        << "SparsePooler::infer: Hasn't learnt yet";
    }

    if (inference_mode_ == kthroot_product
        && nearlyZeroRange(input_begin, input_end)) {
      std::fill(output_begin, output_end, (value_type) 0);
      return;
    }

    const size_type segment_size = input_masks_.segmentSize();

    for (size_type p = 0; p != input_masks_.nMasks(); ++p) {

      const SparsePoolerInputMasks::Mask& mask = input_masks_.mask(p);
      buffer_iterator buf_begin = buf_.begin();
      buffer_iterator buf_end = buf_begin + input_masks_.size(p);

      concatenate(input_begin, mask.begin(), mask.end(), buf_begin);

      if (normalize_)
        normalize(buf_begin, buf_end, lp_);

      if (inference_mode_ == gaussian) {

        value_type ratio = input_masks_.ratio(p);
        value_type k = -(value_type) 0.5 / (sigma_*sigma_*ratio);

        if (sparsification_mode_ == none) {

          prototypes_[p].rbf(lp_, k, buf_begin, output_begin);
        } else {

          prototypes_[p].projRbf(lp_, k, buf_begin, output_begin);
        }
      } else if (inference_mode_ == dot) {
        prototypes_[p].rightVecProd(buf_begin, output_begin);

      } else if (inference_mode_ == product) {
        prototypes_[p].rowVecProd(buf_begin, output_begin);

      } else if (inference_mode_ == kthroot_product) {
        SparseMatrixAlgorithms::kthroot_product(prototypes_[p],
                                                segment_size,
                                                buf_begin, output_begin,
                                                .01f/segment_size);
      }

      output_begin += prototypes_[p].nRows();
    }
  }


  template <typename InputIterator, typename InputIterator2, typename OutputIterator>
  void SparsePooler::topDownInfer(InputIterator bu_in, InputIterator bu_in_end,
                                  InputIterator2 td_in, InputIterator2 td_in_end,
                                  OutputIterator td_out)
  {
    using namespace std;
    using namespace nta;

    size_type n_coincidences = getTotalNPrototypes();
    size_type td_n_parents = (size_type) (td_in_end - td_in) / n_coincidences;
    size_type td_out_size = (size_type) (bu_in_end - bu_in);

    vector<value_type> td_sums(n_coincidences, 0);

    for (size_type i = 0; i != n_coincidences; ++i) {
      for (size_type j = 0; j != td_n_parents; ++j)
        td_sums[i] += *(td_in + i + j*n_coincidences);
      td_sums[i] /= td_n_parents;
    }

    size_type offset = 0;

    if (inference_mode_ == gaussian) {

      for (size_type p = 0; p != input_masks_.nMasks(); ++p) {

        size_type nc = prototypes_[p].nRows();
        SparsePoolerInputMasks::Mask mask = input_masks_.mask(p);

        for (size_type j = 0; j != mask.size(); ++j)
          for (size_type k = mask[j].first; k != mask[j].second; ++k)
            for (size_type i = 0; i != nc; ++i)
              *(td_out + k) += td_sums[i] * prototypes_[p].get(i,k);

        offset += nc;
      }

    } else if (inference_mode_ == kthroot_product) {

      vector<value_type> nz(td_sums.size(), 0);

      for (size_type i = 0; i != nz.size(); ++i)
        nz[i] = td_sums[i] > 0;

      for (size_type p = 0; p != input_masks_.nMasks(); ++p) {

        size_type nc = prototypes_[p].nRows();
        size_type n = prototypes_[p].nCols();
        vector<value_type> result(n), maxScores(n);

        prototypes_[p].leftVecSumAtNZ(td_sums.begin() + offset, result.begin());
        prototypes_[p].leftVecSumAtNZ(nz.begin() + offset, maxScores.begin());
        nta::clip(maxScores, 1, numeric_limits<value_type>::max());
        nta::divide(result, maxScores);

        SparsePoolerInputMasks::Mask mask = input_masks_.mask(p);

        for (size_type j = 0; j != mask.size(); ++j)
          for (size_type k = mask[j].first; k != mask[j].second; ++k)
            *(td_out + k) += nc * result[k];

        offset += nc;
      }
    }

    divide_val(td_out, td_out + td_out_size, n_coincidences);
    value_type s = sum(td_out, td_out + td_out_size);
    add_val(td_out, td_out + td_out_size, .1 * s / td_out_size);
  }



}
# 488 "/home/marek/devel/nupic/nta/algorithms/SparsePooler.hpp" 2
# 38 "/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.hpp" 2

namespace nta
{
# 54 "/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.hpp"
  class SpatialPoolerNode : public RegionImpl
  {
  public:
    static Spec* createSpec();
    size_t getNodeOutputElementCount(const std::string& outputName);
    void getParameterFromBuffer(const std::string& name, Int64 index, IWriteBuffer& value);
# 68 "/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.hpp"
    void setParameterFromBuffer(const std::string& name, Int64 index, IReadBuffer& value);

    void setParameterString(const std::string& name, Int64 index, const std::string& s);
    std::string getParameterString(const std::string& name, Int64 index);


    Handle getParameterHandle(const std::string& paramName, Int64 index);


    void initialize();
# 89 "/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.hpp"
    SpatialPoolerNode(const ValueMap& params, Region *region);

    SpatialPoolerNode(BundleIO& bundle, Region* region);
# 101 "/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.hpp"
    virtual ~SpatialPoolerNode();





    virtual void serialize(BundleIO& bundle);




    virtual void deserialize(BundleIO& bundle);
# 127 "/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.hpp"
    void compute();
# 153 "/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.hpp"
    virtual std::string executeCommand(const std::vector<std::string>& args, Int64 index);

    typedef enum { Learning, Inference } Mode;

  private:
    static const std::string current_spatial_pooler_node_version_;

    Mode mode_;
    bool clonedNodes_;
    UInt64 nodeCount_;


    UInt32 segmentSize_;
    SparsePooler::SparsificationMode sparsificationMode_;
    SparsePooler::InferenceMode inferenceMode_;
    std::string patchMasksStr_;
    bool normalize_;
    Real32 norm_;
    Int32 kWinners_;
    Real32 maxDistance_;
    Real32 minAcceptNorm_;
    Real32 minProtoSum_;
    Real32 sigma_;
    UInt32 seed_;


    UInt32 maxNAttempts_;
    UInt32 maxNPrototypes_;
    Real64 acceptanceProbability_;
    Random rgen_;
    bool poolersAllocated_;

    std::vector<SparsePooler*> poolers_;




    Input* bottomUpIn_;
    Input* topDownIn_;



    ArrayRef bottomUpOut_;
    ArrayRef topDownOut_;

    std::vector<Real> bottomUpInputVector_;
    std::vector<Real> topDownInputVector_;

    size_t buInputSizePerNode_;
    size_t tdInputSizePerNode_;

    UInt32 phaseIndex_;


    static void waitDebuggerAttach_();
    void switchToInference_();

    private: SpatialPoolerNode(); SpatialPoolerNode(const SpatialPoolerNode&); SpatialPoolerNode& operator=(const SpatialPoolerNode&);;
  };
}
# 32 "/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp" 2
# 1 "/home/marek/devel/nupic/nta/engine/Spec.hpp" 1
# 32 "/home/marek/devel/nupic/nta/engine/Spec.hpp"
# 1 "/home/marek/devel/nupic/nta/ntypes/Collection.hpp" 1
# 30 "/home/marek/devel/nupic/nta/ntypes/Collection.hpp"
namespace nta
{





  template <typename T>
  class Collection
  {
  public:
    Collection();
    virtual ~Collection();

    size_t getCount() const;





    const std::pair<std::string, T>& getByIndex(size_t index) const;

    bool contains(const std::string & name) const;

    T getByName(const std::string & name) const;




    void add(const std::string & name, const T & item);

    void remove(const std::string& name);



    std::pair<std::string, T>& getByIndex(size_t index);


  private:
    typedef std::vector<std::pair<std::string, T> > CollectionStorage;
    CollectionStorage vec_;
  };
}
# 33 "/home/marek/devel/nupic/nta/engine/Spec.hpp" 2



namespace nta
{
  class InputSpec
  {
  public:
    InputSpec() {}
    InputSpec(
      const std::string & description,
      NTA_BasicType dataType,
      UInt32 count,
      bool required,
      bool regionLevel,
      bool isDefaultInput,
      bool requireSplitterMap = true);

    std::string description;
    NTA_BasicType dataType;


    UInt32 count;

    bool required;
    bool regionLevel;
    bool isDefaultInput;
    bool requireSplitterMap;
  };

  class OutputSpec
  {
  public:
    OutputSpec() {}
    OutputSpec(const std::string& description, const
               NTA_BasicType dataType, size_t count, bool regionLevel, bool isDefaultOutput);

    std::string description;
    NTA_BasicType dataType;


    size_t count;
    bool regionLevel;
    bool isDefaultOutput;
  };

  class CommandSpec
  {
  public:
    CommandSpec() {}
    CommandSpec(const std::string& description);

    std::string description;

  };

  class ParameterSpec
  {
  public:
    typedef enum { CreateAccess, ReadOnlyAccess, ReadWriteAccess } AccessMode;

    ParameterSpec() {}



    ParameterSpec(const std::string& description,
                  NTA_BasicType dataType, size_t count,
                  const std::string& constraints, const std::string& defaultValue,
                  AccessMode accessMode);


    std::string description;



    NTA_BasicType dataType;


    size_t count;
    std::string constraints;
    std::string defaultValue;
    AccessMode accessMode;

  };


  struct Spec
  {



    std::string toString() const;



    bool singleNodeOnly;


    std::string description;

    Collection<InputSpec> inputs;
    Collection<OutputSpec> outputs;
    Collection<CommandSpec> commands;
    Collection<ParameterSpec> parameters;



    Spec();


    std::string getDefaultOutputName() const;
    std::string getDefaultInputName() const;







  };

}
# 33 "/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp" 2
# 1 "/home/marek/devel/nupic/nta/engine/Region.hpp" 1
# 42 "/home/marek/devel/nupic/nta/engine/Region.hpp"
# 1 "/home/marek/devel/nupic/nta/ntypes/Dimensions.hpp" 1
# 31 "/home/marek/devel/nupic/nta/ntypes/Dimensions.hpp"
namespace nta
{






  typedef std::vector<size_t> Coordinate;
# 58 "/home/marek/devel/nupic/nta/ntypes/Dimensions.hpp"
  class Dimensions : public std::vector<size_t>
  {
  public:
    Dimensions();
    Dimensions(std::vector<size_t> v);
    Dimensions(size_t x);
    Dimensions(size_t x, size_t y);
    Dimensions(size_t x, size_t y, size_t z);




    size_t
    getCount() const;





    size_t
    getDimensionCount() const;





    size_t
    getDimension(size_t index) const;






    bool
    isDontcare() const;

    bool
    isUnspecified() const;

    bool
    isSpecified() const;



    bool
    isOnes() const;






    bool
    isValid() const;






    std::string
    toString(bool humanReadable=true) const;




    size_t
    getIndex(const Coordinate&) const;




    Coordinate
    getCoordinate(const size_t) const;




    void
    promote(size_t newDimensionality);

    bool
    operator==(const Dimensions& dims2) const;

    bool
    operator!=(const Dimensions& dims2) const;



    friend std::ostream& operator<<(std::ostream& f, const Dimensions&);



  };

}
# 43 "/home/marek/devel/nupic/nta/engine/Region.hpp" 2
# 1 "/home/marek/devel/nupic/nta/os/Timer.hpp" 1
# 34 "/home/marek/devel/nupic/nta/os/Timer.hpp"
namespace nta
{
# 49 "/home/marek/devel/nupic/nta/os/Timer.hpp"
  class Timer
  {
  public:






    Timer(bool startme = false);





    void
    start();





    void
    stop();







    Real64
    getElapsed() const;




    void
    reset();




    UInt64
    getStartCount() const;




    bool
    isStarted() const;

    std::string
    toString() const;

  private:

    UInt64 prevElapsed_;
    UInt64 start_;
    UInt64 nstarts_;
    bool started_;

  };

}
# 44 "/home/marek/devel/nupic/nta/engine/Region.hpp" 2

namespace nta
{
  class RegionImpl;
  class Output;
  class Input;
  class ArrayRef;
  class Array;
  struct Spec;
  class NodeSet;
  class BundleIO;
  class Timer;
  class Network;





  class Region
  {
  public:
# 77 "/home/marek/devel/nupic/nta/engine/Region.hpp"
    Network *
    getNetwork();






    const std::string&
    getName() const;







    const Dimensions&
    getDimensions() const;
# 104 "/home/marek/devel/nupic/nta/engine/Region.hpp"
    void
    setDimensions(Dimensions & dimensions);




    void
    prepareInputs();
# 122 "/home/marek/devel/nupic/nta/engine/Region.hpp"
    const std::string&
    getType() const;






    const Spec*
    getSpec() const;
# 140 "/home/marek/devel/nupic/nta/engine/Region.hpp"
    static const Spec*
    getSpecFromType(const std::string& nodeType);

    Int32
    getParameterInt32(const std::string& name) const;
    UInt32
    getParameterUInt32(const std::string& name) const;
    Int64
    getParameterInt64(const std::string& name) const;
    UInt64
    getParameterUInt64(const std::string& name) const;
    Real32
    getParameterReal32(const std::string& name) const;
    Real64
    getParameterReal64(const std::string& name) const;
    Handle
    getParameterHandle(const std::string& name) const;


    void
    setParameterInt32(const std::string& name, Int32 value);
    void
    setParameterUInt32(const std::string& name, UInt32 value);
    void
    setParameterInt64(const std::string& name, Int64 value);
    void
    setParameterUInt64(const std::string& name, UInt64 value);
    void
    setParameterReal32(const std::string& name, Real32 value);
    void
    setParameterReal64(const std::string& name, Real64 value);
    void
    setParameterHandle(const std::string& name, Handle value);
# 192 "/home/marek/devel/nupic/nta/engine/Region.hpp"
    void
    getParameterArray(const std::string& name, Array & array) const;






    void
    setParameterArray(const std::string& name, const Array & array);
# 214 "/home/marek/devel/nupic/nta/engine/Region.hpp"
    void
    setParameterString(const std::string& name, const std::string& s);

    std::string
    getParameterString(const std::string& name);

    bool
    isParameterShared(const std::string& name) const;
# 240 "/home/marek/devel/nupic/nta/engine/Region.hpp"
    virtual ArrayRef
    getInputData(const std::string& inputName) const;
# 259 "/home/marek/devel/nupic/nta/engine/Region.hpp"
    virtual ArrayRef
    getOutputData(const std::string& outputName) const;


    virtual size_t
    getOutputCount(const std::string& outputName) const;

    virtual size_t
    getInputCount(const std::string& inputName) const;


    virtual void
    enable();

    virtual void
    disable();
# 289 "/home/marek/devel/nupic/nta/engine/Region.hpp"
    virtual std::string
    executeCommand(const std::vector<std::string>& args);







    void
    compute();
# 308 "/home/marek/devel/nupic/nta/engine/Region.hpp"
    void
    enableProfiling();







    void
    disableProfiling();







    void
    resetProfiling();







    const Timer& getComputeTimer() const;







    const Timer& getExecuteTimer() const;





    Region(const std::string& name,
           const std::string& type,
           const std::string& nodeParams,
           Network * network = __null);


    Region(const std::string& name,
           const std::string& type,
           const Dimensions& dimensions,
           BundleIO& bundle,
           Network * network = __null);

    virtual ~Region();

    void
    initialize();

    bool
    isInitialized() const;




    Output*
    getOutput(const std::string& name) const;

    Input*
    getInput(const std::string& name) const;


    const std::map<const std::string, Input*>&
    getInputs() const;

    const std::map<const std::string, Output*>&
    getOutputs() const;




    size_t
    evaluateLinks();

    std::string
    getLinkErrors() const;

    size_t
    getNodeOutputElementCount(const std::string& name);

    void
    initOutputs();

    void
    initInputs() const;

    void
    intialize();


    void
    setDimensionInfo(const std::string& info);

    const std::string&
    getDimensionInfo() const;

    bool
    hasOutgoingLinks() const;





    void
    uninitialize();

    void
    removeAllIncomingLinks();

    const NodeSet&
    getEnabledNodes() const;



    void
    setPhases(std::set<UInt32>& phases);

    std::set<UInt32>&
    getPhases();


    void
    serializeImpl(BundleIO& bundle);




  private:

    Region();
    Region(Region&);



    void createInputsAndOutputs_();

    const std::string name_;


    RegionImpl* impl_;
    const std::string type_;
    Spec* spec_;

    typedef std::map<const std::string, Output*> OutputMap;
    typedef std::map<const std::string, Input*> InputMap;

    OutputMap outputs_;
    InputMap inputs_;

    std::set<UInt32> phases_;
    Dimensions dims_;
    bool initialized_;

    NodeSet* enabledNodes_;




    Network* network_;





    std::string dimensionInfo_;


    void setupEnabledNodeSet();



    bool profilingEnabled_;
    Timer computeTimer_;
    Timer executeTimer_;
  };

}
# 34 "/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp" 2
# 1 "/home/marek/devel/nupic/nta/ntypes/NodeSet.hpp" 1
# 29 "/home/marek/devel/nupic/nta/ntypes/NodeSet.hpp"
namespace nta
{
# 50 "/home/marek/devel/nupic/nta/ntypes/NodeSet.hpp"
  class NodeSet
  {
  public:
    NodeSet(size_t nnodes) : nnodes_(nnodes)
    {
      set_.clear();
    }

    typedef std::set<size_t>::const_iterator const_iterator;

    const_iterator begin() const
    {
      return set_.begin();
    };

    const_iterator end() const
    {
      return set_.end();
    }

    void allOn()
    {
      for (size_t i = 0; i < nnodes_; i++)
      {
        set_.insert(i);
      }
    }

    void allOff()
    {
      set_.clear();
    }

    void add(size_t index)
    {
      if (index > nnodes_)
      {
        throw nta::LoggingException("/home/marek/devel/nupic/nta/ntypes/NodeSet.hpp", 87) << "Attempt to enable node with index " << index << " which is larger than the number of nodes " << nnodes_;
      }
      set_.insert(index);
    }

    void remove(size_t index)
    {
      iterator f = set_.find(index);
      if (f == set_.end())
        return;
      set_.erase(f);
    }

  private:
    typedef std::set<size_t>::iterator iterator;
    NodeSet();
    size_t nnodes_;
    std::set<size_t> set_;
  };

}
# 35 "/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp" 2
# 1 "/home/marek/devel/nupic/nta/ntypes/BundleIO.hpp" 1
# 27 "/home/marek/devel/nupic/nta/ntypes/BundleIO.hpp"
# 1 "/home/marek/devel/nupic/nta/os/Path.hpp" 1
# 37 "/home/marek/devel/nupic/nta/os/Path.hpp"
namespace nta
{
# 91 "/home/marek/devel/nupic/nta/os/Path.hpp"
  class Path
  {
  public:
    typedef std::vector<std::string> StringVec;

    static const char * sep;
    static const char * pathSep;
    static const char * parDir;
# 133 "/home/marek/devel/nupic/nta/os/Path.hpp"
    static std::string getParent(const std::string & path);




    static std::string getBasename(const std::string & path);




    static std::string getExtension(const std::string & path);
# 161 "/home/marek/devel/nupic/nta/os/Path.hpp"
    static std::string normalize(const std::string & path);
# 170 "/home/marek/devel/nupic/nta/os/Path.hpp"
    static std::string makeAbsolute(const std::string & path);




    static std::string unicodeToUtf8(const std::wstring& path);




    static std::wstring utf8ToUnicode(const std::string& path);
# 197 "/home/marek/devel/nupic/nta/os/Path.hpp"
    static StringVec split(const std::string & path);




    static std::string join(StringVec::const_iterator begin,
      StringVec::const_iterator end);





    static bool isRootdir(const std::string & path);





    static bool isAbsolute(const std::string & path);




    static std::string join(const std::string & path1, const std::string & path2);
    static std::string join(const std::string & path1, const std::string & path2,
                            const std::string & path3);
    static std::string join(const std::string & path1, const std::string & path2,
                            const std::string & path3, const std::string & path4);
# 236 "/home/marek/devel/nupic/nta/os/Path.hpp"
    static bool exists(const std::string & path);




    static Size getFileSize(const std::string & path);





    static void copy(const std::string & source, const std::string & destination);
    static void remove(const std::string & path);
    static void rename(const std::string & oldPath, const std::string & newPath);
    static bool isDirectory(const std::string & path);
    static bool isFile(const std::string & path);
    static bool isSymbolicLink(const std::string & path);
    static bool areEquivalent(const std::string & path1, const std::string & path2);

    static std::string getExecutablePath();

    static void setPermissions(const std::string &path,
        bool userRead, bool userWrite,
        bool groupRead, bool groupWrite,
        bool otherRead, bool otherWrite
      );


    Path(const std::string & path);
    operator const char*() const;





    bool operator==(const Path & other);

    Path & operator +=(const Path & path);
    bool exists() const;
    Path getParent() const;
    Path getBasename() const;
    Path getExtension() const;
    Size getFileSize() const;

    Path & normalize();
    Path & makeAbsolute();
    StringVec split() const;

    void remove() const;
    void copy(const std::string & destination) const;
    void rename(const std::string & newPath);

    bool isDirectory() const;
    bool isFile() const;
    bool isRootdir() const;
    bool isAbsolute() const;
    bool isSymbolicLink() const;
    bool isEmpty() const;

  private:

    static bool isPrefix(const std::string&);
    Path();

  private:
    std::string path_;
  };


  Path operator+(const Path & p1, const Path & p2);
}
# 28 "/home/marek/devel/nupic/nta/ntypes/BundleIO.hpp" 2
# 1 "/home/marek/devel/nupic/nta/os/FStream.hpp" 1
# 39 "/home/marek/devel/nupic/nta/os/FStream.hpp"
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 1 3
# 37 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3



# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/codecvt.h" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/codecvt.h" 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
# 67 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
# 115 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/codecvt.h" 3
      result
      out(state_type& __state, const intern_type* __from,
   const intern_type* __from_end, const intern_type*& __from_next,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const
      {
 return this->do_out(__state, __from, __from_end, __from_next,
       __to, __to_end, __to_next);
      }
# 154 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/codecvt.h" 3
      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
       extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }
# 195 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/codecvt.h" 3
      result
      in(state_type& __state, const extern_type* __from,
  const extern_type* __from_end, const extern_type*& __from_next,
  intern_type* __to, intern_type* __to_end,
  intern_type*& __to_next) const
      {
 return this->do_in(__state, __from, __from_end, __from_next,
      __to, __to_end, __to_next);
      }

      int
      encoding() const throw()
      { return this->do_encoding(); }

      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }

      int
      length(state_type& __state, const extern_type* __from,
      const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }

      int
      max_length() const throw()
      { return this->do_max_length(); }

    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }

      virtual
      ~__codecvt_abstract_base() { }
# 236 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/codecvt.h" 3
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const = 0;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const = 0;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const = 0;

      virtual int
      do_encoding() const throw() = 0;

      virtual bool
      do_always_noconv() const throw() = 0;

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const = 0;

      virtual int
      do_max_length() const throw() = 0;
    };
# 275 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/codecvt.h" 3
   template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs),
 _M_c_locale_codecvt(0)
      { }

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };

  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;


  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
    public:

      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
  };



  template<>
    class codecvt<wchar_t, char, mbstate_t>
    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>
    {
    public:

      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };



  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
     this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
   }
      }

    protected:
      virtual
      ~codecvt_byname() { }
    };




  extern template class codecvt_byname<char, char, mbstate_t>;

  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);


  extern template class codecvt_byname<wchar_t, char, mbstate_t>;

  extern template
    const codecvt<wchar_t, char, mbstate_t>&
    use_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);




}
# 41 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdio" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdio" 3
# 42 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 2 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/basic_file.h" 1 3
# 38 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/basic_file.h" 3


# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/c++io.h" 1 3
# 35 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/c++io.h" 3
# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdio" 1 3
# 40 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/cstdio" 3
# 36 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/c++io.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __gthread_mutex_t __c_lock;


  typedef FILE __c_file;


}
# 41 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/x86_64-unknown-linux-gnu/bits/basic_file.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _CharT>
    class __basic_file;


  template<>
    class __basic_file<char>
    {

      __c_file* _M_cfile;


      bool _M_cfile_created;

    public:
      __basic_file(__c_lock* __lock = 0) throw ();

      __basic_file*
      open(const char* __name, ios_base::openmode __mode, int __prot = 0664);

      __basic_file*
      sys_open(__c_file* __file, ios_base::openmode);

      __basic_file*
      sys_open(int __fd, ios_base::openmode __mode) throw ();

      __basic_file*
      close();

      __attribute__ ((__pure__)) bool
      is_open() const throw ();

      __attribute__ ((__pure__)) int
      fd() throw ();

      __attribute__ ((__pure__)) __c_file*
      file() throw ();

      ~__basic_file();

      streamsize
      xsputn(const char* __s, streamsize __n);

      streamsize
      xsputn_2(const char* __s1, streamsize __n1,
        const char* __s2, streamsize __n2);

      streamsize
      xsgetn(char* __s, streamsize __n);

      streamoff
      seekoff(streamoff __off, ios_base::seekdir __way) throw ();

      int
      sync();

      streamsize
      showmanyc();
    };


}
# 43 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{
# 71 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_filebuf : public basic_streambuf<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef __basic_file<char> __file_type;
      typedef typename traits_type::state_type __state_type;
      typedef codecvt<char_type, char, __state_type> __codecvt_type;

      friend class ios_base;

    protected:


      __c_lock _M_lock;


      __file_type _M_file;


      ios_base::openmode _M_mode;


      __state_type _M_state_beg;




      __state_type _M_state_cur;



      __state_type _M_state_last;


      char_type* _M_buf;






      size_t _M_buf_size;


      bool _M_buf_allocated;
# 133 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
      bool _M_reading;
      bool _M_writing;







      char_type _M_pback;
      char_type* _M_pback_cur_save;
      char_type* _M_pback_end_save;
      bool _M_pback_init;



      const __codecvt_type* _M_codecvt;






      char* _M_ext_buf;




      streamsize _M_ext_buf_size;






      const char* _M_ext_next;
      char* _M_ext_end;






      void
      _M_create_pback()
      {
 if (!_M_pback_init)
   {
     _M_pback_cur_save = this->gptr();
     _M_pback_end_save = this->egptr();
     this->setg(&_M_pback, &_M_pback, &_M_pback + 1);
     _M_pback_init = true;
   }
      }






      void
      _M_destroy_pback() throw()
      {
 if (_M_pback_init)
   {

     _M_pback_cur_save += this->gptr() != this->eback();
     this->setg(_M_buf, _M_pback_cur_save, _M_pback_end_save);
     _M_pback_init = false;
   }
      }

    public:







      basic_filebuf();




      virtual
      ~basic_filebuf()
      { this->close(); }





      bool
      is_open() const throw()
      { return _M_file.is_open(); }
# 269 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
      __filebuf_type*
      open(const char* __s, ios_base::openmode __mode);
# 296 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
      __filebuf_type*
      close();

    protected:
      void
      _M_allocate_internal_buffer();

      void
      _M_destroy_internal_buffer() throw();


      virtual streamsize
      showmanyc();






      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = _Traits::eof());
# 328 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
      virtual int_type
      overflow(int_type __c = _Traits::eof());



      bool
      _M_convert_to_external(char_type*, streamsize);
# 348 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n);

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __pos,
       ios_base::openmode __mode = ios_base::in | ios_base::out);


      pos_type
      _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state);

      int
      _M_get_ext_pos(__state_type &__state);

      virtual int
      sync();

      virtual void
      imbue(const locale& __loc);

      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);

      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);


      bool
      _M_terminate_output();
# 394 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
      void
      _M_set_buffer(streamsize __off)
      {
  const bool __testin = _M_mode & ios_base::in;
  const bool __testout = _M_mode & ios_base::out;

 if (__testin && __off > 0)
   this->setg(_M_buf, _M_buf, _M_buf + __off);
 else
   this->setg(_M_buf, _M_buf, _M_buf);

 if (__testout && __off == 0 && _M_buf_size > 1 )
   this->setp(_M_buf, _M_buf + _M_buf_size - 1);
 else
   this->setp(0, 0);
      }
    };
# 426 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ifstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 453 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
      basic_ifstream() : __istream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 466 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
      explicit
      basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 498 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
      ~basic_ifstream()
      { }
# 508 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 537 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
      void
      open(const char* __s, ios_base::openmode __mode = ios_base::in)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::in))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 575 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
# 598 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ofstream : public basic_ostream<_CharT,_Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 625 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
      basic_ofstream(): __ostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 639 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
      explicit
      basic_ofstream(const char* __s,
       ios_base::openmode __mode = ios_base::out|ios_base::trunc)
      : __ostream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 673 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
      ~basic_ofstream()
      { }
# 683 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 712 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
      void
      open(const char* __s,
    ios_base::openmode __mode = ios_base::out | ios_base::trunc)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::out))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 752 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
# 775 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_fstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ios<char_type, traits_type> __ios_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 803 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
      basic_fstream()
      : __iostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 815 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
      explicit
      basic_fstream(const char* __s,
      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __iostream_type(0), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 846 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
      ~basic_fstream()
      { }
# 856 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 885 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
      void
      open(const char* __s,
    ios_base::openmode __mode = ios_base::in | ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 925 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };


}


# 1 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/fstream.tcc" 1 3
# 38 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/fstream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_allocate_internal_buffer()
    {


      if (!_M_buf_allocated && !_M_buf)
 {
   _M_buf = new char_type[_M_buf_size];
   _M_buf_allocated = true;
 }
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_destroy_internal_buffer() throw()
    {
      if (_M_buf_allocated)
 {
   delete [] _M_buf;
   _M_buf = 0;
   _M_buf_allocated = false;
 }
      delete [] _M_ext_buf;
      _M_ext_buf = 0;
      _M_ext_buf_size = 0;
      _M_ext_next = 0;
      _M_ext_end = 0;
    }

  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>::
    basic_filebuf() : __streambuf_type(), _M_lock(), _M_file(&_M_lock),
    _M_mode(ios_base::openmode(0)), _M_state_beg(), _M_state_cur(),
    _M_state_last(), _M_buf(0), _M_buf_size(8192),
    _M_buf_allocated(false), _M_reading(false), _M_writing(false), _M_pback(),
    _M_pback_cur_save(0), _M_pback_end_save(0), _M_pback_init(false),
    _M_codecvt(0), _M_ext_buf(0), _M_ext_buf_size(0), _M_ext_next(0),
    _M_ext_end(0)
    {
      if (has_facet<__codecvt_type>(this->_M_buf_locale))
 _M_codecvt = &use_facet<__codecvt_type>(this->_M_buf_locale);
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    open(const char* __s, ios_base::openmode __mode)
    {
      __filebuf_type *__ret = 0;
      if (!this->is_open())
 {
   _M_file.open(__s, __mode);
   if (this->is_open())
     {
       _M_allocate_internal_buffer();
       _M_mode = __mode;


       _M_reading = false;
       _M_writing = false;
       _M_set_buffer(-1);


       _M_state_last = _M_state_cur = _M_state_beg;


       if ((__mode & ios_base::ate)
    && this->seekoff(0, ios_base::end, __mode)
    == pos_type(off_type(-1)))
  this->close();
       else
  __ret = this;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    close()
    {
      if (!this->is_open())
 return 0;

      bool __testfail = false;
      {

 struct __close_sentry
 {
   basic_filebuf *__fb;
   __close_sentry (basic_filebuf *__fbi): __fb(__fbi) { }
   ~__close_sentry ()
   {
     __fb->_M_mode = ios_base::openmode(0);
     __fb->_M_pback_init = false;
     __fb->_M_destroy_internal_buffer();
     __fb->_M_reading = false;
     __fb->_M_writing = false;
     __fb->_M_set_buffer(-1);
     __fb->_M_state_last = __fb->_M_state_cur = __fb->_M_state_beg;
   }
 } __cs (this);

 try
   {
     if (!_M_terminate_output())
       __testfail = true;
   }
 catch(__cxxabiv1::__forced_unwind&)
   {
     _M_file.close();
     throw;
   }
 catch(...)
   { __testfail = true; }
      }

      if (!_M_file.close())
 __testfail = true;

      if (__testfail)
 return 0;
      else
 return this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    showmanyc()
    {
      streamsize __ret = -1;
      const bool __testin = _M_mode & ios_base::in;
      if (__testin && this->is_open())
 {


   __ret = this->egptr() - this->gptr();







   if (__check_facet(_M_codecvt).encoding() >= 0)

     __ret += _M_file.showmanyc() / _M_codecvt->max_length();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = _M_mode & ios_base::in;
      if (__testin)
 {
   if (_M_writing)
     {
       if (overflow() == traits_type::eof())
  return __ret;
       _M_set_buffer(-1);
       _M_writing = false;
     }



   _M_destroy_pback();

   if (this->gptr() < this->egptr())
     return traits_type::to_int_type(*this->gptr());


   const size_t __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;


   bool __got_eof = false;

   streamsize __ilen = 0;
   codecvt_base::result __r = codecvt_base::ok;
   if (__check_facet(_M_codecvt).always_noconv())
     {
       __ilen = _M_file.xsgetn(reinterpret_cast<char*>(this->eback()),
          __buflen);
       if (__ilen == 0)
  __got_eof = true;
     }
   else
     {


       const int __enc = _M_codecvt->encoding();
       streamsize __blen;
       streamsize __rlen;
       if (__enc > 0)
  __blen = __rlen = __buflen * __enc;
       else
  {
    __blen = __buflen + _M_codecvt->max_length() - 1;
    __rlen = __buflen;
  }
       const streamsize __remainder = _M_ext_end - _M_ext_next;
       __rlen = __rlen > __remainder ? __rlen - __remainder : 0;



       if (_M_reading && this->egptr() == this->eback() && __remainder)
  __rlen = 0;



       if (_M_ext_buf_size < __blen)
  {
    char* __buf = new char[__blen];
    if (__remainder)
      __builtin_memcpy(__buf, _M_ext_next, __remainder);

    delete [] _M_ext_buf;
    _M_ext_buf = __buf;
    _M_ext_buf_size = __blen;
  }
       else if (__remainder)
  __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);

       _M_ext_next = _M_ext_buf;
       _M_ext_end = _M_ext_buf + __remainder;
       _M_state_last = _M_state_cur;

       do
  {
    if (__rlen > 0)
      {



        if (_M_ext_end - _M_ext_buf + __rlen > _M_ext_buf_size)
   {
     __throw_ios_failure(("basic_filebuf::underflow " "codecvt::max_length() " "is not valid"));


   }
        streamsize __elen = _M_file.xsgetn(_M_ext_end, __rlen);
        if (__elen == 0)
   __got_eof = true;
        else if (__elen == -1)
   break;
        _M_ext_end += __elen;
      }

    char_type* __iend = this->eback();
    if (_M_ext_next < _M_ext_end)
      __r = _M_codecvt->in(_M_state_cur, _M_ext_next,
      _M_ext_end, _M_ext_next,
      this->eback(),
      this->eback() + __buflen, __iend);
    if (__r == codecvt_base::noconv)
      {
        size_t __avail = _M_ext_end - _M_ext_buf;
        __ilen = std::min(__avail, __buflen);
        traits_type::copy(this->eback(),
     reinterpret_cast<char_type*>
     (_M_ext_buf), __ilen);
        _M_ext_next = _M_ext_buf + __ilen;
      }
    else
      __ilen = __iend - this->eback();




    if (__r == codecvt_base::error)
      break;

    __rlen = 1;
  }
       while (__ilen == 0 && !__got_eof);
     }

   if (__ilen > 0)
     {
       _M_set_buffer(__ilen);
       _M_reading = true;
       __ret = traits_type::to_int_type(*this->gptr());
     }
   else if (__got_eof)
     {



       _M_set_buffer(-1);
       _M_reading = false;


       if (__r == codecvt_base::partial)
  __throw_ios_failure(("basic_filebuf::underflow " "incomplete character in file"));

     }
   else if (__r == codecvt_base::error)
     __throw_ios_failure(("basic_filebuf::underflow " "invalid byte sequence in file"));

   else
     __throw_ios_failure(("basic_filebuf::underflow " "error reading the file"));

 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    pbackfail(int_type __i)
    {
      int_type __ret = traits_type::eof();
      const bool __testin = _M_mode & ios_base::in;
      if (__testin)
 {
   if (_M_writing)
     {
       if (overflow() == traits_type::eof())
  return __ret;
       _M_set_buffer(-1);
       _M_writing = false;
     }


   const bool __testpb = _M_pback_init;
   const bool __testeof = traits_type::eq_int_type(__i, __ret);
   int_type __tmp;
   if (this->eback() < this->gptr())
     {
       this->gbump(-1);
       __tmp = traits_type::to_int_type(*this->gptr());
     }
   else if (this->seekoff(-1, ios_base::cur) != pos_type(off_type(-1)))
     {
       __tmp = this->underflow();
       if (traits_type::eq_int_type(__tmp, __ret))
  return __ret;
     }
   else
     {





       return __ret;
     }



   if (!__testeof && traits_type::eq_int_type(__i, __tmp))
     __ret = __i;
   else if (__testeof)
     __ret = traits_type::not_eof(__i);
   else if (!__testpb)
     {
       _M_create_pback();
       _M_reading = true;
       *this->gptr() = traits_type::to_char_type(__i);
       __ret = __i;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    overflow(int_type __c)
    {
      int_type __ret = traits_type::eof();
      const bool __testeof = traits_type::eq_int_type(__c, __ret);
      const bool __testout = _M_mode & ios_base::out;
      if (__testout)
 {
          if (_M_reading)
            {
              _M_destroy_pback();
              const int __gptr_off = _M_get_ext_pos(_M_state_last);
              if (_M_seek(__gptr_off, ios_base::cur, _M_state_last)
                  == pos_type(off_type(-1)))
                return __ret;
            }
   if (this->pbase() < this->pptr())
     {

       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }



       if (_M_convert_to_external(this->pbase(),
      this->pptr() - this->pbase()))
  {
    _M_set_buffer(0);
    __ret = traits_type::not_eof(__c);
  }
     }
   else if (_M_buf_size > 1)
     {



       _M_set_buffer(0);
       _M_writing = true;
       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }
       __ret = traits_type::not_eof(__c);
     }
   else
     {

       char_type __conv = traits_type::to_char_type(__c);
       if (__testeof || _M_convert_to_external(&__conv, 1))
  {
    _M_writing = true;
    __ret = traits_type::not_eof(__c);
  }
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_convert_to_external(_CharT* __ibuf, streamsize __ilen)
    {

      streamsize __elen;
      streamsize __plen;
      if (__check_facet(_M_codecvt).always_noconv())
 {
   __elen = _M_file.xsputn(reinterpret_cast<char*>(__ibuf), __ilen);
   __plen = __ilen;
 }
      else
 {


   streamsize __blen = __ilen * _M_codecvt->max_length();
   char* __buf = static_cast<char*>(__builtin_alloca(__blen));

   char* __bend;
   const char_type* __iend;
   codecvt_base::result __r;
   __r = _M_codecvt->out(_M_state_cur, __ibuf, __ibuf + __ilen,
    __iend, __buf, __buf + __blen, __bend);

   if (__r == codecvt_base::ok || __r == codecvt_base::partial)
     __blen = __bend - __buf;
   else if (__r == codecvt_base::noconv)
     {

       __buf = reinterpret_cast<char*>(__ibuf);
       __blen = __ilen;
     }
   else
     __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error"));


   __elen = _M_file.xsputn(__buf, __blen);
   __plen = __blen;


   if (__r == codecvt_base::partial && __elen == __plen)
     {
       const char_type* __iresume = __iend;
       streamsize __rlen = this->pptr() - __iend;
       __r = _M_codecvt->out(_M_state_cur, __iresume,
        __iresume + __rlen, __iend, __buf,
        __buf + __blen, __bend);
       if (__r != codecvt_base::error)
  {
    __rlen = __bend - __buf;
    __elen = _M_file.xsputn(__buf, __rlen);
    __plen = __rlen;
  }
       else
  __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error"));

     }
 }
      return __elen == __plen;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    xsgetn(_CharT* __s, streamsize __n)
    {

      streamsize __ret = 0;
      if (_M_pback_init)
 {
   if (__n > 0 && this->gptr() == this->eback())
     {
       *__s++ = *this->gptr();
       this->gbump(1);
       __ret = 1;
       --__n;
     }
   _M_destroy_pback();
 }
      else if (_M_writing)
 {
    if (overflow() == traits_type::eof())
      return __ret;
    _M_set_buffer(-1);
    _M_writing = false;
  }




      const bool __testin = _M_mode & ios_base::in;
      const streamsize __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;

      if (__n > __buflen && __check_facet(_M_codecvt).always_noconv()
     && __testin)
   {

     const streamsize __avail = this->egptr() - this->gptr();
     if (__avail != 0)
       {
        traits_type::copy(__s, this->gptr(), __avail);
         __s += __avail;
        this->setg(this->eback(), this->gptr() + __avail,
     this->egptr());
        __ret += __avail;
        __n -= __avail;
       }



     streamsize __len;
     for (;;)
       {
         __len = _M_file.xsgetn(reinterpret_cast<char*>(__s),
           __n);
         if (__len == -1)
    __throw_ios_failure(("basic_filebuf::xsgetn " "error reading the file"));

         if (__len == 0)
    break;

         __n -= __len;
         __ret += __len;
         if (__n == 0)
    break;

         __s += __len;
       }

     if (__n == 0)
       {
         _M_set_buffer(0);
         _M_reading = true;
       }
     else if (__len == 0)
       {



         _M_set_buffer(-1);
         _M_reading = false;
       }
   }
      else
   __ret += __streambuf_type::xsgetn(__s, __n);

      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    xsputn(const _CharT* __s, streamsize __n)
    {
      streamsize __ret = 0;



      const bool __testout = _M_mode & ios_base::out;
      if (__check_facet(_M_codecvt).always_noconv()
     && __testout && !_M_reading)
 {

   const streamsize __chunk = 1ul << 10;
   streamsize __bufavail = this->epptr() - this->pptr();


   if (!_M_writing && _M_buf_size > 1)
     __bufavail = _M_buf_size - 1;

   const streamsize __limit = std::min(__chunk, __bufavail);
   if (__n >= __limit)
     {
       const streamsize __buffill = this->pptr() - this->pbase();
       const char* __buf = reinterpret_cast<const char*>(this->pbase());
       __ret = _M_file.xsputn_2(__buf, __buffill,
           reinterpret_cast<const char*>(__s),
           __n);
       if (__ret == __buffill + __n)
  {
    _M_set_buffer(0);
    _M_writing = true;
  }
       if (__ret > __buffill)
  __ret -= __buffill;
       else
  __ret = 0;
     }
   else
     __ret = __streambuf_type::xsputn(__s, __n);
 }
       else
  __ret = __streambuf_type::xsputn(__s, __n);
       return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__streambuf_type*
    basic_filebuf<_CharT, _Traits>::
    setbuf(char_type* __s, streamsize __n)
    {
      if (!this->is_open())
 {
   if (__s == 0 && __n == 0)
     _M_buf_size = 1;
   else if (__s && __n > 0)
     {
# 700 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/bits/fstream.tcc" 3
       _M_buf = __s;
       _M_buf_size = __n;
     }
 }
      return this;
    }




  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode)
    {
      int __width = 0;
      if (_M_codecvt)
 __width = _M_codecvt->encoding();
      if (__width < 0)
 __width = 0;

      pos_type __ret = pos_type(off_type(-1));
      const bool __testfail = __off != 0 && __width <= 0;
      if (this->is_open() && !__testfail)
 {




   bool __no_movement = __way == ios_base::cur && __off == 0
     && (!_M_writing || _M_codecvt->always_noconv());


   if (!__no_movement)
     _M_destroy_pback();






   __state_type __state = _M_state_beg;
   off_type __computed_off = __off * __width;
   if (_M_reading && __way == ios_base::cur)
     {
       __state = _M_state_last;
       __computed_off += _M_get_ext_pos(__state);
     }
   if (!__no_movement)
     __ret = _M_seek(__computed_off, __way, __state);
   else
     {
       if (_M_writing)
  __computed_off = this->pptr() - this->pbase();

        off_type __file_off = _M_file.seekoff(0, ios_base::cur);
        if (__file_off != off_type(-1))
  {
    __ret = __file_off + __computed_off;
    __ret.state(__state);
  }
     }
 }
      return __ret;
    }





  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekpos(pos_type __pos, ios_base::openmode)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (this->is_open())
 {

   _M_destroy_pback();
   __ret = _M_seek(off_type(__pos), ios_base::beg, __pos.state());
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (_M_terminate_output())
 {
   off_type __file_off = _M_file.seekoff(__off, __way);
   if (__file_off != off_type(-1))
     {
       _M_reading = false;
       _M_writing = false;
       _M_ext_next = _M_ext_end = _M_ext_buf;
       _M_set_buffer(-1);
       _M_state_cur = __state;
       __ret = __file_off;
       __ret.state(_M_state_cur);
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    int basic_filebuf<_CharT, _Traits>::
    _M_get_ext_pos(__state_type& __state)
    {
      if (_M_codecvt->always_noconv())
        return this->gptr() - this->egptr();
      else
        {



          const int __gptr_off =
            _M_codecvt->length(__state, _M_ext_buf, _M_ext_next,
                               this->gptr() - this->eback());
          return _M_ext_buf + __gptr_off - _M_ext_end;
        }
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_terminate_output()
    {

      bool __testvalid = true;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __testvalid = false;
 }


      if (_M_writing && !__check_facet(_M_codecvt).always_noconv()
   && __testvalid)
 {



   const size_t __blen = 128;
   char __buf[__blen];
   codecvt_base::result __r;
   streamsize __ilen = 0;

   do
     {
       char* __next;
       __r = _M_codecvt->unshift(_M_state_cur, __buf,
     __buf + __blen, __next);
       if (__r == codecvt_base::error)
  __testvalid = false;
       else if (__r == codecvt_base::ok ||
         __r == codecvt_base::partial)
  {
    __ilen = __next - __buf;
    if (__ilen > 0)
      {
        const streamsize __elen = _M_file.xsputn(__buf, __ilen);
        if (__elen != __ilen)
   __testvalid = false;
      }
  }
     }
   while (__r == codecvt_base::partial && __ilen > 0 && __testvalid);

   if (__testvalid)
     {




       const int_type __tmp = this->overflow();
       if (traits_type::eq_int_type(__tmp, traits_type::eof()))
  __testvalid = false;
     }
 }
      return __testvalid;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_filebuf<_CharT, _Traits>::
    sync()
    {


      int __ret = 0;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __ret = -1;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    imbue(const locale& __loc)
    {
      bool __testvalid = true;

      const __codecvt_type* _M_codecvt_tmp = 0;
      if (__builtin_expect(has_facet<__codecvt_type>(__loc), true))
 _M_codecvt_tmp = &use_facet<__codecvt_type>(__loc);

      if (this->is_open())
 {

   if ((_M_reading || _M_writing)
       && __check_facet(_M_codecvt).encoding() == -1)
     __testvalid = false;
   else
     {
       if (_M_reading)
  {
    if (__check_facet(_M_codecvt).always_noconv())
      {
        if (_M_codecvt_tmp
     && !__check_facet(_M_codecvt_tmp).always_noconv())
   __testvalid = this->seekoff(0, ios_base::cur, _M_mode)
                 != pos_type(off_type(-1));
      }
    else
      {

        _M_ext_next = _M_ext_buf
   + _M_codecvt->length(_M_state_last, _M_ext_buf,
          _M_ext_next,
          this->gptr() - this->eback());
        const streamsize __remainder = _M_ext_end - _M_ext_next;
        if (__remainder)
   __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);

        _M_ext_next = _M_ext_buf;
        _M_ext_end = _M_ext_buf + __remainder;
        _M_set_buffer(-1);
        _M_state_last = _M_state_cur = _M_state_beg;
      }
  }
       else if (_M_writing && (__testvalid = _M_terminate_output()))
  _M_set_buffer(-1);
     }
 }

      if (__testvalid)
 _M_codecvt = _M_codecvt_tmp;
      else
 _M_codecvt = 0;
    }




  extern template class basic_filebuf<char>;
  extern template class basic_ifstream<char>;
  extern template class basic_ofstream<char>;
  extern template class basic_fstream<char>;


  extern template class basic_filebuf<wchar_t>;
  extern template class basic_ifstream<wchar_t>;
  extern template class basic_ofstream<wchar_t>;
  extern template class basic_fstream<wchar_t>;




}
# 937 "/usr/lib64/gcc/x86_64-unknown-linux-gnu/4.8.2/../../../../include/c++/4.8.2/fstream" 2 3
# 40 "/home/marek/devel/nupic/nta/os/FStream.hpp" 2

namespace nta {
# 56 "/home/marek/devel/nupic/nta/os/FStream.hpp"
class IFStream : public std::ifstream
{

public:



  IFStream () : std::ifstream() {}







  virtual ~IFStream() {}







  IFStream (const char * filename, ios_base::openmode mode = ios_base::in ) : std::ifstream()
  {
    open(filename, mode);
  }







  void open(const char * filename, ios_base::openmode mode = ios_base::in );




  static void diagnostics(const char* filename);

};
# 113 "/home/marek/devel/nupic/nta/os/FStream.hpp"
class OFStream : public std::ofstream
{

public:



  OFStream () : std::ofstream() {}







  virtual ~OFStream() {}
# 137 "/home/marek/devel/nupic/nta/os/FStream.hpp"
  OFStream (const char * filename, ios_base::openmode mode = ios_base::out ) : std::ofstream()
  {
    open(filename, mode);
  }







  void open(const char * filename, ios_base::openmode mode = ios_base::out );


};

class ZLib
{
public:
  static void *fopen(const std::string &filename, const std::string &mode,
    std::string *errorMessage=0);
};



}
# 29 "/home/marek/devel/nupic/nta/ntypes/BundleIO.hpp" 2

namespace nta
{
  class BundleIO
  {
  public:
    BundleIO(const std::string& bundlePath, const std::string& label,
             const std::string& regionName, bool isInput);

    ~BundleIO();



    std::ofstream& getOutputStream(const std::string& name) const;

    std::ifstream& getInputStream(const std::string& name) const;

    std::string getPath(const std::string& name) const;

  private:



    void checkStreams_() const;



    bool isInput_;



    std::string bundlePath_;


    std::string filePrefix_;


    std::string regionName_;





    mutable std::ofstream *ostream_;
    mutable std::ifstream *istream_;

  };
}
# 36 "/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp" 2
# 49 "/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp"
using namespace std;
namespace nta
{

Spec* SpatialPoolerNode::createSpec()
{
  Spec *ns = new Spec;

  ns->description =
    "The spatial pooler finds spatial coincidences patterns between the outputs "
    "from its\n"
    "children. It stores an optionally sparse representation of those spatial "
    "coincidences.\n"
    "The spatial pooler has two modes of operation: \"learning\" and "
    "\"inference\".\n"
    "In \"learning\" mode, it learns relevant coincidence patterns, and in\n"
    "\"inference\" mode, it produces an output by comparing the input\n"
    "pattern against all the stored patterns. The output is a vector that "
    "represents\n"
    "the degree of match of the input pattern to all the stored patterns.\n"
    "The spatial pooler is controlled by the parameters below.\n"
    "Additional documentation is available in NodeAlgorithmsGuide.pdf, "
    "located in $NTA/share/docs.";

  ns->inputs.add(
    "bottomUpIn",
    InputSpec(
      "The input to this node from children nodes.\n"
      "This input is a vector of reals.",
      NTA_BasicType_Real32,
      0,
      true,
      false,
      true
      ));


  ns->inputs.add(
    "topDownIn",
    InputSpec(
      "The input to this node from nodes above. "
      "It is a vector of reals.",
      NTA_BasicType_Real,
      0,
      false,
      false,
      false
      ));

  ns->outputs.add(
    "bottomUpOut",
    OutputSpec(
      "The bottom-up output of this node. It is a vector of reals.\n"
      "In learning mode, it is zero (there is no output).\n"
      "In inference mode, it returns an approximation of the input\n"
      "vector using radial basis functions centered on each learned\n"
      "coincidence. There are therefore as many elements\n"
      "in bottomUpOut as there are coincidences stored in the\n"
      "SpatialPooler.",
      NTA_BasicType_Real32,
      0,
      false,
      true
      ));

  ns->outputs.add(
    "topDownOut",
    OutputSpec(
      "The top-down output of this node is a vector or reals.\n",
      NTA_BasicType_Real,
      0,
      false,
      false
      ));


  ns->parameters.add(
    "clonedNodes",
    ParameterSpec(
      "If true, this specifies that all the nodes in the region will\n"
      "be clones and will share state.",
      NTA_BasicType_UInt32,
      1,
      "enum: 0, 1",
      "1",
      ParameterSpec::CreateAccess
      ));


  ns->parameters.add(
    "nta_phaseIndex",
    ParameterSpec(
      "The scheduler phase.",
      NTA_BasicType_UInt32,
      1,
      "",
      "",
      ParameterSpec::ReadWriteAccess
      ));

  ns->parameters.add(
    "learningMode",
    ParameterSpec(
      "Whether or not this node is in learning mode.\n"
      "Turning off learning has the side effect of turning on inference.",
      NTA_BasicType_UInt32,
      1,
      "enum: 0, 1",
      "1",
      ParameterSpec::ReadWriteAccess
      ));


  ns->parameters.add(
    "inferenceMode",
    ParameterSpec(
      "Whether or not this node is inferring.\n"
      "Turning on inference has the side effect of turning off learning.",
      NTA_BasicType_UInt32,
      1,
      "enum: 0, 1",
      "0",
      ParameterSpec::ReadWriteAccess
      ));

  ns->parameters.add(






    "sparsify",
    ParameterSpec(
      "Whether to sparsify the input vectors or not.",
      NTA_BasicType_Byte,
      0,


      "enum: 0, 1",
      "0",
      ParameterSpec::ReadWriteAccess
      ));


  ns->parameters.add(
    "spatialPoolerAlgorithm",
    ParameterSpec(
      "The algorithm to use during inference.",
      NTA_BasicType_Byte,
      0,
      "enum: gaussian,kthroot_product",
      "gaussian",
      ParameterSpec::CreateAccess
      ));

  ns->parameters.add(
    "maxDistance",
    ParameterSpec(
      "The max distance between a candidate coincidence and a\n"
      "coincidence, within which the candidate will be considered\n"
      "the same as the coincidence.",
      NTA_BasicType_Real32,
      1,
      "interval: [0, ...)",
      "0",
      ParameterSpec::CreateAccess
      ));


  ns->parameters.add(
    "sigma",
    ParameterSpec(
      "Sigma to be used in the radial-basis function in gaussian\n"
      "inference mode.",
      NTA_BasicType_Real32,
      1,
      "interval: (0, ...)",
      "1.0",
      ParameterSpec::CreateAccess
      ));

  ns->parameters.add(
    "maxCoincidenceCount",
    ParameterSpec(
      "The maximum number of coincidences that can be learned\n"
      "by each node in this node.",
      NTA_BasicType_UInt32,
      1,
      "",
      "",
      ParameterSpec::CreateAccess
      ));

  ns->parameters.add(
    "coincidenceCount",
    ParameterSpec(
      "The number of coincidences learned.",
      NTA_BasicType_UInt32,
      1,
      "",
      "",
      ParameterSpec::ReadOnlyAccess
      ));

  ns->parameters.add(
    "coincidenceMatrix",
    ParameterSpec(
      "The coincidence matrix, as a sparse matrix.",
      NTA_BasicType_Handle,
      1,
      "",
      "",
      ParameterSpec::ReadOnlyAccess
      ));

  ns->parameters.add(
    "activeOutputCount",
    ParameterSpec(
      "The number of active elements in bottomUpOut.",
      NTA_BasicType_UInt32,
      1,
      "",
      "",
      ParameterSpec::ReadOnlyAccess
      ));


  ns->parameters.add(
    "nta_patchMasks",
    ParameterSpec(
      "The masks that will be used to extract prototypes.",
      NTA_BasicType_Byte,
      0,
      "",
      "",
      ParameterSpec::CreateAccess
      ));

  ns->parameters.add(
    "nta_segmentSize",
    ParameterSpec(
      "The size of the segments for sparsification.",
      NTA_BasicType_UInt32,
      1,
      "interval: [1, ...)",
      "",
      ParameterSpec::CreateAccess
      ));

  ns->parameters.add(
    "nta_normalize",
    ParameterSpec(
      "Whether to normalize the inputs or not.",
      NTA_BasicType_UInt32,
      1,
      "enum: 0, 1",
      "0",
      ParameterSpec::ReadWriteAccess
      ));

  ns->parameters.add(
    "nta_norm",
    ParameterSpec(
      "The value to use for normalization.",
      NTA_BasicType_Real32,
      1,
      "interval: [0, ...)",
      "2",
      ParameterSpec::CreateAccess
      ));

  ns->parameters.add(
    "nta_kWinners",
    ParameterSpec(
      "The number of winners to keep per segment, "
      "when using k-winners sparsification mode.",
      NTA_BasicType_UInt32,
      1,
      "interval: [1, ...)",
      "1",
      ParameterSpec::CreateAccess
      ));

  ns->parameters.add(
    "nta_minAcceptNorm",
    ParameterSpec(
      "The min norm that a candidate prototype should have.",
      NTA_BasicType_Real32,
      1,
      "interval: [0, ...)",
      "0",
      ParameterSpec::CreateAccess
      ));

  ns->parameters.add(
    "nta_minProtoSum",
    ParameterSpec(
      "The min sum of the components of a prototype.",
      NTA_BasicType_Real32,
      1,
      "interval: [0, ...)",
      "8",
      ParameterSpec::CreateAccess
      ));

  ns->parameters.add(
    "nta_maxNAttempts",
    ParameterSpec(
      "The max number of attempts.",
      NTA_BasicType_UInt32,
      1,
      "interval: [0, ...)",
      "0",
      ParameterSpec::CreateAccess
      ));

  ns->parameters.add(
    "nta_seed",
    ParameterSpec(
      "Seed the random number generator used for random coincidence "
      "selection. If equal to 0, will be seeded automatically. "
      "Not stored when the node is saved.",
      NTA_BasicType_UInt32,
      1,
      "interval: [0, ...)",
      "42",
      ParameterSpec::CreateAccess
      ));


  ns->parameters.add(
    "nta_acceptanceProbability",
    ParameterSpec(
      "The probability that each node will attempt to learn "
      "on each compute iteration. Only applied if cloning is off. "
      "Setting this to something less than 1.0 "
      "allows presenting many vectors but only considering a tiny "
      "fraction of them for learning. For example, if the total "
      "training input is 100,000 vectors, "
      "and the number of coincidences to be "
      "stored must be no more than 100, then this parameter should be "
      "set to approximately 100/100,000 = 0.001. "
      "This probability is considered "
      "before testing for minimum norm, sparsificiation, max distance "
      "and other checks. "
      "Applied by drawing a pseudorandom 48-bit fraction "
      "between 0 and 1, and attempting to learn only if the value "
      "is less than the parameter value. "
      "When set to 1.0 (the default), no pseudorandom draws occur. "
      "Not stored when the node is saved.",
      NTA_BasicType_Real64,
      1,
      "interval: (0.0, 1.0]",
      "1.0",
      ParameterSpec::ReadWriteAccess
      ));


  return ns;
}







const std::string SpatialPoolerNode::current_spatial_pooler_node_version_ =
  "SpatialPoolerNode_1.8";




SpatialPoolerNode::SpatialPoolerNode(const ValueMap& params, Region* region)
  : RegionImpl(region),
    mode_(Learning),

    nodeCount_(0),
# 442 "/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp"
    acceptanceProbability_(1.0),

    poolersAllocated_(false),


    bottomUpIn_(__null),
    topDownIn_(__null),
    bottomUpOut_(NTA_BasicType_Real),
    topDownOut_(NTA_BasicType_Real),


    buInputSizePerNode_(0),
    tdInputSizePerNode_(0),
    phaseIndex_(0)
{

  waitDebuggerAttach_();

  clonedNodes_ = params.getScalarT<UInt32>("clonedNodes");
  segmentSize_ = params.getScalarT<UInt32>("nta_segmentSize");
  sparsificationMode_ =
    SparsePooler::convertSparsificationMode(*params.getString("sparsify"));
  inferenceMode_ =
    SparsePooler::convertInferenceMode(*params.getString("spatialPoolerAlgorithm"));
  patchMasksStr_ = *params.getString("nta_patchMasks");
  normalize_ = (bool)params.getScalarT<UInt32>("nta_normalize");
  norm_ = params.getScalarT<Real32>("nta_norm");
  kWinners_ = params.getScalarT<UInt32>("nta_kWinners");
  maxDistance_ = max(nta::Epsilon, params.getScalarT<Real32>("maxDistance"));
  minAcceptNorm_ = params.getScalarT<Real32>("nta_minAcceptNorm");
  minProtoSum_ = params.getScalarT<Real32>("nta_minProtoSum");
  sigma_ = params.getScalarT<Real32>("sigma");
  seed_ = params.getScalarT<UInt32>("nta_seed");
  maxNPrototypes_ = params.getScalarT<UInt32>("maxCoincidenceCount");
# 484 "/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp"
  maxNAttempts_ = params.getScalarT<UInt32>("nta_maxNAttempts", 0);

  poolers_.clear();



}


SpatialPoolerNode::SpatialPoolerNode(BundleIO& bundle, Region* region) :
  RegionImpl(region),
  bottomUpOut_(NTA_BasicType_Real),
  topDownOut_(NTA_BasicType_Real)

{
  deserialize(bundle);
}




SpatialPoolerNode::~SpatialPoolerNode()
{
  for (UInt i = 0; i != poolers_.size(); ++i) {
    delete poolers_[i];
    poolers_[i] = __null;
  }
}


void SpatialPoolerNode::initialize()
{
  const char* where = "SpatialPoolerNode, in initialize: ";

  if (region_ != __null) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp", 518) << "CHECK FAILED: \"" << "region_ != NULL" << "\" ";
  nodeCount_ = region_->getDimensions().getCount();

  bottomUpOut_ = region_->getOutputData("bottomUpOut");
  topDownOut_ = region_->getOutputData("topDownOut");
  bottomUpIn_ = region_->getInput("bottomUpIn");
  topDownIn_ = region_->getInput("topDownIn");

  if (bottomUpIn_->getData().getCount() == 0)
  {
    throw nta::LoggingException("/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp", 528) << "Unable to initialize SpatialPooler Region '"
              << region_->getName() << "' because bottom up input is not linked.";
  }


  if (bottomUpOut_.getCount() == nodeCount_ * maxNPrototypes_) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp", 533) << "CHECK FAILED: \"" << "bottomUpOut_.getCount() == nodeCount_ * maxNPrototypes_" << "\" ";


  if (mode_ == Learning || mode_ == Inference) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp", 536) << "CHECK FAILED: \"" << "mode_ == Learning || mode_ == Inference" << "\" "
    << where << "Expected 0 (Learning) or 1 (Inference) for nodeMode, got: "
    << mode_;

  if (maxNAttempts_ == 0)
    maxNAttempts_ = (UInt32) min(max((Real32)32, sqrt((Real32)nodeCount_)), (Real32)nodeCount_);

  buInputSizePerNode_ = bottomUpIn_->getData().getCount() / nodeCount_;
  tdInputSizePerNode_ = topDownIn_->getData().getCount() / nodeCount_;


  UInt actualNumNodes = clonedNodes_ ? 1 : nodeCount_;


  rgen_ = nta::Random(seed_);

  if (!poolersAllocated_)
  {
    std::stringstream tmp;
    tmp << segmentSize_ << " ";
    if (patchMasksStr_.empty()) {
      tmp << " 1 1 0 " << max((size_t)1, buInputSizePerNode_) << " ";
    } else
      tmp << patchMasksStr_;
    SparsePoolerInputMasks input_masks(tmp);
    for (UInt i = 0; i < actualNumNodes; i++)
    {
      SparsePooler *sp =
        new SparsePooler(
          input_masks,
          normalize_,
          norm_,
          sparsificationMode_,
          inferenceMode_,
          kWinners_,
          1.0,
          maxDistance_,
          minAcceptNorm_,
          minProtoSum_,
          sigma_,
          rgen_.getUInt32());
      poolers_.push_back(sp);
    }
    poolersAllocated_ = true;
  }
}


void SpatialPoolerNode::compute()
{
  if (!poolersAllocated_)
    throw nta::LoggingException("/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp", 587) << "Invalid operation -- SpatialPoolerNode must be initialized by initializing the network";

  if (mode_ == Learning) {

    if (clonedNodes_) {



      if (poolers_[0]->getTotalNPrototypes() >= maxNPrototypes_)
        return;


      UInt maxNAttempts = maxNAttempts_ == 0 ?
        poolers_[0]->getNPrototypeSizes() : maxNAttempts_;




      vector<UInt> cand;
      for (NodeSet::const_iterator i = getEnabledNodes().begin();
           i != getEnabledNodes().end(); i++)
      {
        cand.push_back(*i);
      }







      if((acceptanceProbability_ < 1.0) &&
         (rgen_.getReal64() > acceptanceProbability_)) {
        return;
      }

      bool accepted = false;
      UInt n_attempts = 0;

      maxNAttempts = min(maxNAttempts, (UInt)cand.size());

      while (!accepted && n_attempts < maxNAttempts) {

        UInt node = cand[rgen_(cand.size())];

        bottomUpIn_->getInputForNode(node, bottomUpInputVector_);

        Real* bottomUpOut = (Real*) bottomUpOut_.getBuffer() + node * maxNPrototypes_;

        accepted = poolers_[0]->learn(bottomUpInputVector_.begin(),
                                      bottomUpInputVector_.end(), bottomUpOut);

        if (!accepted)
          cand.erase(remove(cand.begin(), cand.end(), (UInt)node), cand.end());

        ++n_attempts;
      }

    } else {

      for (NodeSet::const_iterator i = getEnabledNodes().begin();
           i != getEnabledNodes().end(); i++)
      {
        size_t node = *i;




        if (poolers_[node]->getTotalNPrototypes() < maxNPrototypes_) {

          if((acceptanceProbability_ < 1.0) &&
             (rgen_.getReal64() > acceptanceProbability_))
            {

            }
          else {
            bottomUpIn_->getInputForNode(node, bottomUpInputVector_);

            Real* bottomUpOut = (Real*) bottomUpOut_.getBuffer() + node * maxNPrototypes_;

            poolers_[node]->learn(bottomUpInputVector_.begin(),
                                  bottomUpInputVector_.end(), bottomUpOut);
          }
        }
      }
    }

  } else if (mode_ == Inference) {

    for (NodeSet::const_iterator i = getEnabledNodes().begin();
         i != getEnabledNodes().end(); i++)
    {
      size_t node = *i;

      bottomUpIn_->getInputForNode(node, bottomUpInputVector_);

      Real* bottomUpOut = (Real*) bottomUpOut_.getBuffer() + node * maxNPrototypes_;
      Real* bottomUpOut_end = bottomUpOut + maxNPrototypes_;

      UInt poolerIndex = clonedNodes_ ? (UInt) 0 : (UInt) node;

      if (phaseIndex_ == 0) {

        poolers_[poolerIndex]->infer(bottomUpInputVector_.begin(),
                                     bottomUpInputVector_.end(), bottomUpOut, bottomUpOut_end);

      } else {
        if (tdInputSizePerNode_ != 0) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp", 694) << "CHECK FAILED: \"" << "tdInputSizePerNode_ != 0" << "\" ";

        topDownIn_->getInputForNode(node, topDownInputVector_);

        Real* topDownOut = (Real*) topDownOut_.getBuffer()+maxNPrototypes_* node;

        poolers_[poolerIndex]->topDownInfer(bottomUpInputVector_.begin(),
                                            bottomUpInputVector_.end(),
                                            topDownInputVector_.begin(),
                                            topDownInputVector_.end(), topDownOut);
      }
    }
  }
}


void SpatialPoolerNode::setParameterString(const std::string& paramName, Int64 index, const std::string& s)
{
  if (!poolersAllocated_)
    throw nta::LoggingException("/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp", 713) << "Invalid operation -- SpatialPoolerNode must be initialized by initializing the network";

  if (paramName == "sparsify") {
    SparsePooler::SparsificationMode mode = SparsePooler::convertSparsificationMode(s);
    for(std::vector<nta::SparsePooler*>::iterator i = poolers_.begin(); i!=poolers_.end(); ++i)
      (*i)->setSparsificationMode(mode);
  } else {
    throw nta::LoggingException("/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp", 720) << "Unknown string parameter '" << paramName << "'";
  }
}


std::string SpatialPoolerNode::getParameterString(const std::string& paramName, Int64 index)
{
  if (!poolersAllocated_)
    throw nta::LoggingException("/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp", 728) << "Invalid operation -- SpatialPoolerNode must be initialized by initializing the network";


  UInt poolerIndex = clonedNodes_ ? 0 : (UInt) index;

  if (paramName == "sparsify") {
    return poolers_[poolerIndex]->getSparsificationModeStr();
  } else if (paramName == "spatialPoolerAlgorithm") {
    return poolers_[poolerIndex]->getInferenceModeStr();
  } else if (paramName == "nta_patchMasks") {
    OMemStream buf;
    poolers_[poolerIndex]->getInputMasks().saveState(buf);
    return buf.str();
  } else if (paramName == "coincidenceMatrixString") {
    OMemStream buf;
    poolers_[0]->getCoincidenceMatrix(buf);
    return buf.str();
  } else {
        throw nta::LoggingException("/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp", 746) << "Unknown string parameter: " << paramName;
  }
}


Handle SpatialPoolerNode::getParameterHandle(const std::string& paramName, Int64 index)
{
  if (!poolersAllocated_)
    throw nta::LoggingException("/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp", 754) << "Invalid operation -- SpatialPoolerNode must be initialized by initializing the network";

  if (paramName == "coincidenceMatrix")
  {
    if (clonedNodes_ && index != -1)
    {
      throw nta::LoggingException("/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp", 760) << "CoincidenceMatrix is a node level parameter -- must be retrieved for a specific node";
    }
    Int64 poolerIndex = clonedNodes_ ? 0 : index;
    if ((UInt32)poolerIndex < poolers_.size()) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp", 763) << "CHECK FAILED: \"" << "(UInt32)poolerIndex < poolers_.size()" << "\" ";
    return (Handle)(poolers_[poolerIndex]->getCoincidenceMatrixHandle());
  } else {



    throw nta::LoggingException("/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp", 769) << "Unknown handle parameter '" << paramName << "'";
  }
}



void SpatialPoolerNode::setParameterFromBuffer(const std::string& paramName, Int64 index,
                                               IReadBuffer& buf)
{

  const char* where = "SpatialPoolerNode, while setting parameter: ";

  try {

    UInt int_param = 0;


    if (paramName == "nta_phaseIndex") {
      buf.read(int_param);
      phaseIndex_ = (UInt32) int_param;
    }

    else if (paramName == "learningMode") {
      buf.read(int_param);
      mode_ = (int_param == 1) ? Learning : Inference;
      if (mode_ == Inference)
        switchToInference_();
    }

    else if (paramName == "inferenceMode") {
      buf.read(int_param);
      mode_ = (int_param == 1) ? Inference : Learning;
      if (mode_ == Inference)
        switchToInference_();
    }


    else if (paramName == "nta_acceptanceProbability") {
      double x = 1.0;
      buf.read(x);


      if (x > (1.0 / double(0x1LL << 48))) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp", 811) << "CHECK FAILED: \"" << "x > (1.0 / double(0x1LL << 48))" << "\" "
        << "Acceptance probability is too small. "
        "Fewer samples would be learned than expected.";

      acceptanceProbability_ = x;
    }

    else {

      throw nta::LoggingException("/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp", 820) << "Unknown parameter: " << paramName;

    }
  } catch (std::exception& e) {
    throw nta::LoggingException("/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp", 824) << where << "Couldn't set " << paramName
              << ": " << e.what();
  }
}


void SpatialPoolerNode::getParameterFromBuffer(const std::string& paramName,
                                               Int64 index,
                                               IWriteBuffer& value)
{


  const char* where = "SpatialPoolerNode, while getting parameter: ";

  try {

    if (paramName == "learningMode") {
      value.write((UInt32) (mode_ == Learning ? 1 : 0));

    } else if (paramName == "inferenceMode") {
      value.write((UInt32) (mode_ == Inference ? 1 : 0));

    } else if (paramName == "maxCoincidenceCount") {
      value.write(maxNPrototypes_);

    } else if (paramName == "clonedNodes") {
      value.write((UInt32) (clonedNodes_ ? 1 : 0));
    } else if (paramName == "nta_phaseIndex") {
      value.write((UInt32) phaseIndex_);
    } else if (paramName == "nta_maxNAttempts") {
      value.write((UInt32) maxNAttempts_);
    } else if (paramName == "nta_acceptanceProbability") {
      value.write(acceptanceProbability_);
    } else if (paramName == "nta_seed") {
      value.write((nta::Int32)rgen_.getSeed());
    } else {
      if (!poolersAllocated_)
        throw nta::LoggingException("/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp", 861) << "Invalid operation -- SpatialPoolerNode must be initialized by initializing the network";

      UInt poolerIndex = clonedNodes_ ? 0 : (UInt) index;
      OMemStream buf;
      if (paramName == "maxDistance") {
        Real val = poolers_[poolerIndex]->getMinAcceptDistance();
        if (val <= nta::Epsilon)
          val = (Real) 0;
        value.write(val);

      } else if (paramName == "sigma") {
        value.write(poolers_[poolerIndex]->getSigma());

      } else if (paramName == "coincidenceCount") {
        value.write(poolers_[poolerIndex]->getTotalNPrototypes());

      } else if (paramName == "activeOutputCount") {
        value.write(poolers_[poolerIndex]->getTotalNPrototypes());

      } else if (paramName == "nta_segmentSize") {
        value.write((UInt32) poolers_[poolerIndex]->getSegmentSize());

      } else if (paramName == "nta_normalize") {
        value.write(poolers_[poolerIndex]->getDoNormalization());

      } else if (paramName == "nta_norm") {
        value.write(poolers_[poolerIndex]->getNorm());

      } else if (paramName == "nta_kWinners") {
        value.write(poolers_[poolerIndex]->getKWinners());

      } else if (paramName == "nta_minAcceptNorm") {
        value.write(poolers_[poolerIndex]->getMinAcceptNorm());

      } else if (paramName == "nta_minProtoSum") {
        value.write(poolers_[poolerIndex]->getMinProtoSum());

      } else {
        throw nta::LoggingException("/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp", 899) << "Unknown parameter: " << paramName;
      }
    }

  } catch (std::exception& e) {
    throw nta::LoggingException("/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp", 904) << where << "Couldn't retrieve " << paramName
              << ": " << e.what();
  }
}


std::string SpatialPoolerNode::executeCommand(const std::vector<std::string>& args, Int64 index)
{
  if (args.size() >= 1) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp", 912) << "CHECK FAILED: \"" << "args.size() >= 1" << "\" ";
  throw nta::LoggingException("/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp", 913) << "SpatialPoolerNode: command '" << args[0] << " not known";
  return "";
}


void SpatialPoolerNode::switchToInference_()
{
  if (!poolersAllocated_)
    throw nta::LoggingException("/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp", 921) << "Invalid operation -- SpatialPoolerNode must be initialized by initializing the network";

  bool hasLearned = true;

  for (UInt i = 0; i != poolers_.size(); ++i)
    if (poolers_[i]->getTotalNPrototypes() == 0)
      hasLearned = false;

  if (hasLearned == false)
    throw nta::LoggingException("/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp", 930) << "SpatialPoolerNode::switchToInference: "
              << "Can't switch to inference, didn't learn anything.";
}


void SpatialPoolerNode::waitDebuggerAttach_()
{
  if (0) {



    pid_t pid = ::getpid();

    nta::LogItem("/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp", 943, nta::LogItem::debug).stream() << "SpatialPoolerNode Waiting for connect to process ID "
              << pid << "...";
    string str;
    cin >> str;
    nta::LogItem("/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp", 947, nta::LogItem::debug).stream() << "Connected.";
  }
}



size_t SpatialPoolerNode::getNodeOutputElementCount(const std::string& outputName)
{

  if (outputName == "bottomUpOut")
    return maxNPrototypes_;
  return 0;
}



void SpatialPoolerNode::serialize(BundleIO& bundle)
{
  std::ofstream& f = bundle.getOutputStream("spmain");
  f << current_spatial_pooler_node_version_ << " "
      << (UInt32) mode_ << " "
      << (UInt32) clonedNodes_ << " "
      << nodeCount_ << " "
      << segmentSize_ << " "
      << (UInt32) sparsificationMode_ << " "
      << (UInt32) inferenceMode_ << " "

      << (UInt32) normalize_ << " "
      << norm_ << " "
      << kWinners_ << " "
      << maxDistance_ << " "
      << minAcceptNorm_ << " "
      << minProtoSum_ << " "
      << sigma_ << " "
      << seed_ << " "
      << maxNAttempts_ << " "
      << maxNPrototypes_ << " "
      << acceptanceProbability_ << " "


      << (UInt32) rgen_.getSeed() << " "
      << (UInt32) poolersAllocated_ << " ";

  if (poolersAllocated_)
  {


    UInt actualNumNodes = clonedNodes_ ? 1 : nodeCount_;
    for (UInt i = 0; i != actualNumNodes; ++i) {
      poolers_[i]->saveState(f);
      f << " ";
    }
  }
  f.close();
}

void SpatialPoolerNode::deserialize(BundleIO& bundle)
{
  std::ifstream& f = bundle.getInputStream("spmain");
  std::string version;
  f >> version;
  if (version == current_spatial_pooler_node_version_) {} else throw nta::LoggingException("/home/marek/devel/nupic/nta/regions/SpatialPoolerNode.cpp", 1008) << "CHECK FAILED: \"" << "version == current_spatial_pooler_node_version_" << "\" ";
  {

    Int32 mode;
    f >> mode;
    mode_ = (Mode)mode;
  }
  f >> clonedNodes_;
  f >> nodeCount_;
  f >> segmentSize_;
  {
    Int32 mode;
    f >> mode;
    sparsificationMode_ = (SparsePooler::SparsificationMode) mode;
    f >> mode;
    inferenceMode_ = (SparsePooler::InferenceMode) mode;
  }
  f >> normalize_;
  f >> norm_;
  f >> kWinners_;
  f >> maxDistance_;
  f >> minAcceptNorm_;
  f >> minProtoSum_;
  f >> sigma_;

  f >> seed_;
  f >> maxNAttempts_;
  f >> maxNPrototypes_;
  f >> acceptanceProbability_;
  {
    UInt32 actualSeed;
    f >> actualSeed;


    rgen_ = nta::Random(actualSeed);
  }

  f >> poolersAllocated_;
  if (poolersAllocated_)
  {
    UInt poolerCount = clonedNodes_ ? 1 : nodeCount_;
    poolers_.resize(poolerCount);
    for (UInt i = 0; i != poolerCount; ++i) {
      poolers_[i] = new SparsePooler();
      poolers_[i]->readState(f);
    }
  }
  f.close();


}

}
